
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model MaintenanceSetting
 * 
 */
export type MaintenanceSetting = $Result.DefaultSelection<Prisma.$MaintenanceSettingPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model SubscriberSubscription
 * 
 */
export type SubscriberSubscription = $Result.DefaultSelection<Prisma.$SubscriberSubscriptionPayload>
/**
 * Model Discount
 * 
 */
export type Discount = $Result.DefaultSelection<Prisma.$DiscountPayload>
/**
 * Model SubscriptionDiscountLog
 * 
 */
export type SubscriptionDiscountLog = $Result.DefaultSelection<Prisma.$SubscriptionDiscountLogPayload>
/**
 * Model Business
 * 
 */
export type Business = $Result.DefaultSelection<Prisma.$BusinessPayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model ScheduleHour
 * 
 */
export type ScheduleHour = $Result.DefaultSelection<Prisma.$ScheduleHourPayload>
/**
 * Model StaffStatusLog
 * 
 */
export type StaffStatusLog = $Result.DefaultSelection<Prisma.$StaffStatusLogPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model Vacation
 * 
 */
export type Vacation = $Result.DefaultSelection<Prisma.$VacationPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model UserOnService
 * 
 */
export type UserOnService = $Result.DefaultSelection<Prisma.$UserOnServicePayload>
/**
 * Model ServiceBranch
 * 
 */
export type ServiceBranch = $Result.DefaultSelection<Prisma.$ServiceBranchPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Promotion
 * 
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model TabletAccount
 * 
 */
export type TabletAccount = $Result.DefaultSelection<Prisma.$TabletAccountPayload>
/**
 * Model WhatsappAd
 * 
 */
export type WhatsappAd = $Result.DefaultSelection<Prisma.$WhatsappAdPayload>
/**
 * Model WhatsAppNumber
 * 
 */
export type WhatsAppNumber = $Result.DefaultSelection<Prisma.$WhatsAppNumberPayload>
/**
 * Model Flow
 * 
 */
export type Flow = $Result.DefaultSelection<Prisma.$FlowPayload>
/**
 * Model Step
 * 
 */
export type Step = $Result.DefaultSelection<Prisma.$StepPayload>
/**
 * Model StepOption
 * 
 */
export type StepOption = $Result.DefaultSelection<Prisma.$StepOptionPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model ContactUs
 * 
 */
export type ContactUs = $Result.DefaultSelection<Prisma.$ContactUsPayload>
/**
 * Model BookDemo
 * 
 */
export type BookDemo = $Result.DefaultSelection<Prisma.$BookDemoPayload>
/**
 * Model FAQ
 * 
 */
export type FAQ = $Result.DefaultSelection<Prisma.$FAQPayload>
/**
 * Model TermsCondition
 * 
 */
export type TermsCondition = $Result.DefaultSelection<Prisma.$TermsConditionPayload>
/**
 * Model PrivacyPolicy
 * 
 */
export type PrivacyPolicy = $Result.DefaultSelection<Prisma.$PrivacyPolicyPayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const BusinessType: {
  SPA: 'SPA',
  CLINIC: 'CLINIC',
  BARBER: 'BARBER',
  GENERAL: 'GENERAL'
};

export type BusinessType = (typeof BusinessType)[keyof typeof BusinessType]


export const ContactStatus: {
  PENDING: 'PENDING',
  CONTACTED: 'CONTACTED'
};

export type ContactStatus = (typeof ContactStatus)[keyof typeof ContactStatus]


export const DemoStatus: {
  PENDING: 'PENDING',
  CONTACTED: 'CONTACTED'
};

export type DemoStatus = (typeof DemoStatus)[keyof typeof DemoStatus]


export const DiscountGroup: {
  OLD: 'OLD',
  NEW: 'NEW'
};

export type DiscountGroup = (typeof DiscountGroup)[keyof typeof DiscountGroup]


export const DiscountType: {
  FIXED: 'FIXED',
  PERCENTAGE: 'PERCENTAGE'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]


export const SubscriptionType: {
  BASIC: 'BASIC',
  STANDARD: 'STANDARD',
  PRO: 'PRO',
  ENTERPRISE: 'ENTERPRISE'
};

export type SubscriptionType = (typeof SubscriptionType)[keyof typeof SubscriptionType]


export const SubscriptionValidity: {
  MONTHLY: 'MONTHLY',
  YEARLY: 'YEARLY'
};

export type SubscriptionValidity = (typeof SubscriptionValidity)[keyof typeof SubscriptionValidity]


export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  TECHNICAL_ADMIN: 'TECHNICAL_ADMIN',
  DEMO_ADMIN: 'DEMO_ADMIN',
  STAFF_MEMBER: 'STAFF_MEMBER',
  SUBSCRIBER: 'SUBSCRIBER',
  BRANCH_MANAGER: 'BRANCH_MANAGER',
  SERVICE_PROVIDER: 'SERVICE_PROVIDER',
  RECEPTIONIST: 'RECEPTIONIST',
  CONSUMER: 'CONSUMER',
  TABLET: 'TABLET'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const WeekDay: {
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY'
};

export type WeekDay = (typeof WeekDay)[keyof typeof WeekDay]


export const ScheduleOwnerType: {
  BUSINESS: 'BUSINESS',
  BRANCH: 'BRANCH',
  STAFF: 'STAFF'
};

export type ScheduleOwnerType = (typeof ScheduleOwnerType)[keyof typeof ScheduleOwnerType]


export const ScheduleInheritanceMode: {
  INHERIT: 'INHERIT',
  CUSTOM: 'CUSTOM'
};

export type ScheduleInheritanceMode = (typeof ScheduleInheritanceMode)[keyof typeof ScheduleInheritanceMode]


export const NotificationType: {
  SCHEDULE_CHANGE_BUSINESS: 'SCHEDULE_CHANGE_BUSINESS',
  SCHEDULE_CHANGE_BRANCH: 'SCHEDULE_CHANGE_BRANCH',
  SCHEDULE_CHANGE_OVERRIDE: 'SCHEDULE_CHANGE_OVERRIDE',
  BRANCH_ASSIGNMENT: 'BRANCH_ASSIGNMENT',
  GENERAL: 'GENERAL'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const BusinessStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type BusinessStatus = (typeof BusinessStatus)[keyof typeof BusinessStatus]


export const AdTargetType: {
  NEW: 'NEW',
  OLD: 'OLD',
  BOTH: 'BOTH'
};

export type AdTargetType = (typeof AdTargetType)[keyof typeof AdTargetType]


export const AdStatus: {
  PENDING: 'PENDING',
  EXPIRED: 'EXPIRED'
};

export type AdStatus = (typeof AdStatus)[keyof typeof AdStatus]


export const StepType: {
  TEXT: 'TEXT',
  TEXT_WITH_OPTIONS: 'TEXT_WITH_OPTIONS',
  BUTTONS: 'BUTTONS',
  CONFIRMATION: 'CONFIRMATION',
  INPUT: 'INPUT',
  FORM: 'FORM',
  INSERT_FLOW: 'INSERT_FLOW'
};

export type StepType = (typeof StepType)[keyof typeof StepType]


export const DynamicSource: {
  NONE: 'NONE',
  BRANCHES: 'BRANCHES',
  SERVICES: 'SERVICES',
  PROVIDERS: 'PROVIDERS',
  APPOINTMENT: 'APPOINTMENT'
};

export type DynamicSource = (typeof DynamicSource)[keyof typeof DynamicSource]


export const VacationType: {
  SICK: 'SICK',
  PERSONAL: 'PERSONAL',
  MATERNITY: 'MATERNITY',
  UNPAID: 'UNPAID'
};

export type VacationType = (typeof VacationType)[keyof typeof VacationType]


export const VacationStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type VacationStatus = (typeof VacationStatus)[keyof typeof VacationStatus]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LEAVE: 'LEAVE'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const AppointmentStatus: {
  SCHEDULED: 'SCHEDULED',
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const AppointmentBookingType: {
  BY_TIME: 'BY_TIME',
  BY_SERVICE_PROVIDER: 'BY_SERVICE_PROVIDER'
};

export type AppointmentBookingType = (typeof AppointmentBookingType)[keyof typeof AppointmentBookingType]


export const StaffStatus: {
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE'
};

export type StaffStatus = (typeof StaffStatus)[keyof typeof StaffStatus]


export const AlertAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  EXPORT: 'EXPORT',
  IMPORT: 'IMPORT',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  EDIT: 'EDIT',
  REQUEST: 'REQUEST',
  CHANGE_STATUS: 'CHANGE_STATUS',
  CONTACTED: 'CONTACTED',
  RENEW: 'RENEW',
  MAINTENANCE_MODE: 'MAINTENANCE_MODE'
};

export type AlertAction = (typeof AlertAction)[keyof typeof AlertAction]

}

export type BusinessType = $Enums.BusinessType

export const BusinessType: typeof $Enums.BusinessType

export type ContactStatus = $Enums.ContactStatus

export const ContactStatus: typeof $Enums.ContactStatus

export type DemoStatus = $Enums.DemoStatus

export const DemoStatus: typeof $Enums.DemoStatus

export type DiscountGroup = $Enums.DiscountGroup

export const DiscountGroup: typeof $Enums.DiscountGroup

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

export type SubscriptionType = $Enums.SubscriptionType

export const SubscriptionType: typeof $Enums.SubscriptionType

export type SubscriptionValidity = $Enums.SubscriptionValidity

export const SubscriptionValidity: typeof $Enums.SubscriptionValidity

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type WeekDay = $Enums.WeekDay

export const WeekDay: typeof $Enums.WeekDay

export type ScheduleOwnerType = $Enums.ScheduleOwnerType

export const ScheduleOwnerType: typeof $Enums.ScheduleOwnerType

export type ScheduleInheritanceMode = $Enums.ScheduleInheritanceMode

export const ScheduleInheritanceMode: typeof $Enums.ScheduleInheritanceMode

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type BusinessStatus = $Enums.BusinessStatus

export const BusinessStatus: typeof $Enums.BusinessStatus

export type AdTargetType = $Enums.AdTargetType

export const AdTargetType: typeof $Enums.AdTargetType

export type AdStatus = $Enums.AdStatus

export const AdStatus: typeof $Enums.AdStatus

export type StepType = $Enums.StepType

export const StepType: typeof $Enums.StepType

export type DynamicSource = $Enums.DynamicSource

export const DynamicSource: typeof $Enums.DynamicSource

export type VacationType = $Enums.VacationType

export const VacationType: typeof $Enums.VacationType

export type VacationStatus = $Enums.VacationStatus

export const VacationStatus: typeof $Enums.VacationStatus

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type AppointmentBookingType = $Enums.AppointmentBookingType

export const AppointmentBookingType: typeof $Enums.AppointmentBookingType

export type StaffStatus = $Enums.StaffStatus

export const StaffStatus: typeof $Enums.StaffStatus

export type AlertAction = $Enums.AlertAction

export const AlertAction: typeof $Enums.AlertAction

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenanceSetting`: Exposes CRUD operations for the **MaintenanceSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceSettings
    * const maintenanceSettings = await prisma.maintenanceSetting.findMany()
    * ```
    */
  get maintenanceSetting(): Prisma.MaintenanceSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriberSubscription`: Exposes CRUD operations for the **SubscriberSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriberSubscriptions
    * const subscriberSubscriptions = await prisma.subscriberSubscription.findMany()
    * ```
    */
  get subscriberSubscription(): Prisma.SubscriberSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discount`: Exposes CRUD operations for the **Discount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discounts
    * const discounts = await prisma.discount.findMany()
    * ```
    */
  get discount(): Prisma.DiscountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionDiscountLog`: Exposes CRUD operations for the **SubscriptionDiscountLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionDiscountLogs
    * const subscriptionDiscountLogs = await prisma.subscriptionDiscountLog.findMany()
    * ```
    */
  get subscriptionDiscountLog(): Prisma.SubscriptionDiscountLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.business`: Exposes CRUD operations for the **Business** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Businesses
    * const businesses = await prisma.business.findMany()
    * ```
    */
  get business(): Prisma.BusinessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduleHour`: Exposes CRUD operations for the **ScheduleHour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduleHours
    * const scheduleHours = await prisma.scheduleHour.findMany()
    * ```
    */
  get scheduleHour(): Prisma.ScheduleHourDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staffStatusLog`: Exposes CRUD operations for the **StaffStatusLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffStatusLogs
    * const staffStatusLogs = await prisma.staffStatusLog.findMany()
    * ```
    */
  get staffStatusLog(): Prisma.StaffStatusLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vacation`: Exposes CRUD operations for the **Vacation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vacations
    * const vacations = await prisma.vacation.findMany()
    * ```
    */
  get vacation(): Prisma.VacationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userOnService`: Exposes CRUD operations for the **UserOnService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserOnServices
    * const userOnServices = await prisma.userOnService.findMany()
    * ```
    */
  get userOnService(): Prisma.UserOnServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceBranch`: Exposes CRUD operations for the **ServiceBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceBranches
    * const serviceBranches = await prisma.serviceBranch.findMany()
    * ```
    */
  get serviceBranch(): Prisma.ServiceBranchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tabletAccount`: Exposes CRUD operations for the **TabletAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TabletAccounts
    * const tabletAccounts = await prisma.tabletAccount.findMany()
    * ```
    */
  get tabletAccount(): Prisma.TabletAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsappAd`: Exposes CRUD operations for the **WhatsappAd** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsappAds
    * const whatsappAds = await prisma.whatsappAd.findMany()
    * ```
    */
  get whatsappAd(): Prisma.WhatsappAdDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppNumber`: Exposes CRUD operations for the **WhatsAppNumber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppNumbers
    * const whatsAppNumbers = await prisma.whatsAppNumber.findMany()
    * ```
    */
  get whatsAppNumber(): Prisma.WhatsAppNumberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flow`: Exposes CRUD operations for the **Flow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flows
    * const flows = await prisma.flow.findMany()
    * ```
    */
  get flow(): Prisma.FlowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.step`: Exposes CRUD operations for the **Step** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Steps
    * const steps = await prisma.step.findMany()
    * ```
    */
  get step(): Prisma.StepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stepOption`: Exposes CRUD operations for the **StepOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StepOptions
    * const stepOptions = await prisma.stepOption.findMany()
    * ```
    */
  get stepOption(): Prisma.StepOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactUs`: Exposes CRUD operations for the **ContactUs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contactuses
    * const contactuses = await prisma.contactUs.findMany()
    * ```
    */
  get contactUs(): Prisma.ContactUsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookDemo`: Exposes CRUD operations for the **BookDemo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookDemos
    * const bookDemos = await prisma.bookDemo.findMany()
    * ```
    */
  get bookDemo(): Prisma.BookDemoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fAQ`: Exposes CRUD operations for the **FAQ** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FAQS
    * const fAQS = await prisma.fAQ.findMany()
    * ```
    */
  get fAQ(): Prisma.FAQDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.termsCondition`: Exposes CRUD operations for the **TermsCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TermsConditions
    * const termsConditions = await prisma.termsCondition.findMany()
    * ```
    */
  get termsCondition(): Prisma.TermsConditionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privacyPolicy`: Exposes CRUD operations for the **PrivacyPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrivacyPolicies
    * const privacyPolicies = await prisma.privacyPolicy.findMany()
    * ```
    */
  get privacyPolicy(): Prisma.PrivacyPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    MaintenanceSetting: 'MaintenanceSetting',
    Subscription: 'Subscription',
    SubscriberSubscription: 'SubscriberSubscription',
    Discount: 'Discount',
    SubscriptionDiscountLog: 'SubscriptionDiscountLog',
    Business: 'Business',
    Branch: 'Branch',
    ScheduleHour: 'ScheduleHour',
    StaffStatusLog: 'StaffStatusLog',
    Attendance: 'Attendance',
    Vacation: 'Vacation',
    Service: 'Service',
    UserOnService: 'UserOnService',
    ServiceBranch: 'ServiceBranch',
    Appointment: 'Appointment',
    Promotion: 'Promotion',
    TabletAccount: 'TabletAccount',
    WhatsappAd: 'WhatsappAd',
    WhatsAppNumber: 'WhatsAppNumber',
    Flow: 'Flow',
    Step: 'Step',
    StepOption: 'StepOption',
    Session: 'Session',
    Log: 'Log',
    ContactUs: 'ContactUs',
    BookDemo: 'BookDemo',
    FAQ: 'FAQ',
    TermsCondition: 'TermsCondition',
    PrivacyPolicy: 'PrivacyPolicy',
    Alert: 'Alert'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "maintenanceSetting" | "subscription" | "subscriberSubscription" | "discount" | "subscriptionDiscountLog" | "business" | "branch" | "scheduleHour" | "staffStatusLog" | "attendance" | "vacation" | "service" | "userOnService" | "serviceBranch" | "appointment" | "promotion" | "tabletAccount" | "whatsappAd" | "whatsAppNumber" | "flow" | "step" | "stepOption" | "session" | "log" | "contactUs" | "bookDemo" | "fAQ" | "termsCondition" | "privacyPolicy" | "alert"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceSetting: {
        payload: Prisma.$MaintenanceSettingPayload<ExtArgs>
        fields: Prisma.MaintenanceSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSettingPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSettingPayload>
          }
          findMany: {
            args: Prisma.MaintenanceSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSettingPayload>[]
          }
          create: {
            args: Prisma.MaintenanceSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSettingPayload>
          }
          createMany: {
            args: Prisma.MaintenanceSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSettingPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSettingPayload>
          }
          update: {
            args: Prisma.MaintenanceSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSettingPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSettingPayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSettingPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceSetting>
          }
          groupBy: {
            args: Prisma.MaintenanceSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceSettingCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceSettingCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      SubscriberSubscription: {
        payload: Prisma.$SubscriberSubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriberSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriberSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriberSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriberSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriberSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberSubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriberSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberSubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriberSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberSubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriberSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriberSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriberSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberSubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriberSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriberSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriberSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriberSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriberSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriberSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriberSubscription>
          }
          groupBy: {
            args: Prisma.SubscriberSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriberSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriberSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriberSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Discount: {
        payload: Prisma.$DiscountPayload<ExtArgs>
        fields: Prisma.DiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findFirst: {
            args: Prisma.DiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findMany: {
            args: Prisma.DiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          create: {
            args: Prisma.DiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          createMany: {
            args: Prisma.DiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          delete: {
            args: Prisma.DiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          update: {
            args: Prisma.DiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          deleteMany: {
            args: Prisma.DiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          upsert: {
            args: Prisma.DiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          aggregate: {
            args: Prisma.DiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscount>
          }
          groupBy: {
            args: Prisma.DiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscountCountArgs<ExtArgs>
            result: $Utils.Optional<DiscountCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionDiscountLog: {
        payload: Prisma.$SubscriptionDiscountLogPayload<ExtArgs>
        fields: Prisma.SubscriptionDiscountLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionDiscountLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDiscountLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionDiscountLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDiscountLogPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionDiscountLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDiscountLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionDiscountLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDiscountLogPayload>
          }
          findMany: {
            args: Prisma.SubscriptionDiscountLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDiscountLogPayload>[]
          }
          create: {
            args: Prisma.SubscriptionDiscountLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDiscountLogPayload>
          }
          createMany: {
            args: Prisma.SubscriptionDiscountLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionDiscountLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDiscountLogPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDiscountLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDiscountLogPayload>
          }
          update: {
            args: Prisma.SubscriptionDiscountLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDiscountLogPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDiscountLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionDiscountLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionDiscountLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDiscountLogPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionDiscountLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDiscountLogPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionDiscountLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionDiscountLog>
          }
          groupBy: {
            args: Prisma.SubscriptionDiscountLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionDiscountLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionDiscountLogCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionDiscountLogCountAggregateOutputType> | number
          }
        }
      }
      Business: {
        payload: Prisma.$BusinessPayload<ExtArgs>
        fields: Prisma.BusinessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findFirst: {
            args: Prisma.BusinessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findMany: {
            args: Prisma.BusinessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          create: {
            args: Prisma.BusinessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          createMany: {
            args: Prisma.BusinessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          delete: {
            args: Prisma.BusinessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          update: {
            args: Prisma.BusinessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          deleteMany: {
            args: Prisma.BusinessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          upsert: {
            args: Prisma.BusinessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          aggregate: {
            args: Prisma.BusinessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusiness>
          }
          groupBy: {
            args: Prisma.BusinessGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BranchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      ScheduleHour: {
        payload: Prisma.$ScheduleHourPayload<ExtArgs>
        fields: Prisma.ScheduleHourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleHourFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleHourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleHourFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleHourPayload>
          }
          findFirst: {
            args: Prisma.ScheduleHourFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleHourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleHourFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleHourPayload>
          }
          findMany: {
            args: Prisma.ScheduleHourFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleHourPayload>[]
          }
          create: {
            args: Prisma.ScheduleHourCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleHourPayload>
          }
          createMany: {
            args: Prisma.ScheduleHourCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleHourCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleHourPayload>[]
          }
          delete: {
            args: Prisma.ScheduleHourDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleHourPayload>
          }
          update: {
            args: Prisma.ScheduleHourUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleHourPayload>
          }
          deleteMany: {
            args: Prisma.ScheduleHourDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleHourUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleHourUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleHourPayload>[]
          }
          upsert: {
            args: Prisma.ScheduleHourUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleHourPayload>
          }
          aggregate: {
            args: Prisma.ScheduleHourAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduleHour>
          }
          groupBy: {
            args: Prisma.ScheduleHourGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleHourGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleHourCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleHourCountAggregateOutputType> | number
          }
        }
      }
      StaffStatusLog: {
        payload: Prisma.$StaffStatusLogPayload<ExtArgs>
        fields: Prisma.StaffStatusLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffStatusLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffStatusLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffStatusLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffStatusLogPayload>
          }
          findFirst: {
            args: Prisma.StaffStatusLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffStatusLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffStatusLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffStatusLogPayload>
          }
          findMany: {
            args: Prisma.StaffStatusLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffStatusLogPayload>[]
          }
          create: {
            args: Prisma.StaffStatusLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffStatusLogPayload>
          }
          createMany: {
            args: Prisma.StaffStatusLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffStatusLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffStatusLogPayload>[]
          }
          delete: {
            args: Prisma.StaffStatusLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffStatusLogPayload>
          }
          update: {
            args: Prisma.StaffStatusLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffStatusLogPayload>
          }
          deleteMany: {
            args: Prisma.StaffStatusLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffStatusLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffStatusLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffStatusLogPayload>[]
          }
          upsert: {
            args: Prisma.StaffStatusLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffStatusLogPayload>
          }
          aggregate: {
            args: Prisma.StaffStatusLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaffStatusLog>
          }
          groupBy: {
            args: Prisma.StaffStatusLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffStatusLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffStatusLogCountArgs<ExtArgs>
            result: $Utils.Optional<StaffStatusLogCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      Vacation: {
        payload: Prisma.$VacationPayload<ExtArgs>
        fields: Prisma.VacationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VacationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VacationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationPayload>
          }
          findFirst: {
            args: Prisma.VacationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VacationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationPayload>
          }
          findMany: {
            args: Prisma.VacationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationPayload>[]
          }
          create: {
            args: Prisma.VacationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationPayload>
          }
          createMany: {
            args: Prisma.VacationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VacationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationPayload>[]
          }
          delete: {
            args: Prisma.VacationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationPayload>
          }
          update: {
            args: Prisma.VacationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationPayload>
          }
          deleteMany: {
            args: Prisma.VacationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VacationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VacationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationPayload>[]
          }
          upsert: {
            args: Prisma.VacationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationPayload>
          }
          aggregate: {
            args: Prisma.VacationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVacation>
          }
          groupBy: {
            args: Prisma.VacationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VacationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VacationCountArgs<ExtArgs>
            result: $Utils.Optional<VacationCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      UserOnService: {
        payload: Prisma.$UserOnServicePayload<ExtArgs>
        fields: Prisma.UserOnServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserOnServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserOnServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnServicePayload>
          }
          findFirst: {
            args: Prisma.UserOnServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserOnServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnServicePayload>
          }
          findMany: {
            args: Prisma.UserOnServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnServicePayload>[]
          }
          create: {
            args: Prisma.UserOnServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnServicePayload>
          }
          createMany: {
            args: Prisma.UserOnServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserOnServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnServicePayload>[]
          }
          delete: {
            args: Prisma.UserOnServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnServicePayload>
          }
          update: {
            args: Prisma.UserOnServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnServicePayload>
          }
          deleteMany: {
            args: Prisma.UserOnServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserOnServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserOnServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnServicePayload>[]
          }
          upsert: {
            args: Prisma.UserOnServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnServicePayload>
          }
          aggregate: {
            args: Prisma.UserOnServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserOnService>
          }
          groupBy: {
            args: Prisma.UserOnServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserOnServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserOnServiceCountArgs<ExtArgs>
            result: $Utils.Optional<UserOnServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceBranch: {
        payload: Prisma.$ServiceBranchPayload<ExtArgs>
        fields: Prisma.ServiceBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          findFirst: {
            args: Prisma.ServiceBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          findMany: {
            args: Prisma.ServiceBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>[]
          }
          create: {
            args: Prisma.ServiceBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          createMany: {
            args: Prisma.ServiceBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceBranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>[]
          }
          delete: {
            args: Prisma.ServiceBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          update: {
            args: Prisma.ServiceBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          deleteMany: {
            args: Prisma.ServiceBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceBranchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>[]
          }
          upsert: {
            args: Prisma.ServiceBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          aggregate: {
            args: Prisma.ServiceBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceBranch>
          }
          groupBy: {
            args: Prisma.ServiceBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceBranchCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceBranchCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromotionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      TabletAccount: {
        payload: Prisma.$TabletAccountPayload<ExtArgs>
        fields: Prisma.TabletAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TabletAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TabletAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TabletAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TabletAccountPayload>
          }
          findFirst: {
            args: Prisma.TabletAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TabletAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TabletAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TabletAccountPayload>
          }
          findMany: {
            args: Prisma.TabletAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TabletAccountPayload>[]
          }
          create: {
            args: Prisma.TabletAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TabletAccountPayload>
          }
          createMany: {
            args: Prisma.TabletAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TabletAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TabletAccountPayload>[]
          }
          delete: {
            args: Prisma.TabletAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TabletAccountPayload>
          }
          update: {
            args: Prisma.TabletAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TabletAccountPayload>
          }
          deleteMany: {
            args: Prisma.TabletAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TabletAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TabletAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TabletAccountPayload>[]
          }
          upsert: {
            args: Prisma.TabletAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TabletAccountPayload>
          }
          aggregate: {
            args: Prisma.TabletAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTabletAccount>
          }
          groupBy: {
            args: Prisma.TabletAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<TabletAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.TabletAccountCountArgs<ExtArgs>
            result: $Utils.Optional<TabletAccountCountAggregateOutputType> | number
          }
        }
      }
      WhatsappAd: {
        payload: Prisma.$WhatsappAdPayload<ExtArgs>
        fields: Prisma.WhatsappAdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsappAdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappAdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsappAdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappAdPayload>
          }
          findFirst: {
            args: Prisma.WhatsappAdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappAdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsappAdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappAdPayload>
          }
          findMany: {
            args: Prisma.WhatsappAdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappAdPayload>[]
          }
          create: {
            args: Prisma.WhatsappAdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappAdPayload>
          }
          createMany: {
            args: Prisma.WhatsappAdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsappAdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappAdPayload>[]
          }
          delete: {
            args: Prisma.WhatsappAdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappAdPayload>
          }
          update: {
            args: Prisma.WhatsappAdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappAdPayload>
          }
          deleteMany: {
            args: Prisma.WhatsappAdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsappAdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsappAdUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappAdPayload>[]
          }
          upsert: {
            args: Prisma.WhatsappAdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappAdPayload>
          }
          aggregate: {
            args: Prisma.WhatsappAdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsappAd>
          }
          groupBy: {
            args: Prisma.WhatsappAdGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsappAdGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsappAdCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsappAdCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppNumber: {
        payload: Prisma.$WhatsAppNumberPayload<ExtArgs>
        fields: Prisma.WhatsAppNumberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppNumberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppNumberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppNumberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppNumberPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppNumberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppNumberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppNumberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppNumberPayload>
          }
          findMany: {
            args: Prisma.WhatsAppNumberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppNumberPayload>[]
          }
          create: {
            args: Prisma.WhatsAppNumberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppNumberPayload>
          }
          createMany: {
            args: Prisma.WhatsAppNumberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppNumberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppNumberPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppNumberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppNumberPayload>
          }
          update: {
            args: Prisma.WhatsAppNumberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppNumberPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppNumberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppNumberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppNumberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppNumberPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppNumberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppNumberPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppNumberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppNumber>
          }
          groupBy: {
            args: Prisma.WhatsAppNumberGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppNumberGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppNumberCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppNumberCountAggregateOutputType> | number
          }
        }
      }
      Flow: {
        payload: Prisma.$FlowPayload<ExtArgs>
        fields: Prisma.FlowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>
          }
          findFirst: {
            args: Prisma.FlowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>
          }
          findMany: {
            args: Prisma.FlowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>[]
          }
          create: {
            args: Prisma.FlowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>
          }
          createMany: {
            args: Prisma.FlowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>[]
          }
          delete: {
            args: Prisma.FlowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>
          }
          update: {
            args: Prisma.FlowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>
          }
          deleteMany: {
            args: Prisma.FlowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>[]
          }
          upsert: {
            args: Prisma.FlowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowPayload>
          }
          aggregate: {
            args: Prisma.FlowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlow>
          }
          groupBy: {
            args: Prisma.FlowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlowCountArgs<ExtArgs>
            result: $Utils.Optional<FlowCountAggregateOutputType> | number
          }
        }
      }
      Step: {
        payload: Prisma.$StepPayload<ExtArgs>
        fields: Prisma.StepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepPayload>
          }
          findFirst: {
            args: Prisma.StepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepPayload>
          }
          findMany: {
            args: Prisma.StepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepPayload>[]
          }
          create: {
            args: Prisma.StepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepPayload>
          }
          createMany: {
            args: Prisma.StepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepPayload>[]
          }
          delete: {
            args: Prisma.StepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepPayload>
          }
          update: {
            args: Prisma.StepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepPayload>
          }
          deleteMany: {
            args: Prisma.StepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepPayload>[]
          }
          upsert: {
            args: Prisma.StepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepPayload>
          }
          aggregate: {
            args: Prisma.StepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStep>
          }
          groupBy: {
            args: Prisma.StepGroupByArgs<ExtArgs>
            result: $Utils.Optional<StepGroupByOutputType>[]
          }
          count: {
            args: Prisma.StepCountArgs<ExtArgs>
            result: $Utils.Optional<StepCountAggregateOutputType> | number
          }
        }
      }
      StepOption: {
        payload: Prisma.$StepOptionPayload<ExtArgs>
        fields: Prisma.StepOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StepOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StepOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepOptionPayload>
          }
          findFirst: {
            args: Prisma.StepOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StepOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepOptionPayload>
          }
          findMany: {
            args: Prisma.StepOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepOptionPayload>[]
          }
          create: {
            args: Prisma.StepOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepOptionPayload>
          }
          createMany: {
            args: Prisma.StepOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StepOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepOptionPayload>[]
          }
          delete: {
            args: Prisma.StepOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepOptionPayload>
          }
          update: {
            args: Prisma.StepOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepOptionPayload>
          }
          deleteMany: {
            args: Prisma.StepOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StepOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StepOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepOptionPayload>[]
          }
          upsert: {
            args: Prisma.StepOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepOptionPayload>
          }
          aggregate: {
            args: Prisma.StepOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStepOption>
          }
          groupBy: {
            args: Prisma.StepOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StepOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StepOptionCountArgs<ExtArgs>
            result: $Utils.Optional<StepOptionCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      ContactUs: {
        payload: Prisma.$ContactUsPayload<ExtArgs>
        fields: Prisma.ContactUsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactUsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactUsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          findFirst: {
            args: Prisma.ContactUsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactUsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          findMany: {
            args: Prisma.ContactUsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>[]
          }
          create: {
            args: Prisma.ContactUsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          createMany: {
            args: Prisma.ContactUsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactUsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>[]
          }
          delete: {
            args: Prisma.ContactUsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          update: {
            args: Prisma.ContactUsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          deleteMany: {
            args: Prisma.ContactUsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>[]
          }
          upsert: {
            args: Prisma.ContactUsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          aggregate: {
            args: Prisma.ContactUsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactUs>
          }
          groupBy: {
            args: Prisma.ContactUsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactUsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactUsCountArgs<ExtArgs>
            result: $Utils.Optional<ContactUsCountAggregateOutputType> | number
          }
        }
      }
      BookDemo: {
        payload: Prisma.$BookDemoPayload<ExtArgs>
        fields: Prisma.BookDemoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookDemoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookDemoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookDemoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookDemoPayload>
          }
          findFirst: {
            args: Prisma.BookDemoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookDemoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookDemoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookDemoPayload>
          }
          findMany: {
            args: Prisma.BookDemoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookDemoPayload>[]
          }
          create: {
            args: Prisma.BookDemoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookDemoPayload>
          }
          createMany: {
            args: Prisma.BookDemoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookDemoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookDemoPayload>[]
          }
          delete: {
            args: Prisma.BookDemoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookDemoPayload>
          }
          update: {
            args: Prisma.BookDemoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookDemoPayload>
          }
          deleteMany: {
            args: Prisma.BookDemoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookDemoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookDemoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookDemoPayload>[]
          }
          upsert: {
            args: Prisma.BookDemoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookDemoPayload>
          }
          aggregate: {
            args: Prisma.BookDemoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookDemo>
          }
          groupBy: {
            args: Prisma.BookDemoGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookDemoGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookDemoCountArgs<ExtArgs>
            result: $Utils.Optional<BookDemoCountAggregateOutputType> | number
          }
        }
      }
      FAQ: {
        payload: Prisma.$FAQPayload<ExtArgs>
        fields: Prisma.FAQFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FAQFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FAQFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findFirst: {
            args: Prisma.FAQFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FAQFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findMany: {
            args: Prisma.FAQFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          create: {
            args: Prisma.FAQCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          createMany: {
            args: Prisma.FAQCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FAQCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          delete: {
            args: Prisma.FAQDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          update: {
            args: Prisma.FAQUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          deleteMany: {
            args: Prisma.FAQDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FAQUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FAQUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          upsert: {
            args: Prisma.FAQUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          aggregate: {
            args: Prisma.FAQAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFAQ>
          }
          groupBy: {
            args: Prisma.FAQGroupByArgs<ExtArgs>
            result: $Utils.Optional<FAQGroupByOutputType>[]
          }
          count: {
            args: Prisma.FAQCountArgs<ExtArgs>
            result: $Utils.Optional<FAQCountAggregateOutputType> | number
          }
        }
      }
      TermsCondition: {
        payload: Prisma.$TermsConditionPayload<ExtArgs>
        fields: Prisma.TermsConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TermsConditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TermsConditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionPayload>
          }
          findFirst: {
            args: Prisma.TermsConditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TermsConditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionPayload>
          }
          findMany: {
            args: Prisma.TermsConditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionPayload>[]
          }
          create: {
            args: Prisma.TermsConditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionPayload>
          }
          createMany: {
            args: Prisma.TermsConditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TermsConditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionPayload>[]
          }
          delete: {
            args: Prisma.TermsConditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionPayload>
          }
          update: {
            args: Prisma.TermsConditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionPayload>
          }
          deleteMany: {
            args: Prisma.TermsConditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TermsConditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TermsConditionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionPayload>[]
          }
          upsert: {
            args: Prisma.TermsConditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionPayload>
          }
          aggregate: {
            args: Prisma.TermsConditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTermsCondition>
          }
          groupBy: {
            args: Prisma.TermsConditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TermsConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TermsConditionCountArgs<ExtArgs>
            result: $Utils.Optional<TermsConditionCountAggregateOutputType> | number
          }
        }
      }
      PrivacyPolicy: {
        payload: Prisma.$PrivacyPolicyPayload<ExtArgs>
        fields: Prisma.PrivacyPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivacyPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivacyPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          findFirst: {
            args: Prisma.PrivacyPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivacyPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          findMany: {
            args: Prisma.PrivacyPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>[]
          }
          create: {
            args: Prisma.PrivacyPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          createMany: {
            args: Prisma.PrivacyPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrivacyPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>[]
          }
          delete: {
            args: Prisma.PrivacyPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          update: {
            args: Prisma.PrivacyPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          deleteMany: {
            args: Prisma.PrivacyPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivacyPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrivacyPolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>[]
          }
          upsert: {
            args: Prisma.PrivacyPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          aggregate: {
            args: Prisma.PrivacyPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivacyPolicy>
          }
          groupBy: {
            args: Prisma.PrivacyPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivacyPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivacyPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PrivacyPolicyCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    maintenanceSetting?: MaintenanceSettingOmit
    subscription?: SubscriptionOmit
    subscriberSubscription?: SubscriberSubscriptionOmit
    discount?: DiscountOmit
    subscriptionDiscountLog?: SubscriptionDiscountLogOmit
    business?: BusinessOmit
    branch?: BranchOmit
    scheduleHour?: ScheduleHourOmit
    staffStatusLog?: StaffStatusLogOmit
    attendance?: AttendanceOmit
    vacation?: VacationOmit
    service?: ServiceOmit
    userOnService?: UserOnServiceOmit
    serviceBranch?: ServiceBranchOmit
    appointment?: AppointmentOmit
    promotion?: PromotionOmit
    tabletAccount?: TabletAccountOmit
    whatsappAd?: WhatsappAdOmit
    whatsAppNumber?: WhatsAppNumberOmit
    flow?: FlowOmit
    step?: StepOmit
    stepOption?: StepOptionOmit
    session?: SessionOmit
    log?: LogOmit
    contactUs?: ContactUsOmit
    bookDemo?: BookDemoOmit
    fAQ?: FAQOmit
    termsCondition?: TermsConditionOmit
    privacyPolicy?: PrivacyPolicyOmit
    alert?: AlertOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    subscriberMembers: number
    services: number
    appointmentsAsConsumer: number
    appointmentsAsProvider: number
    businesses: number
    ownedBranches: number
    subscriberSubscriptions: number
    assignedWhatsappAds: number
    scheduleHours: number
    sessions: number
    attendanceRecords: number
    vacations: number
    staffMembers: number
    statusLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriberMembers?: boolean | UserCountOutputTypeCountSubscriberMembersArgs
    services?: boolean | UserCountOutputTypeCountServicesArgs
    appointmentsAsConsumer?: boolean | UserCountOutputTypeCountAppointmentsAsConsumerArgs
    appointmentsAsProvider?: boolean | UserCountOutputTypeCountAppointmentsAsProviderArgs
    businesses?: boolean | UserCountOutputTypeCountBusinessesArgs
    ownedBranches?: boolean | UserCountOutputTypeCountOwnedBranchesArgs
    subscriberSubscriptions?: boolean | UserCountOutputTypeCountSubscriberSubscriptionsArgs
    assignedWhatsappAds?: boolean | UserCountOutputTypeCountAssignedWhatsappAdsArgs
    scheduleHours?: boolean | UserCountOutputTypeCountScheduleHoursArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    attendanceRecords?: boolean | UserCountOutputTypeCountAttendanceRecordsArgs
    vacations?: boolean | UserCountOutputTypeCountVacationsArgs
    staffMembers?: boolean | UserCountOutputTypeCountStaffMembersArgs
    statusLogs?: boolean | UserCountOutputTypeCountStatusLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriberMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOnServiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsAsConsumerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsAsProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBusinessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriberSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriberSubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedWhatsappAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappAdWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScheduleHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleHourWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVacationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VacationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStaffMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffStatusLogWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    subscriberSubscriptions: number
    businesses: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriberSubscriptions?: boolean | SubscriptionCountOutputTypeCountSubscriberSubscriptionsArgs
    businesses?: boolean | SubscriptionCountOutputTypeCountBusinessesArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountSubscriberSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriberSubscriptionWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountBusinessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
  }


  /**
   * Count Type SubscriberSubscriptionCountOutputType
   */

  export type SubscriberSubscriptionCountOutputType = {
    appointments: number
    discountLogs: number
  }

  export type SubscriberSubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | SubscriberSubscriptionCountOutputTypeCountAppointmentsArgs
    discountLogs?: boolean | SubscriberSubscriptionCountOutputTypeCountDiscountLogsArgs
  }

  // Custom InputTypes
  /**
   * SubscriberSubscriptionCountOutputType without action
   */
  export type SubscriberSubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscriptionCountOutputType
     */
    select?: SubscriberSubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriberSubscriptionCountOutputType without action
   */
  export type SubscriberSubscriptionCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * SubscriberSubscriptionCountOutputType without action
   */
  export type SubscriberSubscriptionCountOutputTypeCountDiscountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionDiscountLogWhereInput
  }


  /**
   * Count Type DiscountCountOutputType
   */

  export type DiscountCountOutputType = {
    businesses: number
    appointments: number
    subscriptionDiscountLogs: number
  }

  export type DiscountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businesses?: boolean | DiscountCountOutputTypeCountBusinessesArgs
    appointments?: boolean | DiscountCountOutputTypeCountAppointmentsArgs
    subscriptionDiscountLogs?: boolean | DiscountCountOutputTypeCountSubscriptionDiscountLogsArgs
  }

  // Custom InputTypes
  /**
   * DiscountCountOutputType without action
   */
  export type DiscountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountCountOutputType
     */
    select?: DiscountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiscountCountOutputType without action
   */
  export type DiscountCountOutputTypeCountBusinessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
  }

  /**
   * DiscountCountOutputType without action
   */
  export type DiscountCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * DiscountCountOutputType without action
   */
  export type DiscountCountOutputTypeCountSubscriptionDiscountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionDiscountLogWhereInput
  }


  /**
   * Count Type BusinessCountOutputType
   */

  export type BusinessCountOutputType = {
    flows: number
    whatsappNumbers: number
    branches: number
    subscriberSubscriptions: number
    scheduleHours: number
  }

  export type BusinessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flows?: boolean | BusinessCountOutputTypeCountFlowsArgs
    whatsappNumbers?: boolean | BusinessCountOutputTypeCountWhatsappNumbersArgs
    branches?: boolean | BusinessCountOutputTypeCountBranchesArgs
    subscriberSubscriptions?: boolean | BusinessCountOutputTypeCountSubscriberSubscriptionsArgs
    scheduleHours?: boolean | BusinessCountOutputTypeCountScheduleHoursArgs
  }

  // Custom InputTypes
  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCountOutputType
     */
    select?: BusinessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountFlowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountWhatsappNumbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppNumberWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountSubscriberSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriberSubscriptionWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountScheduleHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleHourWhereInput
  }


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    users: number
    serviceBranches: number
    appointments: number
    promotions: number
    tabletAccounts: number
    whatsappAds: number
    scheduleHours: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BranchCountOutputTypeCountUsersArgs
    serviceBranches?: boolean | BranchCountOutputTypeCountServiceBranchesArgs
    appointments?: boolean | BranchCountOutputTypeCountAppointmentsArgs
    promotions?: boolean | BranchCountOutputTypeCountPromotionsArgs
    tabletAccounts?: boolean | BranchCountOutputTypeCountTabletAccountsArgs
    whatsappAds?: boolean | BranchCountOutputTypeCountWhatsappAdsArgs
    scheduleHours?: boolean | BranchCountOutputTypeCountScheduleHoursArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountServiceBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBranchWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountTabletAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TabletAccountWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountWhatsappAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappAdWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountScheduleHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleHourWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    providers: number
    branches: number
    appointments: number
    whatsappAds: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | ServiceCountOutputTypeCountProvidersArgs
    branches?: boolean | ServiceCountOutputTypeCountBranchesArgs
    appointments?: boolean | ServiceCountOutputTypeCountAppointmentsArgs
    whatsappAds?: boolean | ServiceCountOutputTypeCountWhatsappAdsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOnServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBranchWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountWhatsappAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappAdWhereInput
  }


  /**
   * Count Type PromotionCountOutputType
   */

  export type PromotionCountOutputType = {
    branches: number
    appointments: number
  }

  export type PromotionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | PromotionCountOutputTypeCountBranchesArgs
    appointments?: boolean | PromotionCountOutputTypeCountAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCountOutputType
     */
    select?: PromotionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }


  /**
   * Count Type WhatsappAdCountOutputType
   */

  export type WhatsappAdCountOutputType = {
    assignedCustomers: number
  }

  export type WhatsappAdCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedCustomers?: boolean | WhatsappAdCountOutputTypeCountAssignedCustomersArgs
  }

  // Custom InputTypes
  /**
   * WhatsappAdCountOutputType without action
   */
  export type WhatsappAdCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAdCountOutputType
     */
    select?: WhatsappAdCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsappAdCountOutputType without action
   */
  export type WhatsappAdCountOutputTypeCountAssignedCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type FlowCountOutputType
   */

  export type FlowCountOutputType = {
    steps: number
    sessions: number
    whatsappNumbers: number
  }

  export type FlowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | FlowCountOutputTypeCountStepsArgs
    sessions?: boolean | FlowCountOutputTypeCountSessionsArgs
    whatsappNumbers?: boolean | FlowCountOutputTypeCountWhatsappNumbersArgs
  }

  // Custom InputTypes
  /**
   * FlowCountOutputType without action
   */
  export type FlowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowCountOutputType
     */
    select?: FlowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlowCountOutputType without action
   */
  export type FlowCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StepWhereInput
  }

  /**
   * FlowCountOutputType without action
   */
  export type FlowCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * FlowCountOutputType without action
   */
  export type FlowCountOutputTypeCountWhatsappNumbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppNumberWhereInput
  }


  /**
   * Count Type StepCountOutputType
   */

  export type StepCountOutputType = {
    options: number
    sessions: number
    logs: number
    nextStepOptions: number
  }

  export type StepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | StepCountOutputTypeCountOptionsArgs
    sessions?: boolean | StepCountOutputTypeCountSessionsArgs
    logs?: boolean | StepCountOutputTypeCountLogsArgs
    nextStepOptions?: boolean | StepCountOutputTypeCountNextStepOptionsArgs
  }

  // Custom InputTypes
  /**
   * StepCountOutputType without action
   */
  export type StepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepCountOutputType
     */
    select?: StepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StepCountOutputType without action
   */
  export type StepCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StepOptionWhereInput
  }

  /**
   * StepCountOutputType without action
   */
  export type StepCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * StepCountOutputType without action
   */
  export type StepCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * StepCountOutputType without action
   */
  export type StepCountOutputTypeCountNextStepOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StepOptionWhereInput
  }


  /**
   * Count Type SessionCountOutputType
   */

  export type SessionCountOutputType = {
    logs: number
  }

  export type SessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | SessionCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionCountOutputType
     */
    select?: SessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
    role: $Enums.UserRole | null
    branchId: string | null
    subscriberId: string | null
    imageUrl: string | null
    isActive: boolean | null
    usesBranchSchedule: boolean | null
    managerId: string | null
    x: string | null
    instagram: string | null
    fb: string | null
    whatsapp: string | null
    language: string | null
    isLoggedIn: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
    role: $Enums.UserRole | null
    branchId: string | null
    subscriberId: string | null
    imageUrl: string | null
    isActive: boolean | null
    usesBranchSchedule: boolean | null
    managerId: string | null
    x: string | null
    instagram: string | null
    fb: string | null
    whatsapp: string | null
    language: string | null
    isLoggedIn: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    password: number
    phone: number
    role: number
    branchId: number
    subscriberId: number
    imageUrl: number
    isActive: number
    availability: number
    usesBranchSchedule: number
    managerId: number
    x: number
    instagram: number
    fb: number
    whatsapp: number
    language: number
    isLoggedIn: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    role?: true
    branchId?: true
    subscriberId?: true
    imageUrl?: true
    isActive?: true
    usesBranchSchedule?: true
    managerId?: true
    x?: true
    instagram?: true
    fb?: true
    whatsapp?: true
    language?: true
    isLoggedIn?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    role?: true
    branchId?: true
    subscriberId?: true
    imageUrl?: true
    isActive?: true
    usesBranchSchedule?: true
    managerId?: true
    x?: true
    instagram?: true
    fb?: true
    whatsapp?: true
    language?: true
    isLoggedIn?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    role?: true
    branchId?: true
    subscriberId?: true
    imageUrl?: true
    isActive?: true
    availability?: true
    usesBranchSchedule?: true
    managerId?: true
    x?: true
    instagram?: true
    fb?: true
    whatsapp?: true
    language?: true
    isLoggedIn?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    role: $Enums.UserRole
    branchId: string | null
    subscriberId: string | null
    imageUrl: string | null
    isActive: boolean
    availability: JsonValue | null
    usesBranchSchedule: boolean
    managerId: string | null
    x: string | null
    instagram: string | null
    fb: string | null
    whatsapp: string | null
    language: string | null
    isLoggedIn: boolean
    createdAt: Date
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    role?: boolean
    branchId?: boolean
    subscriberId?: boolean
    imageUrl?: boolean
    isActive?: boolean
    availability?: boolean
    usesBranchSchedule?: boolean
    managerId?: boolean
    x?: boolean
    instagram?: boolean
    fb?: boolean
    whatsapp?: boolean
    language?: boolean
    isLoggedIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    subscriber?: boolean | User$subscriberArgs<ExtArgs>
    subscriberMembers?: boolean | User$subscriberMembersArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    services?: boolean | User$servicesArgs<ExtArgs>
    appointmentsAsConsumer?: boolean | User$appointmentsAsConsumerArgs<ExtArgs>
    appointmentsAsProvider?: boolean | User$appointmentsAsProviderArgs<ExtArgs>
    businesses?: boolean | User$businessesArgs<ExtArgs>
    ownedBranches?: boolean | User$ownedBranchesArgs<ExtArgs>
    subscriberSubscriptions?: boolean | User$subscriberSubscriptionsArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    assignedWhatsappAds?: boolean | User$assignedWhatsappAdsArgs<ExtArgs>
    scheduleHours?: boolean | User$scheduleHoursArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    attendanceRecords?: boolean | User$attendanceRecordsArgs<ExtArgs>
    vacations?: boolean | User$vacationsArgs<ExtArgs>
    staffMembers?: boolean | User$staffMembersArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    statusLogs?: boolean | User$statusLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    role?: boolean
    branchId?: boolean
    subscriberId?: boolean
    imageUrl?: boolean
    isActive?: boolean
    availability?: boolean
    usesBranchSchedule?: boolean
    managerId?: boolean
    x?: boolean
    instagram?: boolean
    fb?: boolean
    whatsapp?: boolean
    language?: boolean
    isLoggedIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    subscriber?: boolean | User$subscriberArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    role?: boolean
    branchId?: boolean
    subscriberId?: boolean
    imageUrl?: boolean
    isActive?: boolean
    availability?: boolean
    usesBranchSchedule?: boolean
    managerId?: boolean
    x?: boolean
    instagram?: boolean
    fb?: boolean
    whatsapp?: boolean
    language?: boolean
    isLoggedIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    subscriber?: boolean | User$subscriberArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    role?: boolean
    branchId?: boolean
    subscriberId?: boolean
    imageUrl?: boolean
    isActive?: boolean
    availability?: boolean
    usesBranchSchedule?: boolean
    managerId?: boolean
    x?: boolean
    instagram?: boolean
    fb?: boolean
    whatsapp?: boolean
    language?: boolean
    isLoggedIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "email" | "password" | "phone" | "role" | "branchId" | "subscriberId" | "imageUrl" | "isActive" | "availability" | "usesBranchSchedule" | "managerId" | "x" | "instagram" | "fb" | "whatsapp" | "language" | "isLoggedIn" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | User$subscriberArgs<ExtArgs>
    subscriberMembers?: boolean | User$subscriberMembersArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    services?: boolean | User$servicesArgs<ExtArgs>
    appointmentsAsConsumer?: boolean | User$appointmentsAsConsumerArgs<ExtArgs>
    appointmentsAsProvider?: boolean | User$appointmentsAsProviderArgs<ExtArgs>
    businesses?: boolean | User$businessesArgs<ExtArgs>
    ownedBranches?: boolean | User$ownedBranchesArgs<ExtArgs>
    subscriberSubscriptions?: boolean | User$subscriberSubscriptionsArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    assignedWhatsappAds?: boolean | User$assignedWhatsappAdsArgs<ExtArgs>
    scheduleHours?: boolean | User$scheduleHoursArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    attendanceRecords?: boolean | User$attendanceRecordsArgs<ExtArgs>
    vacations?: boolean | User$vacationsArgs<ExtArgs>
    staffMembers?: boolean | User$staffMembersArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    statusLogs?: boolean | User$statusLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | User$subscriberArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | User$subscriberArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      subscriber: Prisma.$UserPayload<ExtArgs> | null
      subscriberMembers: Prisma.$UserPayload<ExtArgs>[]
      branch: Prisma.$BranchPayload<ExtArgs> | null
      services: Prisma.$UserOnServicePayload<ExtArgs>[]
      appointmentsAsConsumer: Prisma.$AppointmentPayload<ExtArgs>[]
      appointmentsAsProvider: Prisma.$AppointmentPayload<ExtArgs>[]
      businesses: Prisma.$BusinessPayload<ExtArgs>[]
      ownedBranches: Prisma.$BranchPayload<ExtArgs>[]
      subscriberSubscriptions: Prisma.$SubscriberSubscriptionPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      assignedWhatsappAds: Prisma.$WhatsappAdPayload<ExtArgs>[]
      scheduleHours: Prisma.$ScheduleHourPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      attendanceRecords: Prisma.$AttendancePayload<ExtArgs>[]
      vacations: Prisma.$VacationPayload<ExtArgs>[]
      staffMembers: Prisma.$UserPayload<ExtArgs>[]
      manager: Prisma.$UserPayload<ExtArgs> | null
      statusLogs: Prisma.$StaffStatusLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      email: string
      password: string
      phone: string
      role: $Enums.UserRole
      branchId: string | null
      subscriberId: string | null
      imageUrl: string | null
      isActive: boolean
      availability: Prisma.JsonValue | null
      usesBranchSchedule: boolean
      managerId: string | null
      x: string | null
      instagram: string | null
      fb: string | null
      whatsapp: string | null
      language: string | null
      isLoggedIn: boolean
      createdAt: Date
      updatedAt: Date | null
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriber<T extends User$subscriberArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriberArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subscriberMembers<T extends User$subscriberMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriberMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branch<T extends User$branchArgs<ExtArgs> = {}>(args?: Subset<T, User$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    services<T extends User$servicesArgs<ExtArgs> = {}>(args?: Subset<T, User$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOnServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointmentsAsConsumer<T extends User$appointmentsAsConsumerArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsAsConsumerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointmentsAsProvider<T extends User$appointmentsAsProviderArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsAsProviderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businesses<T extends User$businessesArgs<ExtArgs> = {}>(args?: Subset<T, User$businessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedBranches<T extends User$ownedBranchesArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriberSubscriptions<T extends User$subscriberSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriberSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends User$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedWhatsappAds<T extends User$assignedWhatsappAdsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedWhatsappAdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappAdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduleHours<T extends User$scheduleHoursArgs<ExtArgs> = {}>(args?: Subset<T, User$scheduleHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleHourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceRecords<T extends User$attendanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$attendanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vacations<T extends User$vacationsArgs<ExtArgs> = {}>(args?: Subset<T, User$vacationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VacationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staffMembers<T extends User$staffMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$staffMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manager<T extends User$managerArgs<ExtArgs> = {}>(args?: Subset<T, User$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    statusLogs<T extends User$statusLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$statusLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffStatusLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly branchId: FieldRef<"User", 'String'>
    readonly subscriberId: FieldRef<"User", 'String'>
    readonly imageUrl: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly availability: FieldRef<"User", 'Json'>
    readonly usesBranchSchedule: FieldRef<"User", 'Boolean'>
    readonly managerId: FieldRef<"User", 'String'>
    readonly x: FieldRef<"User", 'String'>
    readonly instagram: FieldRef<"User", 'String'>
    readonly fb: FieldRef<"User", 'String'>
    readonly whatsapp: FieldRef<"User", 'String'>
    readonly language: FieldRef<"User", 'String'>
    readonly isLoggedIn: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly createdBy: FieldRef<"User", 'String'>
    readonly updatedBy: FieldRef<"User", 'String'>
    readonly isDeleted: FieldRef<"User", 'Boolean'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
    readonly deletedBy: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.subscriber
   */
  export type User$subscriberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.subscriberMembers
   */
  export type User$subscriberMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.branch
   */
  export type User$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * User.services
   */
  export type User$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnService
     */
    select?: UserOnServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOnService
     */
    omit?: UserOnServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnServiceInclude<ExtArgs> | null
    where?: UserOnServiceWhereInput
    orderBy?: UserOnServiceOrderByWithRelationInput | UserOnServiceOrderByWithRelationInput[]
    cursor?: UserOnServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserOnServiceScalarFieldEnum | UserOnServiceScalarFieldEnum[]
  }

  /**
   * User.appointmentsAsConsumer
   */
  export type User$appointmentsAsConsumerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.appointmentsAsProvider
   */
  export type User$appointmentsAsProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.businesses
   */
  export type User$businessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    cursor?: BusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * User.ownedBranches
   */
  export type User$ownedBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * User.subscriberSubscriptions
   */
  export type User$subscriberSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionInclude<ExtArgs> | null
    where?: SubscriberSubscriptionWhereInput
    orderBy?: SubscriberSubscriptionOrderByWithRelationInput | SubscriberSubscriptionOrderByWithRelationInput[]
    cursor?: SubscriberSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriberSubscriptionScalarFieldEnum | SubscriberSubscriptionScalarFieldEnum[]
  }

  /**
   * User.subscription
   */
  export type User$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * User.assignedWhatsappAds
   */
  export type User$assignedWhatsappAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdInclude<ExtArgs> | null
    where?: WhatsappAdWhereInput
    orderBy?: WhatsappAdOrderByWithRelationInput | WhatsappAdOrderByWithRelationInput[]
    cursor?: WhatsappAdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsappAdScalarFieldEnum | WhatsappAdScalarFieldEnum[]
  }

  /**
   * User.scheduleHours
   */
  export type User$scheduleHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourInclude<ExtArgs> | null
    where?: ScheduleHourWhereInput
    orderBy?: ScheduleHourOrderByWithRelationInput | ScheduleHourOrderByWithRelationInput[]
    cursor?: ScheduleHourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleHourScalarFieldEnum | ScheduleHourScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.attendanceRecords
   */
  export type User$attendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * User.vacations
   */
  export type User$vacationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vacation
     */
    select?: VacationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vacation
     */
    omit?: VacationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationInclude<ExtArgs> | null
    where?: VacationWhereInput
    orderBy?: VacationOrderByWithRelationInput | VacationOrderByWithRelationInput[]
    cursor?: VacationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VacationScalarFieldEnum | VacationScalarFieldEnum[]
  }

  /**
   * User.staffMembers
   */
  export type User$staffMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.manager
   */
  export type User$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.statusLogs
   */
  export type User$statusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffStatusLog
     */
    select?: StaffStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffStatusLog
     */
    omit?: StaffStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffStatusLogInclude<ExtArgs> | null
    where?: StaffStatusLogWhereInput
    orderBy?: StaffStatusLogOrderByWithRelationInput | StaffStatusLogOrderByWithRelationInput[]
    cursor?: StaffStatusLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffStatusLogScalarFieldEnum | StaffStatusLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceSetting
   */

  export type AggregateMaintenanceSetting = {
    _count: MaintenanceSettingCountAggregateOutputType | null
    _min: MaintenanceSettingMinAggregateOutputType | null
    _max: MaintenanceSettingMaxAggregateOutputType | null
  }

  export type MaintenanceSettingMinAggregateOutputType = {
    id: string | null
    isEnabled: boolean | null
    updatedById: string | null
    updatedByName: string | null
    updatedByRole: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type MaintenanceSettingMaxAggregateOutputType = {
    id: string | null
    isEnabled: boolean | null
    updatedById: string | null
    updatedByName: string | null
    updatedByRole: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type MaintenanceSettingCountAggregateOutputType = {
    id: number
    isEnabled: number
    updatedById: number
    updatedByName: number
    updatedByRole: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type MaintenanceSettingMinAggregateInputType = {
    id?: true
    isEnabled?: true
    updatedById?: true
    updatedByName?: true
    updatedByRole?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type MaintenanceSettingMaxAggregateInputType = {
    id?: true
    isEnabled?: true
    updatedById?: true
    updatedByName?: true
    updatedByRole?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type MaintenanceSettingCountAggregateInputType = {
    id?: true
    isEnabled?: true
    updatedById?: true
    updatedByName?: true
    updatedByRole?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type MaintenanceSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceSetting to aggregate.
     */
    where?: MaintenanceSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceSettings to fetch.
     */
    orderBy?: MaintenanceSettingOrderByWithRelationInput | MaintenanceSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceSettings
    **/
    _count?: true | MaintenanceSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceSettingMaxAggregateInputType
  }

  export type GetMaintenanceSettingAggregateType<T extends MaintenanceSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceSetting[P]>
      : GetScalarType<T[P], AggregateMaintenanceSetting[P]>
  }




  export type MaintenanceSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceSettingWhereInput
    orderBy?: MaintenanceSettingOrderByWithAggregationInput | MaintenanceSettingOrderByWithAggregationInput[]
    by: MaintenanceSettingScalarFieldEnum[] | MaintenanceSettingScalarFieldEnum
    having?: MaintenanceSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceSettingCountAggregateInputType | true
    _min?: MaintenanceSettingMinAggregateInputType
    _max?: MaintenanceSettingMaxAggregateInputType
  }

  export type MaintenanceSettingGroupByOutputType = {
    id: string
    isEnabled: boolean
    updatedById: string | null
    updatedByName: string | null
    updatedByRole: $Enums.UserRole | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: MaintenanceSettingCountAggregateOutputType | null
    _min: MaintenanceSettingMinAggregateOutputType | null
    _max: MaintenanceSettingMaxAggregateOutputType | null
  }

  type GetMaintenanceSettingGroupByPayload<T extends MaintenanceSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceSettingGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceSettingGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isEnabled?: boolean
    updatedById?: boolean
    updatedByName?: boolean
    updatedByRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["maintenanceSetting"]>

  export type MaintenanceSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isEnabled?: boolean
    updatedById?: boolean
    updatedByName?: boolean
    updatedByRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["maintenanceSetting"]>

  export type MaintenanceSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isEnabled?: boolean
    updatedById?: boolean
    updatedByName?: boolean
    updatedByRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["maintenanceSetting"]>

  export type MaintenanceSettingSelectScalar = {
    id?: boolean
    isEnabled?: boolean
    updatedById?: boolean
    updatedByName?: boolean
    updatedByRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type MaintenanceSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isEnabled" | "updatedById" | "updatedByName" | "updatedByRole" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["maintenanceSetting"]>

  export type $MaintenanceSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isEnabled: boolean
      updatedById: string | null
      updatedByName: string | null
      updatedByRole: $Enums.UserRole | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["maintenanceSetting"]>
    composites: {}
  }

  type MaintenanceSettingGetPayload<S extends boolean | null | undefined | MaintenanceSettingDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceSettingPayload, S>

  type MaintenanceSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceSettingCountAggregateInputType | true
    }

  export interface MaintenanceSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceSetting'], meta: { name: 'MaintenanceSetting' } }
    /**
     * Find zero or one MaintenanceSetting that matches the filter.
     * @param {MaintenanceSettingFindUniqueArgs} args - Arguments to find a MaintenanceSetting
     * @example
     * // Get one MaintenanceSetting
     * const maintenanceSetting = await prisma.maintenanceSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceSettingFindUniqueArgs>(args: SelectSubset<T, MaintenanceSettingFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceSettingClient<$Result.GetResult<Prisma.$MaintenanceSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaintenanceSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceSettingFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceSetting
     * @example
     * // Get one MaintenanceSetting
     * const maintenanceSetting = await prisma.maintenanceSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceSettingClient<$Result.GetResult<Prisma.$MaintenanceSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSettingFindFirstArgs} args - Arguments to find a MaintenanceSetting
     * @example
     * // Get one MaintenanceSetting
     * const maintenanceSetting = await prisma.maintenanceSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceSettingFindFirstArgs>(args?: SelectSubset<T, MaintenanceSettingFindFirstArgs<ExtArgs>>): Prisma__MaintenanceSettingClient<$Result.GetResult<Prisma.$MaintenanceSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSettingFindFirstOrThrowArgs} args - Arguments to find a MaintenanceSetting
     * @example
     * // Get one MaintenanceSetting
     * const maintenanceSetting = await prisma.maintenanceSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceSettingClient<$Result.GetResult<Prisma.$MaintenanceSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaintenanceSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceSettings
     * const maintenanceSettings = await prisma.maintenanceSetting.findMany()
     * 
     * // Get first 10 MaintenanceSettings
     * const maintenanceSettings = await prisma.maintenanceSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceSettingWithIdOnly = await prisma.maintenanceSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceSettingFindManyArgs>(args?: SelectSubset<T, MaintenanceSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaintenanceSetting.
     * @param {MaintenanceSettingCreateArgs} args - Arguments to create a MaintenanceSetting.
     * @example
     * // Create one MaintenanceSetting
     * const MaintenanceSetting = await prisma.maintenanceSetting.create({
     *   data: {
     *     // ... data to create a MaintenanceSetting
     *   }
     * })
     * 
     */
    create<T extends MaintenanceSettingCreateArgs>(args: SelectSubset<T, MaintenanceSettingCreateArgs<ExtArgs>>): Prisma__MaintenanceSettingClient<$Result.GetResult<Prisma.$MaintenanceSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaintenanceSettings.
     * @param {MaintenanceSettingCreateManyArgs} args - Arguments to create many MaintenanceSettings.
     * @example
     * // Create many MaintenanceSettings
     * const maintenanceSetting = await prisma.maintenanceSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceSettingCreateManyArgs>(args?: SelectSubset<T, MaintenanceSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceSettings and returns the data saved in the database.
     * @param {MaintenanceSettingCreateManyAndReturnArgs} args - Arguments to create many MaintenanceSettings.
     * @example
     * // Create many MaintenanceSettings
     * const maintenanceSetting = await prisma.maintenanceSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceSettings and only return the `id`
     * const maintenanceSettingWithIdOnly = await prisma.maintenanceSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaintenanceSetting.
     * @param {MaintenanceSettingDeleteArgs} args - Arguments to delete one MaintenanceSetting.
     * @example
     * // Delete one MaintenanceSetting
     * const MaintenanceSetting = await prisma.maintenanceSetting.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceSetting
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceSettingDeleteArgs>(args: SelectSubset<T, MaintenanceSettingDeleteArgs<ExtArgs>>): Prisma__MaintenanceSettingClient<$Result.GetResult<Prisma.$MaintenanceSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaintenanceSetting.
     * @param {MaintenanceSettingUpdateArgs} args - Arguments to update one MaintenanceSetting.
     * @example
     * // Update one MaintenanceSetting
     * const maintenanceSetting = await prisma.maintenanceSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceSettingUpdateArgs>(args: SelectSubset<T, MaintenanceSettingUpdateArgs<ExtArgs>>): Prisma__MaintenanceSettingClient<$Result.GetResult<Prisma.$MaintenanceSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaintenanceSettings.
     * @param {MaintenanceSettingDeleteManyArgs} args - Arguments to filter MaintenanceSettings to delete.
     * @example
     * // Delete a few MaintenanceSettings
     * const { count } = await prisma.maintenanceSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceSettingDeleteManyArgs>(args?: SelectSubset<T, MaintenanceSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceSettings
     * const maintenanceSetting = await prisma.maintenanceSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceSettingUpdateManyArgs>(args: SelectSubset<T, MaintenanceSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceSettings and returns the data updated in the database.
     * @param {MaintenanceSettingUpdateManyAndReturnArgs} args - Arguments to update many MaintenanceSettings.
     * @example
     * // Update many MaintenanceSettings
     * const maintenanceSetting = await prisma.maintenanceSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaintenanceSettings and only return the `id`
     * const maintenanceSettingWithIdOnly = await prisma.maintenanceSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaintenanceSetting.
     * @param {MaintenanceSettingUpsertArgs} args - Arguments to update or create a MaintenanceSetting.
     * @example
     * // Update or create a MaintenanceSetting
     * const maintenanceSetting = await prisma.maintenanceSetting.upsert({
     *   create: {
     *     // ... data to create a MaintenanceSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceSetting we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceSettingUpsertArgs>(args: SelectSubset<T, MaintenanceSettingUpsertArgs<ExtArgs>>): Prisma__MaintenanceSettingClient<$Result.GetResult<Prisma.$MaintenanceSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaintenanceSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSettingCountArgs} args - Arguments to filter MaintenanceSettings to count.
     * @example
     * // Count the number of MaintenanceSettings
     * const count = await prisma.maintenanceSetting.count({
     *   where: {
     *     // ... the filter for the MaintenanceSettings we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceSettingCountArgs>(
      args?: Subset<T, MaintenanceSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceSettingAggregateArgs>(args: Subset<T, MaintenanceSettingAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceSettingAggregateType<T>>

    /**
     * Group by MaintenanceSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceSettingGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceSetting model
   */
  readonly fields: MaintenanceSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceSetting model
   */
  interface MaintenanceSettingFieldRefs {
    readonly id: FieldRef<"MaintenanceSetting", 'String'>
    readonly isEnabled: FieldRef<"MaintenanceSetting", 'Boolean'>
    readonly updatedById: FieldRef<"MaintenanceSetting", 'String'>
    readonly updatedByName: FieldRef<"MaintenanceSetting", 'String'>
    readonly updatedByRole: FieldRef<"MaintenanceSetting", 'UserRole'>
    readonly createdAt: FieldRef<"MaintenanceSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"MaintenanceSetting", 'DateTime'>
    readonly createdBy: FieldRef<"MaintenanceSetting", 'String'>
    readonly updatedBy: FieldRef<"MaintenanceSetting", 'String'>
    readonly isDeleted: FieldRef<"MaintenanceSetting", 'Boolean'>
    readonly deletedAt: FieldRef<"MaintenanceSetting", 'DateTime'>
    readonly deletedBy: FieldRef<"MaintenanceSetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceSetting findUnique
   */
  export type MaintenanceSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSetting
     */
    select?: MaintenanceSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSetting
     */
    omit?: MaintenanceSettingOmit<ExtArgs> | null
    /**
     * Filter, which MaintenanceSetting to fetch.
     */
    where: MaintenanceSettingWhereUniqueInput
  }

  /**
   * MaintenanceSetting findUniqueOrThrow
   */
  export type MaintenanceSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSetting
     */
    select?: MaintenanceSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSetting
     */
    omit?: MaintenanceSettingOmit<ExtArgs> | null
    /**
     * Filter, which MaintenanceSetting to fetch.
     */
    where: MaintenanceSettingWhereUniqueInput
  }

  /**
   * MaintenanceSetting findFirst
   */
  export type MaintenanceSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSetting
     */
    select?: MaintenanceSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSetting
     */
    omit?: MaintenanceSettingOmit<ExtArgs> | null
    /**
     * Filter, which MaintenanceSetting to fetch.
     */
    where?: MaintenanceSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceSettings to fetch.
     */
    orderBy?: MaintenanceSettingOrderByWithRelationInput | MaintenanceSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceSettings.
     */
    cursor?: MaintenanceSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceSettings.
     */
    distinct?: MaintenanceSettingScalarFieldEnum | MaintenanceSettingScalarFieldEnum[]
  }

  /**
   * MaintenanceSetting findFirstOrThrow
   */
  export type MaintenanceSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSetting
     */
    select?: MaintenanceSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSetting
     */
    omit?: MaintenanceSettingOmit<ExtArgs> | null
    /**
     * Filter, which MaintenanceSetting to fetch.
     */
    where?: MaintenanceSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceSettings to fetch.
     */
    orderBy?: MaintenanceSettingOrderByWithRelationInput | MaintenanceSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceSettings.
     */
    cursor?: MaintenanceSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceSettings.
     */
    distinct?: MaintenanceSettingScalarFieldEnum | MaintenanceSettingScalarFieldEnum[]
  }

  /**
   * MaintenanceSetting findMany
   */
  export type MaintenanceSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSetting
     */
    select?: MaintenanceSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSetting
     */
    omit?: MaintenanceSettingOmit<ExtArgs> | null
    /**
     * Filter, which MaintenanceSettings to fetch.
     */
    where?: MaintenanceSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceSettings to fetch.
     */
    orderBy?: MaintenanceSettingOrderByWithRelationInput | MaintenanceSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceSettings.
     */
    cursor?: MaintenanceSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceSettings.
     */
    skip?: number
    distinct?: MaintenanceSettingScalarFieldEnum | MaintenanceSettingScalarFieldEnum[]
  }

  /**
   * MaintenanceSetting create
   */
  export type MaintenanceSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSetting
     */
    select?: MaintenanceSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSetting
     */
    omit?: MaintenanceSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceSetting.
     */
    data: XOR<MaintenanceSettingCreateInput, MaintenanceSettingUncheckedCreateInput>
  }

  /**
   * MaintenanceSetting createMany
   */
  export type MaintenanceSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceSettings.
     */
    data: MaintenanceSettingCreateManyInput | MaintenanceSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceSetting createManyAndReturn
   */
  export type MaintenanceSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSetting
     */
    select?: MaintenanceSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSetting
     */
    omit?: MaintenanceSettingOmit<ExtArgs> | null
    /**
     * The data used to create many MaintenanceSettings.
     */
    data: MaintenanceSettingCreateManyInput | MaintenanceSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceSetting update
   */
  export type MaintenanceSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSetting
     */
    select?: MaintenanceSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSetting
     */
    omit?: MaintenanceSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceSetting.
     */
    data: XOR<MaintenanceSettingUpdateInput, MaintenanceSettingUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceSetting to update.
     */
    where: MaintenanceSettingWhereUniqueInput
  }

  /**
   * MaintenanceSetting updateMany
   */
  export type MaintenanceSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceSettings.
     */
    data: XOR<MaintenanceSettingUpdateManyMutationInput, MaintenanceSettingUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceSettings to update
     */
    where?: MaintenanceSettingWhereInput
    /**
     * Limit how many MaintenanceSettings to update.
     */
    limit?: number
  }

  /**
   * MaintenanceSetting updateManyAndReturn
   */
  export type MaintenanceSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSetting
     */
    select?: MaintenanceSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSetting
     */
    omit?: MaintenanceSettingOmit<ExtArgs> | null
    /**
     * The data used to update MaintenanceSettings.
     */
    data: XOR<MaintenanceSettingUpdateManyMutationInput, MaintenanceSettingUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceSettings to update
     */
    where?: MaintenanceSettingWhereInput
    /**
     * Limit how many MaintenanceSettings to update.
     */
    limit?: number
  }

  /**
   * MaintenanceSetting upsert
   */
  export type MaintenanceSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSetting
     */
    select?: MaintenanceSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSetting
     */
    omit?: MaintenanceSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceSetting to update in case it exists.
     */
    where: MaintenanceSettingWhereUniqueInput
    /**
     * In case the MaintenanceSetting found by the `where` argument doesn't exist, create a new MaintenanceSetting with this data.
     */
    create: XOR<MaintenanceSettingCreateInput, MaintenanceSettingUncheckedCreateInput>
    /**
     * In case the MaintenanceSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceSettingUpdateInput, MaintenanceSettingUncheckedUpdateInput>
  }

  /**
   * MaintenanceSetting delete
   */
  export type MaintenanceSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSetting
     */
    select?: MaintenanceSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSetting
     */
    omit?: MaintenanceSettingOmit<ExtArgs> | null
    /**
     * Filter which MaintenanceSetting to delete.
     */
    where: MaintenanceSettingWhereUniqueInput
  }

  /**
   * MaintenanceSetting deleteMany
   */
  export type MaintenanceSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceSettings to delete
     */
    where?: MaintenanceSettingWhereInput
    /**
     * Limit how many MaintenanceSettings to delete.
     */
    limit?: number
  }

  /**
   * MaintenanceSetting without action
   */
  export type MaintenanceSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSetting
     */
    select?: MaintenanceSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSetting
     */
    omit?: MaintenanceSettingOmit<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    price: number | null
    noOfBranches: number | null
    noOfAdmins: number | null
    noOfStaffManagers: number | null
    noOfServiceProviders: number | null
    noOfReceptionists: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    price: number | null
    noOfBranches: number | null
    noOfAdmins: number | null
    noOfStaffManagers: number | null
    noOfServiceProviders: number | null
    noOfReceptionists: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    type: $Enums.SubscriptionType | null
    description: string | null
    price: number | null
    noOfBranches: number | null
    noOfAdmins: number | null
    noOfStaffManagers: number | null
    noOfServiceProviders: number | null
    noOfReceptionists: number | null
    whatsappBot: boolean | null
    manualReminder: boolean | null
    automatedReminder: boolean | null
    googleReviewLink: boolean | null
    promotions: boolean | null
    selfServiceTablet: boolean | null
    basicDashboard: boolean | null
    fullAccessDashboard: boolean | null
    subscriberId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    type: $Enums.SubscriptionType | null
    description: string | null
    price: number | null
    noOfBranches: number | null
    noOfAdmins: number | null
    noOfStaffManagers: number | null
    noOfServiceProviders: number | null
    noOfReceptionists: number | null
    whatsappBot: boolean | null
    manualReminder: boolean | null
    automatedReminder: boolean | null
    googleReviewLink: boolean | null
    promotions: boolean | null
    selfServiceTablet: boolean | null
    basicDashboard: boolean | null
    fullAccessDashboard: boolean | null
    subscriberId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    type: number
    description: number
    price: number
    noOfBranches: number
    noOfAdmins: number
    noOfStaffManagers: number
    noOfServiceProviders: number
    noOfReceptionists: number
    whatsappBot: number
    manualReminder: number
    automatedReminder: number
    googleReviewLink: number
    promotions: number
    selfServiceTablet: number
    basicDashboard: number
    fullAccessDashboard: number
    subscriberId: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    price?: true
    noOfBranches?: true
    noOfAdmins?: true
    noOfStaffManagers?: true
    noOfServiceProviders?: true
    noOfReceptionists?: true
  }

  export type SubscriptionSumAggregateInputType = {
    price?: true
    noOfBranches?: true
    noOfAdmins?: true
    noOfStaffManagers?: true
    noOfServiceProviders?: true
    noOfReceptionists?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    type?: true
    description?: true
    price?: true
    noOfBranches?: true
    noOfAdmins?: true
    noOfStaffManagers?: true
    noOfServiceProviders?: true
    noOfReceptionists?: true
    whatsappBot?: true
    manualReminder?: true
    automatedReminder?: true
    googleReviewLink?: true
    promotions?: true
    selfServiceTablet?: true
    basicDashboard?: true
    fullAccessDashboard?: true
    subscriberId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    type?: true
    description?: true
    price?: true
    noOfBranches?: true
    noOfAdmins?: true
    noOfStaffManagers?: true
    noOfServiceProviders?: true
    noOfReceptionists?: true
    whatsappBot?: true
    manualReminder?: true
    automatedReminder?: true
    googleReviewLink?: true
    promotions?: true
    selfServiceTablet?: true
    basicDashboard?: true
    fullAccessDashboard?: true
    subscriberId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    type?: true
    description?: true
    price?: true
    noOfBranches?: true
    noOfAdmins?: true
    noOfStaffManagers?: true
    noOfServiceProviders?: true
    noOfReceptionists?: true
    whatsappBot?: true
    manualReminder?: true
    automatedReminder?: true
    googleReviewLink?: true
    promotions?: true
    selfServiceTablet?: true
    basicDashboard?: true
    fullAccessDashboard?: true
    subscriberId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    type: $Enums.SubscriptionType
    description: string
    price: number
    noOfBranches: number
    noOfAdmins: number
    noOfStaffManagers: number
    noOfServiceProviders: number
    noOfReceptionists: number
    whatsappBot: boolean
    manualReminder: boolean
    automatedReminder: boolean
    googleReviewLink: boolean
    promotions: boolean
    selfServiceTablet: boolean
    basicDashboard: boolean
    fullAccessDashboard: boolean
    subscriberId: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    price?: boolean
    noOfBranches?: boolean
    noOfAdmins?: boolean
    noOfStaffManagers?: boolean
    noOfServiceProviders?: boolean
    noOfReceptionists?: boolean
    whatsappBot?: boolean
    manualReminder?: boolean
    automatedReminder?: boolean
    googleReviewLink?: boolean
    promotions?: boolean
    selfServiceTablet?: boolean
    basicDashboard?: boolean
    fullAccessDashboard?: boolean
    subscriberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    subscriber?: boolean | Subscription$subscriberArgs<ExtArgs>
    subscriberSubscriptions?: boolean | Subscription$subscriberSubscriptionsArgs<ExtArgs>
    businesses?: boolean | Subscription$businessesArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    price?: boolean
    noOfBranches?: boolean
    noOfAdmins?: boolean
    noOfStaffManagers?: boolean
    noOfServiceProviders?: boolean
    noOfReceptionists?: boolean
    whatsappBot?: boolean
    manualReminder?: boolean
    automatedReminder?: boolean
    googleReviewLink?: boolean
    promotions?: boolean
    selfServiceTablet?: boolean
    basicDashboard?: boolean
    fullAccessDashboard?: boolean
    subscriberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    subscriber?: boolean | Subscription$subscriberArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    price?: boolean
    noOfBranches?: boolean
    noOfAdmins?: boolean
    noOfStaffManagers?: boolean
    noOfServiceProviders?: boolean
    noOfReceptionists?: boolean
    whatsappBot?: boolean
    manualReminder?: boolean
    automatedReminder?: boolean
    googleReviewLink?: boolean
    promotions?: boolean
    selfServiceTablet?: boolean
    basicDashboard?: boolean
    fullAccessDashboard?: boolean
    subscriberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    subscriber?: boolean | Subscription$subscriberArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    type?: boolean
    description?: boolean
    price?: boolean
    noOfBranches?: boolean
    noOfAdmins?: boolean
    noOfStaffManagers?: boolean
    noOfServiceProviders?: boolean
    noOfReceptionists?: boolean
    whatsappBot?: boolean
    manualReminder?: boolean
    automatedReminder?: boolean
    googleReviewLink?: boolean
    promotions?: boolean
    selfServiceTablet?: boolean
    basicDashboard?: boolean
    fullAccessDashboard?: boolean
    subscriberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "description" | "price" | "noOfBranches" | "noOfAdmins" | "noOfStaffManagers" | "noOfServiceProviders" | "noOfReceptionists" | "whatsappBot" | "manualReminder" | "automatedReminder" | "googleReviewLink" | "promotions" | "selfServiceTablet" | "basicDashboard" | "fullAccessDashboard" | "subscriberId" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | Subscription$subscriberArgs<ExtArgs>
    subscriberSubscriptions?: boolean | Subscription$subscriberSubscriptionsArgs<ExtArgs>
    businesses?: boolean | Subscription$businessesArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | Subscription$subscriberArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | Subscription$subscriberArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      subscriber: Prisma.$UserPayload<ExtArgs> | null
      subscriberSubscriptions: Prisma.$SubscriberSubscriptionPayload<ExtArgs>[]
      businesses: Prisma.$BusinessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.SubscriptionType
      description: string
      price: number
      noOfBranches: number
      noOfAdmins: number
      noOfStaffManagers: number
      noOfServiceProviders: number
      noOfReceptionists: number
      whatsappBot: boolean
      manualReminder: boolean
      automatedReminder: boolean
      googleReviewLink: boolean
      promotions: boolean
      selfServiceTablet: boolean
      basicDashboard: boolean
      fullAccessDashboard: boolean
      subscriberId: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriber<T extends Subscription$subscriberArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$subscriberArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subscriberSubscriptions<T extends Subscription$subscriberSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$subscriberSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businesses<T extends Subscription$businessesArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$businessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly type: FieldRef<"Subscription", 'SubscriptionType'>
    readonly description: FieldRef<"Subscription", 'String'>
    readonly price: FieldRef<"Subscription", 'Float'>
    readonly noOfBranches: FieldRef<"Subscription", 'Int'>
    readonly noOfAdmins: FieldRef<"Subscription", 'Int'>
    readonly noOfStaffManagers: FieldRef<"Subscription", 'Int'>
    readonly noOfServiceProviders: FieldRef<"Subscription", 'Int'>
    readonly noOfReceptionists: FieldRef<"Subscription", 'Int'>
    readonly whatsappBot: FieldRef<"Subscription", 'Boolean'>
    readonly manualReminder: FieldRef<"Subscription", 'Boolean'>
    readonly automatedReminder: FieldRef<"Subscription", 'Boolean'>
    readonly googleReviewLink: FieldRef<"Subscription", 'Boolean'>
    readonly promotions: FieldRef<"Subscription", 'Boolean'>
    readonly selfServiceTablet: FieldRef<"Subscription", 'Boolean'>
    readonly basicDashboard: FieldRef<"Subscription", 'Boolean'>
    readonly fullAccessDashboard: FieldRef<"Subscription", 'Boolean'>
    readonly subscriberId: FieldRef<"Subscription", 'String'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
    readonly createdBy: FieldRef<"Subscription", 'String'>
    readonly updatedBy: FieldRef<"Subscription", 'String'>
    readonly isDeleted: FieldRef<"Subscription", 'Boolean'>
    readonly deletedAt: FieldRef<"Subscription", 'DateTime'>
    readonly deletedBy: FieldRef<"Subscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.subscriber
   */
  export type Subscription$subscriberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Subscription.subscriberSubscriptions
   */
  export type Subscription$subscriberSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionInclude<ExtArgs> | null
    where?: SubscriberSubscriptionWhereInput
    orderBy?: SubscriberSubscriptionOrderByWithRelationInput | SubscriberSubscriptionOrderByWithRelationInput[]
    cursor?: SubscriberSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriberSubscriptionScalarFieldEnum | SubscriberSubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription.businesses
   */
  export type Subscription$businessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    cursor?: BusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model SubscriberSubscription
   */

  export type AggregateSubscriberSubscription = {
    _count: SubscriberSubscriptionCountAggregateOutputType | null
    _avg: SubscriberSubscriptionAvgAggregateOutputType | null
    _sum: SubscriberSubscriptionSumAggregateOutputType | null
    _min: SubscriberSubscriptionMinAggregateOutputType | null
    _max: SubscriberSubscriptionMaxAggregateOutputType | null
  }

  export type SubscriberSubscriptionAvgAggregateOutputType = {
    price: number | null
  }

  export type SubscriberSubscriptionSumAggregateOutputType = {
    price: number | null
  }

  export type SubscriberSubscriptionMinAggregateOutputType = {
    id: string | null
    subscriberId: string | null
    subscriptionId: string | null
    type: $Enums.SubscriptionType | null
    validity: $Enums.SubscriptionValidity | null
    price: number | null
    startDate: Date | null
    businessId: string | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type SubscriberSubscriptionMaxAggregateOutputType = {
    id: string | null
    subscriberId: string | null
    subscriptionId: string | null
    type: $Enums.SubscriptionType | null
    validity: $Enums.SubscriptionValidity | null
    price: number | null
    startDate: Date | null
    businessId: string | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type SubscriberSubscriptionCountAggregateOutputType = {
    id: number
    subscriberId: number
    subscriptionId: number
    type: number
    validity: number
    price: number
    features: number
    startDate: number
    businessId: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type SubscriberSubscriptionAvgAggregateInputType = {
    price?: true
  }

  export type SubscriberSubscriptionSumAggregateInputType = {
    price?: true
  }

  export type SubscriberSubscriptionMinAggregateInputType = {
    id?: true
    subscriberId?: true
    subscriptionId?: true
    type?: true
    validity?: true
    price?: true
    startDate?: true
    businessId?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type SubscriberSubscriptionMaxAggregateInputType = {
    id?: true
    subscriberId?: true
    subscriptionId?: true
    type?: true
    validity?: true
    price?: true
    startDate?: true
    businessId?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type SubscriberSubscriptionCountAggregateInputType = {
    id?: true
    subscriberId?: true
    subscriptionId?: true
    type?: true
    validity?: true
    price?: true
    features?: true
    startDate?: true
    businessId?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type SubscriberSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriberSubscription to aggregate.
     */
    where?: SubscriberSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriberSubscriptions to fetch.
     */
    orderBy?: SubscriberSubscriptionOrderByWithRelationInput | SubscriberSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriberSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriberSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriberSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriberSubscriptions
    **/
    _count?: true | SubscriberSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriberSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriberSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriberSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriberSubscriptionMaxAggregateInputType
  }

  export type GetSubscriberSubscriptionAggregateType<T extends SubscriberSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriberSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriberSubscription[P]>
      : GetScalarType<T[P], AggregateSubscriberSubscription[P]>
  }




  export type SubscriberSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriberSubscriptionWhereInput
    orderBy?: SubscriberSubscriptionOrderByWithAggregationInput | SubscriberSubscriptionOrderByWithAggregationInput[]
    by: SubscriberSubscriptionScalarFieldEnum[] | SubscriberSubscriptionScalarFieldEnum
    having?: SubscriberSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriberSubscriptionCountAggregateInputType | true
    _avg?: SubscriberSubscriptionAvgAggregateInputType
    _sum?: SubscriberSubscriptionSumAggregateInputType
    _min?: SubscriberSubscriptionMinAggregateInputType
    _max?: SubscriberSubscriptionMaxAggregateInputType
  }

  export type SubscriberSubscriptionGroupByOutputType = {
    id: string
    subscriberId: string
    subscriptionId: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonValue
    startDate: Date
    businessId: string | null
    endDate: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: SubscriberSubscriptionCountAggregateOutputType | null
    _avg: SubscriberSubscriptionAvgAggregateOutputType | null
    _sum: SubscriberSubscriptionSumAggregateOutputType | null
    _min: SubscriberSubscriptionMinAggregateOutputType | null
    _max: SubscriberSubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriberSubscriptionGroupByPayload<T extends SubscriberSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriberSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriberSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriberSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriberSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriberSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriberId?: boolean
    subscriptionId?: boolean
    type?: boolean
    validity?: boolean
    price?: boolean
    features?: boolean
    startDate?: boolean
    businessId?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    business?: boolean | SubscriberSubscription$businessArgs<ExtArgs>
    subscriber?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    appointments?: boolean | SubscriberSubscription$appointmentsArgs<ExtArgs>
    discountLogs?: boolean | SubscriberSubscription$discountLogsArgs<ExtArgs>
    _count?: boolean | SubscriberSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriberSubscription"]>

  export type SubscriberSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriberId?: boolean
    subscriptionId?: boolean
    type?: boolean
    validity?: boolean
    price?: boolean
    features?: boolean
    startDate?: boolean
    businessId?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    business?: boolean | SubscriberSubscription$businessArgs<ExtArgs>
    subscriber?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriberSubscription"]>

  export type SubscriberSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriberId?: boolean
    subscriptionId?: boolean
    type?: boolean
    validity?: boolean
    price?: boolean
    features?: boolean
    startDate?: boolean
    businessId?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    business?: boolean | SubscriberSubscription$businessArgs<ExtArgs>
    subscriber?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriberSubscription"]>

  export type SubscriberSubscriptionSelectScalar = {
    id?: boolean
    subscriberId?: boolean
    subscriptionId?: boolean
    type?: boolean
    validity?: boolean
    price?: boolean
    features?: boolean
    startDate?: boolean
    businessId?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type SubscriberSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriberId" | "subscriptionId" | "type" | "validity" | "price" | "features" | "startDate" | "businessId" | "endDate" | "isActive" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["subscriberSubscription"]>
  export type SubscriberSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | SubscriberSubscription$businessArgs<ExtArgs>
    subscriber?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    appointments?: boolean | SubscriberSubscription$appointmentsArgs<ExtArgs>
    discountLogs?: boolean | SubscriberSubscription$discountLogsArgs<ExtArgs>
    _count?: boolean | SubscriberSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriberSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | SubscriberSubscription$businessArgs<ExtArgs>
    subscriber?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type SubscriberSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | SubscriberSubscription$businessArgs<ExtArgs>
    subscriber?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $SubscriberSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriberSubscription"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs> | null
      subscriber: Prisma.$UserPayload<ExtArgs>
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      discountLogs: Prisma.$SubscriptionDiscountLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriberId: string
      subscriptionId: string
      type: $Enums.SubscriptionType
      validity: $Enums.SubscriptionValidity
      price: number
      features: Prisma.JsonValue
      startDate: Date
      businessId: string | null
      endDate: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["subscriberSubscription"]>
    composites: {}
  }

  type SubscriberSubscriptionGetPayload<S extends boolean | null | undefined | SubscriberSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriberSubscriptionPayload, S>

  type SubscriberSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriberSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriberSubscriptionCountAggregateInputType | true
    }

  export interface SubscriberSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriberSubscription'], meta: { name: 'SubscriberSubscription' } }
    /**
     * Find zero or one SubscriberSubscription that matches the filter.
     * @param {SubscriberSubscriptionFindUniqueArgs} args - Arguments to find a SubscriberSubscription
     * @example
     * // Get one SubscriberSubscription
     * const subscriberSubscription = await prisma.subscriberSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriberSubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriberSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriberSubscriptionClient<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriberSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriberSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a SubscriberSubscription
     * @example
     * // Get one SubscriberSubscription
     * const subscriberSubscription = await prisma.subscriberSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriberSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriberSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriberSubscriptionClient<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriberSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberSubscriptionFindFirstArgs} args - Arguments to find a SubscriberSubscription
     * @example
     * // Get one SubscriberSubscription
     * const subscriberSubscription = await prisma.subscriberSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriberSubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriberSubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriberSubscriptionClient<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriberSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberSubscriptionFindFirstOrThrowArgs} args - Arguments to find a SubscriberSubscription
     * @example
     * // Get one SubscriberSubscription
     * const subscriberSubscription = await prisma.subscriberSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriberSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriberSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriberSubscriptionClient<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriberSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriberSubscriptions
     * const subscriberSubscriptions = await prisma.subscriberSubscription.findMany()
     * 
     * // Get first 10 SubscriberSubscriptions
     * const subscriberSubscriptions = await prisma.subscriberSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriberSubscriptionWithIdOnly = await prisma.subscriberSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriberSubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriberSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriberSubscription.
     * @param {SubscriberSubscriptionCreateArgs} args - Arguments to create a SubscriberSubscription.
     * @example
     * // Create one SubscriberSubscription
     * const SubscriberSubscription = await prisma.subscriberSubscription.create({
     *   data: {
     *     // ... data to create a SubscriberSubscription
     *   }
     * })
     * 
     */
    create<T extends SubscriberSubscriptionCreateArgs>(args: SelectSubset<T, SubscriberSubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriberSubscriptionClient<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriberSubscriptions.
     * @param {SubscriberSubscriptionCreateManyArgs} args - Arguments to create many SubscriberSubscriptions.
     * @example
     * // Create many SubscriberSubscriptions
     * const subscriberSubscription = await prisma.subscriberSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriberSubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriberSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriberSubscriptions and returns the data saved in the database.
     * @param {SubscriberSubscriptionCreateManyAndReturnArgs} args - Arguments to create many SubscriberSubscriptions.
     * @example
     * // Create many SubscriberSubscriptions
     * const subscriberSubscription = await prisma.subscriberSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriberSubscriptions and only return the `id`
     * const subscriberSubscriptionWithIdOnly = await prisma.subscriberSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriberSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriberSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriberSubscription.
     * @param {SubscriberSubscriptionDeleteArgs} args - Arguments to delete one SubscriberSubscription.
     * @example
     * // Delete one SubscriberSubscription
     * const SubscriberSubscription = await prisma.subscriberSubscription.delete({
     *   where: {
     *     // ... filter to delete one SubscriberSubscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriberSubscriptionDeleteArgs>(args: SelectSubset<T, SubscriberSubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriberSubscriptionClient<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriberSubscription.
     * @param {SubscriberSubscriptionUpdateArgs} args - Arguments to update one SubscriberSubscription.
     * @example
     * // Update one SubscriberSubscription
     * const subscriberSubscription = await prisma.subscriberSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriberSubscriptionUpdateArgs>(args: SelectSubset<T, SubscriberSubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriberSubscriptionClient<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriberSubscriptions.
     * @param {SubscriberSubscriptionDeleteManyArgs} args - Arguments to filter SubscriberSubscriptions to delete.
     * @example
     * // Delete a few SubscriberSubscriptions
     * const { count } = await prisma.subscriberSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriberSubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriberSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriberSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriberSubscriptions
     * const subscriberSubscription = await prisma.subscriberSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriberSubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriberSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriberSubscriptions and returns the data updated in the database.
     * @param {SubscriberSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many SubscriberSubscriptions.
     * @example
     * // Update many SubscriberSubscriptions
     * const subscriberSubscription = await prisma.subscriberSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriberSubscriptions and only return the `id`
     * const subscriberSubscriptionWithIdOnly = await prisma.subscriberSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriberSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriberSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriberSubscription.
     * @param {SubscriberSubscriptionUpsertArgs} args - Arguments to update or create a SubscriberSubscription.
     * @example
     * // Update or create a SubscriberSubscription
     * const subscriberSubscription = await prisma.subscriberSubscription.upsert({
     *   create: {
     *     // ... data to create a SubscriberSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriberSubscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriberSubscriptionUpsertArgs>(args: SelectSubset<T, SubscriberSubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriberSubscriptionClient<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriberSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberSubscriptionCountArgs} args - Arguments to filter SubscriberSubscriptions to count.
     * @example
     * // Count the number of SubscriberSubscriptions
     * const count = await prisma.subscriberSubscription.count({
     *   where: {
     *     // ... the filter for the SubscriberSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriberSubscriptionCountArgs>(
      args?: Subset<T, SubscriberSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriberSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriberSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriberSubscriptionAggregateArgs>(args: Subset<T, SubscriberSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriberSubscriptionAggregateType<T>>

    /**
     * Group by SubscriberSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriberSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriberSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriberSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriberSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriberSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriberSubscription model
   */
  readonly fields: SubscriberSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriberSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriberSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends SubscriberSubscription$businessArgs<ExtArgs> = {}>(args?: Subset<T, SubscriberSubscription$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subscriber<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointments<T extends SubscriberSubscription$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriberSubscription$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discountLogs<T extends SubscriberSubscription$discountLogsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriberSubscription$discountLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionDiscountLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriberSubscription model
   */
  interface SubscriberSubscriptionFieldRefs {
    readonly id: FieldRef<"SubscriberSubscription", 'String'>
    readonly subscriberId: FieldRef<"SubscriberSubscription", 'String'>
    readonly subscriptionId: FieldRef<"SubscriberSubscription", 'String'>
    readonly type: FieldRef<"SubscriberSubscription", 'SubscriptionType'>
    readonly validity: FieldRef<"SubscriberSubscription", 'SubscriptionValidity'>
    readonly price: FieldRef<"SubscriberSubscription", 'Float'>
    readonly features: FieldRef<"SubscriberSubscription", 'Json'>
    readonly startDate: FieldRef<"SubscriberSubscription", 'DateTime'>
    readonly businessId: FieldRef<"SubscriberSubscription", 'String'>
    readonly endDate: FieldRef<"SubscriberSubscription", 'DateTime'>
    readonly isActive: FieldRef<"SubscriberSubscription", 'Boolean'>
    readonly createdAt: FieldRef<"SubscriberSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriberSubscription", 'DateTime'>
    readonly createdBy: FieldRef<"SubscriberSubscription", 'String'>
    readonly updatedBy: FieldRef<"SubscriberSubscription", 'String'>
    readonly isDeleted: FieldRef<"SubscriberSubscription", 'Boolean'>
    readonly deletedAt: FieldRef<"SubscriberSubscription", 'DateTime'>
    readonly deletedBy: FieldRef<"SubscriberSubscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubscriberSubscription findUnique
   */
  export type SubscriberSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which SubscriberSubscription to fetch.
     */
    where: SubscriberSubscriptionWhereUniqueInput
  }

  /**
   * SubscriberSubscription findUniqueOrThrow
   */
  export type SubscriberSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which SubscriberSubscription to fetch.
     */
    where: SubscriberSubscriptionWhereUniqueInput
  }

  /**
   * SubscriberSubscription findFirst
   */
  export type SubscriberSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which SubscriberSubscription to fetch.
     */
    where?: SubscriberSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriberSubscriptions to fetch.
     */
    orderBy?: SubscriberSubscriptionOrderByWithRelationInput | SubscriberSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriberSubscriptions.
     */
    cursor?: SubscriberSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriberSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriberSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriberSubscriptions.
     */
    distinct?: SubscriberSubscriptionScalarFieldEnum | SubscriberSubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriberSubscription findFirstOrThrow
   */
  export type SubscriberSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which SubscriberSubscription to fetch.
     */
    where?: SubscriberSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriberSubscriptions to fetch.
     */
    orderBy?: SubscriberSubscriptionOrderByWithRelationInput | SubscriberSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriberSubscriptions.
     */
    cursor?: SubscriberSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriberSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriberSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriberSubscriptions.
     */
    distinct?: SubscriberSubscriptionScalarFieldEnum | SubscriberSubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriberSubscription findMany
   */
  export type SubscriberSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which SubscriberSubscriptions to fetch.
     */
    where?: SubscriberSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriberSubscriptions to fetch.
     */
    orderBy?: SubscriberSubscriptionOrderByWithRelationInput | SubscriberSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriberSubscriptions.
     */
    cursor?: SubscriberSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriberSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriberSubscriptions.
     */
    skip?: number
    distinct?: SubscriberSubscriptionScalarFieldEnum | SubscriberSubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriberSubscription create
   */
  export type SubscriberSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriberSubscription.
     */
    data: XOR<SubscriberSubscriptionCreateInput, SubscriberSubscriptionUncheckedCreateInput>
  }

  /**
   * SubscriberSubscription createMany
   */
  export type SubscriberSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriberSubscriptions.
     */
    data: SubscriberSubscriptionCreateManyInput | SubscriberSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriberSubscription createManyAndReturn
   */
  export type SubscriberSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriberSubscriptions.
     */
    data: SubscriberSubscriptionCreateManyInput | SubscriberSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriberSubscription update
   */
  export type SubscriberSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriberSubscription.
     */
    data: XOR<SubscriberSubscriptionUpdateInput, SubscriberSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which SubscriberSubscription to update.
     */
    where: SubscriberSubscriptionWhereUniqueInput
  }

  /**
   * SubscriberSubscription updateMany
   */
  export type SubscriberSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriberSubscriptions.
     */
    data: XOR<SubscriberSubscriptionUpdateManyMutationInput, SubscriberSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which SubscriberSubscriptions to update
     */
    where?: SubscriberSubscriptionWhereInput
    /**
     * Limit how many SubscriberSubscriptions to update.
     */
    limit?: number
  }

  /**
   * SubscriberSubscription updateManyAndReturn
   */
  export type SubscriberSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update SubscriberSubscriptions.
     */
    data: XOR<SubscriberSubscriptionUpdateManyMutationInput, SubscriberSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which SubscriberSubscriptions to update
     */
    where?: SubscriberSubscriptionWhereInput
    /**
     * Limit how many SubscriberSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriberSubscription upsert
   */
  export type SubscriberSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriberSubscription to update in case it exists.
     */
    where: SubscriberSubscriptionWhereUniqueInput
    /**
     * In case the SubscriberSubscription found by the `where` argument doesn't exist, create a new SubscriberSubscription with this data.
     */
    create: XOR<SubscriberSubscriptionCreateInput, SubscriberSubscriptionUncheckedCreateInput>
    /**
     * In case the SubscriberSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriberSubscriptionUpdateInput, SubscriberSubscriptionUncheckedUpdateInput>
  }

  /**
   * SubscriberSubscription delete
   */
  export type SubscriberSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which SubscriberSubscription to delete.
     */
    where: SubscriberSubscriptionWhereUniqueInput
  }

  /**
   * SubscriberSubscription deleteMany
   */
  export type SubscriberSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriberSubscriptions to delete
     */
    where?: SubscriberSubscriptionWhereInput
    /**
     * Limit how many SubscriberSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * SubscriberSubscription.business
   */
  export type SubscriberSubscription$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * SubscriberSubscription.appointments
   */
  export type SubscriberSubscription$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * SubscriberSubscription.discountLogs
   */
  export type SubscriberSubscription$discountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDiscountLog
     */
    select?: SubscriptionDiscountLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDiscountLog
     */
    omit?: SubscriptionDiscountLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDiscountLogInclude<ExtArgs> | null
    where?: SubscriptionDiscountLogWhereInput
    orderBy?: SubscriptionDiscountLogOrderByWithRelationInput | SubscriptionDiscountLogOrderByWithRelationInput[]
    cursor?: SubscriptionDiscountLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionDiscountLogScalarFieldEnum | SubscriptionDiscountLogScalarFieldEnum[]
  }

  /**
   * SubscriberSubscription without action
   */
  export type SubscriberSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Discount
   */

  export type AggregateDiscount = {
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  export type DiscountAvgAggregateOutputType = {
    value: number | null
    usageLimit: number | null
    usageCount: number | null
  }

  export type DiscountSumAggregateOutputType = {
    value: number | null
    usageLimit: number | null
    usageCount: number | null
  }

  export type DiscountMinAggregateOutputType = {
    id: string | null
    code: string | null
    group: $Enums.DiscountGroup | null
    packageType: $Enums.SubscriptionType | null
    discountType: $Enums.DiscountType | null
    value: number | null
    usageLimit: number | null
    usageCount: number | null
    startDate: Date | null
    expiryDate: Date | null
    isManuallyExpired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type DiscountMaxAggregateOutputType = {
    id: string | null
    code: string | null
    group: $Enums.DiscountGroup | null
    packageType: $Enums.SubscriptionType | null
    discountType: $Enums.DiscountType | null
    value: number | null
    usageLimit: number | null
    usageCount: number | null
    startDate: Date | null
    expiryDate: Date | null
    isManuallyExpired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type DiscountCountAggregateOutputType = {
    id: number
    code: number
    group: number
    packageType: number
    discountType: number
    value: number
    usageLimit: number
    usageCount: number
    startDate: number
    expiryDate: number
    isManuallyExpired: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type DiscountAvgAggregateInputType = {
    value?: true
    usageLimit?: true
    usageCount?: true
  }

  export type DiscountSumAggregateInputType = {
    value?: true
    usageLimit?: true
    usageCount?: true
  }

  export type DiscountMinAggregateInputType = {
    id?: true
    code?: true
    group?: true
    packageType?: true
    discountType?: true
    value?: true
    usageLimit?: true
    usageCount?: true
    startDate?: true
    expiryDate?: true
    isManuallyExpired?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type DiscountMaxAggregateInputType = {
    id?: true
    code?: true
    group?: true
    packageType?: true
    discountType?: true
    value?: true
    usageLimit?: true
    usageCount?: true
    startDate?: true
    expiryDate?: true
    isManuallyExpired?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type DiscountCountAggregateInputType = {
    id?: true
    code?: true
    group?: true
    packageType?: true
    discountType?: true
    value?: true
    usageLimit?: true
    usageCount?: true
    startDate?: true
    expiryDate?: true
    isManuallyExpired?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type DiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discount to aggregate.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Discounts
    **/
    _count?: true | DiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountMaxAggregateInputType
  }

  export type GetDiscountAggregateType<T extends DiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscount[P]>
      : GetScalarType<T[P], AggregateDiscount[P]>
  }




  export type DiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountWhereInput
    orderBy?: DiscountOrderByWithAggregationInput | DiscountOrderByWithAggregationInput[]
    by: DiscountScalarFieldEnum[] | DiscountScalarFieldEnum
    having?: DiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountCountAggregateInputType | true
    _avg?: DiscountAvgAggregateInputType
    _sum?: DiscountSumAggregateInputType
    _min?: DiscountMinAggregateInputType
    _max?: DiscountMaxAggregateInputType
  }

  export type DiscountGroupByOutputType = {
    id: string
    code: string
    group: $Enums.DiscountGroup
    packageType: $Enums.SubscriptionType
    discountType: $Enums.DiscountType
    value: number
    usageLimit: number | null
    usageCount: number
    startDate: Date
    expiryDate: Date
    isManuallyExpired: boolean
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  type GetDiscountGroupByPayload<T extends DiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountGroupByOutputType[P]>
        }
      >
    >


  export type DiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    group?: boolean
    packageType?: boolean
    discountType?: boolean
    value?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    startDate?: boolean
    expiryDate?: boolean
    isManuallyExpired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    businesses?: boolean | Discount$businessesArgs<ExtArgs>
    appointments?: boolean | Discount$appointmentsArgs<ExtArgs>
    subscriptionDiscountLogs?: boolean | Discount$subscriptionDiscountLogsArgs<ExtArgs>
    _count?: boolean | DiscountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    group?: boolean
    packageType?: boolean
    discountType?: boolean
    value?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    startDate?: boolean
    expiryDate?: boolean
    isManuallyExpired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    group?: boolean
    packageType?: boolean
    discountType?: boolean
    value?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    startDate?: boolean
    expiryDate?: boolean
    isManuallyExpired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectScalar = {
    id?: boolean
    code?: boolean
    group?: boolean
    packageType?: boolean
    discountType?: boolean
    value?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    startDate?: boolean
    expiryDate?: boolean
    isManuallyExpired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type DiscountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "group" | "packageType" | "discountType" | "value" | "usageLimit" | "usageCount" | "startDate" | "expiryDate" | "isManuallyExpired" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["discount"]>
  export type DiscountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businesses?: boolean | Discount$businessesArgs<ExtArgs>
    appointments?: boolean | Discount$appointmentsArgs<ExtArgs>
    subscriptionDiscountLogs?: boolean | Discount$subscriptionDiscountLogsArgs<ExtArgs>
    _count?: boolean | DiscountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DiscountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DiscountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Discount"
    objects: {
      businesses: Prisma.$BusinessPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      subscriptionDiscountLogs: Prisma.$SubscriptionDiscountLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      group: $Enums.DiscountGroup
      packageType: $Enums.SubscriptionType
      discountType: $Enums.DiscountType
      value: number
      usageLimit: number | null
      usageCount: number
      startDate: Date
      expiryDate: Date
      isManuallyExpired: boolean
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["discount"]>
    composites: {}
  }

  type DiscountGetPayload<S extends boolean | null | undefined | DiscountDefaultArgs> = $Result.GetResult<Prisma.$DiscountPayload, S>

  type DiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscountCountAggregateInputType | true
    }

  export interface DiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Discount'], meta: { name: 'Discount' } }
    /**
     * Find zero or one Discount that matches the filter.
     * @param {DiscountFindUniqueArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscountFindUniqueArgs>(args: SelectSubset<T, DiscountFindUniqueArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Discount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscountFindUniqueOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscountFindFirstArgs>(args?: SelectSubset<T, DiscountFindFirstArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Discounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discounts
     * const discounts = await prisma.discount.findMany()
     * 
     * // Get first 10 Discounts
     * const discounts = await prisma.discount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountWithIdOnly = await prisma.discount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscountFindManyArgs>(args?: SelectSubset<T, DiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Discount.
     * @param {DiscountCreateArgs} args - Arguments to create a Discount.
     * @example
     * // Create one Discount
     * const Discount = await prisma.discount.create({
     *   data: {
     *     // ... data to create a Discount
     *   }
     * })
     * 
     */
    create<T extends DiscountCreateArgs>(args: SelectSubset<T, DiscountCreateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Discounts.
     * @param {DiscountCreateManyArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscountCreateManyArgs>(args?: SelectSubset<T, DiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Discounts and returns the data saved in the database.
     * @param {DiscountCreateManyAndReturnArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Discounts and only return the `id`
     * const discountWithIdOnly = await prisma.discount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscountCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Discount.
     * @param {DiscountDeleteArgs} args - Arguments to delete one Discount.
     * @example
     * // Delete one Discount
     * const Discount = await prisma.discount.delete({
     *   where: {
     *     // ... filter to delete one Discount
     *   }
     * })
     * 
     */
    delete<T extends DiscountDeleteArgs>(args: SelectSubset<T, DiscountDeleteArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Discount.
     * @param {DiscountUpdateArgs} args - Arguments to update one Discount.
     * @example
     * // Update one Discount
     * const discount = await prisma.discount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscountUpdateArgs>(args: SelectSubset<T, DiscountUpdateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Discounts.
     * @param {DiscountDeleteManyArgs} args - Arguments to filter Discounts to delete.
     * @example
     * // Delete a few Discounts
     * const { count } = await prisma.discount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscountDeleteManyArgs>(args?: SelectSubset<T, DiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscountUpdateManyArgs>(args: SelectSubset<T, DiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts and returns the data updated in the database.
     * @param {DiscountUpdateManyAndReturnArgs} args - Arguments to update many Discounts.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Discounts and only return the `id`
     * const discountWithIdOnly = await prisma.discount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscountUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Discount.
     * @param {DiscountUpsertArgs} args - Arguments to update or create a Discount.
     * @example
     * // Update or create a Discount
     * const discount = await prisma.discount.upsert({
     *   create: {
     *     // ... data to create a Discount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discount we want to update
     *   }
     * })
     */
    upsert<T extends DiscountUpsertArgs>(args: SelectSubset<T, DiscountUpsertArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountCountArgs} args - Arguments to filter Discounts to count.
     * @example
     * // Count the number of Discounts
     * const count = await prisma.discount.count({
     *   where: {
     *     // ... the filter for the Discounts we want to count
     *   }
     * })
    **/
    count<T extends DiscountCountArgs>(
      args?: Subset<T, DiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountAggregateArgs>(args: Subset<T, DiscountAggregateArgs>): Prisma.PrismaPromise<GetDiscountAggregateType<T>>

    /**
     * Group by Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountGroupByArgs['orderBy'] }
        : { orderBy?: DiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Discount model
   */
  readonly fields: DiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Discount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businesses<T extends Discount$businessesArgs<ExtArgs> = {}>(args?: Subset<T, Discount$businessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Discount$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Discount$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptionDiscountLogs<T extends Discount$subscriptionDiscountLogsArgs<ExtArgs> = {}>(args?: Subset<T, Discount$subscriptionDiscountLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionDiscountLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Discount model
   */
  interface DiscountFieldRefs {
    readonly id: FieldRef<"Discount", 'String'>
    readonly code: FieldRef<"Discount", 'String'>
    readonly group: FieldRef<"Discount", 'DiscountGroup'>
    readonly packageType: FieldRef<"Discount", 'SubscriptionType'>
    readonly discountType: FieldRef<"Discount", 'DiscountType'>
    readonly value: FieldRef<"Discount", 'Float'>
    readonly usageLimit: FieldRef<"Discount", 'Int'>
    readonly usageCount: FieldRef<"Discount", 'Int'>
    readonly startDate: FieldRef<"Discount", 'DateTime'>
    readonly expiryDate: FieldRef<"Discount", 'DateTime'>
    readonly isManuallyExpired: FieldRef<"Discount", 'Boolean'>
    readonly createdAt: FieldRef<"Discount", 'DateTime'>
    readonly updatedAt: FieldRef<"Discount", 'DateTime'>
    readonly createdBy: FieldRef<"Discount", 'String'>
    readonly updatedBy: FieldRef<"Discount", 'String'>
    readonly isDeleted: FieldRef<"Discount", 'Boolean'>
    readonly deletedAt: FieldRef<"Discount", 'DateTime'>
    readonly deletedBy: FieldRef<"Discount", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Discount findUnique
   */
  export type DiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findUniqueOrThrow
   */
  export type DiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findFirst
   */
  export type DiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findFirstOrThrow
   */
  export type DiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findMany
   */
  export type DiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discounts to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount create
   */
  export type DiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The data needed to create a Discount.
     */
    data: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
  }

  /**
   * Discount createMany
   */
  export type DiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Discounts.
     */
    data: DiscountCreateManyInput | DiscountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Discount createManyAndReturn
   */
  export type DiscountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The data used to create many Discounts.
     */
    data: DiscountCreateManyInput | DiscountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Discount update
   */
  export type DiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The data needed to update a Discount.
     */
    data: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
    /**
     * Choose, which Discount to update.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount updateMany
   */
  export type DiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Discounts.
     */
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to update.
     */
    limit?: number
  }

  /**
   * Discount updateManyAndReturn
   */
  export type DiscountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The data used to update Discounts.
     */
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to update.
     */
    limit?: number
  }

  /**
   * Discount upsert
   */
  export type DiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The filter to search for the Discount to update in case it exists.
     */
    where: DiscountWhereUniqueInput
    /**
     * In case the Discount found by the `where` argument doesn't exist, create a new Discount with this data.
     */
    create: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
    /**
     * In case the Discount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
  }

  /**
   * Discount delete
   */
  export type DiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter which Discount to delete.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount deleteMany
   */
  export type DiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discounts to delete
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to delete.
     */
    limit?: number
  }

  /**
   * Discount.businesses
   */
  export type Discount$businessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    cursor?: BusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Discount.appointments
   */
  export type Discount$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Discount.subscriptionDiscountLogs
   */
  export type Discount$subscriptionDiscountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDiscountLog
     */
    select?: SubscriptionDiscountLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDiscountLog
     */
    omit?: SubscriptionDiscountLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDiscountLogInclude<ExtArgs> | null
    where?: SubscriptionDiscountLogWhereInput
    orderBy?: SubscriptionDiscountLogOrderByWithRelationInput | SubscriptionDiscountLogOrderByWithRelationInput[]
    cursor?: SubscriptionDiscountLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionDiscountLogScalarFieldEnum | SubscriptionDiscountLogScalarFieldEnum[]
  }

  /**
   * Discount without action
   */
  export type DiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionDiscountLog
   */

  export type AggregateSubscriptionDiscountLog = {
    _count: SubscriptionDiscountLogCountAggregateOutputType | null
    _avg: SubscriptionDiscountLogAvgAggregateOutputType | null
    _sum: SubscriptionDiscountLogSumAggregateOutputType | null
    _min: SubscriptionDiscountLogMinAggregateOutputType | null
    _max: SubscriptionDiscountLogMaxAggregateOutputType | null
  }

  export type SubscriptionDiscountLogAvgAggregateOutputType = {
    discountValue: number | null
    discountedAmount: number | null
    originalPrice: number | null
    finalPrice: number | null
  }

  export type SubscriptionDiscountLogSumAggregateOutputType = {
    discountValue: number | null
    discountedAmount: number | null
    originalPrice: number | null
    finalPrice: number | null
  }

  export type SubscriptionDiscountLogMinAggregateOutputType = {
    id: string | null
    subscriberSubscriptionId: string | null
    discountId: string | null
    discountCode: string | null
    discountType: $Enums.DiscountType | null
    discountValue: number | null
    discountedAmount: number | null
    originalPrice: number | null
    finalPrice: number | null
    appliedAt: Date | null
    createdBy: string | null
  }

  export type SubscriptionDiscountLogMaxAggregateOutputType = {
    id: string | null
    subscriberSubscriptionId: string | null
    discountId: string | null
    discountCode: string | null
    discountType: $Enums.DiscountType | null
    discountValue: number | null
    discountedAmount: number | null
    originalPrice: number | null
    finalPrice: number | null
    appliedAt: Date | null
    createdBy: string | null
  }

  export type SubscriptionDiscountLogCountAggregateOutputType = {
    id: number
    subscriberSubscriptionId: number
    discountId: number
    discountCode: number
    discountType: number
    discountValue: number
    discountedAmount: number
    originalPrice: number
    finalPrice: number
    appliedAt: number
    createdBy: number
    _all: number
  }


  export type SubscriptionDiscountLogAvgAggregateInputType = {
    discountValue?: true
    discountedAmount?: true
    originalPrice?: true
    finalPrice?: true
  }

  export type SubscriptionDiscountLogSumAggregateInputType = {
    discountValue?: true
    discountedAmount?: true
    originalPrice?: true
    finalPrice?: true
  }

  export type SubscriptionDiscountLogMinAggregateInputType = {
    id?: true
    subscriberSubscriptionId?: true
    discountId?: true
    discountCode?: true
    discountType?: true
    discountValue?: true
    discountedAmount?: true
    originalPrice?: true
    finalPrice?: true
    appliedAt?: true
    createdBy?: true
  }

  export type SubscriptionDiscountLogMaxAggregateInputType = {
    id?: true
    subscriberSubscriptionId?: true
    discountId?: true
    discountCode?: true
    discountType?: true
    discountValue?: true
    discountedAmount?: true
    originalPrice?: true
    finalPrice?: true
    appliedAt?: true
    createdBy?: true
  }

  export type SubscriptionDiscountLogCountAggregateInputType = {
    id?: true
    subscriberSubscriptionId?: true
    discountId?: true
    discountCode?: true
    discountType?: true
    discountValue?: true
    discountedAmount?: true
    originalPrice?: true
    finalPrice?: true
    appliedAt?: true
    createdBy?: true
    _all?: true
  }

  export type SubscriptionDiscountLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionDiscountLog to aggregate.
     */
    where?: SubscriptionDiscountLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionDiscountLogs to fetch.
     */
    orderBy?: SubscriptionDiscountLogOrderByWithRelationInput | SubscriptionDiscountLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionDiscountLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionDiscountLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionDiscountLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionDiscountLogs
    **/
    _count?: true | SubscriptionDiscountLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionDiscountLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionDiscountLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionDiscountLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionDiscountLogMaxAggregateInputType
  }

  export type GetSubscriptionDiscountLogAggregateType<T extends SubscriptionDiscountLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionDiscountLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionDiscountLog[P]>
      : GetScalarType<T[P], AggregateSubscriptionDiscountLog[P]>
  }




  export type SubscriptionDiscountLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionDiscountLogWhereInput
    orderBy?: SubscriptionDiscountLogOrderByWithAggregationInput | SubscriptionDiscountLogOrderByWithAggregationInput[]
    by: SubscriptionDiscountLogScalarFieldEnum[] | SubscriptionDiscountLogScalarFieldEnum
    having?: SubscriptionDiscountLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionDiscountLogCountAggregateInputType | true
    _avg?: SubscriptionDiscountLogAvgAggregateInputType
    _sum?: SubscriptionDiscountLogSumAggregateInputType
    _min?: SubscriptionDiscountLogMinAggregateInputType
    _max?: SubscriptionDiscountLogMaxAggregateInputType
  }

  export type SubscriptionDiscountLogGroupByOutputType = {
    id: string
    subscriberSubscriptionId: string
    discountId: string
    discountCode: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountedAmount: number
    originalPrice: number
    finalPrice: number
    appliedAt: Date
    createdBy: string | null
    _count: SubscriptionDiscountLogCountAggregateOutputType | null
    _avg: SubscriptionDiscountLogAvgAggregateOutputType | null
    _sum: SubscriptionDiscountLogSumAggregateOutputType | null
    _min: SubscriptionDiscountLogMinAggregateOutputType | null
    _max: SubscriptionDiscountLogMaxAggregateOutputType | null
  }

  type GetSubscriptionDiscountLogGroupByPayload<T extends SubscriptionDiscountLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionDiscountLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionDiscountLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionDiscountLogGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionDiscountLogGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionDiscountLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriberSubscriptionId?: boolean
    discountId?: boolean
    discountCode?: boolean
    discountType?: boolean
    discountValue?: boolean
    discountedAmount?: boolean
    originalPrice?: boolean
    finalPrice?: boolean
    appliedAt?: boolean
    createdBy?: boolean
    subscriberSubscription?: boolean | SubscriberSubscriptionDefaultArgs<ExtArgs>
    discount?: boolean | DiscountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionDiscountLog"]>

  export type SubscriptionDiscountLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriberSubscriptionId?: boolean
    discountId?: boolean
    discountCode?: boolean
    discountType?: boolean
    discountValue?: boolean
    discountedAmount?: boolean
    originalPrice?: boolean
    finalPrice?: boolean
    appliedAt?: boolean
    createdBy?: boolean
    subscriberSubscription?: boolean | SubscriberSubscriptionDefaultArgs<ExtArgs>
    discount?: boolean | DiscountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionDiscountLog"]>

  export type SubscriptionDiscountLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriberSubscriptionId?: boolean
    discountId?: boolean
    discountCode?: boolean
    discountType?: boolean
    discountValue?: boolean
    discountedAmount?: boolean
    originalPrice?: boolean
    finalPrice?: boolean
    appliedAt?: boolean
    createdBy?: boolean
    subscriberSubscription?: boolean | SubscriberSubscriptionDefaultArgs<ExtArgs>
    discount?: boolean | DiscountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionDiscountLog"]>

  export type SubscriptionDiscountLogSelectScalar = {
    id?: boolean
    subscriberSubscriptionId?: boolean
    discountId?: boolean
    discountCode?: boolean
    discountType?: boolean
    discountValue?: boolean
    discountedAmount?: boolean
    originalPrice?: boolean
    finalPrice?: boolean
    appliedAt?: boolean
    createdBy?: boolean
  }

  export type SubscriptionDiscountLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriberSubscriptionId" | "discountId" | "discountCode" | "discountType" | "discountValue" | "discountedAmount" | "originalPrice" | "finalPrice" | "appliedAt" | "createdBy", ExtArgs["result"]["subscriptionDiscountLog"]>
  export type SubscriptionDiscountLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriberSubscription?: boolean | SubscriberSubscriptionDefaultArgs<ExtArgs>
    discount?: boolean | DiscountDefaultArgs<ExtArgs>
  }
  export type SubscriptionDiscountLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriberSubscription?: boolean | SubscriberSubscriptionDefaultArgs<ExtArgs>
    discount?: boolean | DiscountDefaultArgs<ExtArgs>
  }
  export type SubscriptionDiscountLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriberSubscription?: boolean | SubscriberSubscriptionDefaultArgs<ExtArgs>
    discount?: boolean | DiscountDefaultArgs<ExtArgs>
  }

  export type $SubscriptionDiscountLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionDiscountLog"
    objects: {
      subscriberSubscription: Prisma.$SubscriberSubscriptionPayload<ExtArgs>
      discount: Prisma.$DiscountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriberSubscriptionId: string
      discountId: string
      discountCode: string
      discountType: $Enums.DiscountType
      discountValue: number
      discountedAmount: number
      originalPrice: number
      finalPrice: number
      appliedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["subscriptionDiscountLog"]>
    composites: {}
  }

  type SubscriptionDiscountLogGetPayload<S extends boolean | null | undefined | SubscriptionDiscountLogDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionDiscountLogPayload, S>

  type SubscriptionDiscountLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionDiscountLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionDiscountLogCountAggregateInputType | true
    }

  export interface SubscriptionDiscountLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionDiscountLog'], meta: { name: 'SubscriptionDiscountLog' } }
    /**
     * Find zero or one SubscriptionDiscountLog that matches the filter.
     * @param {SubscriptionDiscountLogFindUniqueArgs} args - Arguments to find a SubscriptionDiscountLog
     * @example
     * // Get one SubscriptionDiscountLog
     * const subscriptionDiscountLog = await prisma.subscriptionDiscountLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionDiscountLogFindUniqueArgs>(args: SelectSubset<T, SubscriptionDiscountLogFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionDiscountLogClient<$Result.GetResult<Prisma.$SubscriptionDiscountLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionDiscountLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionDiscountLogFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionDiscountLog
     * @example
     * // Get one SubscriptionDiscountLog
     * const subscriptionDiscountLog = await prisma.subscriptionDiscountLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionDiscountLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionDiscountLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionDiscountLogClient<$Result.GetResult<Prisma.$SubscriptionDiscountLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionDiscountLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDiscountLogFindFirstArgs} args - Arguments to find a SubscriptionDiscountLog
     * @example
     * // Get one SubscriptionDiscountLog
     * const subscriptionDiscountLog = await prisma.subscriptionDiscountLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionDiscountLogFindFirstArgs>(args?: SelectSubset<T, SubscriptionDiscountLogFindFirstArgs<ExtArgs>>): Prisma__SubscriptionDiscountLogClient<$Result.GetResult<Prisma.$SubscriptionDiscountLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionDiscountLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDiscountLogFindFirstOrThrowArgs} args - Arguments to find a SubscriptionDiscountLog
     * @example
     * // Get one SubscriptionDiscountLog
     * const subscriptionDiscountLog = await prisma.subscriptionDiscountLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionDiscountLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionDiscountLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionDiscountLogClient<$Result.GetResult<Prisma.$SubscriptionDiscountLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionDiscountLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDiscountLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionDiscountLogs
     * const subscriptionDiscountLogs = await prisma.subscriptionDiscountLog.findMany()
     * 
     * // Get first 10 SubscriptionDiscountLogs
     * const subscriptionDiscountLogs = await prisma.subscriptionDiscountLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionDiscountLogWithIdOnly = await prisma.subscriptionDiscountLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionDiscountLogFindManyArgs>(args?: SelectSubset<T, SubscriptionDiscountLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionDiscountLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionDiscountLog.
     * @param {SubscriptionDiscountLogCreateArgs} args - Arguments to create a SubscriptionDiscountLog.
     * @example
     * // Create one SubscriptionDiscountLog
     * const SubscriptionDiscountLog = await prisma.subscriptionDiscountLog.create({
     *   data: {
     *     // ... data to create a SubscriptionDiscountLog
     *   }
     * })
     * 
     */
    create<T extends SubscriptionDiscountLogCreateArgs>(args: SelectSubset<T, SubscriptionDiscountLogCreateArgs<ExtArgs>>): Prisma__SubscriptionDiscountLogClient<$Result.GetResult<Prisma.$SubscriptionDiscountLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionDiscountLogs.
     * @param {SubscriptionDiscountLogCreateManyArgs} args - Arguments to create many SubscriptionDiscountLogs.
     * @example
     * // Create many SubscriptionDiscountLogs
     * const subscriptionDiscountLog = await prisma.subscriptionDiscountLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionDiscountLogCreateManyArgs>(args?: SelectSubset<T, SubscriptionDiscountLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionDiscountLogs and returns the data saved in the database.
     * @param {SubscriptionDiscountLogCreateManyAndReturnArgs} args - Arguments to create many SubscriptionDiscountLogs.
     * @example
     * // Create many SubscriptionDiscountLogs
     * const subscriptionDiscountLog = await prisma.subscriptionDiscountLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionDiscountLogs and only return the `id`
     * const subscriptionDiscountLogWithIdOnly = await prisma.subscriptionDiscountLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionDiscountLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionDiscountLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionDiscountLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionDiscountLog.
     * @param {SubscriptionDiscountLogDeleteArgs} args - Arguments to delete one SubscriptionDiscountLog.
     * @example
     * // Delete one SubscriptionDiscountLog
     * const SubscriptionDiscountLog = await prisma.subscriptionDiscountLog.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionDiscountLog
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDiscountLogDeleteArgs>(args: SelectSubset<T, SubscriptionDiscountLogDeleteArgs<ExtArgs>>): Prisma__SubscriptionDiscountLogClient<$Result.GetResult<Prisma.$SubscriptionDiscountLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionDiscountLog.
     * @param {SubscriptionDiscountLogUpdateArgs} args - Arguments to update one SubscriptionDiscountLog.
     * @example
     * // Update one SubscriptionDiscountLog
     * const subscriptionDiscountLog = await prisma.subscriptionDiscountLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionDiscountLogUpdateArgs>(args: SelectSubset<T, SubscriptionDiscountLogUpdateArgs<ExtArgs>>): Prisma__SubscriptionDiscountLogClient<$Result.GetResult<Prisma.$SubscriptionDiscountLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionDiscountLogs.
     * @param {SubscriptionDiscountLogDeleteManyArgs} args - Arguments to filter SubscriptionDiscountLogs to delete.
     * @example
     * // Delete a few SubscriptionDiscountLogs
     * const { count } = await prisma.subscriptionDiscountLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDiscountLogDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDiscountLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionDiscountLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDiscountLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionDiscountLogs
     * const subscriptionDiscountLog = await prisma.subscriptionDiscountLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionDiscountLogUpdateManyArgs>(args: SelectSubset<T, SubscriptionDiscountLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionDiscountLogs and returns the data updated in the database.
     * @param {SubscriptionDiscountLogUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionDiscountLogs.
     * @example
     * // Update many SubscriptionDiscountLogs
     * const subscriptionDiscountLog = await prisma.subscriptionDiscountLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionDiscountLogs and only return the `id`
     * const subscriptionDiscountLogWithIdOnly = await prisma.subscriptionDiscountLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionDiscountLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionDiscountLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionDiscountLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionDiscountLog.
     * @param {SubscriptionDiscountLogUpsertArgs} args - Arguments to update or create a SubscriptionDiscountLog.
     * @example
     * // Update or create a SubscriptionDiscountLog
     * const subscriptionDiscountLog = await prisma.subscriptionDiscountLog.upsert({
     *   create: {
     *     // ... data to create a SubscriptionDiscountLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionDiscountLog we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionDiscountLogUpsertArgs>(args: SelectSubset<T, SubscriptionDiscountLogUpsertArgs<ExtArgs>>): Prisma__SubscriptionDiscountLogClient<$Result.GetResult<Prisma.$SubscriptionDiscountLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionDiscountLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDiscountLogCountArgs} args - Arguments to filter SubscriptionDiscountLogs to count.
     * @example
     * // Count the number of SubscriptionDiscountLogs
     * const count = await prisma.subscriptionDiscountLog.count({
     *   where: {
     *     // ... the filter for the SubscriptionDiscountLogs we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionDiscountLogCountArgs>(
      args?: Subset<T, SubscriptionDiscountLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionDiscountLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionDiscountLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDiscountLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionDiscountLogAggregateArgs>(args: Subset<T, SubscriptionDiscountLogAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionDiscountLogAggregateType<T>>

    /**
     * Group by SubscriptionDiscountLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDiscountLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionDiscountLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionDiscountLogGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionDiscountLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionDiscountLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionDiscountLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionDiscountLog model
   */
  readonly fields: SubscriptionDiscountLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionDiscountLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionDiscountLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriberSubscription<T extends SubscriberSubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriberSubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriberSubscriptionClient<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    discount<T extends DiscountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DiscountDefaultArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionDiscountLog model
   */
  interface SubscriptionDiscountLogFieldRefs {
    readonly id: FieldRef<"SubscriptionDiscountLog", 'String'>
    readonly subscriberSubscriptionId: FieldRef<"SubscriptionDiscountLog", 'String'>
    readonly discountId: FieldRef<"SubscriptionDiscountLog", 'String'>
    readonly discountCode: FieldRef<"SubscriptionDiscountLog", 'String'>
    readonly discountType: FieldRef<"SubscriptionDiscountLog", 'DiscountType'>
    readonly discountValue: FieldRef<"SubscriptionDiscountLog", 'Float'>
    readonly discountedAmount: FieldRef<"SubscriptionDiscountLog", 'Float'>
    readonly originalPrice: FieldRef<"SubscriptionDiscountLog", 'Float'>
    readonly finalPrice: FieldRef<"SubscriptionDiscountLog", 'Float'>
    readonly appliedAt: FieldRef<"SubscriptionDiscountLog", 'DateTime'>
    readonly createdBy: FieldRef<"SubscriptionDiscountLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionDiscountLog findUnique
   */
  export type SubscriptionDiscountLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDiscountLog
     */
    select?: SubscriptionDiscountLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDiscountLog
     */
    omit?: SubscriptionDiscountLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDiscountLogInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionDiscountLog to fetch.
     */
    where: SubscriptionDiscountLogWhereUniqueInput
  }

  /**
   * SubscriptionDiscountLog findUniqueOrThrow
   */
  export type SubscriptionDiscountLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDiscountLog
     */
    select?: SubscriptionDiscountLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDiscountLog
     */
    omit?: SubscriptionDiscountLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDiscountLogInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionDiscountLog to fetch.
     */
    where: SubscriptionDiscountLogWhereUniqueInput
  }

  /**
   * SubscriptionDiscountLog findFirst
   */
  export type SubscriptionDiscountLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDiscountLog
     */
    select?: SubscriptionDiscountLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDiscountLog
     */
    omit?: SubscriptionDiscountLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDiscountLogInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionDiscountLog to fetch.
     */
    where?: SubscriptionDiscountLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionDiscountLogs to fetch.
     */
    orderBy?: SubscriptionDiscountLogOrderByWithRelationInput | SubscriptionDiscountLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionDiscountLogs.
     */
    cursor?: SubscriptionDiscountLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionDiscountLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionDiscountLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionDiscountLogs.
     */
    distinct?: SubscriptionDiscountLogScalarFieldEnum | SubscriptionDiscountLogScalarFieldEnum[]
  }

  /**
   * SubscriptionDiscountLog findFirstOrThrow
   */
  export type SubscriptionDiscountLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDiscountLog
     */
    select?: SubscriptionDiscountLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDiscountLog
     */
    omit?: SubscriptionDiscountLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDiscountLogInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionDiscountLog to fetch.
     */
    where?: SubscriptionDiscountLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionDiscountLogs to fetch.
     */
    orderBy?: SubscriptionDiscountLogOrderByWithRelationInput | SubscriptionDiscountLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionDiscountLogs.
     */
    cursor?: SubscriptionDiscountLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionDiscountLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionDiscountLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionDiscountLogs.
     */
    distinct?: SubscriptionDiscountLogScalarFieldEnum | SubscriptionDiscountLogScalarFieldEnum[]
  }

  /**
   * SubscriptionDiscountLog findMany
   */
  export type SubscriptionDiscountLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDiscountLog
     */
    select?: SubscriptionDiscountLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDiscountLog
     */
    omit?: SubscriptionDiscountLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDiscountLogInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionDiscountLogs to fetch.
     */
    where?: SubscriptionDiscountLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionDiscountLogs to fetch.
     */
    orderBy?: SubscriptionDiscountLogOrderByWithRelationInput | SubscriptionDiscountLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionDiscountLogs.
     */
    cursor?: SubscriptionDiscountLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionDiscountLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionDiscountLogs.
     */
    skip?: number
    distinct?: SubscriptionDiscountLogScalarFieldEnum | SubscriptionDiscountLogScalarFieldEnum[]
  }

  /**
   * SubscriptionDiscountLog create
   */
  export type SubscriptionDiscountLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDiscountLog
     */
    select?: SubscriptionDiscountLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDiscountLog
     */
    omit?: SubscriptionDiscountLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDiscountLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionDiscountLog.
     */
    data: XOR<SubscriptionDiscountLogCreateInput, SubscriptionDiscountLogUncheckedCreateInput>
  }

  /**
   * SubscriptionDiscountLog createMany
   */
  export type SubscriptionDiscountLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionDiscountLogs.
     */
    data: SubscriptionDiscountLogCreateManyInput | SubscriptionDiscountLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionDiscountLog createManyAndReturn
   */
  export type SubscriptionDiscountLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDiscountLog
     */
    select?: SubscriptionDiscountLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDiscountLog
     */
    omit?: SubscriptionDiscountLogOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionDiscountLogs.
     */
    data: SubscriptionDiscountLogCreateManyInput | SubscriptionDiscountLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDiscountLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionDiscountLog update
   */
  export type SubscriptionDiscountLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDiscountLog
     */
    select?: SubscriptionDiscountLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDiscountLog
     */
    omit?: SubscriptionDiscountLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDiscountLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionDiscountLog.
     */
    data: XOR<SubscriptionDiscountLogUpdateInput, SubscriptionDiscountLogUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionDiscountLog to update.
     */
    where: SubscriptionDiscountLogWhereUniqueInput
  }

  /**
   * SubscriptionDiscountLog updateMany
   */
  export type SubscriptionDiscountLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionDiscountLogs.
     */
    data: XOR<SubscriptionDiscountLogUpdateManyMutationInput, SubscriptionDiscountLogUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionDiscountLogs to update
     */
    where?: SubscriptionDiscountLogWhereInput
    /**
     * Limit how many SubscriptionDiscountLogs to update.
     */
    limit?: number
  }

  /**
   * SubscriptionDiscountLog updateManyAndReturn
   */
  export type SubscriptionDiscountLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDiscountLog
     */
    select?: SubscriptionDiscountLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDiscountLog
     */
    omit?: SubscriptionDiscountLogOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionDiscountLogs.
     */
    data: XOR<SubscriptionDiscountLogUpdateManyMutationInput, SubscriptionDiscountLogUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionDiscountLogs to update
     */
    where?: SubscriptionDiscountLogWhereInput
    /**
     * Limit how many SubscriptionDiscountLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDiscountLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionDiscountLog upsert
   */
  export type SubscriptionDiscountLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDiscountLog
     */
    select?: SubscriptionDiscountLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDiscountLog
     */
    omit?: SubscriptionDiscountLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDiscountLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionDiscountLog to update in case it exists.
     */
    where: SubscriptionDiscountLogWhereUniqueInput
    /**
     * In case the SubscriptionDiscountLog found by the `where` argument doesn't exist, create a new SubscriptionDiscountLog with this data.
     */
    create: XOR<SubscriptionDiscountLogCreateInput, SubscriptionDiscountLogUncheckedCreateInput>
    /**
     * In case the SubscriptionDiscountLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionDiscountLogUpdateInput, SubscriptionDiscountLogUncheckedUpdateInput>
  }

  /**
   * SubscriptionDiscountLog delete
   */
  export type SubscriptionDiscountLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDiscountLog
     */
    select?: SubscriptionDiscountLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDiscountLog
     */
    omit?: SubscriptionDiscountLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDiscountLogInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionDiscountLog to delete.
     */
    where: SubscriptionDiscountLogWhereUniqueInput
  }

  /**
   * SubscriptionDiscountLog deleteMany
   */
  export type SubscriptionDiscountLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionDiscountLogs to delete
     */
    where?: SubscriptionDiscountLogWhereInput
    /**
     * Limit how many SubscriptionDiscountLogs to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionDiscountLog without action
   */
  export type SubscriptionDiscountLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDiscountLog
     */
    select?: SubscriptionDiscountLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDiscountLog
     */
    omit?: SubscriptionDiscountLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDiscountLogInclude<ExtArgs> | null
  }


  /**
   * Model Business
   */

  export type AggregateBusiness = {
    _count: BusinessCountAggregateOutputType | null
    _avg: BusinessAvgAggregateOutputType | null
    _sum: BusinessSumAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  export type BusinessAvgAggregateOutputType = {
    businessId: number | null
    subscriptionPrice: number | null
  }

  export type BusinessSumAggregateOutputType = {
    businessId: number | null
    subscriptionPrice: number | null
  }

  export type BusinessMinAggregateOutputType = {
    id: string | null
    businessId: number | null
    name: string | null
    image: string | null
    websiteLink: string | null
    phoneNumber: string | null
    businessType: $Enums.BusinessType | null
    subscriptionId: string | null
    subscriptionType: $Enums.SubscriptionType | null
    subscriptionPrice: number | null
    subscriptionValidity: $Enums.SubscriptionValidity | null
    discountCodeId: string | null
    subscriberId: string | null
    status: $Enums.BusinessStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type BusinessMaxAggregateOutputType = {
    id: string | null
    businessId: number | null
    name: string | null
    image: string | null
    websiteLink: string | null
    phoneNumber: string | null
    businessType: $Enums.BusinessType | null
    subscriptionId: string | null
    subscriptionType: $Enums.SubscriptionType | null
    subscriptionPrice: number | null
    subscriptionValidity: $Enums.SubscriptionValidity | null
    discountCodeId: string | null
    subscriberId: string | null
    status: $Enums.BusinessStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type BusinessCountAggregateOutputType = {
    id: number
    businessId: number
    name: number
    image: number
    websiteLink: number
    phoneNumber: number
    businessType: number
    subscriptionId: number
    subscriptionType: number
    subscriptionPrice: number
    subscriptionValidity: number
    discountCodeId: number
    subscriberId: number
    status: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type BusinessAvgAggregateInputType = {
    businessId?: true
    subscriptionPrice?: true
  }

  export type BusinessSumAggregateInputType = {
    businessId?: true
    subscriptionPrice?: true
  }

  export type BusinessMinAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    image?: true
    websiteLink?: true
    phoneNumber?: true
    businessType?: true
    subscriptionId?: true
    subscriptionType?: true
    subscriptionPrice?: true
    subscriptionValidity?: true
    discountCodeId?: true
    subscriberId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type BusinessMaxAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    image?: true
    websiteLink?: true
    phoneNumber?: true
    businessType?: true
    subscriptionId?: true
    subscriptionType?: true
    subscriptionPrice?: true
    subscriptionValidity?: true
    discountCodeId?: true
    subscriberId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type BusinessCountAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    image?: true
    websiteLink?: true
    phoneNumber?: true
    businessType?: true
    subscriptionId?: true
    subscriptionType?: true
    subscriptionPrice?: true
    subscriptionValidity?: true
    discountCodeId?: true
    subscriberId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type BusinessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Business to aggregate.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Businesses
    **/
    _count?: true | BusinessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessMaxAggregateInputType
  }

  export type GetBusinessAggregateType<T extends BusinessAggregateArgs> = {
        [P in keyof T & keyof AggregateBusiness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusiness[P]>
      : GetScalarType<T[P], AggregateBusiness[P]>
  }




  export type BusinessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithAggregationInput | BusinessOrderByWithAggregationInput[]
    by: BusinessScalarFieldEnum[] | BusinessScalarFieldEnum
    having?: BusinessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessCountAggregateInputType | true
    _avg?: BusinessAvgAggregateInputType
    _sum?: BusinessSumAggregateInputType
    _min?: BusinessMinAggregateInputType
    _max?: BusinessMaxAggregateInputType
  }

  export type BusinessGroupByOutputType = {
    id: string
    businessId: number
    name: string
    image: string | null
    websiteLink: string | null
    phoneNumber: string | null
    businessType: $Enums.BusinessType
    subscriptionId: string | null
    subscriptionType: $Enums.SubscriptionType | null
    subscriptionPrice: number | null
    subscriptionValidity: $Enums.SubscriptionValidity | null
    discountCodeId: string | null
    subscriberId: string | null
    status: $Enums.BusinessStatus
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: BusinessCountAggregateOutputType | null
    _avg: BusinessAvgAggregateOutputType | null
    _sum: BusinessSumAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  type GetBusinessGroupByPayload<T extends BusinessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessGroupByOutputType[P]>
        }
      >
    >


  export type BusinessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    image?: boolean
    websiteLink?: boolean
    phoneNumber?: boolean
    businessType?: boolean
    subscriptionId?: boolean
    subscriptionType?: boolean
    subscriptionPrice?: boolean
    subscriptionValidity?: boolean
    discountCodeId?: boolean
    subscriberId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    flows?: boolean | Business$flowsArgs<ExtArgs>
    whatsappNumbers?: boolean | Business$whatsappNumbersArgs<ExtArgs>
    subscriber?: boolean | Business$subscriberArgs<ExtArgs>
    discountCode?: boolean | Business$discountCodeArgs<ExtArgs>
    branches?: boolean | Business$branchesArgs<ExtArgs>
    subscription?: boolean | Business$subscriptionArgs<ExtArgs>
    subscriberSubscriptions?: boolean | Business$subscriberSubscriptionsArgs<ExtArgs>
    scheduleHours?: boolean | Business$scheduleHoursArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    image?: boolean
    websiteLink?: boolean
    phoneNumber?: boolean
    businessType?: boolean
    subscriptionId?: boolean
    subscriptionType?: boolean
    subscriptionPrice?: boolean
    subscriptionValidity?: boolean
    discountCodeId?: boolean
    subscriberId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    subscriber?: boolean | Business$subscriberArgs<ExtArgs>
    discountCode?: boolean | Business$discountCodeArgs<ExtArgs>
    subscription?: boolean | Business$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    image?: boolean
    websiteLink?: boolean
    phoneNumber?: boolean
    businessType?: boolean
    subscriptionId?: boolean
    subscriptionType?: boolean
    subscriptionPrice?: boolean
    subscriptionValidity?: boolean
    discountCodeId?: boolean
    subscriberId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    subscriber?: boolean | Business$subscriberArgs<ExtArgs>
    discountCode?: boolean | Business$discountCodeArgs<ExtArgs>
    subscription?: boolean | Business$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectScalar = {
    id?: boolean
    businessId?: boolean
    name?: boolean
    image?: boolean
    websiteLink?: boolean
    phoneNumber?: boolean
    businessType?: boolean
    subscriptionId?: boolean
    subscriptionType?: boolean
    subscriptionPrice?: boolean
    subscriptionValidity?: boolean
    discountCodeId?: boolean
    subscriberId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type BusinessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessId" | "name" | "image" | "websiteLink" | "phoneNumber" | "businessType" | "subscriptionId" | "subscriptionType" | "subscriptionPrice" | "subscriptionValidity" | "discountCodeId" | "subscriberId" | "status" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["business"]>
  export type BusinessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flows?: boolean | Business$flowsArgs<ExtArgs>
    whatsappNumbers?: boolean | Business$whatsappNumbersArgs<ExtArgs>
    subscriber?: boolean | Business$subscriberArgs<ExtArgs>
    discountCode?: boolean | Business$discountCodeArgs<ExtArgs>
    branches?: boolean | Business$branchesArgs<ExtArgs>
    subscription?: boolean | Business$subscriptionArgs<ExtArgs>
    subscriberSubscriptions?: boolean | Business$subscriberSubscriptionsArgs<ExtArgs>
    scheduleHours?: boolean | Business$scheduleHoursArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | Business$subscriberArgs<ExtArgs>
    discountCode?: boolean | Business$discountCodeArgs<ExtArgs>
    subscription?: boolean | Business$subscriptionArgs<ExtArgs>
  }
  export type BusinessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | Business$subscriberArgs<ExtArgs>
    discountCode?: boolean | Business$discountCodeArgs<ExtArgs>
    subscription?: boolean | Business$subscriptionArgs<ExtArgs>
  }

  export type $BusinessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Business"
    objects: {
      flows: Prisma.$FlowPayload<ExtArgs>[]
      whatsappNumbers: Prisma.$WhatsAppNumberPayload<ExtArgs>[]
      subscriber: Prisma.$UserPayload<ExtArgs> | null
      discountCode: Prisma.$DiscountPayload<ExtArgs> | null
      branches: Prisma.$BranchPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      subscriberSubscriptions: Prisma.$SubscriberSubscriptionPayload<ExtArgs>[]
      scheduleHours: Prisma.$ScheduleHourPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: number
      name: string
      image: string | null
      websiteLink: string | null
      phoneNumber: string | null
      businessType: $Enums.BusinessType
      subscriptionId: string | null
      subscriptionType: $Enums.SubscriptionType | null
      subscriptionPrice: number | null
      subscriptionValidity: $Enums.SubscriptionValidity | null
      discountCodeId: string | null
      subscriberId: string | null
      status: $Enums.BusinessStatus
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["business"]>
    composites: {}
  }

  type BusinessGetPayload<S extends boolean | null | undefined | BusinessDefaultArgs> = $Result.GetResult<Prisma.$BusinessPayload, S>

  type BusinessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessCountAggregateInputType | true
    }

  export interface BusinessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Business'], meta: { name: 'Business' } }
    /**
     * Find zero or one Business that matches the filter.
     * @param {BusinessFindUniqueArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessFindUniqueArgs>(args: SelectSubset<T, BusinessFindUniqueArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Business that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessFindUniqueOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Business that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessFindFirstArgs>(args?: SelectSubset<T, BusinessFindFirstArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Business that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Businesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Businesses
     * const businesses = await prisma.business.findMany()
     * 
     * // Get first 10 Businesses
     * const businesses = await prisma.business.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessWithIdOnly = await prisma.business.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessFindManyArgs>(args?: SelectSubset<T, BusinessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Business.
     * @param {BusinessCreateArgs} args - Arguments to create a Business.
     * @example
     * // Create one Business
     * const Business = await prisma.business.create({
     *   data: {
     *     // ... data to create a Business
     *   }
     * })
     * 
     */
    create<T extends BusinessCreateArgs>(args: SelectSubset<T, BusinessCreateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Businesses.
     * @param {BusinessCreateManyArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessCreateManyArgs>(args?: SelectSubset<T, BusinessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Businesses and returns the data saved in the database.
     * @param {BusinessCreateManyAndReturnArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Businesses and only return the `id`
     * const businessWithIdOnly = await prisma.business.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Business.
     * @param {BusinessDeleteArgs} args - Arguments to delete one Business.
     * @example
     * // Delete one Business
     * const Business = await prisma.business.delete({
     *   where: {
     *     // ... filter to delete one Business
     *   }
     * })
     * 
     */
    delete<T extends BusinessDeleteArgs>(args: SelectSubset<T, BusinessDeleteArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Business.
     * @param {BusinessUpdateArgs} args - Arguments to update one Business.
     * @example
     * // Update one Business
     * const business = await prisma.business.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessUpdateArgs>(args: SelectSubset<T, BusinessUpdateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Businesses.
     * @param {BusinessDeleteManyArgs} args - Arguments to filter Businesses to delete.
     * @example
     * // Delete a few Businesses
     * const { count } = await prisma.business.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessDeleteManyArgs>(args?: SelectSubset<T, BusinessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Businesses
     * const business = await prisma.business.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessUpdateManyArgs>(args: SelectSubset<T, BusinessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Businesses and returns the data updated in the database.
     * @param {BusinessUpdateManyAndReturnArgs} args - Arguments to update many Businesses.
     * @example
     * // Update many Businesses
     * const business = await prisma.business.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Businesses and only return the `id`
     * const businessWithIdOnly = await prisma.business.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Business.
     * @param {BusinessUpsertArgs} args - Arguments to update or create a Business.
     * @example
     * // Update or create a Business
     * const business = await prisma.business.upsert({
     *   create: {
     *     // ... data to create a Business
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Business we want to update
     *   }
     * })
     */
    upsert<T extends BusinessUpsertArgs>(args: SelectSubset<T, BusinessUpsertArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCountArgs} args - Arguments to filter Businesses to count.
     * @example
     * // Count the number of Businesses
     * const count = await prisma.business.count({
     *   where: {
     *     // ... the filter for the Businesses we want to count
     *   }
     * })
    **/
    count<T extends BusinessCountArgs>(
      args?: Subset<T, BusinessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessAggregateArgs>(args: Subset<T, BusinessAggregateArgs>): Prisma.PrismaPromise<GetBusinessAggregateType<T>>

    /**
     * Group by Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessGroupByArgs['orderBy'] }
        : { orderBy?: BusinessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Business model
   */
  readonly fields: BusinessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Business.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flows<T extends Business$flowsArgs<ExtArgs> = {}>(args?: Subset<T, Business$flowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappNumbers<T extends Business$whatsappNumbersArgs<ExtArgs> = {}>(args?: Subset<T, Business$whatsappNumbersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppNumberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriber<T extends Business$subscriberArgs<ExtArgs> = {}>(args?: Subset<T, Business$subscriberArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    discountCode<T extends Business$discountCodeArgs<ExtArgs> = {}>(args?: Subset<T, Business$discountCodeArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    branches<T extends Business$branchesArgs<ExtArgs> = {}>(args?: Subset<T, Business$branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends Business$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Business$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subscriberSubscriptions<T extends Business$subscriberSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Business$subscriberSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduleHours<T extends Business$scheduleHoursArgs<ExtArgs> = {}>(args?: Subset<T, Business$scheduleHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleHourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Business model
   */
  interface BusinessFieldRefs {
    readonly id: FieldRef<"Business", 'String'>
    readonly businessId: FieldRef<"Business", 'Int'>
    readonly name: FieldRef<"Business", 'String'>
    readonly image: FieldRef<"Business", 'String'>
    readonly websiteLink: FieldRef<"Business", 'String'>
    readonly phoneNumber: FieldRef<"Business", 'String'>
    readonly businessType: FieldRef<"Business", 'BusinessType'>
    readonly subscriptionId: FieldRef<"Business", 'String'>
    readonly subscriptionType: FieldRef<"Business", 'SubscriptionType'>
    readonly subscriptionPrice: FieldRef<"Business", 'Float'>
    readonly subscriptionValidity: FieldRef<"Business", 'SubscriptionValidity'>
    readonly discountCodeId: FieldRef<"Business", 'String'>
    readonly subscriberId: FieldRef<"Business", 'String'>
    readonly status: FieldRef<"Business", 'BusinessStatus'>
    readonly createdAt: FieldRef<"Business", 'DateTime'>
    readonly updatedAt: FieldRef<"Business", 'DateTime'>
    readonly createdBy: FieldRef<"Business", 'String'>
    readonly updatedBy: FieldRef<"Business", 'String'>
    readonly isDeleted: FieldRef<"Business", 'Boolean'>
    readonly deletedAt: FieldRef<"Business", 'DateTime'>
    readonly deletedBy: FieldRef<"Business", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Business findUnique
   */
  export type BusinessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findUniqueOrThrow
   */
  export type BusinessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findFirst
   */
  export type BusinessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findFirstOrThrow
   */
  export type BusinessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findMany
   */
  export type BusinessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Businesses to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business create
   */
  export type BusinessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to create a Business.
     */
    data: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
  }

  /**
   * Business createMany
   */
  export type BusinessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Business createManyAndReturn
   */
  export type BusinessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Business update
   */
  export type BusinessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to update a Business.
     */
    data: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
    /**
     * Choose, which Business to update.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business updateMany
   */
  export type BusinessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Businesses.
     */
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Businesses to update
     */
    where?: BusinessWhereInput
    /**
     * Limit how many Businesses to update.
     */
    limit?: number
  }

  /**
   * Business updateManyAndReturn
   */
  export type BusinessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * The data used to update Businesses.
     */
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Businesses to update
     */
    where?: BusinessWhereInput
    /**
     * Limit how many Businesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Business upsert
   */
  export type BusinessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The filter to search for the Business to update in case it exists.
     */
    where: BusinessWhereUniqueInput
    /**
     * In case the Business found by the `where` argument doesn't exist, create a new Business with this data.
     */
    create: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
    /**
     * In case the Business was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
  }

  /**
   * Business delete
   */
  export type BusinessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter which Business to delete.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business deleteMany
   */
  export type BusinessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Businesses to delete
     */
    where?: BusinessWhereInput
    /**
     * Limit how many Businesses to delete.
     */
    limit?: number
  }

  /**
   * Business.flows
   */
  export type Business$flowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    where?: FlowWhereInput
    orderBy?: FlowOrderByWithRelationInput | FlowOrderByWithRelationInput[]
    cursor?: FlowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowScalarFieldEnum | FlowScalarFieldEnum[]
  }

  /**
   * Business.whatsappNumbers
   */
  export type Business$whatsappNumbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppNumber
     */
    select?: WhatsAppNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppNumber
     */
    omit?: WhatsAppNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppNumberInclude<ExtArgs> | null
    where?: WhatsAppNumberWhereInput
    orderBy?: WhatsAppNumberOrderByWithRelationInput | WhatsAppNumberOrderByWithRelationInput[]
    cursor?: WhatsAppNumberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppNumberScalarFieldEnum | WhatsAppNumberScalarFieldEnum[]
  }

  /**
   * Business.subscriber
   */
  export type Business$subscriberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Business.discountCode
   */
  export type Business$discountCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    where?: DiscountWhereInput
  }

  /**
   * Business.branches
   */
  export type Business$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Business.subscription
   */
  export type Business$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Business.subscriberSubscriptions
   */
  export type Business$subscriberSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionInclude<ExtArgs> | null
    where?: SubscriberSubscriptionWhereInput
    orderBy?: SubscriberSubscriptionOrderByWithRelationInput | SubscriberSubscriptionOrderByWithRelationInput[]
    cursor?: SubscriberSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriberSubscriptionScalarFieldEnum | SubscriberSubscriptionScalarFieldEnum[]
  }

  /**
   * Business.scheduleHours
   */
  export type Business$scheduleHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourInclude<ExtArgs> | null
    where?: ScheduleHourWhereInput
    orderBy?: ScheduleHourOrderByWithRelationInput | ScheduleHourOrderByWithRelationInput[]
    cursor?: ScheduleHourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleHourScalarFieldEnum | ScheduleHourScalarFieldEnum[]
  }

  /**
   * Business without action
   */
  export type BusinessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
  }


  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchMinAggregateOutputType = {
    id: string | null
    name: string | null
    subscriberId: string | null
    businessId: string | null
    location: string | null
    phone: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type BranchMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subscriberId: string | null
    businessId: string | null
    location: string | null
    phone: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    name: number
    subscriberId: number
    businessId: number
    location: number
    phone: number
    status: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type BranchMinAggregateInputType = {
    id?: true
    name?: true
    subscriberId?: true
    businessId?: true
    location?: true
    phone?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    name?: true
    subscriberId?: true
    businessId?: true
    location?: true
    phone?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    name?: true
    subscriberId?: true
    businessId?: true
    location?: true
    phone?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: string
    name: string
    subscriberId: string
    businessId: string | null
    location: string | null
    phone: string | null
    status: boolean
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subscriberId?: boolean
    businessId?: boolean
    location?: boolean
    phone?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    subscriber?: boolean | UserDefaultArgs<ExtArgs>
    business?: boolean | Branch$businessArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    serviceBranches?: boolean | Branch$serviceBranchesArgs<ExtArgs>
    appointments?: boolean | Branch$appointmentsArgs<ExtArgs>
    promotions?: boolean | Branch$promotionsArgs<ExtArgs>
    tabletAccounts?: boolean | Branch$tabletAccountsArgs<ExtArgs>
    whatsappAds?: boolean | Branch$whatsappAdsArgs<ExtArgs>
    scheduleHours?: boolean | Branch$scheduleHoursArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subscriberId?: boolean
    businessId?: boolean
    location?: boolean
    phone?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    subscriber?: boolean | UserDefaultArgs<ExtArgs>
    business?: boolean | Branch$businessArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subscriberId?: boolean
    businessId?: boolean
    location?: boolean
    phone?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    subscriber?: boolean | UserDefaultArgs<ExtArgs>
    business?: boolean | Branch$businessArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    name?: boolean
    subscriberId?: boolean
    businessId?: boolean
    location?: boolean
    phone?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type BranchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subscriberId" | "businessId" | "location" | "phone" | "status" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["branch"]>
  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | UserDefaultArgs<ExtArgs>
    business?: boolean | Branch$businessArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    serviceBranches?: boolean | Branch$serviceBranchesArgs<ExtArgs>
    appointments?: boolean | Branch$appointmentsArgs<ExtArgs>
    promotions?: boolean | Branch$promotionsArgs<ExtArgs>
    tabletAccounts?: boolean | Branch$tabletAccountsArgs<ExtArgs>
    whatsappAds?: boolean | Branch$whatsappAdsArgs<ExtArgs>
    scheduleHours?: boolean | Branch$scheduleHoursArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | UserDefaultArgs<ExtArgs>
    business?: boolean | Branch$businessArgs<ExtArgs>
  }
  export type BranchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | UserDefaultArgs<ExtArgs>
    business?: boolean | Branch$businessArgs<ExtArgs>
  }

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      subscriber: Prisma.$UserPayload<ExtArgs>
      business: Prisma.$BusinessPayload<ExtArgs> | null
      users: Prisma.$UserPayload<ExtArgs>[]
      serviceBranches: Prisma.$ServiceBranchPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      promotions: Prisma.$PromotionPayload<ExtArgs>[]
      tabletAccounts: Prisma.$TabletAccountPayload<ExtArgs>[]
      whatsappAds: Prisma.$WhatsappAdPayload<ExtArgs>[]
      scheduleHours: Prisma.$ScheduleHourPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subscriberId: string
      businessId: string | null
      location: string | null
      phone: string | null
      status: boolean
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches and returns the data updated in the database.
     * @param {BranchUpdateManyAndReturnArgs} args - Arguments to update many Branches.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BranchUpdateManyAndReturnArgs>(args: SelectSubset<T, BranchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriber<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    business<T extends Branch$businessArgs<ExtArgs> = {}>(args?: Subset<T, Branch$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends Branch$usersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceBranches<T extends Branch$serviceBranchesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$serviceBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Branch$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promotions<T extends Branch$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tabletAccounts<T extends Branch$tabletAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$tabletAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TabletAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappAds<T extends Branch$whatsappAdsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$whatsappAdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappAdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduleHours<T extends Branch$scheduleHoursArgs<ExtArgs> = {}>(args?: Subset<T, Branch$scheduleHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleHourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'String'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly subscriberId: FieldRef<"Branch", 'String'>
    readonly businessId: FieldRef<"Branch", 'String'>
    readonly location: FieldRef<"Branch", 'String'>
    readonly phone: FieldRef<"Branch", 'String'>
    readonly status: FieldRef<"Branch", 'Boolean'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updatedAt: FieldRef<"Branch", 'DateTime'>
    readonly createdBy: FieldRef<"Branch", 'String'>
    readonly updatedBy: FieldRef<"Branch", 'String'>
    readonly isDeleted: FieldRef<"Branch", 'Boolean'>
    readonly deletedAt: FieldRef<"Branch", 'DateTime'>
    readonly deletedBy: FieldRef<"Branch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch updateManyAndReturn
   */
  export type BranchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to delete.
     */
    limit?: number
  }

  /**
   * Branch.business
   */
  export type Branch$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * Branch.users
   */
  export type Branch$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Branch.serviceBranches
   */
  export type Branch$serviceBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceBranch
     */
    omit?: ServiceBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    where?: ServiceBranchWhereInput
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    cursor?: ServiceBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * Branch.appointments
   */
  export type Branch$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Branch.promotions
   */
  export type Branch$promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    cursor?: PromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Branch.tabletAccounts
   */
  export type Branch$tabletAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TabletAccount
     */
    select?: TabletAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TabletAccount
     */
    omit?: TabletAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TabletAccountInclude<ExtArgs> | null
    where?: TabletAccountWhereInput
    orderBy?: TabletAccountOrderByWithRelationInput | TabletAccountOrderByWithRelationInput[]
    cursor?: TabletAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TabletAccountScalarFieldEnum | TabletAccountScalarFieldEnum[]
  }

  /**
   * Branch.whatsappAds
   */
  export type Branch$whatsappAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdInclude<ExtArgs> | null
    where?: WhatsappAdWhereInput
    orderBy?: WhatsappAdOrderByWithRelationInput | WhatsappAdOrderByWithRelationInput[]
    cursor?: WhatsappAdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsappAdScalarFieldEnum | WhatsappAdScalarFieldEnum[]
  }

  /**
   * Branch.scheduleHours
   */
  export type Branch$scheduleHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourInclude<ExtArgs> | null
    where?: ScheduleHourWhereInput
    orderBy?: ScheduleHourOrderByWithRelationInput | ScheduleHourOrderByWithRelationInput[]
    cursor?: ScheduleHourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleHourScalarFieldEnum | ScheduleHourScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model ScheduleHour
   */

  export type AggregateScheduleHour = {
    _count: ScheduleHourCountAggregateOutputType | null
    _min: ScheduleHourMinAggregateOutputType | null
    _max: ScheduleHourMaxAggregateOutputType | null
  }

  export type ScheduleHourMinAggregateOutputType = {
    id: string | null
    ownerType: $Enums.ScheduleOwnerType | null
    ownerId: string | null
    dayOfWeek: $Enums.WeekDay | null
    openTime: string | null
    closeTime: string | null
    isClosed: boolean | null
    inheritanceMode: $Enums.ScheduleInheritanceMode | null
    staffId: string | null
    businessId: string | null
    branchId: string | null
    lastModifiedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ScheduleHourMaxAggregateOutputType = {
    id: string | null
    ownerType: $Enums.ScheduleOwnerType | null
    ownerId: string | null
    dayOfWeek: $Enums.WeekDay | null
    openTime: string | null
    closeTime: string | null
    isClosed: boolean | null
    inheritanceMode: $Enums.ScheduleInheritanceMode | null
    staffId: string | null
    businessId: string | null
    branchId: string | null
    lastModifiedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ScheduleHourCountAggregateOutputType = {
    id: number
    ownerType: number
    ownerId: number
    dayOfWeek: number
    openTime: number
    closeTime: number
    isClosed: number
    inheritanceMode: number
    staffId: number
    businessId: number
    branchId: number
    lastModifiedBy: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type ScheduleHourMinAggregateInputType = {
    id?: true
    ownerType?: true
    ownerId?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    isClosed?: true
    inheritanceMode?: true
    staffId?: true
    businessId?: true
    branchId?: true
    lastModifiedBy?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ScheduleHourMaxAggregateInputType = {
    id?: true
    ownerType?: true
    ownerId?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    isClosed?: true
    inheritanceMode?: true
    staffId?: true
    businessId?: true
    branchId?: true
    lastModifiedBy?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ScheduleHourCountAggregateInputType = {
    id?: true
    ownerType?: true
    ownerId?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    isClosed?: true
    inheritanceMode?: true
    staffId?: true
    businessId?: true
    branchId?: true
    lastModifiedBy?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type ScheduleHourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleHour to aggregate.
     */
    where?: ScheduleHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleHours to fetch.
     */
    orderBy?: ScheduleHourOrderByWithRelationInput | ScheduleHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduleHours
    **/
    _count?: true | ScheduleHourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleHourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleHourMaxAggregateInputType
  }

  export type GetScheduleHourAggregateType<T extends ScheduleHourAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduleHour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduleHour[P]>
      : GetScalarType<T[P], AggregateScheduleHour[P]>
  }




  export type ScheduleHourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleHourWhereInput
    orderBy?: ScheduleHourOrderByWithAggregationInput | ScheduleHourOrderByWithAggregationInput[]
    by: ScheduleHourScalarFieldEnum[] | ScheduleHourScalarFieldEnum
    having?: ScheduleHourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleHourCountAggregateInputType | true
    _min?: ScheduleHourMinAggregateInputType
    _max?: ScheduleHourMaxAggregateInputType
  }

  export type ScheduleHourGroupByOutputType = {
    id: string
    ownerType: $Enums.ScheduleOwnerType
    ownerId: string
    dayOfWeek: $Enums.WeekDay
    openTime: string
    closeTime: string
    isClosed: boolean
    inheritanceMode: $Enums.ScheduleInheritanceMode
    staffId: string | null
    businessId: string | null
    branchId: string | null
    lastModifiedBy: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: ScheduleHourCountAggregateOutputType | null
    _min: ScheduleHourMinAggregateOutputType | null
    _max: ScheduleHourMaxAggregateOutputType | null
  }

  type GetScheduleHourGroupByPayload<T extends ScheduleHourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleHourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleHourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleHourGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleHourGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleHourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerType?: boolean
    ownerId?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    isClosed?: boolean
    inheritanceMode?: boolean
    staffId?: boolean
    businessId?: boolean
    branchId?: boolean
    lastModifiedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    staff?: boolean | ScheduleHour$staffArgs<ExtArgs>
    business?: boolean | ScheduleHour$businessArgs<ExtArgs>
    branch?: boolean | ScheduleHour$branchArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleHour"]>

  export type ScheduleHourSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerType?: boolean
    ownerId?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    isClosed?: boolean
    inheritanceMode?: boolean
    staffId?: boolean
    businessId?: boolean
    branchId?: boolean
    lastModifiedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    staff?: boolean | ScheduleHour$staffArgs<ExtArgs>
    business?: boolean | ScheduleHour$businessArgs<ExtArgs>
    branch?: boolean | ScheduleHour$branchArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleHour"]>

  export type ScheduleHourSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerType?: boolean
    ownerId?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    isClosed?: boolean
    inheritanceMode?: boolean
    staffId?: boolean
    businessId?: boolean
    branchId?: boolean
    lastModifiedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    staff?: boolean | ScheduleHour$staffArgs<ExtArgs>
    business?: boolean | ScheduleHour$businessArgs<ExtArgs>
    branch?: boolean | ScheduleHour$branchArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleHour"]>

  export type ScheduleHourSelectScalar = {
    id?: boolean
    ownerType?: boolean
    ownerId?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    isClosed?: boolean
    inheritanceMode?: boolean
    staffId?: boolean
    businessId?: boolean
    branchId?: boolean
    lastModifiedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type ScheduleHourOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerType" | "ownerId" | "dayOfWeek" | "openTime" | "closeTime" | "isClosed" | "inheritanceMode" | "staffId" | "businessId" | "branchId" | "lastModifiedBy" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["scheduleHour"]>
  export type ScheduleHourInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | ScheduleHour$staffArgs<ExtArgs>
    business?: boolean | ScheduleHour$businessArgs<ExtArgs>
    branch?: boolean | ScheduleHour$branchArgs<ExtArgs>
  }
  export type ScheduleHourIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | ScheduleHour$staffArgs<ExtArgs>
    business?: boolean | ScheduleHour$businessArgs<ExtArgs>
    branch?: boolean | ScheduleHour$branchArgs<ExtArgs>
  }
  export type ScheduleHourIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | ScheduleHour$staffArgs<ExtArgs>
    business?: boolean | ScheduleHour$businessArgs<ExtArgs>
    branch?: boolean | ScheduleHour$branchArgs<ExtArgs>
  }

  export type $ScheduleHourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduleHour"
    objects: {
      staff: Prisma.$UserPayload<ExtArgs> | null
      business: Prisma.$BusinessPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerType: $Enums.ScheduleOwnerType
      ownerId: string
      dayOfWeek: $Enums.WeekDay
      openTime: string
      closeTime: string
      isClosed: boolean
      inheritanceMode: $Enums.ScheduleInheritanceMode
      staffId: string | null
      businessId: string | null
      branchId: string | null
      lastModifiedBy: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["scheduleHour"]>
    composites: {}
  }

  type ScheduleHourGetPayload<S extends boolean | null | undefined | ScheduleHourDefaultArgs> = $Result.GetResult<Prisma.$ScheduleHourPayload, S>

  type ScheduleHourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleHourFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleHourCountAggregateInputType | true
    }

  export interface ScheduleHourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduleHour'], meta: { name: 'ScheduleHour' } }
    /**
     * Find zero or one ScheduleHour that matches the filter.
     * @param {ScheduleHourFindUniqueArgs} args - Arguments to find a ScheduleHour
     * @example
     * // Get one ScheduleHour
     * const scheduleHour = await prisma.scheduleHour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleHourFindUniqueArgs>(args: SelectSubset<T, ScheduleHourFindUniqueArgs<ExtArgs>>): Prisma__ScheduleHourClient<$Result.GetResult<Prisma.$ScheduleHourPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduleHour that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleHourFindUniqueOrThrowArgs} args - Arguments to find a ScheduleHour
     * @example
     * // Get one ScheduleHour
     * const scheduleHour = await prisma.scheduleHour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleHourFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleHourFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleHourClient<$Result.GetResult<Prisma.$ScheduleHourPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleHour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleHourFindFirstArgs} args - Arguments to find a ScheduleHour
     * @example
     * // Get one ScheduleHour
     * const scheduleHour = await prisma.scheduleHour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleHourFindFirstArgs>(args?: SelectSubset<T, ScheduleHourFindFirstArgs<ExtArgs>>): Prisma__ScheduleHourClient<$Result.GetResult<Prisma.$ScheduleHourPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleHour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleHourFindFirstOrThrowArgs} args - Arguments to find a ScheduleHour
     * @example
     * // Get one ScheduleHour
     * const scheduleHour = await prisma.scheduleHour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleHourFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleHourFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleHourClient<$Result.GetResult<Prisma.$ScheduleHourPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduleHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleHourFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduleHours
     * const scheduleHours = await prisma.scheduleHour.findMany()
     * 
     * // Get first 10 ScheduleHours
     * const scheduleHours = await prisma.scheduleHour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleHourWithIdOnly = await prisma.scheduleHour.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleHourFindManyArgs>(args?: SelectSubset<T, ScheduleHourFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleHourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduleHour.
     * @param {ScheduleHourCreateArgs} args - Arguments to create a ScheduleHour.
     * @example
     * // Create one ScheduleHour
     * const ScheduleHour = await prisma.scheduleHour.create({
     *   data: {
     *     // ... data to create a ScheduleHour
     *   }
     * })
     * 
     */
    create<T extends ScheduleHourCreateArgs>(args: SelectSubset<T, ScheduleHourCreateArgs<ExtArgs>>): Prisma__ScheduleHourClient<$Result.GetResult<Prisma.$ScheduleHourPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduleHours.
     * @param {ScheduleHourCreateManyArgs} args - Arguments to create many ScheduleHours.
     * @example
     * // Create many ScheduleHours
     * const scheduleHour = await prisma.scheduleHour.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleHourCreateManyArgs>(args?: SelectSubset<T, ScheduleHourCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduleHours and returns the data saved in the database.
     * @param {ScheduleHourCreateManyAndReturnArgs} args - Arguments to create many ScheduleHours.
     * @example
     * // Create many ScheduleHours
     * const scheduleHour = await prisma.scheduleHour.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduleHours and only return the `id`
     * const scheduleHourWithIdOnly = await prisma.scheduleHour.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleHourCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleHourCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleHourPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduleHour.
     * @param {ScheduleHourDeleteArgs} args - Arguments to delete one ScheduleHour.
     * @example
     * // Delete one ScheduleHour
     * const ScheduleHour = await prisma.scheduleHour.delete({
     *   where: {
     *     // ... filter to delete one ScheduleHour
     *   }
     * })
     * 
     */
    delete<T extends ScheduleHourDeleteArgs>(args: SelectSubset<T, ScheduleHourDeleteArgs<ExtArgs>>): Prisma__ScheduleHourClient<$Result.GetResult<Prisma.$ScheduleHourPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduleHour.
     * @param {ScheduleHourUpdateArgs} args - Arguments to update one ScheduleHour.
     * @example
     * // Update one ScheduleHour
     * const scheduleHour = await prisma.scheduleHour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleHourUpdateArgs>(args: SelectSubset<T, ScheduleHourUpdateArgs<ExtArgs>>): Prisma__ScheduleHourClient<$Result.GetResult<Prisma.$ScheduleHourPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduleHours.
     * @param {ScheduleHourDeleteManyArgs} args - Arguments to filter ScheduleHours to delete.
     * @example
     * // Delete a few ScheduleHours
     * const { count } = await prisma.scheduleHour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleHourDeleteManyArgs>(args?: SelectSubset<T, ScheduleHourDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleHourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduleHours
     * const scheduleHour = await prisma.scheduleHour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleHourUpdateManyArgs>(args: SelectSubset<T, ScheduleHourUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleHours and returns the data updated in the database.
     * @param {ScheduleHourUpdateManyAndReturnArgs} args - Arguments to update many ScheduleHours.
     * @example
     * // Update many ScheduleHours
     * const scheduleHour = await prisma.scheduleHour.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduleHours and only return the `id`
     * const scheduleHourWithIdOnly = await prisma.scheduleHour.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleHourUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleHourUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleHourPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduleHour.
     * @param {ScheduleHourUpsertArgs} args - Arguments to update or create a ScheduleHour.
     * @example
     * // Update or create a ScheduleHour
     * const scheduleHour = await prisma.scheduleHour.upsert({
     *   create: {
     *     // ... data to create a ScheduleHour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduleHour we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleHourUpsertArgs>(args: SelectSubset<T, ScheduleHourUpsertArgs<ExtArgs>>): Prisma__ScheduleHourClient<$Result.GetResult<Prisma.$ScheduleHourPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduleHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleHourCountArgs} args - Arguments to filter ScheduleHours to count.
     * @example
     * // Count the number of ScheduleHours
     * const count = await prisma.scheduleHour.count({
     *   where: {
     *     // ... the filter for the ScheduleHours we want to count
     *   }
     * })
    **/
    count<T extends ScheduleHourCountArgs>(
      args?: Subset<T, ScheduleHourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleHourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduleHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleHourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleHourAggregateArgs>(args: Subset<T, ScheduleHourAggregateArgs>): Prisma.PrismaPromise<GetScheduleHourAggregateType<T>>

    /**
     * Group by ScheduleHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleHourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleHourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleHourGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleHourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleHourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleHourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduleHour model
   */
  readonly fields: ScheduleHourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduleHour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleHourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends ScheduleHour$staffArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleHour$staffArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    business<T extends ScheduleHour$businessArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleHour$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    branch<T extends ScheduleHour$branchArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleHour$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduleHour model
   */
  interface ScheduleHourFieldRefs {
    readonly id: FieldRef<"ScheduleHour", 'String'>
    readonly ownerType: FieldRef<"ScheduleHour", 'ScheduleOwnerType'>
    readonly ownerId: FieldRef<"ScheduleHour", 'String'>
    readonly dayOfWeek: FieldRef<"ScheduleHour", 'WeekDay'>
    readonly openTime: FieldRef<"ScheduleHour", 'String'>
    readonly closeTime: FieldRef<"ScheduleHour", 'String'>
    readonly isClosed: FieldRef<"ScheduleHour", 'Boolean'>
    readonly inheritanceMode: FieldRef<"ScheduleHour", 'ScheduleInheritanceMode'>
    readonly staffId: FieldRef<"ScheduleHour", 'String'>
    readonly businessId: FieldRef<"ScheduleHour", 'String'>
    readonly branchId: FieldRef<"ScheduleHour", 'String'>
    readonly lastModifiedBy: FieldRef<"ScheduleHour", 'String'>
    readonly createdAt: FieldRef<"ScheduleHour", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduleHour", 'DateTime'>
    readonly createdBy: FieldRef<"ScheduleHour", 'String'>
    readonly updatedBy: FieldRef<"ScheduleHour", 'String'>
    readonly isDeleted: FieldRef<"ScheduleHour", 'Boolean'>
    readonly deletedAt: FieldRef<"ScheduleHour", 'DateTime'>
    readonly deletedBy: FieldRef<"ScheduleHour", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ScheduleHour findUnique
   */
  export type ScheduleHourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleHour to fetch.
     */
    where: ScheduleHourWhereUniqueInput
  }

  /**
   * ScheduleHour findUniqueOrThrow
   */
  export type ScheduleHourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleHour to fetch.
     */
    where: ScheduleHourWhereUniqueInput
  }

  /**
   * ScheduleHour findFirst
   */
  export type ScheduleHourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleHour to fetch.
     */
    where?: ScheduleHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleHours to fetch.
     */
    orderBy?: ScheduleHourOrderByWithRelationInput | ScheduleHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleHours.
     */
    cursor?: ScheduleHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleHours.
     */
    distinct?: ScheduleHourScalarFieldEnum | ScheduleHourScalarFieldEnum[]
  }

  /**
   * ScheduleHour findFirstOrThrow
   */
  export type ScheduleHourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleHour to fetch.
     */
    where?: ScheduleHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleHours to fetch.
     */
    orderBy?: ScheduleHourOrderByWithRelationInput | ScheduleHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleHours.
     */
    cursor?: ScheduleHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleHours.
     */
    distinct?: ScheduleHourScalarFieldEnum | ScheduleHourScalarFieldEnum[]
  }

  /**
   * ScheduleHour findMany
   */
  export type ScheduleHourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleHours to fetch.
     */
    where?: ScheduleHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleHours to fetch.
     */
    orderBy?: ScheduleHourOrderByWithRelationInput | ScheduleHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduleHours.
     */
    cursor?: ScheduleHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleHours.
     */
    skip?: number
    distinct?: ScheduleHourScalarFieldEnum | ScheduleHourScalarFieldEnum[]
  }

  /**
   * ScheduleHour create
   */
  export type ScheduleHourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduleHour.
     */
    data: XOR<ScheduleHourCreateInput, ScheduleHourUncheckedCreateInput>
  }

  /**
   * ScheduleHour createMany
   */
  export type ScheduleHourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduleHours.
     */
    data: ScheduleHourCreateManyInput | ScheduleHourCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduleHour createManyAndReturn
   */
  export type ScheduleHourCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduleHours.
     */
    data: ScheduleHourCreateManyInput | ScheduleHourCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleHour update
   */
  export type ScheduleHourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduleHour.
     */
    data: XOR<ScheduleHourUpdateInput, ScheduleHourUncheckedUpdateInput>
    /**
     * Choose, which ScheduleHour to update.
     */
    where: ScheduleHourWhereUniqueInput
  }

  /**
   * ScheduleHour updateMany
   */
  export type ScheduleHourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduleHours.
     */
    data: XOR<ScheduleHourUpdateManyMutationInput, ScheduleHourUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleHours to update
     */
    where?: ScheduleHourWhereInput
    /**
     * Limit how many ScheduleHours to update.
     */
    limit?: number
  }

  /**
   * ScheduleHour updateManyAndReturn
   */
  export type ScheduleHourUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * The data used to update ScheduleHours.
     */
    data: XOR<ScheduleHourUpdateManyMutationInput, ScheduleHourUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleHours to update
     */
    where?: ScheduleHourWhereInput
    /**
     * Limit how many ScheduleHours to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleHour upsert
   */
  export type ScheduleHourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduleHour to update in case it exists.
     */
    where: ScheduleHourWhereUniqueInput
    /**
     * In case the ScheduleHour found by the `where` argument doesn't exist, create a new ScheduleHour with this data.
     */
    create: XOR<ScheduleHourCreateInput, ScheduleHourUncheckedCreateInput>
    /**
     * In case the ScheduleHour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleHourUpdateInput, ScheduleHourUncheckedUpdateInput>
  }

  /**
   * ScheduleHour delete
   */
  export type ScheduleHourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourInclude<ExtArgs> | null
    /**
     * Filter which ScheduleHour to delete.
     */
    where: ScheduleHourWhereUniqueInput
  }

  /**
   * ScheduleHour deleteMany
   */
  export type ScheduleHourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleHours to delete
     */
    where?: ScheduleHourWhereInput
    /**
     * Limit how many ScheduleHours to delete.
     */
    limit?: number
  }

  /**
   * ScheduleHour.staff
   */
  export type ScheduleHour$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ScheduleHour.business
   */
  export type ScheduleHour$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * ScheduleHour.branch
   */
  export type ScheduleHour$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * ScheduleHour without action
   */
  export type ScheduleHourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleHour
     */
    select?: ScheduleHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleHour
     */
    omit?: ScheduleHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleHourInclude<ExtArgs> | null
  }


  /**
   * Model StaffStatusLog
   */

  export type AggregateStaffStatusLog = {
    _count: StaffStatusLogCountAggregateOutputType | null
    _min: StaffStatusLogMinAggregateOutputType | null
    _max: StaffStatusLogMaxAggregateOutputType | null
  }

  export type StaffStatusLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.StaffStatus | null
    timestamp: Date | null
  }

  export type StaffStatusLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.StaffStatus | null
    timestamp: Date | null
  }

  export type StaffStatusLogCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    timestamp: number
    _all: number
  }


  export type StaffStatusLogMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    timestamp?: true
  }

  export type StaffStatusLogMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    timestamp?: true
  }

  export type StaffStatusLogCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    timestamp?: true
    _all?: true
  }

  export type StaffStatusLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffStatusLog to aggregate.
     */
    where?: StaffStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffStatusLogs to fetch.
     */
    orderBy?: StaffStatusLogOrderByWithRelationInput | StaffStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffStatusLogs
    **/
    _count?: true | StaffStatusLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffStatusLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffStatusLogMaxAggregateInputType
  }

  export type GetStaffStatusLogAggregateType<T extends StaffStatusLogAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffStatusLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffStatusLog[P]>
      : GetScalarType<T[P], AggregateStaffStatusLog[P]>
  }




  export type StaffStatusLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffStatusLogWhereInput
    orderBy?: StaffStatusLogOrderByWithAggregationInput | StaffStatusLogOrderByWithAggregationInput[]
    by: StaffStatusLogScalarFieldEnum[] | StaffStatusLogScalarFieldEnum
    having?: StaffStatusLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffStatusLogCountAggregateInputType | true
    _min?: StaffStatusLogMinAggregateInputType
    _max?: StaffStatusLogMaxAggregateInputType
  }

  export type StaffStatusLogGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.StaffStatus
    timestamp: Date
    _count: StaffStatusLogCountAggregateOutputType | null
    _min: StaffStatusLogMinAggregateOutputType | null
    _max: StaffStatusLogMaxAggregateOutputType | null
  }

  type GetStaffStatusLogGroupByPayload<T extends StaffStatusLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffStatusLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffStatusLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffStatusLogGroupByOutputType[P]>
            : GetScalarType<T[P], StaffStatusLogGroupByOutputType[P]>
        }
      >
    >


  export type StaffStatusLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffStatusLog"]>

  export type StaffStatusLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffStatusLog"]>

  export type StaffStatusLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffStatusLog"]>

  export type StaffStatusLogSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    timestamp?: boolean
  }

  export type StaffStatusLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "timestamp", ExtArgs["result"]["staffStatusLog"]>
  export type StaffStatusLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StaffStatusLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StaffStatusLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StaffStatusLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffStatusLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.StaffStatus
      timestamp: Date
    }, ExtArgs["result"]["staffStatusLog"]>
    composites: {}
  }

  type StaffStatusLogGetPayload<S extends boolean | null | undefined | StaffStatusLogDefaultArgs> = $Result.GetResult<Prisma.$StaffStatusLogPayload, S>

  type StaffStatusLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffStatusLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffStatusLogCountAggregateInputType | true
    }

  export interface StaffStatusLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffStatusLog'], meta: { name: 'StaffStatusLog' } }
    /**
     * Find zero or one StaffStatusLog that matches the filter.
     * @param {StaffStatusLogFindUniqueArgs} args - Arguments to find a StaffStatusLog
     * @example
     * // Get one StaffStatusLog
     * const staffStatusLog = await prisma.staffStatusLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffStatusLogFindUniqueArgs>(args: SelectSubset<T, StaffStatusLogFindUniqueArgs<ExtArgs>>): Prisma__StaffStatusLogClient<$Result.GetResult<Prisma.$StaffStatusLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StaffStatusLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffStatusLogFindUniqueOrThrowArgs} args - Arguments to find a StaffStatusLog
     * @example
     * // Get one StaffStatusLog
     * const staffStatusLog = await prisma.staffStatusLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffStatusLogFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffStatusLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffStatusLogClient<$Result.GetResult<Prisma.$StaffStatusLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffStatusLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffStatusLogFindFirstArgs} args - Arguments to find a StaffStatusLog
     * @example
     * // Get one StaffStatusLog
     * const staffStatusLog = await prisma.staffStatusLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffStatusLogFindFirstArgs>(args?: SelectSubset<T, StaffStatusLogFindFirstArgs<ExtArgs>>): Prisma__StaffStatusLogClient<$Result.GetResult<Prisma.$StaffStatusLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffStatusLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffStatusLogFindFirstOrThrowArgs} args - Arguments to find a StaffStatusLog
     * @example
     * // Get one StaffStatusLog
     * const staffStatusLog = await prisma.staffStatusLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffStatusLogFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffStatusLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffStatusLogClient<$Result.GetResult<Prisma.$StaffStatusLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StaffStatusLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffStatusLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffStatusLogs
     * const staffStatusLogs = await prisma.staffStatusLog.findMany()
     * 
     * // Get first 10 StaffStatusLogs
     * const staffStatusLogs = await prisma.staffStatusLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffStatusLogWithIdOnly = await prisma.staffStatusLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffStatusLogFindManyArgs>(args?: SelectSubset<T, StaffStatusLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffStatusLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StaffStatusLog.
     * @param {StaffStatusLogCreateArgs} args - Arguments to create a StaffStatusLog.
     * @example
     * // Create one StaffStatusLog
     * const StaffStatusLog = await prisma.staffStatusLog.create({
     *   data: {
     *     // ... data to create a StaffStatusLog
     *   }
     * })
     * 
     */
    create<T extends StaffStatusLogCreateArgs>(args: SelectSubset<T, StaffStatusLogCreateArgs<ExtArgs>>): Prisma__StaffStatusLogClient<$Result.GetResult<Prisma.$StaffStatusLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StaffStatusLogs.
     * @param {StaffStatusLogCreateManyArgs} args - Arguments to create many StaffStatusLogs.
     * @example
     * // Create many StaffStatusLogs
     * const staffStatusLog = await prisma.staffStatusLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffStatusLogCreateManyArgs>(args?: SelectSubset<T, StaffStatusLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StaffStatusLogs and returns the data saved in the database.
     * @param {StaffStatusLogCreateManyAndReturnArgs} args - Arguments to create many StaffStatusLogs.
     * @example
     * // Create many StaffStatusLogs
     * const staffStatusLog = await prisma.staffStatusLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StaffStatusLogs and only return the `id`
     * const staffStatusLogWithIdOnly = await prisma.staffStatusLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffStatusLogCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffStatusLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffStatusLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StaffStatusLog.
     * @param {StaffStatusLogDeleteArgs} args - Arguments to delete one StaffStatusLog.
     * @example
     * // Delete one StaffStatusLog
     * const StaffStatusLog = await prisma.staffStatusLog.delete({
     *   where: {
     *     // ... filter to delete one StaffStatusLog
     *   }
     * })
     * 
     */
    delete<T extends StaffStatusLogDeleteArgs>(args: SelectSubset<T, StaffStatusLogDeleteArgs<ExtArgs>>): Prisma__StaffStatusLogClient<$Result.GetResult<Prisma.$StaffStatusLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StaffStatusLog.
     * @param {StaffStatusLogUpdateArgs} args - Arguments to update one StaffStatusLog.
     * @example
     * // Update one StaffStatusLog
     * const staffStatusLog = await prisma.staffStatusLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffStatusLogUpdateArgs>(args: SelectSubset<T, StaffStatusLogUpdateArgs<ExtArgs>>): Prisma__StaffStatusLogClient<$Result.GetResult<Prisma.$StaffStatusLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StaffStatusLogs.
     * @param {StaffStatusLogDeleteManyArgs} args - Arguments to filter StaffStatusLogs to delete.
     * @example
     * // Delete a few StaffStatusLogs
     * const { count } = await prisma.staffStatusLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffStatusLogDeleteManyArgs>(args?: SelectSubset<T, StaffStatusLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffStatusLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffStatusLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffStatusLogs
     * const staffStatusLog = await prisma.staffStatusLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffStatusLogUpdateManyArgs>(args: SelectSubset<T, StaffStatusLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffStatusLogs and returns the data updated in the database.
     * @param {StaffStatusLogUpdateManyAndReturnArgs} args - Arguments to update many StaffStatusLogs.
     * @example
     * // Update many StaffStatusLogs
     * const staffStatusLog = await prisma.staffStatusLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StaffStatusLogs and only return the `id`
     * const staffStatusLogWithIdOnly = await prisma.staffStatusLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffStatusLogUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffStatusLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffStatusLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StaffStatusLog.
     * @param {StaffStatusLogUpsertArgs} args - Arguments to update or create a StaffStatusLog.
     * @example
     * // Update or create a StaffStatusLog
     * const staffStatusLog = await prisma.staffStatusLog.upsert({
     *   create: {
     *     // ... data to create a StaffStatusLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffStatusLog we want to update
     *   }
     * })
     */
    upsert<T extends StaffStatusLogUpsertArgs>(args: SelectSubset<T, StaffStatusLogUpsertArgs<ExtArgs>>): Prisma__StaffStatusLogClient<$Result.GetResult<Prisma.$StaffStatusLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StaffStatusLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffStatusLogCountArgs} args - Arguments to filter StaffStatusLogs to count.
     * @example
     * // Count the number of StaffStatusLogs
     * const count = await prisma.staffStatusLog.count({
     *   where: {
     *     // ... the filter for the StaffStatusLogs we want to count
     *   }
     * })
    **/
    count<T extends StaffStatusLogCountArgs>(
      args?: Subset<T, StaffStatusLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffStatusLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffStatusLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffStatusLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffStatusLogAggregateArgs>(args: Subset<T, StaffStatusLogAggregateArgs>): Prisma.PrismaPromise<GetStaffStatusLogAggregateType<T>>

    /**
     * Group by StaffStatusLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffStatusLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffStatusLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffStatusLogGroupByArgs['orderBy'] }
        : { orderBy?: StaffStatusLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffStatusLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffStatusLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffStatusLog model
   */
  readonly fields: StaffStatusLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffStatusLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffStatusLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaffStatusLog model
   */
  interface StaffStatusLogFieldRefs {
    readonly id: FieldRef<"StaffStatusLog", 'String'>
    readonly userId: FieldRef<"StaffStatusLog", 'String'>
    readonly status: FieldRef<"StaffStatusLog", 'StaffStatus'>
    readonly timestamp: FieldRef<"StaffStatusLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StaffStatusLog findUnique
   */
  export type StaffStatusLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffStatusLog
     */
    select?: StaffStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffStatusLog
     */
    omit?: StaffStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which StaffStatusLog to fetch.
     */
    where: StaffStatusLogWhereUniqueInput
  }

  /**
   * StaffStatusLog findUniqueOrThrow
   */
  export type StaffStatusLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffStatusLog
     */
    select?: StaffStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffStatusLog
     */
    omit?: StaffStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which StaffStatusLog to fetch.
     */
    where: StaffStatusLogWhereUniqueInput
  }

  /**
   * StaffStatusLog findFirst
   */
  export type StaffStatusLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffStatusLog
     */
    select?: StaffStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffStatusLog
     */
    omit?: StaffStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which StaffStatusLog to fetch.
     */
    where?: StaffStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffStatusLogs to fetch.
     */
    orderBy?: StaffStatusLogOrderByWithRelationInput | StaffStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffStatusLogs.
     */
    cursor?: StaffStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffStatusLogs.
     */
    distinct?: StaffStatusLogScalarFieldEnum | StaffStatusLogScalarFieldEnum[]
  }

  /**
   * StaffStatusLog findFirstOrThrow
   */
  export type StaffStatusLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffStatusLog
     */
    select?: StaffStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffStatusLog
     */
    omit?: StaffStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which StaffStatusLog to fetch.
     */
    where?: StaffStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffStatusLogs to fetch.
     */
    orderBy?: StaffStatusLogOrderByWithRelationInput | StaffStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffStatusLogs.
     */
    cursor?: StaffStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffStatusLogs.
     */
    distinct?: StaffStatusLogScalarFieldEnum | StaffStatusLogScalarFieldEnum[]
  }

  /**
   * StaffStatusLog findMany
   */
  export type StaffStatusLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffStatusLog
     */
    select?: StaffStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffStatusLog
     */
    omit?: StaffStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which StaffStatusLogs to fetch.
     */
    where?: StaffStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffStatusLogs to fetch.
     */
    orderBy?: StaffStatusLogOrderByWithRelationInput | StaffStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffStatusLogs.
     */
    cursor?: StaffStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffStatusLogs.
     */
    skip?: number
    distinct?: StaffStatusLogScalarFieldEnum | StaffStatusLogScalarFieldEnum[]
  }

  /**
   * StaffStatusLog create
   */
  export type StaffStatusLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffStatusLog
     */
    select?: StaffStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffStatusLog
     */
    omit?: StaffStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffStatusLogInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffStatusLog.
     */
    data: XOR<StaffStatusLogCreateInput, StaffStatusLogUncheckedCreateInput>
  }

  /**
   * StaffStatusLog createMany
   */
  export type StaffStatusLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffStatusLogs.
     */
    data: StaffStatusLogCreateManyInput | StaffStatusLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StaffStatusLog createManyAndReturn
   */
  export type StaffStatusLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffStatusLog
     */
    select?: StaffStatusLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffStatusLog
     */
    omit?: StaffStatusLogOmit<ExtArgs> | null
    /**
     * The data used to create many StaffStatusLogs.
     */
    data: StaffStatusLogCreateManyInput | StaffStatusLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffStatusLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffStatusLog update
   */
  export type StaffStatusLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffStatusLog
     */
    select?: StaffStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffStatusLog
     */
    omit?: StaffStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffStatusLogInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffStatusLog.
     */
    data: XOR<StaffStatusLogUpdateInput, StaffStatusLogUncheckedUpdateInput>
    /**
     * Choose, which StaffStatusLog to update.
     */
    where: StaffStatusLogWhereUniqueInput
  }

  /**
   * StaffStatusLog updateMany
   */
  export type StaffStatusLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffStatusLogs.
     */
    data: XOR<StaffStatusLogUpdateManyMutationInput, StaffStatusLogUncheckedUpdateManyInput>
    /**
     * Filter which StaffStatusLogs to update
     */
    where?: StaffStatusLogWhereInput
    /**
     * Limit how many StaffStatusLogs to update.
     */
    limit?: number
  }

  /**
   * StaffStatusLog updateManyAndReturn
   */
  export type StaffStatusLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffStatusLog
     */
    select?: StaffStatusLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffStatusLog
     */
    omit?: StaffStatusLogOmit<ExtArgs> | null
    /**
     * The data used to update StaffStatusLogs.
     */
    data: XOR<StaffStatusLogUpdateManyMutationInput, StaffStatusLogUncheckedUpdateManyInput>
    /**
     * Filter which StaffStatusLogs to update
     */
    where?: StaffStatusLogWhereInput
    /**
     * Limit how many StaffStatusLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffStatusLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffStatusLog upsert
   */
  export type StaffStatusLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffStatusLog
     */
    select?: StaffStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffStatusLog
     */
    omit?: StaffStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffStatusLogInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffStatusLog to update in case it exists.
     */
    where: StaffStatusLogWhereUniqueInput
    /**
     * In case the StaffStatusLog found by the `where` argument doesn't exist, create a new StaffStatusLog with this data.
     */
    create: XOR<StaffStatusLogCreateInput, StaffStatusLogUncheckedCreateInput>
    /**
     * In case the StaffStatusLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffStatusLogUpdateInput, StaffStatusLogUncheckedUpdateInput>
  }

  /**
   * StaffStatusLog delete
   */
  export type StaffStatusLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffStatusLog
     */
    select?: StaffStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffStatusLog
     */
    omit?: StaffStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffStatusLogInclude<ExtArgs> | null
    /**
     * Filter which StaffStatusLog to delete.
     */
    where: StaffStatusLogWhereUniqueInput
  }

  /**
   * StaffStatusLog deleteMany
   */
  export type StaffStatusLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffStatusLogs to delete
     */
    where?: StaffStatusLogWhereInput
    /**
     * Limit how many StaffStatusLogs to delete.
     */
    limit?: number
  }

  /**
   * StaffStatusLog without action
   */
  export type StaffStatusLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffStatusLog
     */
    select?: StaffStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffStatusLog
     */
    omit?: StaffStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffStatusLogInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    staffId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    staffId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    staffId: number
    date: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    staffId?: true
    date?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    staffId?: true
    date?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    staffId?: true
    date?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    staffId: string
    date: Date
    status: $Enums.AttendanceStatus
    notes: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    date?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    date?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    date?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    staffId?: boolean
    date?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "staffId" | "date" | "status" | "notes" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      staff: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      staffId: string
      date: Date
      status: $Enums.AttendanceStatus
      notes: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly staffId: FieldRef<"Attendance", 'String'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly status: FieldRef<"Attendance", 'AttendanceStatus'>
    readonly notes: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
    readonly createdBy: FieldRef<"Attendance", 'String'>
    readonly updatedBy: FieldRef<"Attendance", 'String'>
    readonly isDeleted: FieldRef<"Attendance", 'Boolean'>
    readonly deletedAt: FieldRef<"Attendance", 'DateTime'>
    readonly deletedBy: FieldRef<"Attendance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Vacation
   */

  export type AggregateVacation = {
    _count: VacationCountAggregateOutputType | null
    _min: VacationMinAggregateOutputType | null
    _max: VacationMaxAggregateOutputType | null
  }

  export type VacationMinAggregateOutputType = {
    id: string | null
    staffId: string | null
    startDate: Date | null
    endDate: Date | null
    reason: string | null
    status: $Enums.VacationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type VacationMaxAggregateOutputType = {
    id: string | null
    staffId: string | null
    startDate: Date | null
    endDate: Date | null
    reason: string | null
    status: $Enums.VacationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type VacationCountAggregateOutputType = {
    id: number
    staffId: number
    startDate: number
    endDate: number
    reason: number
    status: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type VacationMinAggregateInputType = {
    id?: true
    staffId?: true
    startDate?: true
    endDate?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type VacationMaxAggregateInputType = {
    id?: true
    staffId?: true
    startDate?: true
    endDate?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type VacationCountAggregateInputType = {
    id?: true
    staffId?: true
    startDate?: true
    endDate?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type VacationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vacation to aggregate.
     */
    where?: VacationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vacations to fetch.
     */
    orderBy?: VacationOrderByWithRelationInput | VacationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VacationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vacations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vacations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vacations
    **/
    _count?: true | VacationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VacationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VacationMaxAggregateInputType
  }

  export type GetVacationAggregateType<T extends VacationAggregateArgs> = {
        [P in keyof T & keyof AggregateVacation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVacation[P]>
      : GetScalarType<T[P], AggregateVacation[P]>
  }




  export type VacationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VacationWhereInput
    orderBy?: VacationOrderByWithAggregationInput | VacationOrderByWithAggregationInput[]
    by: VacationScalarFieldEnum[] | VacationScalarFieldEnum
    having?: VacationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VacationCountAggregateInputType | true
    _min?: VacationMinAggregateInputType
    _max?: VacationMaxAggregateInputType
  }

  export type VacationGroupByOutputType = {
    id: string
    staffId: string
    startDate: Date
    endDate: Date
    reason: string | null
    status: $Enums.VacationStatus
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: VacationCountAggregateOutputType | null
    _min: VacationMinAggregateOutputType | null
    _max: VacationMaxAggregateOutputType | null
  }

  type GetVacationGroupByPayload<T extends VacationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VacationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VacationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VacationGroupByOutputType[P]>
            : GetScalarType<T[P], VacationGroupByOutputType[P]>
        }
      >
    >


  export type VacationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vacation"]>

  export type VacationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vacation"]>

  export type VacationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vacation"]>

  export type VacationSelectScalar = {
    id?: boolean
    staffId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type VacationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "staffId" | "startDate" | "endDate" | "reason" | "status" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["vacation"]>
  export type VacationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VacationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VacationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VacationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vacation"
    objects: {
      staff: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      staffId: string
      startDate: Date
      endDate: Date
      reason: string | null
      status: $Enums.VacationStatus
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["vacation"]>
    composites: {}
  }

  type VacationGetPayload<S extends boolean | null | undefined | VacationDefaultArgs> = $Result.GetResult<Prisma.$VacationPayload, S>

  type VacationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VacationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VacationCountAggregateInputType | true
    }

  export interface VacationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vacation'], meta: { name: 'Vacation' } }
    /**
     * Find zero or one Vacation that matches the filter.
     * @param {VacationFindUniqueArgs} args - Arguments to find a Vacation
     * @example
     * // Get one Vacation
     * const vacation = await prisma.vacation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VacationFindUniqueArgs>(args: SelectSubset<T, VacationFindUniqueArgs<ExtArgs>>): Prisma__VacationClient<$Result.GetResult<Prisma.$VacationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vacation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VacationFindUniqueOrThrowArgs} args - Arguments to find a Vacation
     * @example
     * // Get one Vacation
     * const vacation = await prisma.vacation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VacationFindUniqueOrThrowArgs>(args: SelectSubset<T, VacationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VacationClient<$Result.GetResult<Prisma.$VacationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vacation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationFindFirstArgs} args - Arguments to find a Vacation
     * @example
     * // Get one Vacation
     * const vacation = await prisma.vacation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VacationFindFirstArgs>(args?: SelectSubset<T, VacationFindFirstArgs<ExtArgs>>): Prisma__VacationClient<$Result.GetResult<Prisma.$VacationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vacation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationFindFirstOrThrowArgs} args - Arguments to find a Vacation
     * @example
     * // Get one Vacation
     * const vacation = await prisma.vacation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VacationFindFirstOrThrowArgs>(args?: SelectSubset<T, VacationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VacationClient<$Result.GetResult<Prisma.$VacationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vacations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vacations
     * const vacations = await prisma.vacation.findMany()
     * 
     * // Get first 10 Vacations
     * const vacations = await prisma.vacation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vacationWithIdOnly = await prisma.vacation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VacationFindManyArgs>(args?: SelectSubset<T, VacationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VacationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vacation.
     * @param {VacationCreateArgs} args - Arguments to create a Vacation.
     * @example
     * // Create one Vacation
     * const Vacation = await prisma.vacation.create({
     *   data: {
     *     // ... data to create a Vacation
     *   }
     * })
     * 
     */
    create<T extends VacationCreateArgs>(args: SelectSubset<T, VacationCreateArgs<ExtArgs>>): Prisma__VacationClient<$Result.GetResult<Prisma.$VacationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vacations.
     * @param {VacationCreateManyArgs} args - Arguments to create many Vacations.
     * @example
     * // Create many Vacations
     * const vacation = await prisma.vacation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VacationCreateManyArgs>(args?: SelectSubset<T, VacationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vacations and returns the data saved in the database.
     * @param {VacationCreateManyAndReturnArgs} args - Arguments to create many Vacations.
     * @example
     * // Create many Vacations
     * const vacation = await prisma.vacation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vacations and only return the `id`
     * const vacationWithIdOnly = await prisma.vacation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VacationCreateManyAndReturnArgs>(args?: SelectSubset<T, VacationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VacationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vacation.
     * @param {VacationDeleteArgs} args - Arguments to delete one Vacation.
     * @example
     * // Delete one Vacation
     * const Vacation = await prisma.vacation.delete({
     *   where: {
     *     // ... filter to delete one Vacation
     *   }
     * })
     * 
     */
    delete<T extends VacationDeleteArgs>(args: SelectSubset<T, VacationDeleteArgs<ExtArgs>>): Prisma__VacationClient<$Result.GetResult<Prisma.$VacationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vacation.
     * @param {VacationUpdateArgs} args - Arguments to update one Vacation.
     * @example
     * // Update one Vacation
     * const vacation = await prisma.vacation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VacationUpdateArgs>(args: SelectSubset<T, VacationUpdateArgs<ExtArgs>>): Prisma__VacationClient<$Result.GetResult<Prisma.$VacationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vacations.
     * @param {VacationDeleteManyArgs} args - Arguments to filter Vacations to delete.
     * @example
     * // Delete a few Vacations
     * const { count } = await prisma.vacation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VacationDeleteManyArgs>(args?: SelectSubset<T, VacationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vacations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vacations
     * const vacation = await prisma.vacation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VacationUpdateManyArgs>(args: SelectSubset<T, VacationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vacations and returns the data updated in the database.
     * @param {VacationUpdateManyAndReturnArgs} args - Arguments to update many Vacations.
     * @example
     * // Update many Vacations
     * const vacation = await prisma.vacation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vacations and only return the `id`
     * const vacationWithIdOnly = await prisma.vacation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VacationUpdateManyAndReturnArgs>(args: SelectSubset<T, VacationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VacationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vacation.
     * @param {VacationUpsertArgs} args - Arguments to update or create a Vacation.
     * @example
     * // Update or create a Vacation
     * const vacation = await prisma.vacation.upsert({
     *   create: {
     *     // ... data to create a Vacation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vacation we want to update
     *   }
     * })
     */
    upsert<T extends VacationUpsertArgs>(args: SelectSubset<T, VacationUpsertArgs<ExtArgs>>): Prisma__VacationClient<$Result.GetResult<Prisma.$VacationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vacations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationCountArgs} args - Arguments to filter Vacations to count.
     * @example
     * // Count the number of Vacations
     * const count = await prisma.vacation.count({
     *   where: {
     *     // ... the filter for the Vacations we want to count
     *   }
     * })
    **/
    count<T extends VacationCountArgs>(
      args?: Subset<T, VacationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VacationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vacation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VacationAggregateArgs>(args: Subset<T, VacationAggregateArgs>): Prisma.PrismaPromise<GetVacationAggregateType<T>>

    /**
     * Group by Vacation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VacationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VacationGroupByArgs['orderBy'] }
        : { orderBy?: VacationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VacationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVacationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vacation model
   */
  readonly fields: VacationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vacation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VacationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vacation model
   */
  interface VacationFieldRefs {
    readonly id: FieldRef<"Vacation", 'String'>
    readonly staffId: FieldRef<"Vacation", 'String'>
    readonly startDate: FieldRef<"Vacation", 'DateTime'>
    readonly endDate: FieldRef<"Vacation", 'DateTime'>
    readonly reason: FieldRef<"Vacation", 'String'>
    readonly status: FieldRef<"Vacation", 'VacationStatus'>
    readonly createdAt: FieldRef<"Vacation", 'DateTime'>
    readonly updatedAt: FieldRef<"Vacation", 'DateTime'>
    readonly createdBy: FieldRef<"Vacation", 'String'>
    readonly updatedBy: FieldRef<"Vacation", 'String'>
    readonly isDeleted: FieldRef<"Vacation", 'Boolean'>
    readonly deletedAt: FieldRef<"Vacation", 'DateTime'>
    readonly deletedBy: FieldRef<"Vacation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vacation findUnique
   */
  export type VacationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vacation
     */
    select?: VacationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vacation
     */
    omit?: VacationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationInclude<ExtArgs> | null
    /**
     * Filter, which Vacation to fetch.
     */
    where: VacationWhereUniqueInput
  }

  /**
   * Vacation findUniqueOrThrow
   */
  export type VacationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vacation
     */
    select?: VacationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vacation
     */
    omit?: VacationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationInclude<ExtArgs> | null
    /**
     * Filter, which Vacation to fetch.
     */
    where: VacationWhereUniqueInput
  }

  /**
   * Vacation findFirst
   */
  export type VacationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vacation
     */
    select?: VacationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vacation
     */
    omit?: VacationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationInclude<ExtArgs> | null
    /**
     * Filter, which Vacation to fetch.
     */
    where?: VacationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vacations to fetch.
     */
    orderBy?: VacationOrderByWithRelationInput | VacationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vacations.
     */
    cursor?: VacationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vacations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vacations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vacations.
     */
    distinct?: VacationScalarFieldEnum | VacationScalarFieldEnum[]
  }

  /**
   * Vacation findFirstOrThrow
   */
  export type VacationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vacation
     */
    select?: VacationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vacation
     */
    omit?: VacationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationInclude<ExtArgs> | null
    /**
     * Filter, which Vacation to fetch.
     */
    where?: VacationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vacations to fetch.
     */
    orderBy?: VacationOrderByWithRelationInput | VacationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vacations.
     */
    cursor?: VacationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vacations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vacations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vacations.
     */
    distinct?: VacationScalarFieldEnum | VacationScalarFieldEnum[]
  }

  /**
   * Vacation findMany
   */
  export type VacationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vacation
     */
    select?: VacationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vacation
     */
    omit?: VacationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationInclude<ExtArgs> | null
    /**
     * Filter, which Vacations to fetch.
     */
    where?: VacationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vacations to fetch.
     */
    orderBy?: VacationOrderByWithRelationInput | VacationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vacations.
     */
    cursor?: VacationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vacations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vacations.
     */
    skip?: number
    distinct?: VacationScalarFieldEnum | VacationScalarFieldEnum[]
  }

  /**
   * Vacation create
   */
  export type VacationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vacation
     */
    select?: VacationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vacation
     */
    omit?: VacationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationInclude<ExtArgs> | null
    /**
     * The data needed to create a Vacation.
     */
    data: XOR<VacationCreateInput, VacationUncheckedCreateInput>
  }

  /**
   * Vacation createMany
   */
  export type VacationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vacations.
     */
    data: VacationCreateManyInput | VacationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vacation createManyAndReturn
   */
  export type VacationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vacation
     */
    select?: VacationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vacation
     */
    omit?: VacationOmit<ExtArgs> | null
    /**
     * The data used to create many Vacations.
     */
    data: VacationCreateManyInput | VacationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vacation update
   */
  export type VacationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vacation
     */
    select?: VacationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vacation
     */
    omit?: VacationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationInclude<ExtArgs> | null
    /**
     * The data needed to update a Vacation.
     */
    data: XOR<VacationUpdateInput, VacationUncheckedUpdateInput>
    /**
     * Choose, which Vacation to update.
     */
    where: VacationWhereUniqueInput
  }

  /**
   * Vacation updateMany
   */
  export type VacationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vacations.
     */
    data: XOR<VacationUpdateManyMutationInput, VacationUncheckedUpdateManyInput>
    /**
     * Filter which Vacations to update
     */
    where?: VacationWhereInput
    /**
     * Limit how many Vacations to update.
     */
    limit?: number
  }

  /**
   * Vacation updateManyAndReturn
   */
  export type VacationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vacation
     */
    select?: VacationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vacation
     */
    omit?: VacationOmit<ExtArgs> | null
    /**
     * The data used to update Vacations.
     */
    data: XOR<VacationUpdateManyMutationInput, VacationUncheckedUpdateManyInput>
    /**
     * Filter which Vacations to update
     */
    where?: VacationWhereInput
    /**
     * Limit how many Vacations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vacation upsert
   */
  export type VacationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vacation
     */
    select?: VacationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vacation
     */
    omit?: VacationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationInclude<ExtArgs> | null
    /**
     * The filter to search for the Vacation to update in case it exists.
     */
    where: VacationWhereUniqueInput
    /**
     * In case the Vacation found by the `where` argument doesn't exist, create a new Vacation with this data.
     */
    create: XOR<VacationCreateInput, VacationUncheckedCreateInput>
    /**
     * In case the Vacation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VacationUpdateInput, VacationUncheckedUpdateInput>
  }

  /**
   * Vacation delete
   */
  export type VacationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vacation
     */
    select?: VacationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vacation
     */
    omit?: VacationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationInclude<ExtArgs> | null
    /**
     * Filter which Vacation to delete.
     */
    where: VacationWhereUniqueInput
  }

  /**
   * Vacation deleteMany
   */
  export type VacationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vacations to delete
     */
    where?: VacationWhereInput
    /**
     * Limit how many Vacations to delete.
     */
    limit?: number
  }

  /**
   * Vacation without action
   */
  export type VacationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vacation
     */
    select?: VacationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vacation
     */
    omit?: VacationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    duration: number | null
    price: number | null
    bufferTime: number | null
    frequency: number | null
  }

  export type ServiceSumAggregateOutputType = {
    duration: number | null
    price: number | null
    bufferTime: number | null
    frequency: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    providerId: string | null
    duration: number | null
    price: number | null
    bufferTime: number | null
    status: boolean | null
    frequency: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    providerId: string | null
    duration: number | null
    price: number | null
    bufferTime: number | null
    status: boolean | null
    frequency: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    providerId: number
    duration: number
    price: number
    bufferTime: number
    status: number
    frequency: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    duration?: true
    price?: true
    bufferTime?: true
    frequency?: true
  }

  export type ServiceSumAggregateInputType = {
    duration?: true
    price?: true
    bufferTime?: true
    frequency?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    providerId?: true
    duration?: true
    price?: true
    bufferTime?: true
    status?: true
    frequency?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    providerId?: true
    duration?: true
    price?: true
    bufferTime?: true
    status?: true
    frequency?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    providerId?: true
    duration?: true
    price?: true
    bufferTime?: true
    status?: true
    frequency?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    providerId: string | null
    duration: number
    price: number
    bufferTime: number
    status: boolean
    frequency: number | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    providerId?: boolean
    duration?: boolean
    price?: boolean
    bufferTime?: boolean
    status?: boolean
    frequency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    providers?: boolean | Service$providersArgs<ExtArgs>
    branches?: boolean | Service$branchesArgs<ExtArgs>
    appointments?: boolean | Service$appointmentsArgs<ExtArgs>
    whatsappAds?: boolean | Service$whatsappAdsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    providerId?: boolean
    duration?: boolean
    price?: boolean
    bufferTime?: boolean
    status?: boolean
    frequency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    providerId?: boolean
    duration?: boolean
    price?: boolean
    bufferTime?: boolean
    status?: boolean
    frequency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    providerId?: boolean
    duration?: boolean
    price?: boolean
    bufferTime?: boolean
    status?: boolean
    frequency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "providerId" | "duration" | "price" | "bufferTime" | "status" | "frequency" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | Service$providersArgs<ExtArgs>
    branches?: boolean | Service$branchesArgs<ExtArgs>
    appointments?: boolean | Service$appointmentsArgs<ExtArgs>
    whatsappAds?: boolean | Service$whatsappAdsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      providers: Prisma.$UserOnServicePayload<ExtArgs>[]
      branches: Prisma.$ServiceBranchPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      whatsappAds: Prisma.$WhatsappAdPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      providerId: string | null
      duration: number
      price: number
      bufferTime: number
      status: boolean
      frequency: number | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    providers<T extends Service$providersArgs<ExtArgs> = {}>(args?: Subset<T, Service$providersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOnServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branches<T extends Service$branchesArgs<ExtArgs> = {}>(args?: Subset<T, Service$branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Service$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Service$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappAds<T extends Service$whatsappAdsArgs<ExtArgs> = {}>(args?: Subset<T, Service$whatsappAdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappAdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly providerId: FieldRef<"Service", 'String'>
    readonly duration: FieldRef<"Service", 'Int'>
    readonly price: FieldRef<"Service", 'Float'>
    readonly bufferTime: FieldRef<"Service", 'Int'>
    readonly status: FieldRef<"Service", 'Boolean'>
    readonly frequency: FieldRef<"Service", 'Int'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
    readonly createdBy: FieldRef<"Service", 'String'>
    readonly updatedBy: FieldRef<"Service", 'String'>
    readonly isDeleted: FieldRef<"Service", 'Boolean'>
    readonly deletedAt: FieldRef<"Service", 'DateTime'>
    readonly deletedBy: FieldRef<"Service", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.providers
   */
  export type Service$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnService
     */
    select?: UserOnServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOnService
     */
    omit?: UserOnServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnServiceInclude<ExtArgs> | null
    where?: UserOnServiceWhereInput
    orderBy?: UserOnServiceOrderByWithRelationInput | UserOnServiceOrderByWithRelationInput[]
    cursor?: UserOnServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserOnServiceScalarFieldEnum | UserOnServiceScalarFieldEnum[]
  }

  /**
   * Service.branches
   */
  export type Service$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceBranch
     */
    omit?: ServiceBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    where?: ServiceBranchWhereInput
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    cursor?: ServiceBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * Service.appointments
   */
  export type Service$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Service.whatsappAds
   */
  export type Service$whatsappAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdInclude<ExtArgs> | null
    where?: WhatsappAdWhereInput
    orderBy?: WhatsappAdOrderByWithRelationInput | WhatsappAdOrderByWithRelationInput[]
    cursor?: WhatsappAdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsappAdScalarFieldEnum | WhatsappAdScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model UserOnService
   */

  export type AggregateUserOnService = {
    _count: UserOnServiceCountAggregateOutputType | null
    _min: UserOnServiceMinAggregateOutputType | null
    _max: UserOnServiceMaxAggregateOutputType | null
  }

  export type UserOnServiceMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    providerId: string | null
  }

  export type UserOnServiceMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    providerId: string | null
  }

  export type UserOnServiceCountAggregateOutputType = {
    id: number
    serviceId: number
    providerId: number
    _all: number
  }


  export type UserOnServiceMinAggregateInputType = {
    id?: true
    serviceId?: true
    providerId?: true
  }

  export type UserOnServiceMaxAggregateInputType = {
    id?: true
    serviceId?: true
    providerId?: true
  }

  export type UserOnServiceCountAggregateInputType = {
    id?: true
    serviceId?: true
    providerId?: true
    _all?: true
  }

  export type UserOnServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOnService to aggregate.
     */
    where?: UserOnServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOnServices to fetch.
     */
    orderBy?: UserOnServiceOrderByWithRelationInput | UserOnServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserOnServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOnServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOnServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserOnServices
    **/
    _count?: true | UserOnServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserOnServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserOnServiceMaxAggregateInputType
  }

  export type GetUserOnServiceAggregateType<T extends UserOnServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserOnService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserOnService[P]>
      : GetScalarType<T[P], AggregateUserOnService[P]>
  }




  export type UserOnServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOnServiceWhereInput
    orderBy?: UserOnServiceOrderByWithAggregationInput | UserOnServiceOrderByWithAggregationInput[]
    by: UserOnServiceScalarFieldEnum[] | UserOnServiceScalarFieldEnum
    having?: UserOnServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserOnServiceCountAggregateInputType | true
    _min?: UserOnServiceMinAggregateInputType
    _max?: UserOnServiceMaxAggregateInputType
  }

  export type UserOnServiceGroupByOutputType = {
    id: string
    serviceId: string
    providerId: string
    _count: UserOnServiceCountAggregateOutputType | null
    _min: UserOnServiceMinAggregateOutputType | null
    _max: UserOnServiceMaxAggregateOutputType | null
  }

  type GetUserOnServiceGroupByPayload<T extends UserOnServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserOnServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserOnServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserOnServiceGroupByOutputType[P]>
            : GetScalarType<T[P], UserOnServiceGroupByOutputType[P]>
        }
      >
    >


  export type UserOnServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    providerId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOnService"]>

  export type UserOnServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    providerId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOnService"]>

  export type UserOnServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    providerId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOnService"]>

  export type UserOnServiceSelectScalar = {
    id?: boolean
    serviceId?: boolean
    providerId?: boolean
  }

  export type UserOnServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceId" | "providerId", ExtArgs["result"]["userOnService"]>
  export type UserOnServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserOnServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserOnServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserOnServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserOnService"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      provider: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      providerId: string
    }, ExtArgs["result"]["userOnService"]>
    composites: {}
  }

  type UserOnServiceGetPayload<S extends boolean | null | undefined | UserOnServiceDefaultArgs> = $Result.GetResult<Prisma.$UserOnServicePayload, S>

  type UserOnServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserOnServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserOnServiceCountAggregateInputType | true
    }

  export interface UserOnServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserOnService'], meta: { name: 'UserOnService' } }
    /**
     * Find zero or one UserOnService that matches the filter.
     * @param {UserOnServiceFindUniqueArgs} args - Arguments to find a UserOnService
     * @example
     * // Get one UserOnService
     * const userOnService = await prisma.userOnService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserOnServiceFindUniqueArgs>(args: SelectSubset<T, UserOnServiceFindUniqueArgs<ExtArgs>>): Prisma__UserOnServiceClient<$Result.GetResult<Prisma.$UserOnServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserOnService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserOnServiceFindUniqueOrThrowArgs} args - Arguments to find a UserOnService
     * @example
     * // Get one UserOnService
     * const userOnService = await prisma.userOnService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserOnServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserOnServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserOnServiceClient<$Result.GetResult<Prisma.$UserOnServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserOnService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnServiceFindFirstArgs} args - Arguments to find a UserOnService
     * @example
     * // Get one UserOnService
     * const userOnService = await prisma.userOnService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserOnServiceFindFirstArgs>(args?: SelectSubset<T, UserOnServiceFindFirstArgs<ExtArgs>>): Prisma__UserOnServiceClient<$Result.GetResult<Prisma.$UserOnServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserOnService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnServiceFindFirstOrThrowArgs} args - Arguments to find a UserOnService
     * @example
     * // Get one UserOnService
     * const userOnService = await prisma.userOnService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserOnServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserOnServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserOnServiceClient<$Result.GetResult<Prisma.$UserOnServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserOnServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserOnServices
     * const userOnServices = await prisma.userOnService.findMany()
     * 
     * // Get first 10 UserOnServices
     * const userOnServices = await prisma.userOnService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userOnServiceWithIdOnly = await prisma.userOnService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserOnServiceFindManyArgs>(args?: SelectSubset<T, UserOnServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOnServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserOnService.
     * @param {UserOnServiceCreateArgs} args - Arguments to create a UserOnService.
     * @example
     * // Create one UserOnService
     * const UserOnService = await prisma.userOnService.create({
     *   data: {
     *     // ... data to create a UserOnService
     *   }
     * })
     * 
     */
    create<T extends UserOnServiceCreateArgs>(args: SelectSubset<T, UserOnServiceCreateArgs<ExtArgs>>): Prisma__UserOnServiceClient<$Result.GetResult<Prisma.$UserOnServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserOnServices.
     * @param {UserOnServiceCreateManyArgs} args - Arguments to create many UserOnServices.
     * @example
     * // Create many UserOnServices
     * const userOnService = await prisma.userOnService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserOnServiceCreateManyArgs>(args?: SelectSubset<T, UserOnServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserOnServices and returns the data saved in the database.
     * @param {UserOnServiceCreateManyAndReturnArgs} args - Arguments to create many UserOnServices.
     * @example
     * // Create many UserOnServices
     * const userOnService = await prisma.userOnService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserOnServices and only return the `id`
     * const userOnServiceWithIdOnly = await prisma.userOnService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserOnServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserOnServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOnServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserOnService.
     * @param {UserOnServiceDeleteArgs} args - Arguments to delete one UserOnService.
     * @example
     * // Delete one UserOnService
     * const UserOnService = await prisma.userOnService.delete({
     *   where: {
     *     // ... filter to delete one UserOnService
     *   }
     * })
     * 
     */
    delete<T extends UserOnServiceDeleteArgs>(args: SelectSubset<T, UserOnServiceDeleteArgs<ExtArgs>>): Prisma__UserOnServiceClient<$Result.GetResult<Prisma.$UserOnServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserOnService.
     * @param {UserOnServiceUpdateArgs} args - Arguments to update one UserOnService.
     * @example
     * // Update one UserOnService
     * const userOnService = await prisma.userOnService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserOnServiceUpdateArgs>(args: SelectSubset<T, UserOnServiceUpdateArgs<ExtArgs>>): Prisma__UserOnServiceClient<$Result.GetResult<Prisma.$UserOnServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserOnServices.
     * @param {UserOnServiceDeleteManyArgs} args - Arguments to filter UserOnServices to delete.
     * @example
     * // Delete a few UserOnServices
     * const { count } = await prisma.userOnService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserOnServiceDeleteManyArgs>(args?: SelectSubset<T, UserOnServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOnServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserOnServices
     * const userOnService = await prisma.userOnService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserOnServiceUpdateManyArgs>(args: SelectSubset<T, UserOnServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOnServices and returns the data updated in the database.
     * @param {UserOnServiceUpdateManyAndReturnArgs} args - Arguments to update many UserOnServices.
     * @example
     * // Update many UserOnServices
     * const userOnService = await prisma.userOnService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserOnServices and only return the `id`
     * const userOnServiceWithIdOnly = await prisma.userOnService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserOnServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, UserOnServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOnServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserOnService.
     * @param {UserOnServiceUpsertArgs} args - Arguments to update or create a UserOnService.
     * @example
     * // Update or create a UserOnService
     * const userOnService = await prisma.userOnService.upsert({
     *   create: {
     *     // ... data to create a UserOnService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserOnService we want to update
     *   }
     * })
     */
    upsert<T extends UserOnServiceUpsertArgs>(args: SelectSubset<T, UserOnServiceUpsertArgs<ExtArgs>>): Prisma__UserOnServiceClient<$Result.GetResult<Prisma.$UserOnServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserOnServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnServiceCountArgs} args - Arguments to filter UserOnServices to count.
     * @example
     * // Count the number of UserOnServices
     * const count = await prisma.userOnService.count({
     *   where: {
     *     // ... the filter for the UserOnServices we want to count
     *   }
     * })
    **/
    count<T extends UserOnServiceCountArgs>(
      args?: Subset<T, UserOnServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserOnServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserOnService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserOnServiceAggregateArgs>(args: Subset<T, UserOnServiceAggregateArgs>): Prisma.PrismaPromise<GetUserOnServiceAggregateType<T>>

    /**
     * Group by UserOnService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserOnServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserOnServiceGroupByArgs['orderBy'] }
        : { orderBy?: UserOnServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserOnServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserOnServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserOnService model
   */
  readonly fields: UserOnServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserOnService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserOnServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provider<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserOnService model
   */
  interface UserOnServiceFieldRefs {
    readonly id: FieldRef<"UserOnService", 'String'>
    readonly serviceId: FieldRef<"UserOnService", 'String'>
    readonly providerId: FieldRef<"UserOnService", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserOnService findUnique
   */
  export type UserOnServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnService
     */
    select?: UserOnServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOnService
     */
    omit?: UserOnServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnServiceInclude<ExtArgs> | null
    /**
     * Filter, which UserOnService to fetch.
     */
    where: UserOnServiceWhereUniqueInput
  }

  /**
   * UserOnService findUniqueOrThrow
   */
  export type UserOnServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnService
     */
    select?: UserOnServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOnService
     */
    omit?: UserOnServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnServiceInclude<ExtArgs> | null
    /**
     * Filter, which UserOnService to fetch.
     */
    where: UserOnServiceWhereUniqueInput
  }

  /**
   * UserOnService findFirst
   */
  export type UserOnServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnService
     */
    select?: UserOnServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOnService
     */
    omit?: UserOnServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnServiceInclude<ExtArgs> | null
    /**
     * Filter, which UserOnService to fetch.
     */
    where?: UserOnServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOnServices to fetch.
     */
    orderBy?: UserOnServiceOrderByWithRelationInput | UserOnServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOnServices.
     */
    cursor?: UserOnServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOnServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOnServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOnServices.
     */
    distinct?: UserOnServiceScalarFieldEnum | UserOnServiceScalarFieldEnum[]
  }

  /**
   * UserOnService findFirstOrThrow
   */
  export type UserOnServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnService
     */
    select?: UserOnServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOnService
     */
    omit?: UserOnServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnServiceInclude<ExtArgs> | null
    /**
     * Filter, which UserOnService to fetch.
     */
    where?: UserOnServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOnServices to fetch.
     */
    orderBy?: UserOnServiceOrderByWithRelationInput | UserOnServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOnServices.
     */
    cursor?: UserOnServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOnServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOnServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOnServices.
     */
    distinct?: UserOnServiceScalarFieldEnum | UserOnServiceScalarFieldEnum[]
  }

  /**
   * UserOnService findMany
   */
  export type UserOnServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnService
     */
    select?: UserOnServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOnService
     */
    omit?: UserOnServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnServiceInclude<ExtArgs> | null
    /**
     * Filter, which UserOnServices to fetch.
     */
    where?: UserOnServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOnServices to fetch.
     */
    orderBy?: UserOnServiceOrderByWithRelationInput | UserOnServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserOnServices.
     */
    cursor?: UserOnServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOnServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOnServices.
     */
    skip?: number
    distinct?: UserOnServiceScalarFieldEnum | UserOnServiceScalarFieldEnum[]
  }

  /**
   * UserOnService create
   */
  export type UserOnServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnService
     */
    select?: UserOnServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOnService
     */
    omit?: UserOnServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserOnService.
     */
    data: XOR<UserOnServiceCreateInput, UserOnServiceUncheckedCreateInput>
  }

  /**
   * UserOnService createMany
   */
  export type UserOnServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserOnServices.
     */
    data: UserOnServiceCreateManyInput | UserOnServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserOnService createManyAndReturn
   */
  export type UserOnServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnService
     */
    select?: UserOnServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserOnService
     */
    omit?: UserOnServiceOmit<ExtArgs> | null
    /**
     * The data used to create many UserOnServices.
     */
    data: UserOnServiceCreateManyInput | UserOnServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserOnService update
   */
  export type UserOnServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnService
     */
    select?: UserOnServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOnService
     */
    omit?: UserOnServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserOnService.
     */
    data: XOR<UserOnServiceUpdateInput, UserOnServiceUncheckedUpdateInput>
    /**
     * Choose, which UserOnService to update.
     */
    where: UserOnServiceWhereUniqueInput
  }

  /**
   * UserOnService updateMany
   */
  export type UserOnServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserOnServices.
     */
    data: XOR<UserOnServiceUpdateManyMutationInput, UserOnServiceUncheckedUpdateManyInput>
    /**
     * Filter which UserOnServices to update
     */
    where?: UserOnServiceWhereInput
    /**
     * Limit how many UserOnServices to update.
     */
    limit?: number
  }

  /**
   * UserOnService updateManyAndReturn
   */
  export type UserOnServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnService
     */
    select?: UserOnServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserOnService
     */
    omit?: UserOnServiceOmit<ExtArgs> | null
    /**
     * The data used to update UserOnServices.
     */
    data: XOR<UserOnServiceUpdateManyMutationInput, UserOnServiceUncheckedUpdateManyInput>
    /**
     * Filter which UserOnServices to update
     */
    where?: UserOnServiceWhereInput
    /**
     * Limit how many UserOnServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserOnService upsert
   */
  export type UserOnServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnService
     */
    select?: UserOnServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOnService
     */
    omit?: UserOnServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserOnService to update in case it exists.
     */
    where: UserOnServiceWhereUniqueInput
    /**
     * In case the UserOnService found by the `where` argument doesn't exist, create a new UserOnService with this data.
     */
    create: XOR<UserOnServiceCreateInput, UserOnServiceUncheckedCreateInput>
    /**
     * In case the UserOnService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserOnServiceUpdateInput, UserOnServiceUncheckedUpdateInput>
  }

  /**
   * UserOnService delete
   */
  export type UserOnServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnService
     */
    select?: UserOnServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOnService
     */
    omit?: UserOnServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnServiceInclude<ExtArgs> | null
    /**
     * Filter which UserOnService to delete.
     */
    where: UserOnServiceWhereUniqueInput
  }

  /**
   * UserOnService deleteMany
   */
  export type UserOnServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOnServices to delete
     */
    where?: UserOnServiceWhereInput
    /**
     * Limit how many UserOnServices to delete.
     */
    limit?: number
  }

  /**
   * UserOnService without action
   */
  export type UserOnServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnService
     */
    select?: UserOnServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOnService
     */
    omit?: UserOnServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceBranch
   */

  export type AggregateServiceBranch = {
    _count: ServiceBranchCountAggregateOutputType | null
    _min: ServiceBranchMinAggregateOutputType | null
    _max: ServiceBranchMaxAggregateOutputType | null
  }

  export type ServiceBranchMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    branchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ServiceBranchMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    branchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ServiceBranchCountAggregateOutputType = {
    id: number
    serviceId: number
    branchId: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type ServiceBranchMinAggregateInputType = {
    id?: true
    serviceId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ServiceBranchMaxAggregateInputType = {
    id?: true
    serviceId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ServiceBranchCountAggregateInputType = {
    id?: true
    serviceId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type ServiceBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceBranch to aggregate.
     */
    where?: ServiceBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBranches to fetch.
     */
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceBranches
    **/
    _count?: true | ServiceBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceBranchMaxAggregateInputType
  }

  export type GetServiceBranchAggregateType<T extends ServiceBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceBranch[P]>
      : GetScalarType<T[P], AggregateServiceBranch[P]>
  }




  export type ServiceBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBranchWhereInput
    orderBy?: ServiceBranchOrderByWithAggregationInput | ServiceBranchOrderByWithAggregationInput[]
    by: ServiceBranchScalarFieldEnum[] | ServiceBranchScalarFieldEnum
    having?: ServiceBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceBranchCountAggregateInputType | true
    _min?: ServiceBranchMinAggregateInputType
    _max?: ServiceBranchMaxAggregateInputType
  }

  export type ServiceBranchGroupByOutputType = {
    id: string
    serviceId: string
    branchId: string
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: ServiceBranchCountAggregateOutputType | null
    _min: ServiceBranchMinAggregateOutputType | null
    _max: ServiceBranchMaxAggregateOutputType | null
  }

  type GetServiceBranchGroupByPayload<T extends ServiceBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceBranchGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceBranchGroupByOutputType[P]>
        }
      >
    >


  export type ServiceBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceBranch"]>

  export type ServiceBranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceBranch"]>

  export type ServiceBranchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceBranch"]>

  export type ServiceBranchSelectScalar = {
    id?: boolean
    serviceId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type ServiceBranchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceId" | "branchId" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["serviceBranch"]>
  export type ServiceBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type ServiceBranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type ServiceBranchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $ServiceBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceBranch"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      branchId: string
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["serviceBranch"]>
    composites: {}
  }

  type ServiceBranchGetPayload<S extends boolean | null | undefined | ServiceBranchDefaultArgs> = $Result.GetResult<Prisma.$ServiceBranchPayload, S>

  type ServiceBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceBranchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceBranchCountAggregateInputType | true
    }

  export interface ServiceBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceBranch'], meta: { name: 'ServiceBranch' } }
    /**
     * Find zero or one ServiceBranch that matches the filter.
     * @param {ServiceBranchFindUniqueArgs} args - Arguments to find a ServiceBranch
     * @example
     * // Get one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceBranchFindUniqueArgs>(args: SelectSubset<T, ServiceBranchFindUniqueArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceBranch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceBranchFindUniqueOrThrowArgs} args - Arguments to find a ServiceBranch
     * @example
     * // Get one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchFindFirstArgs} args - Arguments to find a ServiceBranch
     * @example
     * // Get one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceBranchFindFirstArgs>(args?: SelectSubset<T, ServiceBranchFindFirstArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchFindFirstOrThrowArgs} args - Arguments to find a ServiceBranch
     * @example
     * // Get one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceBranches
     * const serviceBranches = await prisma.serviceBranch.findMany()
     * 
     * // Get first 10 ServiceBranches
     * const serviceBranches = await prisma.serviceBranch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceBranchWithIdOnly = await prisma.serviceBranch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceBranchFindManyArgs>(args?: SelectSubset<T, ServiceBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceBranch.
     * @param {ServiceBranchCreateArgs} args - Arguments to create a ServiceBranch.
     * @example
     * // Create one ServiceBranch
     * const ServiceBranch = await prisma.serviceBranch.create({
     *   data: {
     *     // ... data to create a ServiceBranch
     *   }
     * })
     * 
     */
    create<T extends ServiceBranchCreateArgs>(args: SelectSubset<T, ServiceBranchCreateArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceBranches.
     * @param {ServiceBranchCreateManyArgs} args - Arguments to create many ServiceBranches.
     * @example
     * // Create many ServiceBranches
     * const serviceBranch = await prisma.serviceBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceBranchCreateManyArgs>(args?: SelectSubset<T, ServiceBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceBranches and returns the data saved in the database.
     * @param {ServiceBranchCreateManyAndReturnArgs} args - Arguments to create many ServiceBranches.
     * @example
     * // Create many ServiceBranches
     * const serviceBranch = await prisma.serviceBranch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceBranches and only return the `id`
     * const serviceBranchWithIdOnly = await prisma.serviceBranch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceBranchCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceBranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceBranch.
     * @param {ServiceBranchDeleteArgs} args - Arguments to delete one ServiceBranch.
     * @example
     * // Delete one ServiceBranch
     * const ServiceBranch = await prisma.serviceBranch.delete({
     *   where: {
     *     // ... filter to delete one ServiceBranch
     *   }
     * })
     * 
     */
    delete<T extends ServiceBranchDeleteArgs>(args: SelectSubset<T, ServiceBranchDeleteArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceBranch.
     * @param {ServiceBranchUpdateArgs} args - Arguments to update one ServiceBranch.
     * @example
     * // Update one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceBranchUpdateArgs>(args: SelectSubset<T, ServiceBranchUpdateArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceBranches.
     * @param {ServiceBranchDeleteManyArgs} args - Arguments to filter ServiceBranches to delete.
     * @example
     * // Delete a few ServiceBranches
     * const { count } = await prisma.serviceBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceBranchDeleteManyArgs>(args?: SelectSubset<T, ServiceBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceBranches
     * const serviceBranch = await prisma.serviceBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceBranchUpdateManyArgs>(args: SelectSubset<T, ServiceBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceBranches and returns the data updated in the database.
     * @param {ServiceBranchUpdateManyAndReturnArgs} args - Arguments to update many ServiceBranches.
     * @example
     * // Update many ServiceBranches
     * const serviceBranch = await prisma.serviceBranch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceBranches and only return the `id`
     * const serviceBranchWithIdOnly = await prisma.serviceBranch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceBranchUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceBranchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceBranch.
     * @param {ServiceBranchUpsertArgs} args - Arguments to update or create a ServiceBranch.
     * @example
     * // Update or create a ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.upsert({
     *   create: {
     *     // ... data to create a ServiceBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceBranch we want to update
     *   }
     * })
     */
    upsert<T extends ServiceBranchUpsertArgs>(args: SelectSubset<T, ServiceBranchUpsertArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchCountArgs} args - Arguments to filter ServiceBranches to count.
     * @example
     * // Count the number of ServiceBranches
     * const count = await prisma.serviceBranch.count({
     *   where: {
     *     // ... the filter for the ServiceBranches we want to count
     *   }
     * })
    **/
    count<T extends ServiceBranchCountArgs>(
      args?: Subset<T, ServiceBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceBranchAggregateArgs>(args: Subset<T, ServiceBranchAggregateArgs>): Prisma.PrismaPromise<GetServiceBranchAggregateType<T>>

    /**
     * Group by ServiceBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceBranchGroupByArgs['orderBy'] }
        : { orderBy?: ServiceBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceBranch model
   */
  readonly fields: ServiceBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceBranch model
   */
  interface ServiceBranchFieldRefs {
    readonly id: FieldRef<"ServiceBranch", 'String'>
    readonly serviceId: FieldRef<"ServiceBranch", 'String'>
    readonly branchId: FieldRef<"ServiceBranch", 'String'>
    readonly createdAt: FieldRef<"ServiceBranch", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceBranch", 'DateTime'>
    readonly createdBy: FieldRef<"ServiceBranch", 'String'>
    readonly updatedBy: FieldRef<"ServiceBranch", 'String'>
    readonly isDeleted: FieldRef<"ServiceBranch", 'Boolean'>
    readonly deletedAt: FieldRef<"ServiceBranch", 'DateTime'>
    readonly deletedBy: FieldRef<"ServiceBranch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceBranch findUnique
   */
  export type ServiceBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceBranch
     */
    omit?: ServiceBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranch to fetch.
     */
    where: ServiceBranchWhereUniqueInput
  }

  /**
   * ServiceBranch findUniqueOrThrow
   */
  export type ServiceBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceBranch
     */
    omit?: ServiceBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranch to fetch.
     */
    where: ServiceBranchWhereUniqueInput
  }

  /**
   * ServiceBranch findFirst
   */
  export type ServiceBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceBranch
     */
    omit?: ServiceBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranch to fetch.
     */
    where?: ServiceBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBranches to fetch.
     */
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceBranches.
     */
    cursor?: ServiceBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceBranches.
     */
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * ServiceBranch findFirstOrThrow
   */
  export type ServiceBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceBranch
     */
    omit?: ServiceBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranch to fetch.
     */
    where?: ServiceBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBranches to fetch.
     */
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceBranches.
     */
    cursor?: ServiceBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceBranches.
     */
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * ServiceBranch findMany
   */
  export type ServiceBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceBranch
     */
    omit?: ServiceBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranches to fetch.
     */
    where?: ServiceBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBranches to fetch.
     */
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceBranches.
     */
    cursor?: ServiceBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBranches.
     */
    skip?: number
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * ServiceBranch create
   */
  export type ServiceBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceBranch
     */
    omit?: ServiceBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceBranch.
     */
    data: XOR<ServiceBranchCreateInput, ServiceBranchUncheckedCreateInput>
  }

  /**
   * ServiceBranch createMany
   */
  export type ServiceBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceBranches.
     */
    data: ServiceBranchCreateManyInput | ServiceBranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceBranch createManyAndReturn
   */
  export type ServiceBranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceBranch
     */
    omit?: ServiceBranchOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceBranches.
     */
    data: ServiceBranchCreateManyInput | ServiceBranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceBranch update
   */
  export type ServiceBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceBranch
     */
    omit?: ServiceBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceBranch.
     */
    data: XOR<ServiceBranchUpdateInput, ServiceBranchUncheckedUpdateInput>
    /**
     * Choose, which ServiceBranch to update.
     */
    where: ServiceBranchWhereUniqueInput
  }

  /**
   * ServiceBranch updateMany
   */
  export type ServiceBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceBranches.
     */
    data: XOR<ServiceBranchUpdateManyMutationInput, ServiceBranchUncheckedUpdateManyInput>
    /**
     * Filter which ServiceBranches to update
     */
    where?: ServiceBranchWhereInput
    /**
     * Limit how many ServiceBranches to update.
     */
    limit?: number
  }

  /**
   * ServiceBranch updateManyAndReturn
   */
  export type ServiceBranchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceBranch
     */
    omit?: ServiceBranchOmit<ExtArgs> | null
    /**
     * The data used to update ServiceBranches.
     */
    data: XOR<ServiceBranchUpdateManyMutationInput, ServiceBranchUncheckedUpdateManyInput>
    /**
     * Filter which ServiceBranches to update
     */
    where?: ServiceBranchWhereInput
    /**
     * Limit how many ServiceBranches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceBranch upsert
   */
  export type ServiceBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceBranch
     */
    omit?: ServiceBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceBranch to update in case it exists.
     */
    where: ServiceBranchWhereUniqueInput
    /**
     * In case the ServiceBranch found by the `where` argument doesn't exist, create a new ServiceBranch with this data.
     */
    create: XOR<ServiceBranchCreateInput, ServiceBranchUncheckedCreateInput>
    /**
     * In case the ServiceBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceBranchUpdateInput, ServiceBranchUncheckedUpdateInput>
  }

  /**
   * ServiceBranch delete
   */
  export type ServiceBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceBranch
     */
    omit?: ServiceBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter which ServiceBranch to delete.
     */
    where: ServiceBranchWhereUniqueInput
  }

  /**
   * ServiceBranch deleteMany
   */
  export type ServiceBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceBranches to delete
     */
    where?: ServiceBranchWhereInput
    /**
     * Limit how many ServiceBranches to delete.
     */
    limit?: number
  }

  /**
   * ServiceBranch without action
   */
  export type ServiceBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceBranch
     */
    omit?: ServiceBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    reminderMinutesBefore: number | null
    rating: number | null
    price: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    reminderMinutesBefore: number | null
    rating: number | null
    price: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    consumerId: string | null
    branchId: string | null
    serviceProviderId: string | null
    appointmentTime: Date | null
    appointmentDate: Date | null
    appointmentTimeSlot: string | null
    reminderMinutesBefore: number | null
    discountId: string | null
    note: string | null
    status: $Enums.AppointmentStatus | null
    bookingType: $Enums.AppointmentBookingType | null
    review: string | null
    rating: number | null
    isManual: boolean | null
    price: number | null
    subscriberSubscriptionId: string | null
    promotionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    consumerId: string | null
    branchId: string | null
    serviceProviderId: string | null
    appointmentTime: Date | null
    appointmentDate: Date | null
    appointmentTimeSlot: string | null
    reminderMinutesBefore: number | null
    discountId: string | null
    note: string | null
    status: $Enums.AppointmentStatus | null
    bookingType: $Enums.AppointmentBookingType | null
    review: string | null
    rating: number | null
    isManual: boolean | null
    price: number | null
    subscriberSubscriptionId: string | null
    promotionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    serviceId: number
    consumerId: number
    branchId: number
    serviceProviderId: number
    appointmentTime: number
    appointmentDate: number
    appointmentTimeSlot: number
    reminderMinutesBefore: number
    discountId: number
    note: number
    status: number
    bookingType: number
    review: number
    rating: number
    isManual: number
    price: number
    subscriberSubscriptionId: number
    promotionId: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    reminderMinutesBefore?: true
    rating?: true
    price?: true
  }

  export type AppointmentSumAggregateInputType = {
    reminderMinutesBefore?: true
    rating?: true
    price?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    serviceId?: true
    consumerId?: true
    branchId?: true
    serviceProviderId?: true
    appointmentTime?: true
    appointmentDate?: true
    appointmentTimeSlot?: true
    reminderMinutesBefore?: true
    discountId?: true
    note?: true
    status?: true
    bookingType?: true
    review?: true
    rating?: true
    isManual?: true
    price?: true
    subscriberSubscriptionId?: true
    promotionId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    serviceId?: true
    consumerId?: true
    branchId?: true
    serviceProviderId?: true
    appointmentTime?: true
    appointmentDate?: true
    appointmentTimeSlot?: true
    reminderMinutesBefore?: true
    discountId?: true
    note?: true
    status?: true
    bookingType?: true
    review?: true
    rating?: true
    isManual?: true
    price?: true
    subscriberSubscriptionId?: true
    promotionId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    serviceId?: true
    consumerId?: true
    branchId?: true
    serviceProviderId?: true
    appointmentTime?: true
    appointmentDate?: true
    appointmentTimeSlot?: true
    reminderMinutesBefore?: true
    discountId?: true
    note?: true
    status?: true
    bookingType?: true
    review?: true
    rating?: true
    isManual?: true
    price?: true
    subscriberSubscriptionId?: true
    promotionId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    serviceId: string
    consumerId: string
    branchId: string
    serviceProviderId: string | null
    appointmentTime: Date
    appointmentDate: Date | null
    appointmentTimeSlot: string | null
    reminderMinutesBefore: number | null
    discountId: string | null
    note: string | null
    status: $Enums.AppointmentStatus
    bookingType: $Enums.AppointmentBookingType | null
    review: string | null
    rating: number | null
    isManual: boolean
    price: number | null
    subscriberSubscriptionId: string | null
    promotionId: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    consumerId?: boolean
    branchId?: boolean
    serviceProviderId?: boolean
    appointmentTime?: boolean
    appointmentDate?: boolean
    appointmentTimeSlot?: boolean
    reminderMinutesBefore?: boolean
    discountId?: boolean
    note?: boolean
    status?: boolean
    bookingType?: boolean
    review?: boolean
    rating?: boolean
    isManual?: boolean
    price?: boolean
    subscriberSubscriptionId?: boolean
    promotionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    promotion?: boolean | Appointment$promotionArgs<ExtArgs>
    subscriberSubscription?: boolean | Appointment$subscriberSubscriptionArgs<ExtArgs>
    discount?: boolean | Appointment$discountArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    consumer?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | Appointment$serviceProviderArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    consumerId?: boolean
    branchId?: boolean
    serviceProviderId?: boolean
    appointmentTime?: boolean
    appointmentDate?: boolean
    appointmentTimeSlot?: boolean
    reminderMinutesBefore?: boolean
    discountId?: boolean
    note?: boolean
    status?: boolean
    bookingType?: boolean
    review?: boolean
    rating?: boolean
    isManual?: boolean
    price?: boolean
    subscriberSubscriptionId?: boolean
    promotionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    promotion?: boolean | Appointment$promotionArgs<ExtArgs>
    subscriberSubscription?: boolean | Appointment$subscriberSubscriptionArgs<ExtArgs>
    discount?: boolean | Appointment$discountArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    consumer?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | Appointment$serviceProviderArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    consumerId?: boolean
    branchId?: boolean
    serviceProviderId?: boolean
    appointmentTime?: boolean
    appointmentDate?: boolean
    appointmentTimeSlot?: boolean
    reminderMinutesBefore?: boolean
    discountId?: boolean
    note?: boolean
    status?: boolean
    bookingType?: boolean
    review?: boolean
    rating?: boolean
    isManual?: boolean
    price?: boolean
    subscriberSubscriptionId?: boolean
    promotionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    promotion?: boolean | Appointment$promotionArgs<ExtArgs>
    subscriberSubscription?: boolean | Appointment$subscriberSubscriptionArgs<ExtArgs>
    discount?: boolean | Appointment$discountArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    consumer?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | Appointment$serviceProviderArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    serviceId?: boolean
    consumerId?: boolean
    branchId?: boolean
    serviceProviderId?: boolean
    appointmentTime?: boolean
    appointmentDate?: boolean
    appointmentTimeSlot?: boolean
    reminderMinutesBefore?: boolean
    discountId?: boolean
    note?: boolean
    status?: boolean
    bookingType?: boolean
    review?: boolean
    rating?: boolean
    isManual?: boolean
    price?: boolean
    subscriberSubscriptionId?: boolean
    promotionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceId" | "consumerId" | "branchId" | "serviceProviderId" | "appointmentTime" | "appointmentDate" | "appointmentTimeSlot" | "reminderMinutesBefore" | "discountId" | "note" | "status" | "bookingType" | "review" | "rating" | "isManual" | "price" | "subscriberSubscriptionId" | "promotionId" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | Appointment$promotionArgs<ExtArgs>
    subscriberSubscription?: boolean | Appointment$subscriberSubscriptionArgs<ExtArgs>
    discount?: boolean | Appointment$discountArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    consumer?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | Appointment$serviceProviderArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | Appointment$promotionArgs<ExtArgs>
    subscriberSubscription?: boolean | Appointment$subscriberSubscriptionArgs<ExtArgs>
    discount?: boolean | Appointment$discountArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    consumer?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | Appointment$serviceProviderArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | Appointment$promotionArgs<ExtArgs>
    subscriberSubscription?: boolean | Appointment$subscriberSubscriptionArgs<ExtArgs>
    discount?: boolean | Appointment$discountArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    consumer?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | Appointment$serviceProviderArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      promotion: Prisma.$PromotionPayload<ExtArgs> | null
      subscriberSubscription: Prisma.$SubscriberSubscriptionPayload<ExtArgs> | null
      discount: Prisma.$DiscountPayload<ExtArgs> | null
      service: Prisma.$ServicePayload<ExtArgs>
      consumer: Prisma.$UserPayload<ExtArgs>
      serviceProvider: Prisma.$UserPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      consumerId: string
      branchId: string
      serviceProviderId: string | null
      appointmentTime: Date
      appointmentDate: Date | null
      appointmentTimeSlot: string | null
      reminderMinutesBefore: number | null
      discountId: string | null
      note: string | null
      status: $Enums.AppointmentStatus
      bookingType: $Enums.AppointmentBookingType | null
      review: string | null
      rating: number | null
      isManual: boolean
      price: number | null
      subscriberSubscriptionId: string | null
      promotionId: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    promotion<T extends Appointment$promotionArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$promotionArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subscriberSubscription<T extends Appointment$subscriberSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$subscriberSubscriptionArgs<ExtArgs>>): Prisma__SubscriberSubscriptionClient<$Result.GetResult<Prisma.$SubscriberSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    discount<T extends Appointment$discountArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$discountArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    consumer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceProvider<T extends Appointment$serviceProviderArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$serviceProviderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly serviceId: FieldRef<"Appointment", 'String'>
    readonly consumerId: FieldRef<"Appointment", 'String'>
    readonly branchId: FieldRef<"Appointment", 'String'>
    readonly serviceProviderId: FieldRef<"Appointment", 'String'>
    readonly appointmentTime: FieldRef<"Appointment", 'DateTime'>
    readonly appointmentDate: FieldRef<"Appointment", 'DateTime'>
    readonly appointmentTimeSlot: FieldRef<"Appointment", 'String'>
    readonly reminderMinutesBefore: FieldRef<"Appointment", 'Int'>
    readonly discountId: FieldRef<"Appointment", 'String'>
    readonly note: FieldRef<"Appointment", 'String'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly bookingType: FieldRef<"Appointment", 'AppointmentBookingType'>
    readonly review: FieldRef<"Appointment", 'String'>
    readonly rating: FieldRef<"Appointment", 'Int'>
    readonly isManual: FieldRef<"Appointment", 'Boolean'>
    readonly price: FieldRef<"Appointment", 'Int'>
    readonly subscriberSubscriptionId: FieldRef<"Appointment", 'String'>
    readonly promotionId: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
    readonly createdBy: FieldRef<"Appointment", 'String'>
    readonly updatedBy: FieldRef<"Appointment", 'String'>
    readonly isDeleted: FieldRef<"Appointment", 'Boolean'>
    readonly deletedAt: FieldRef<"Appointment", 'DateTime'>
    readonly deletedBy: FieldRef<"Appointment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.promotion
   */
  export type Appointment$promotionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    where?: PromotionWhereInput
  }

  /**
   * Appointment.subscriberSubscription
   */
  export type Appointment$subscriberSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberSubscription
     */
    select?: SubscriberSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriberSubscription
     */
    omit?: SubscriberSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberSubscriptionInclude<ExtArgs> | null
    where?: SubscriberSubscriptionWhereInput
  }

  /**
   * Appointment.discount
   */
  export type Appointment$discountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    where?: DiscountWhereInput
  }

  /**
   * Appointment.serviceProvider
   */
  export type Appointment$serviceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionAvgAggregateOutputType = {
    value: number | null
    limit: number | null
  }

  export type PromotionSumAggregateOutputType = {
    value: number | null
    limit: number | null
  }

  export type PromotionMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.DiscountType | null
    value: number | null
    limit: number | null
    status: boolean | null
    startDate: Date | null
    expiryDate: Date | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.DiscountType | null
    value: number | null
    limit: number | null
    status: boolean | null
    startDate: Date | null
    expiryDate: Date | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    name: number
    type: number
    value: number
    limit: number
    status: number
    startDate: number
    expiryDate: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type PromotionAvgAggregateInputType = {
    value?: true
    limit?: true
  }

  export type PromotionSumAggregateInputType = {
    value?: true
    limit?: true
  }

  export type PromotionMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    limit?: true
    status?: true
    startDate?: true
    expiryDate?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    limit?: true
    status?: true
    startDate?: true
    expiryDate?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    limit?: true
    status?: true
    startDate?: true
    expiryDate?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _avg?: PromotionAvgAggregateInputType
    _sum?: PromotionSumAggregateInputType
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: string
    name: string
    type: $Enums.DiscountType
    value: number
    limit: number | null
    status: boolean
    startDate: Date
    expiryDate: Date
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    limit?: boolean
    status?: boolean
    startDate?: boolean
    expiryDate?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    branches?: boolean | Promotion$branchesArgs<ExtArgs>
    appointments?: boolean | Promotion$appointmentsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    limit?: boolean
    status?: boolean
    startDate?: boolean
    expiryDate?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    limit?: boolean
    status?: boolean
    startDate?: boolean
    expiryDate?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    limit?: boolean
    status?: boolean
    startDate?: boolean
    expiryDate?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type PromotionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "value" | "limit" | "status" | "startDate" | "expiryDate" | "imageUrl" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["promotion"]>
  export type PromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | Promotion$branchesArgs<ExtArgs>
    appointments?: boolean | Promotion$appointmentsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromotionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PromotionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {
      branches: Prisma.$BranchPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.DiscountType
      value: number
      limit: number | null
      status: boolean
      startDate: Date
      expiryDate: Date
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }

  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionFindUniqueArgs>(args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Promotion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionFindFirstArgs>(args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionFindManyArgs>(args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
     */
    create<T extends PromotionCreateArgs>(args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Promotions.
     * @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionCreateManyArgs>(args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Promotions and returns the data saved in the database.
     * @param {PromotionCreateManyAndReturnArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
     */
    delete<T extends PromotionDeleteArgs>(args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionUpdateArgs>(args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionDeleteManyArgs>(args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionUpdateManyArgs>(args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions and returns the data updated in the database.
     * @param {PromotionUpdateManyAndReturnArgs} args - Arguments to update many Promotions.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromotionUpdateManyAndReturnArgs>(args: SelectSubset<T, PromotionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
     */
    upsert<T extends PromotionUpsertArgs>(args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branches<T extends Promotion$branchesArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Promotion$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promotion model
   */
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'String'>
    readonly name: FieldRef<"Promotion", 'String'>
    readonly type: FieldRef<"Promotion", 'DiscountType'>
    readonly value: FieldRef<"Promotion", 'Float'>
    readonly limit: FieldRef<"Promotion", 'Int'>
    readonly status: FieldRef<"Promotion", 'Boolean'>
    readonly startDate: FieldRef<"Promotion", 'DateTime'>
    readonly expiryDate: FieldRef<"Promotion", 'DateTime'>
    readonly imageUrl: FieldRef<"Promotion", 'String'>
    readonly createdAt: FieldRef<"Promotion", 'DateTime'>
    readonly updatedAt: FieldRef<"Promotion", 'DateTime'>
    readonly createdBy: FieldRef<"Promotion", 'String'>
    readonly updatedBy: FieldRef<"Promotion", 'String'>
    readonly isDeleted: FieldRef<"Promotion", 'Boolean'>
    readonly deletedAt: FieldRef<"Promotion", 'DateTime'>
    readonly deletedBy: FieldRef<"Promotion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }

  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion createManyAndReturn
   */
  export type PromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion updateManyAndReturn
   */
  export type PromotionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }

  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to delete.
     */
    limit?: number
  }

  /**
   * Promotion.branches
   */
  export type Promotion$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Promotion.appointments
   */
  export type Promotion$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
  }


  /**
   * Model TabletAccount
   */

  export type AggregateTabletAccount = {
    _count: TabletAccountCountAggregateOutputType | null
    _min: TabletAccountMinAggregateOutputType | null
    _max: TabletAccountMaxAggregateOutputType | null
  }

  export type TabletAccountMinAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    branchId: string | null
    loginLink: string | null
    loginToken: string | null
    isActive: boolean | null
    isLoggedIn: boolean | null
    lastActivityAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type TabletAccountMaxAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    branchId: string | null
    loginLink: string | null
    loginToken: string | null
    isActive: boolean | null
    isLoggedIn: boolean | null
    lastActivityAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type TabletAccountCountAggregateOutputType = {
    id: number
    username: number
    password: number
    branchId: number
    loginLink: number
    loginToken: number
    isActive: number
    isLoggedIn: number
    lastActivityAt: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type TabletAccountMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    branchId?: true
    loginLink?: true
    loginToken?: true
    isActive?: true
    isLoggedIn?: true
    lastActivityAt?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type TabletAccountMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    branchId?: true
    loginLink?: true
    loginToken?: true
    isActive?: true
    isLoggedIn?: true
    lastActivityAt?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type TabletAccountCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    branchId?: true
    loginLink?: true
    loginToken?: true
    isActive?: true
    isLoggedIn?: true
    lastActivityAt?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type TabletAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TabletAccount to aggregate.
     */
    where?: TabletAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TabletAccounts to fetch.
     */
    orderBy?: TabletAccountOrderByWithRelationInput | TabletAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TabletAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TabletAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TabletAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TabletAccounts
    **/
    _count?: true | TabletAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TabletAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TabletAccountMaxAggregateInputType
  }

  export type GetTabletAccountAggregateType<T extends TabletAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateTabletAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTabletAccount[P]>
      : GetScalarType<T[P], AggregateTabletAccount[P]>
  }




  export type TabletAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TabletAccountWhereInput
    orderBy?: TabletAccountOrderByWithAggregationInput | TabletAccountOrderByWithAggregationInput[]
    by: TabletAccountScalarFieldEnum[] | TabletAccountScalarFieldEnum
    having?: TabletAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TabletAccountCountAggregateInputType | true
    _min?: TabletAccountMinAggregateInputType
    _max?: TabletAccountMaxAggregateInputType
  }

  export type TabletAccountGroupByOutputType = {
    id: string
    username: string
    password: string
    branchId: string
    loginLink: string | null
    loginToken: string
    isActive: boolean
    isLoggedIn: boolean
    lastActivityAt: Date | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: TabletAccountCountAggregateOutputType | null
    _min: TabletAccountMinAggregateOutputType | null
    _max: TabletAccountMaxAggregateOutputType | null
  }

  type GetTabletAccountGroupByPayload<T extends TabletAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TabletAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TabletAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TabletAccountGroupByOutputType[P]>
            : GetScalarType<T[P], TabletAccountGroupByOutputType[P]>
        }
      >
    >


  export type TabletAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    branchId?: boolean
    loginLink?: boolean
    loginToken?: boolean
    isActive?: boolean
    isLoggedIn?: boolean
    lastActivityAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tabletAccount"]>

  export type TabletAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    branchId?: boolean
    loginLink?: boolean
    loginToken?: boolean
    isActive?: boolean
    isLoggedIn?: boolean
    lastActivityAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tabletAccount"]>

  export type TabletAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    branchId?: boolean
    loginLink?: boolean
    loginToken?: boolean
    isActive?: boolean
    isLoggedIn?: boolean
    lastActivityAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tabletAccount"]>

  export type TabletAccountSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    branchId?: boolean
    loginLink?: boolean
    loginToken?: boolean
    isActive?: boolean
    isLoggedIn?: boolean
    lastActivityAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type TabletAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "branchId" | "loginLink" | "loginToken" | "isActive" | "isLoggedIn" | "lastActivityAt" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["tabletAccount"]>
  export type TabletAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type TabletAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type TabletAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $TabletAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TabletAccount"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      password: string
      branchId: string
      loginLink: string | null
      loginToken: string
      isActive: boolean
      isLoggedIn: boolean
      lastActivityAt: Date | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["tabletAccount"]>
    composites: {}
  }

  type TabletAccountGetPayload<S extends boolean | null | undefined | TabletAccountDefaultArgs> = $Result.GetResult<Prisma.$TabletAccountPayload, S>

  type TabletAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TabletAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TabletAccountCountAggregateInputType | true
    }

  export interface TabletAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TabletAccount'], meta: { name: 'TabletAccount' } }
    /**
     * Find zero or one TabletAccount that matches the filter.
     * @param {TabletAccountFindUniqueArgs} args - Arguments to find a TabletAccount
     * @example
     * // Get one TabletAccount
     * const tabletAccount = await prisma.tabletAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TabletAccountFindUniqueArgs>(args: SelectSubset<T, TabletAccountFindUniqueArgs<ExtArgs>>): Prisma__TabletAccountClient<$Result.GetResult<Prisma.$TabletAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TabletAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TabletAccountFindUniqueOrThrowArgs} args - Arguments to find a TabletAccount
     * @example
     * // Get one TabletAccount
     * const tabletAccount = await prisma.tabletAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TabletAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, TabletAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TabletAccountClient<$Result.GetResult<Prisma.$TabletAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TabletAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TabletAccountFindFirstArgs} args - Arguments to find a TabletAccount
     * @example
     * // Get one TabletAccount
     * const tabletAccount = await prisma.tabletAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TabletAccountFindFirstArgs>(args?: SelectSubset<T, TabletAccountFindFirstArgs<ExtArgs>>): Prisma__TabletAccountClient<$Result.GetResult<Prisma.$TabletAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TabletAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TabletAccountFindFirstOrThrowArgs} args - Arguments to find a TabletAccount
     * @example
     * // Get one TabletAccount
     * const tabletAccount = await prisma.tabletAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TabletAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, TabletAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__TabletAccountClient<$Result.GetResult<Prisma.$TabletAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TabletAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TabletAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TabletAccounts
     * const tabletAccounts = await prisma.tabletAccount.findMany()
     * 
     * // Get first 10 TabletAccounts
     * const tabletAccounts = await prisma.tabletAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tabletAccountWithIdOnly = await prisma.tabletAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TabletAccountFindManyArgs>(args?: SelectSubset<T, TabletAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TabletAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TabletAccount.
     * @param {TabletAccountCreateArgs} args - Arguments to create a TabletAccount.
     * @example
     * // Create one TabletAccount
     * const TabletAccount = await prisma.tabletAccount.create({
     *   data: {
     *     // ... data to create a TabletAccount
     *   }
     * })
     * 
     */
    create<T extends TabletAccountCreateArgs>(args: SelectSubset<T, TabletAccountCreateArgs<ExtArgs>>): Prisma__TabletAccountClient<$Result.GetResult<Prisma.$TabletAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TabletAccounts.
     * @param {TabletAccountCreateManyArgs} args - Arguments to create many TabletAccounts.
     * @example
     * // Create many TabletAccounts
     * const tabletAccount = await prisma.tabletAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TabletAccountCreateManyArgs>(args?: SelectSubset<T, TabletAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TabletAccounts and returns the data saved in the database.
     * @param {TabletAccountCreateManyAndReturnArgs} args - Arguments to create many TabletAccounts.
     * @example
     * // Create many TabletAccounts
     * const tabletAccount = await prisma.tabletAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TabletAccounts and only return the `id`
     * const tabletAccountWithIdOnly = await prisma.tabletAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TabletAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, TabletAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TabletAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TabletAccount.
     * @param {TabletAccountDeleteArgs} args - Arguments to delete one TabletAccount.
     * @example
     * // Delete one TabletAccount
     * const TabletAccount = await prisma.tabletAccount.delete({
     *   where: {
     *     // ... filter to delete one TabletAccount
     *   }
     * })
     * 
     */
    delete<T extends TabletAccountDeleteArgs>(args: SelectSubset<T, TabletAccountDeleteArgs<ExtArgs>>): Prisma__TabletAccountClient<$Result.GetResult<Prisma.$TabletAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TabletAccount.
     * @param {TabletAccountUpdateArgs} args - Arguments to update one TabletAccount.
     * @example
     * // Update one TabletAccount
     * const tabletAccount = await prisma.tabletAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TabletAccountUpdateArgs>(args: SelectSubset<T, TabletAccountUpdateArgs<ExtArgs>>): Prisma__TabletAccountClient<$Result.GetResult<Prisma.$TabletAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TabletAccounts.
     * @param {TabletAccountDeleteManyArgs} args - Arguments to filter TabletAccounts to delete.
     * @example
     * // Delete a few TabletAccounts
     * const { count } = await prisma.tabletAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TabletAccountDeleteManyArgs>(args?: SelectSubset<T, TabletAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TabletAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TabletAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TabletAccounts
     * const tabletAccount = await prisma.tabletAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TabletAccountUpdateManyArgs>(args: SelectSubset<T, TabletAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TabletAccounts and returns the data updated in the database.
     * @param {TabletAccountUpdateManyAndReturnArgs} args - Arguments to update many TabletAccounts.
     * @example
     * // Update many TabletAccounts
     * const tabletAccount = await prisma.tabletAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TabletAccounts and only return the `id`
     * const tabletAccountWithIdOnly = await prisma.tabletAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TabletAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, TabletAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TabletAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TabletAccount.
     * @param {TabletAccountUpsertArgs} args - Arguments to update or create a TabletAccount.
     * @example
     * // Update or create a TabletAccount
     * const tabletAccount = await prisma.tabletAccount.upsert({
     *   create: {
     *     // ... data to create a TabletAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TabletAccount we want to update
     *   }
     * })
     */
    upsert<T extends TabletAccountUpsertArgs>(args: SelectSubset<T, TabletAccountUpsertArgs<ExtArgs>>): Prisma__TabletAccountClient<$Result.GetResult<Prisma.$TabletAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TabletAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TabletAccountCountArgs} args - Arguments to filter TabletAccounts to count.
     * @example
     * // Count the number of TabletAccounts
     * const count = await prisma.tabletAccount.count({
     *   where: {
     *     // ... the filter for the TabletAccounts we want to count
     *   }
     * })
    **/
    count<T extends TabletAccountCountArgs>(
      args?: Subset<T, TabletAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TabletAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TabletAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TabletAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TabletAccountAggregateArgs>(args: Subset<T, TabletAccountAggregateArgs>): Prisma.PrismaPromise<GetTabletAccountAggregateType<T>>

    /**
     * Group by TabletAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TabletAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TabletAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TabletAccountGroupByArgs['orderBy'] }
        : { orderBy?: TabletAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TabletAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTabletAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TabletAccount model
   */
  readonly fields: TabletAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TabletAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TabletAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TabletAccount model
   */
  interface TabletAccountFieldRefs {
    readonly id: FieldRef<"TabletAccount", 'String'>
    readonly username: FieldRef<"TabletAccount", 'String'>
    readonly password: FieldRef<"TabletAccount", 'String'>
    readonly branchId: FieldRef<"TabletAccount", 'String'>
    readonly loginLink: FieldRef<"TabletAccount", 'String'>
    readonly loginToken: FieldRef<"TabletAccount", 'String'>
    readonly isActive: FieldRef<"TabletAccount", 'Boolean'>
    readonly isLoggedIn: FieldRef<"TabletAccount", 'Boolean'>
    readonly lastActivityAt: FieldRef<"TabletAccount", 'DateTime'>
    readonly createdAt: FieldRef<"TabletAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"TabletAccount", 'DateTime'>
    readonly createdBy: FieldRef<"TabletAccount", 'String'>
    readonly updatedBy: FieldRef<"TabletAccount", 'String'>
    readonly isDeleted: FieldRef<"TabletAccount", 'Boolean'>
    readonly deletedAt: FieldRef<"TabletAccount", 'DateTime'>
    readonly deletedBy: FieldRef<"TabletAccount", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TabletAccount findUnique
   */
  export type TabletAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TabletAccount
     */
    select?: TabletAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TabletAccount
     */
    omit?: TabletAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TabletAccountInclude<ExtArgs> | null
    /**
     * Filter, which TabletAccount to fetch.
     */
    where: TabletAccountWhereUniqueInput
  }

  /**
   * TabletAccount findUniqueOrThrow
   */
  export type TabletAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TabletAccount
     */
    select?: TabletAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TabletAccount
     */
    omit?: TabletAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TabletAccountInclude<ExtArgs> | null
    /**
     * Filter, which TabletAccount to fetch.
     */
    where: TabletAccountWhereUniqueInput
  }

  /**
   * TabletAccount findFirst
   */
  export type TabletAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TabletAccount
     */
    select?: TabletAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TabletAccount
     */
    omit?: TabletAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TabletAccountInclude<ExtArgs> | null
    /**
     * Filter, which TabletAccount to fetch.
     */
    where?: TabletAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TabletAccounts to fetch.
     */
    orderBy?: TabletAccountOrderByWithRelationInput | TabletAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TabletAccounts.
     */
    cursor?: TabletAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TabletAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TabletAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TabletAccounts.
     */
    distinct?: TabletAccountScalarFieldEnum | TabletAccountScalarFieldEnum[]
  }

  /**
   * TabletAccount findFirstOrThrow
   */
  export type TabletAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TabletAccount
     */
    select?: TabletAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TabletAccount
     */
    omit?: TabletAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TabletAccountInclude<ExtArgs> | null
    /**
     * Filter, which TabletAccount to fetch.
     */
    where?: TabletAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TabletAccounts to fetch.
     */
    orderBy?: TabletAccountOrderByWithRelationInput | TabletAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TabletAccounts.
     */
    cursor?: TabletAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TabletAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TabletAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TabletAccounts.
     */
    distinct?: TabletAccountScalarFieldEnum | TabletAccountScalarFieldEnum[]
  }

  /**
   * TabletAccount findMany
   */
  export type TabletAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TabletAccount
     */
    select?: TabletAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TabletAccount
     */
    omit?: TabletAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TabletAccountInclude<ExtArgs> | null
    /**
     * Filter, which TabletAccounts to fetch.
     */
    where?: TabletAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TabletAccounts to fetch.
     */
    orderBy?: TabletAccountOrderByWithRelationInput | TabletAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TabletAccounts.
     */
    cursor?: TabletAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TabletAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TabletAccounts.
     */
    skip?: number
    distinct?: TabletAccountScalarFieldEnum | TabletAccountScalarFieldEnum[]
  }

  /**
   * TabletAccount create
   */
  export type TabletAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TabletAccount
     */
    select?: TabletAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TabletAccount
     */
    omit?: TabletAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TabletAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a TabletAccount.
     */
    data: XOR<TabletAccountCreateInput, TabletAccountUncheckedCreateInput>
  }

  /**
   * TabletAccount createMany
   */
  export type TabletAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TabletAccounts.
     */
    data: TabletAccountCreateManyInput | TabletAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TabletAccount createManyAndReturn
   */
  export type TabletAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TabletAccount
     */
    select?: TabletAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TabletAccount
     */
    omit?: TabletAccountOmit<ExtArgs> | null
    /**
     * The data used to create many TabletAccounts.
     */
    data: TabletAccountCreateManyInput | TabletAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TabletAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TabletAccount update
   */
  export type TabletAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TabletAccount
     */
    select?: TabletAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TabletAccount
     */
    omit?: TabletAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TabletAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a TabletAccount.
     */
    data: XOR<TabletAccountUpdateInput, TabletAccountUncheckedUpdateInput>
    /**
     * Choose, which TabletAccount to update.
     */
    where: TabletAccountWhereUniqueInput
  }

  /**
   * TabletAccount updateMany
   */
  export type TabletAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TabletAccounts.
     */
    data: XOR<TabletAccountUpdateManyMutationInput, TabletAccountUncheckedUpdateManyInput>
    /**
     * Filter which TabletAccounts to update
     */
    where?: TabletAccountWhereInput
    /**
     * Limit how many TabletAccounts to update.
     */
    limit?: number
  }

  /**
   * TabletAccount updateManyAndReturn
   */
  export type TabletAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TabletAccount
     */
    select?: TabletAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TabletAccount
     */
    omit?: TabletAccountOmit<ExtArgs> | null
    /**
     * The data used to update TabletAccounts.
     */
    data: XOR<TabletAccountUpdateManyMutationInput, TabletAccountUncheckedUpdateManyInput>
    /**
     * Filter which TabletAccounts to update
     */
    where?: TabletAccountWhereInput
    /**
     * Limit how many TabletAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TabletAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TabletAccount upsert
   */
  export type TabletAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TabletAccount
     */
    select?: TabletAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TabletAccount
     */
    omit?: TabletAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TabletAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the TabletAccount to update in case it exists.
     */
    where: TabletAccountWhereUniqueInput
    /**
     * In case the TabletAccount found by the `where` argument doesn't exist, create a new TabletAccount with this data.
     */
    create: XOR<TabletAccountCreateInput, TabletAccountUncheckedCreateInput>
    /**
     * In case the TabletAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TabletAccountUpdateInput, TabletAccountUncheckedUpdateInput>
  }

  /**
   * TabletAccount delete
   */
  export type TabletAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TabletAccount
     */
    select?: TabletAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TabletAccount
     */
    omit?: TabletAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TabletAccountInclude<ExtArgs> | null
    /**
     * Filter which TabletAccount to delete.
     */
    where: TabletAccountWhereUniqueInput
  }

  /**
   * TabletAccount deleteMany
   */
  export type TabletAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TabletAccounts to delete
     */
    where?: TabletAccountWhereInput
    /**
     * Limit how many TabletAccounts to delete.
     */
    limit?: number
  }

  /**
   * TabletAccount without action
   */
  export type TabletAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TabletAccount
     */
    select?: TabletAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TabletAccount
     */
    omit?: TabletAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TabletAccountInclude<ExtArgs> | null
  }


  /**
   * Model WhatsappAd
   */

  export type AggregateWhatsappAd = {
    _count: WhatsappAdCountAggregateOutputType | null
    _min: WhatsappAdMinAggregateOutputType | null
    _max: WhatsappAdMaxAggregateOutputType | null
  }

  export type WhatsappAdMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    targetDate: Date | null
    customerType: $Enums.AdTargetType | null
    branchId: string | null
    serviceId: string | null
    status: $Enums.AdStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type WhatsappAdMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    targetDate: Date | null
    customerType: $Enums.AdTargetType | null
    branchId: string | null
    serviceId: string | null
    status: $Enums.AdStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type WhatsappAdCountAggregateOutputType = {
    id: number
    name: number
    description: number
    imageUrl: number
    targetDate: number
    customerType: number
    branchId: number
    serviceId: number
    status: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type WhatsappAdMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    targetDate?: true
    customerType?: true
    branchId?: true
    serviceId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type WhatsappAdMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    targetDate?: true
    customerType?: true
    branchId?: true
    serviceId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type WhatsappAdCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    targetDate?: true
    customerType?: true
    branchId?: true
    serviceId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type WhatsappAdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsappAd to aggregate.
     */
    where?: WhatsappAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappAds to fetch.
     */
    orderBy?: WhatsappAdOrderByWithRelationInput | WhatsappAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsappAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsappAds
    **/
    _count?: true | WhatsappAdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsappAdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsappAdMaxAggregateInputType
  }

  export type GetWhatsappAdAggregateType<T extends WhatsappAdAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsappAd]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsappAd[P]>
      : GetScalarType<T[P], AggregateWhatsappAd[P]>
  }




  export type WhatsappAdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappAdWhereInput
    orderBy?: WhatsappAdOrderByWithAggregationInput | WhatsappAdOrderByWithAggregationInput[]
    by: WhatsappAdScalarFieldEnum[] | WhatsappAdScalarFieldEnum
    having?: WhatsappAdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsappAdCountAggregateInputType | true
    _min?: WhatsappAdMinAggregateInputType
    _max?: WhatsappAdMaxAggregateInputType
  }

  export type WhatsappAdGroupByOutputType = {
    id: string
    name: string
    description: string | null
    imageUrl: string | null
    targetDate: Date
    customerType: $Enums.AdTargetType
    branchId: string
    serviceId: string | null
    status: $Enums.AdStatus
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: WhatsappAdCountAggregateOutputType | null
    _min: WhatsappAdMinAggregateOutputType | null
    _max: WhatsappAdMaxAggregateOutputType | null
  }

  type GetWhatsappAdGroupByPayload<T extends WhatsappAdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsappAdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsappAdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsappAdGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsappAdGroupByOutputType[P]>
        }
      >
    >


  export type WhatsappAdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    targetDate?: boolean
    customerType?: boolean
    branchId?: boolean
    serviceId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    service?: boolean | WhatsappAd$serviceArgs<ExtArgs>
    assignedCustomers?: boolean | WhatsappAd$assignedCustomersArgs<ExtArgs>
    _count?: boolean | WhatsappAdCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsappAd"]>

  export type WhatsappAdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    targetDate?: boolean
    customerType?: boolean
    branchId?: boolean
    serviceId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    service?: boolean | WhatsappAd$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["whatsappAd"]>

  export type WhatsappAdSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    targetDate?: boolean
    customerType?: boolean
    branchId?: boolean
    serviceId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    service?: boolean | WhatsappAd$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["whatsappAd"]>

  export type WhatsappAdSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    targetDate?: boolean
    customerType?: boolean
    branchId?: boolean
    serviceId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type WhatsappAdOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "imageUrl" | "targetDate" | "customerType" | "branchId" | "serviceId" | "status" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["whatsappAd"]>
  export type WhatsappAdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    service?: boolean | WhatsappAd$serviceArgs<ExtArgs>
    assignedCustomers?: boolean | WhatsappAd$assignedCustomersArgs<ExtArgs>
    _count?: boolean | WhatsappAdCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsappAdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    service?: boolean | WhatsappAd$serviceArgs<ExtArgs>
  }
  export type WhatsappAdIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    service?: boolean | WhatsappAd$serviceArgs<ExtArgs>
  }

  export type $WhatsappAdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsappAd"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs> | null
      assignedCustomers: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      imageUrl: string | null
      targetDate: Date
      customerType: $Enums.AdTargetType
      branchId: string
      serviceId: string | null
      status: $Enums.AdStatus
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["whatsappAd"]>
    composites: {}
  }

  type WhatsappAdGetPayload<S extends boolean | null | undefined | WhatsappAdDefaultArgs> = $Result.GetResult<Prisma.$WhatsappAdPayload, S>

  type WhatsappAdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsappAdFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsappAdCountAggregateInputType | true
    }

  export interface WhatsappAdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsappAd'], meta: { name: 'WhatsappAd' } }
    /**
     * Find zero or one WhatsappAd that matches the filter.
     * @param {WhatsappAdFindUniqueArgs} args - Arguments to find a WhatsappAd
     * @example
     * // Get one WhatsappAd
     * const whatsappAd = await prisma.whatsappAd.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsappAdFindUniqueArgs>(args: SelectSubset<T, WhatsappAdFindUniqueArgs<ExtArgs>>): Prisma__WhatsappAdClient<$Result.GetResult<Prisma.$WhatsappAdPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsappAd that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsappAdFindUniqueOrThrowArgs} args - Arguments to find a WhatsappAd
     * @example
     * // Get one WhatsappAd
     * const whatsappAd = await prisma.whatsappAd.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsappAdFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsappAdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsappAdClient<$Result.GetResult<Prisma.$WhatsappAdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsappAd that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappAdFindFirstArgs} args - Arguments to find a WhatsappAd
     * @example
     * // Get one WhatsappAd
     * const whatsappAd = await prisma.whatsappAd.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsappAdFindFirstArgs>(args?: SelectSubset<T, WhatsappAdFindFirstArgs<ExtArgs>>): Prisma__WhatsappAdClient<$Result.GetResult<Prisma.$WhatsappAdPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsappAd that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappAdFindFirstOrThrowArgs} args - Arguments to find a WhatsappAd
     * @example
     * // Get one WhatsappAd
     * const whatsappAd = await prisma.whatsappAd.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsappAdFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsappAdFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsappAdClient<$Result.GetResult<Prisma.$WhatsappAdPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsappAds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappAdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsappAds
     * const whatsappAds = await prisma.whatsappAd.findMany()
     * 
     * // Get first 10 WhatsappAds
     * const whatsappAds = await prisma.whatsappAd.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsappAdWithIdOnly = await prisma.whatsappAd.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsappAdFindManyArgs>(args?: SelectSubset<T, WhatsappAdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappAdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsappAd.
     * @param {WhatsappAdCreateArgs} args - Arguments to create a WhatsappAd.
     * @example
     * // Create one WhatsappAd
     * const WhatsappAd = await prisma.whatsappAd.create({
     *   data: {
     *     // ... data to create a WhatsappAd
     *   }
     * })
     * 
     */
    create<T extends WhatsappAdCreateArgs>(args: SelectSubset<T, WhatsappAdCreateArgs<ExtArgs>>): Prisma__WhatsappAdClient<$Result.GetResult<Prisma.$WhatsappAdPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsappAds.
     * @param {WhatsappAdCreateManyArgs} args - Arguments to create many WhatsappAds.
     * @example
     * // Create many WhatsappAds
     * const whatsappAd = await prisma.whatsappAd.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsappAdCreateManyArgs>(args?: SelectSubset<T, WhatsappAdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsappAds and returns the data saved in the database.
     * @param {WhatsappAdCreateManyAndReturnArgs} args - Arguments to create many WhatsappAds.
     * @example
     * // Create many WhatsappAds
     * const whatsappAd = await prisma.whatsappAd.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsappAds and only return the `id`
     * const whatsappAdWithIdOnly = await prisma.whatsappAd.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsappAdCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsappAdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappAdPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsappAd.
     * @param {WhatsappAdDeleteArgs} args - Arguments to delete one WhatsappAd.
     * @example
     * // Delete one WhatsappAd
     * const WhatsappAd = await prisma.whatsappAd.delete({
     *   where: {
     *     // ... filter to delete one WhatsappAd
     *   }
     * })
     * 
     */
    delete<T extends WhatsappAdDeleteArgs>(args: SelectSubset<T, WhatsappAdDeleteArgs<ExtArgs>>): Prisma__WhatsappAdClient<$Result.GetResult<Prisma.$WhatsappAdPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsappAd.
     * @param {WhatsappAdUpdateArgs} args - Arguments to update one WhatsappAd.
     * @example
     * // Update one WhatsappAd
     * const whatsappAd = await prisma.whatsappAd.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsappAdUpdateArgs>(args: SelectSubset<T, WhatsappAdUpdateArgs<ExtArgs>>): Prisma__WhatsappAdClient<$Result.GetResult<Prisma.$WhatsappAdPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsappAds.
     * @param {WhatsappAdDeleteManyArgs} args - Arguments to filter WhatsappAds to delete.
     * @example
     * // Delete a few WhatsappAds
     * const { count } = await prisma.whatsappAd.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsappAdDeleteManyArgs>(args?: SelectSubset<T, WhatsappAdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsappAds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappAdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsappAds
     * const whatsappAd = await prisma.whatsappAd.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsappAdUpdateManyArgs>(args: SelectSubset<T, WhatsappAdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsappAds and returns the data updated in the database.
     * @param {WhatsappAdUpdateManyAndReturnArgs} args - Arguments to update many WhatsappAds.
     * @example
     * // Update many WhatsappAds
     * const whatsappAd = await prisma.whatsappAd.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsappAds and only return the `id`
     * const whatsappAdWithIdOnly = await prisma.whatsappAd.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsappAdUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsappAdUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappAdPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsappAd.
     * @param {WhatsappAdUpsertArgs} args - Arguments to update or create a WhatsappAd.
     * @example
     * // Update or create a WhatsappAd
     * const whatsappAd = await prisma.whatsappAd.upsert({
     *   create: {
     *     // ... data to create a WhatsappAd
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsappAd we want to update
     *   }
     * })
     */
    upsert<T extends WhatsappAdUpsertArgs>(args: SelectSubset<T, WhatsappAdUpsertArgs<ExtArgs>>): Prisma__WhatsappAdClient<$Result.GetResult<Prisma.$WhatsappAdPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsappAds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappAdCountArgs} args - Arguments to filter WhatsappAds to count.
     * @example
     * // Count the number of WhatsappAds
     * const count = await prisma.whatsappAd.count({
     *   where: {
     *     // ... the filter for the WhatsappAds we want to count
     *   }
     * })
    **/
    count<T extends WhatsappAdCountArgs>(
      args?: Subset<T, WhatsappAdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsappAdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsappAd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappAdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsappAdAggregateArgs>(args: Subset<T, WhatsappAdAggregateArgs>): Prisma.PrismaPromise<GetWhatsappAdAggregateType<T>>

    /**
     * Group by WhatsappAd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappAdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsappAdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsappAdGroupByArgs['orderBy'] }
        : { orderBy?: WhatsappAdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsappAdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsappAdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsappAd model
   */
  readonly fields: WhatsappAdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsappAd.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsappAdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends WhatsappAd$serviceArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappAd$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedCustomers<T extends WhatsappAd$assignedCustomersArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappAd$assignedCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsappAd model
   */
  interface WhatsappAdFieldRefs {
    readonly id: FieldRef<"WhatsappAd", 'String'>
    readonly name: FieldRef<"WhatsappAd", 'String'>
    readonly description: FieldRef<"WhatsappAd", 'String'>
    readonly imageUrl: FieldRef<"WhatsappAd", 'String'>
    readonly targetDate: FieldRef<"WhatsappAd", 'DateTime'>
    readonly customerType: FieldRef<"WhatsappAd", 'AdTargetType'>
    readonly branchId: FieldRef<"WhatsappAd", 'String'>
    readonly serviceId: FieldRef<"WhatsappAd", 'String'>
    readonly status: FieldRef<"WhatsappAd", 'AdStatus'>
    readonly createdAt: FieldRef<"WhatsappAd", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsappAd", 'DateTime'>
    readonly createdBy: FieldRef<"WhatsappAd", 'String'>
    readonly updatedBy: FieldRef<"WhatsappAd", 'String'>
    readonly isDeleted: FieldRef<"WhatsappAd", 'Boolean'>
    readonly deletedAt: FieldRef<"WhatsappAd", 'DateTime'>
    readonly deletedBy: FieldRef<"WhatsappAd", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WhatsappAd findUnique
   */
  export type WhatsappAdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappAd to fetch.
     */
    where: WhatsappAdWhereUniqueInput
  }

  /**
   * WhatsappAd findUniqueOrThrow
   */
  export type WhatsappAdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappAd to fetch.
     */
    where: WhatsappAdWhereUniqueInput
  }

  /**
   * WhatsappAd findFirst
   */
  export type WhatsappAdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappAd to fetch.
     */
    where?: WhatsappAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappAds to fetch.
     */
    orderBy?: WhatsappAdOrderByWithRelationInput | WhatsappAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsappAds.
     */
    cursor?: WhatsappAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsappAds.
     */
    distinct?: WhatsappAdScalarFieldEnum | WhatsappAdScalarFieldEnum[]
  }

  /**
   * WhatsappAd findFirstOrThrow
   */
  export type WhatsappAdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappAd to fetch.
     */
    where?: WhatsappAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappAds to fetch.
     */
    orderBy?: WhatsappAdOrderByWithRelationInput | WhatsappAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsappAds.
     */
    cursor?: WhatsappAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappAds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsappAds.
     */
    distinct?: WhatsappAdScalarFieldEnum | WhatsappAdScalarFieldEnum[]
  }

  /**
   * WhatsappAd findMany
   */
  export type WhatsappAdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappAds to fetch.
     */
    where?: WhatsappAdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappAds to fetch.
     */
    orderBy?: WhatsappAdOrderByWithRelationInput | WhatsappAdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsappAds.
     */
    cursor?: WhatsappAdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappAds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappAds.
     */
    skip?: number
    distinct?: WhatsappAdScalarFieldEnum | WhatsappAdScalarFieldEnum[]
  }

  /**
   * WhatsappAd create
   */
  export type WhatsappAdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsappAd.
     */
    data: XOR<WhatsappAdCreateInput, WhatsappAdUncheckedCreateInput>
  }

  /**
   * WhatsappAd createMany
   */
  export type WhatsappAdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsappAds.
     */
    data: WhatsappAdCreateManyInput | WhatsappAdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsappAd createManyAndReturn
   */
  export type WhatsappAdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsappAds.
     */
    data: WhatsappAdCreateManyInput | WhatsappAdCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsappAd update
   */
  export type WhatsappAdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsappAd.
     */
    data: XOR<WhatsappAdUpdateInput, WhatsappAdUncheckedUpdateInput>
    /**
     * Choose, which WhatsappAd to update.
     */
    where: WhatsappAdWhereUniqueInput
  }

  /**
   * WhatsappAd updateMany
   */
  export type WhatsappAdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsappAds.
     */
    data: XOR<WhatsappAdUpdateManyMutationInput, WhatsappAdUncheckedUpdateManyInput>
    /**
     * Filter which WhatsappAds to update
     */
    where?: WhatsappAdWhereInput
    /**
     * Limit how many WhatsappAds to update.
     */
    limit?: number
  }

  /**
   * WhatsappAd updateManyAndReturn
   */
  export type WhatsappAdUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * The data used to update WhatsappAds.
     */
    data: XOR<WhatsappAdUpdateManyMutationInput, WhatsappAdUncheckedUpdateManyInput>
    /**
     * Filter which WhatsappAds to update
     */
    where?: WhatsappAdWhereInput
    /**
     * Limit how many WhatsappAds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsappAd upsert
   */
  export type WhatsappAdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsappAd to update in case it exists.
     */
    where: WhatsappAdWhereUniqueInput
    /**
     * In case the WhatsappAd found by the `where` argument doesn't exist, create a new WhatsappAd with this data.
     */
    create: XOR<WhatsappAdCreateInput, WhatsappAdUncheckedCreateInput>
    /**
     * In case the WhatsappAd was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsappAdUpdateInput, WhatsappAdUncheckedUpdateInput>
  }

  /**
   * WhatsappAd delete
   */
  export type WhatsappAdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdInclude<ExtArgs> | null
    /**
     * Filter which WhatsappAd to delete.
     */
    where: WhatsappAdWhereUniqueInput
  }

  /**
   * WhatsappAd deleteMany
   */
  export type WhatsappAdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsappAds to delete
     */
    where?: WhatsappAdWhereInput
    /**
     * Limit how many WhatsappAds to delete.
     */
    limit?: number
  }

  /**
   * WhatsappAd.service
   */
  export type WhatsappAd$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * WhatsappAd.assignedCustomers
   */
  export type WhatsappAd$assignedCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * WhatsappAd without action
   */
  export type WhatsappAdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappAd
     */
    select?: WhatsappAdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappAd
     */
    omit?: WhatsappAdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappAdInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppNumber
   */

  export type AggregateWhatsAppNumber = {
    _count: WhatsAppNumberCountAggregateOutputType | null
    _avg: WhatsAppNumberAvgAggregateOutputType | null
    _sum: WhatsAppNumberSumAggregateOutputType | null
    _min: WhatsAppNumberMinAggregateOutputType | null
    _max: WhatsAppNumberMaxAggregateOutputType | null
  }

  export type WhatsAppNumberAvgAggregateOutputType = {
    otp: number | null
  }

  export type WhatsAppNumberSumAggregateOutputType = {
    otp: number | null
  }

  export type WhatsAppNumberMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    phoneNumber: string | null
    phoneNumberId: string | null
    wabaId: string | null
    accessToken: string | null
    isVerified: boolean | null
    defaultFlowId: string | null
    otp: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type WhatsAppNumberMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    phoneNumber: string | null
    phoneNumberId: string | null
    wabaId: string | null
    accessToken: string | null
    isVerified: boolean | null
    defaultFlowId: string | null
    otp: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type WhatsAppNumberCountAggregateOutputType = {
    id: number
    businessId: number
    phoneNumber: number
    phoneNumberId: number
    wabaId: number
    accessToken: number
    isVerified: number
    defaultFlowId: number
    otp: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    _all: number
  }


  export type WhatsAppNumberAvgAggregateInputType = {
    otp?: true
  }

  export type WhatsAppNumberSumAggregateInputType = {
    otp?: true
  }

  export type WhatsAppNumberMinAggregateInputType = {
    id?: true
    businessId?: true
    phoneNumber?: true
    phoneNumberId?: true
    wabaId?: true
    accessToken?: true
    isVerified?: true
    defaultFlowId?: true
    otp?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type WhatsAppNumberMaxAggregateInputType = {
    id?: true
    businessId?: true
    phoneNumber?: true
    phoneNumberId?: true
    wabaId?: true
    accessToken?: true
    isVerified?: true
    defaultFlowId?: true
    otp?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type WhatsAppNumberCountAggregateInputType = {
    id?: true
    businessId?: true
    phoneNumber?: true
    phoneNumberId?: true
    wabaId?: true
    accessToken?: true
    isVerified?: true
    defaultFlowId?: true
    otp?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type WhatsAppNumberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppNumber to aggregate.
     */
    where?: WhatsAppNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppNumbers to fetch.
     */
    orderBy?: WhatsAppNumberOrderByWithRelationInput | WhatsAppNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppNumbers
    **/
    _count?: true | WhatsAppNumberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsAppNumberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsAppNumberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppNumberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppNumberMaxAggregateInputType
  }

  export type GetWhatsAppNumberAggregateType<T extends WhatsAppNumberAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppNumber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppNumber[P]>
      : GetScalarType<T[P], AggregateWhatsAppNumber[P]>
  }




  export type WhatsAppNumberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppNumberWhereInput
    orderBy?: WhatsAppNumberOrderByWithAggregationInput | WhatsAppNumberOrderByWithAggregationInput[]
    by: WhatsAppNumberScalarFieldEnum[] | WhatsAppNumberScalarFieldEnum
    having?: WhatsAppNumberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppNumberCountAggregateInputType | true
    _avg?: WhatsAppNumberAvgAggregateInputType
    _sum?: WhatsAppNumberSumAggregateInputType
    _min?: WhatsAppNumberMinAggregateInputType
    _max?: WhatsAppNumberMaxAggregateInputType
  }

  export type WhatsAppNumberGroupByOutputType = {
    id: string
    businessId: string
    phoneNumber: string
    phoneNumberId: string | null
    wabaId: string | null
    accessToken: string | null
    isVerified: boolean
    defaultFlowId: string | null
    otp: number | null
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    _count: WhatsAppNumberCountAggregateOutputType | null
    _avg: WhatsAppNumberAvgAggregateOutputType | null
    _sum: WhatsAppNumberSumAggregateOutputType | null
    _min: WhatsAppNumberMinAggregateOutputType | null
    _max: WhatsAppNumberMaxAggregateOutputType | null
  }

  type GetWhatsAppNumberGroupByPayload<T extends WhatsAppNumberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppNumberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppNumberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppNumberGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppNumberGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppNumberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    phoneNumber?: boolean
    phoneNumberId?: boolean
    wabaId?: boolean
    accessToken?: boolean
    isVerified?: boolean
    defaultFlowId?: boolean
    otp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    defaultFlow?: boolean | WhatsAppNumber$defaultFlowArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppNumber"]>

  export type WhatsAppNumberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    phoneNumber?: boolean
    phoneNumberId?: boolean
    wabaId?: boolean
    accessToken?: boolean
    isVerified?: boolean
    defaultFlowId?: boolean
    otp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    defaultFlow?: boolean | WhatsAppNumber$defaultFlowArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppNumber"]>

  export type WhatsAppNumberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    phoneNumber?: boolean
    phoneNumberId?: boolean
    wabaId?: boolean
    accessToken?: boolean
    isVerified?: boolean
    defaultFlowId?: boolean
    otp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    defaultFlow?: boolean | WhatsAppNumber$defaultFlowArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppNumber"]>

  export type WhatsAppNumberSelectScalar = {
    id?: boolean
    businessId?: boolean
    phoneNumber?: boolean
    phoneNumberId?: boolean
    wabaId?: boolean
    accessToken?: boolean
    isVerified?: boolean
    defaultFlowId?: boolean
    otp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }

  export type WhatsAppNumberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessId" | "phoneNumber" | "phoneNumberId" | "wabaId" | "accessToken" | "isVerified" | "defaultFlowId" | "otp" | "createdAt" | "updatedAt" | "isDeleted", ExtArgs["result"]["whatsAppNumber"]>
  export type WhatsAppNumberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    defaultFlow?: boolean | WhatsAppNumber$defaultFlowArgs<ExtArgs>
  }
  export type WhatsAppNumberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    defaultFlow?: boolean | WhatsAppNumber$defaultFlowArgs<ExtArgs>
  }
  export type WhatsAppNumberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    defaultFlow?: boolean | WhatsAppNumber$defaultFlowArgs<ExtArgs>
  }

  export type $WhatsAppNumberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppNumber"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
      defaultFlow: Prisma.$FlowPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      phoneNumber: string
      phoneNumberId: string | null
      wabaId: string | null
      accessToken: string | null
      isVerified: boolean
      defaultFlowId: string | null
      otp: number | null
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["whatsAppNumber"]>
    composites: {}
  }

  type WhatsAppNumberGetPayload<S extends boolean | null | undefined | WhatsAppNumberDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppNumberPayload, S>

  type WhatsAppNumberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppNumberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppNumberCountAggregateInputType | true
    }

  export interface WhatsAppNumberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppNumber'], meta: { name: 'WhatsAppNumber' } }
    /**
     * Find zero or one WhatsAppNumber that matches the filter.
     * @param {WhatsAppNumberFindUniqueArgs} args - Arguments to find a WhatsAppNumber
     * @example
     * // Get one WhatsAppNumber
     * const whatsAppNumber = await prisma.whatsAppNumber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppNumberFindUniqueArgs>(args: SelectSubset<T, WhatsAppNumberFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppNumberClient<$Result.GetResult<Prisma.$WhatsAppNumberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppNumber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppNumberFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppNumber
     * @example
     * // Get one WhatsAppNumber
     * const whatsAppNumber = await prisma.whatsAppNumber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppNumberFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppNumberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppNumberClient<$Result.GetResult<Prisma.$WhatsAppNumberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppNumber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppNumberFindFirstArgs} args - Arguments to find a WhatsAppNumber
     * @example
     * // Get one WhatsAppNumber
     * const whatsAppNumber = await prisma.whatsAppNumber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppNumberFindFirstArgs>(args?: SelectSubset<T, WhatsAppNumberFindFirstArgs<ExtArgs>>): Prisma__WhatsAppNumberClient<$Result.GetResult<Prisma.$WhatsAppNumberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppNumber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppNumberFindFirstOrThrowArgs} args - Arguments to find a WhatsAppNumber
     * @example
     * // Get one WhatsAppNumber
     * const whatsAppNumber = await prisma.whatsAppNumber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppNumberFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppNumberFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppNumberClient<$Result.GetResult<Prisma.$WhatsAppNumberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppNumbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppNumberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppNumbers
     * const whatsAppNumbers = await prisma.whatsAppNumber.findMany()
     * 
     * // Get first 10 WhatsAppNumbers
     * const whatsAppNumbers = await prisma.whatsAppNumber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppNumberWithIdOnly = await prisma.whatsAppNumber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppNumberFindManyArgs>(args?: SelectSubset<T, WhatsAppNumberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppNumberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppNumber.
     * @param {WhatsAppNumberCreateArgs} args - Arguments to create a WhatsAppNumber.
     * @example
     * // Create one WhatsAppNumber
     * const WhatsAppNumber = await prisma.whatsAppNumber.create({
     *   data: {
     *     // ... data to create a WhatsAppNumber
     *   }
     * })
     * 
     */
    create<T extends WhatsAppNumberCreateArgs>(args: SelectSubset<T, WhatsAppNumberCreateArgs<ExtArgs>>): Prisma__WhatsAppNumberClient<$Result.GetResult<Prisma.$WhatsAppNumberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppNumbers.
     * @param {WhatsAppNumberCreateManyArgs} args - Arguments to create many WhatsAppNumbers.
     * @example
     * // Create many WhatsAppNumbers
     * const whatsAppNumber = await prisma.whatsAppNumber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppNumberCreateManyArgs>(args?: SelectSubset<T, WhatsAppNumberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppNumbers and returns the data saved in the database.
     * @param {WhatsAppNumberCreateManyAndReturnArgs} args - Arguments to create many WhatsAppNumbers.
     * @example
     * // Create many WhatsAppNumbers
     * const whatsAppNumber = await prisma.whatsAppNumber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppNumbers and only return the `id`
     * const whatsAppNumberWithIdOnly = await prisma.whatsAppNumber.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppNumberCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppNumberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppNumberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppNumber.
     * @param {WhatsAppNumberDeleteArgs} args - Arguments to delete one WhatsAppNumber.
     * @example
     * // Delete one WhatsAppNumber
     * const WhatsAppNumber = await prisma.whatsAppNumber.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppNumber
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppNumberDeleteArgs>(args: SelectSubset<T, WhatsAppNumberDeleteArgs<ExtArgs>>): Prisma__WhatsAppNumberClient<$Result.GetResult<Prisma.$WhatsAppNumberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppNumber.
     * @param {WhatsAppNumberUpdateArgs} args - Arguments to update one WhatsAppNumber.
     * @example
     * // Update one WhatsAppNumber
     * const whatsAppNumber = await prisma.whatsAppNumber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppNumberUpdateArgs>(args: SelectSubset<T, WhatsAppNumberUpdateArgs<ExtArgs>>): Prisma__WhatsAppNumberClient<$Result.GetResult<Prisma.$WhatsAppNumberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppNumbers.
     * @param {WhatsAppNumberDeleteManyArgs} args - Arguments to filter WhatsAppNumbers to delete.
     * @example
     * // Delete a few WhatsAppNumbers
     * const { count } = await prisma.whatsAppNumber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppNumberDeleteManyArgs>(args?: SelectSubset<T, WhatsAppNumberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppNumberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppNumbers
     * const whatsAppNumber = await prisma.whatsAppNumber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppNumberUpdateManyArgs>(args: SelectSubset<T, WhatsAppNumberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppNumbers and returns the data updated in the database.
     * @param {WhatsAppNumberUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppNumbers.
     * @example
     * // Update many WhatsAppNumbers
     * const whatsAppNumber = await prisma.whatsAppNumber.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppNumbers and only return the `id`
     * const whatsAppNumberWithIdOnly = await prisma.whatsAppNumber.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppNumberUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppNumberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppNumberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppNumber.
     * @param {WhatsAppNumberUpsertArgs} args - Arguments to update or create a WhatsAppNumber.
     * @example
     * // Update or create a WhatsAppNumber
     * const whatsAppNumber = await prisma.whatsAppNumber.upsert({
     *   create: {
     *     // ... data to create a WhatsAppNumber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppNumber we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppNumberUpsertArgs>(args: SelectSubset<T, WhatsAppNumberUpsertArgs<ExtArgs>>): Prisma__WhatsAppNumberClient<$Result.GetResult<Prisma.$WhatsAppNumberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppNumberCountArgs} args - Arguments to filter WhatsAppNumbers to count.
     * @example
     * // Count the number of WhatsAppNumbers
     * const count = await prisma.whatsAppNumber.count({
     *   where: {
     *     // ... the filter for the WhatsAppNumbers we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppNumberCountArgs>(
      args?: Subset<T, WhatsAppNumberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppNumberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppNumberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppNumberAggregateArgs>(args: Subset<T, WhatsAppNumberAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppNumberAggregateType<T>>

    /**
     * Group by WhatsAppNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppNumberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppNumberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppNumberGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppNumberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppNumberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppNumberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppNumber model
   */
  readonly fields: WhatsAppNumberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppNumber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppNumberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    defaultFlow<T extends WhatsAppNumber$defaultFlowArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppNumber$defaultFlowArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppNumber model
   */
  interface WhatsAppNumberFieldRefs {
    readonly id: FieldRef<"WhatsAppNumber", 'String'>
    readonly businessId: FieldRef<"WhatsAppNumber", 'String'>
    readonly phoneNumber: FieldRef<"WhatsAppNumber", 'String'>
    readonly phoneNumberId: FieldRef<"WhatsAppNumber", 'String'>
    readonly wabaId: FieldRef<"WhatsAppNumber", 'String'>
    readonly accessToken: FieldRef<"WhatsAppNumber", 'String'>
    readonly isVerified: FieldRef<"WhatsAppNumber", 'Boolean'>
    readonly defaultFlowId: FieldRef<"WhatsAppNumber", 'String'>
    readonly otp: FieldRef<"WhatsAppNumber", 'Int'>
    readonly createdAt: FieldRef<"WhatsAppNumber", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppNumber", 'DateTime'>
    readonly isDeleted: FieldRef<"WhatsAppNumber", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppNumber findUnique
   */
  export type WhatsAppNumberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppNumber
     */
    select?: WhatsAppNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppNumber
     */
    omit?: WhatsAppNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppNumberInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppNumber to fetch.
     */
    where: WhatsAppNumberWhereUniqueInput
  }

  /**
   * WhatsAppNumber findUniqueOrThrow
   */
  export type WhatsAppNumberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppNumber
     */
    select?: WhatsAppNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppNumber
     */
    omit?: WhatsAppNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppNumberInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppNumber to fetch.
     */
    where: WhatsAppNumberWhereUniqueInput
  }

  /**
   * WhatsAppNumber findFirst
   */
  export type WhatsAppNumberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppNumber
     */
    select?: WhatsAppNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppNumber
     */
    omit?: WhatsAppNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppNumberInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppNumber to fetch.
     */
    where?: WhatsAppNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppNumbers to fetch.
     */
    orderBy?: WhatsAppNumberOrderByWithRelationInput | WhatsAppNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppNumbers.
     */
    cursor?: WhatsAppNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppNumbers.
     */
    distinct?: WhatsAppNumberScalarFieldEnum | WhatsAppNumberScalarFieldEnum[]
  }

  /**
   * WhatsAppNumber findFirstOrThrow
   */
  export type WhatsAppNumberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppNumber
     */
    select?: WhatsAppNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppNumber
     */
    omit?: WhatsAppNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppNumberInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppNumber to fetch.
     */
    where?: WhatsAppNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppNumbers to fetch.
     */
    orderBy?: WhatsAppNumberOrderByWithRelationInput | WhatsAppNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppNumbers.
     */
    cursor?: WhatsAppNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppNumbers.
     */
    distinct?: WhatsAppNumberScalarFieldEnum | WhatsAppNumberScalarFieldEnum[]
  }

  /**
   * WhatsAppNumber findMany
   */
  export type WhatsAppNumberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppNumber
     */
    select?: WhatsAppNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppNumber
     */
    omit?: WhatsAppNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppNumberInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppNumbers to fetch.
     */
    where?: WhatsAppNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppNumbers to fetch.
     */
    orderBy?: WhatsAppNumberOrderByWithRelationInput | WhatsAppNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppNumbers.
     */
    cursor?: WhatsAppNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppNumbers.
     */
    skip?: number
    distinct?: WhatsAppNumberScalarFieldEnum | WhatsAppNumberScalarFieldEnum[]
  }

  /**
   * WhatsAppNumber create
   */
  export type WhatsAppNumberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppNumber
     */
    select?: WhatsAppNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppNumber
     */
    omit?: WhatsAppNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppNumberInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppNumber.
     */
    data: XOR<WhatsAppNumberCreateInput, WhatsAppNumberUncheckedCreateInput>
  }

  /**
   * WhatsAppNumber createMany
   */
  export type WhatsAppNumberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppNumbers.
     */
    data: WhatsAppNumberCreateManyInput | WhatsAppNumberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppNumber createManyAndReturn
   */
  export type WhatsAppNumberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppNumber
     */
    select?: WhatsAppNumberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppNumber
     */
    omit?: WhatsAppNumberOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppNumbers.
     */
    data: WhatsAppNumberCreateManyInput | WhatsAppNumberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppNumberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppNumber update
   */
  export type WhatsAppNumberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppNumber
     */
    select?: WhatsAppNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppNumber
     */
    omit?: WhatsAppNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppNumberInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppNumber.
     */
    data: XOR<WhatsAppNumberUpdateInput, WhatsAppNumberUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppNumber to update.
     */
    where: WhatsAppNumberWhereUniqueInput
  }

  /**
   * WhatsAppNumber updateMany
   */
  export type WhatsAppNumberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppNumbers.
     */
    data: XOR<WhatsAppNumberUpdateManyMutationInput, WhatsAppNumberUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppNumbers to update
     */
    where?: WhatsAppNumberWhereInput
    /**
     * Limit how many WhatsAppNumbers to update.
     */
    limit?: number
  }

  /**
   * WhatsAppNumber updateManyAndReturn
   */
  export type WhatsAppNumberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppNumber
     */
    select?: WhatsAppNumberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppNumber
     */
    omit?: WhatsAppNumberOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppNumbers.
     */
    data: XOR<WhatsAppNumberUpdateManyMutationInput, WhatsAppNumberUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppNumbers to update
     */
    where?: WhatsAppNumberWhereInput
    /**
     * Limit how many WhatsAppNumbers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppNumberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppNumber upsert
   */
  export type WhatsAppNumberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppNumber
     */
    select?: WhatsAppNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppNumber
     */
    omit?: WhatsAppNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppNumberInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppNumber to update in case it exists.
     */
    where: WhatsAppNumberWhereUniqueInput
    /**
     * In case the WhatsAppNumber found by the `where` argument doesn't exist, create a new WhatsAppNumber with this data.
     */
    create: XOR<WhatsAppNumberCreateInput, WhatsAppNumberUncheckedCreateInput>
    /**
     * In case the WhatsAppNumber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppNumberUpdateInput, WhatsAppNumberUncheckedUpdateInput>
  }

  /**
   * WhatsAppNumber delete
   */
  export type WhatsAppNumberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppNumber
     */
    select?: WhatsAppNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppNumber
     */
    omit?: WhatsAppNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppNumberInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppNumber to delete.
     */
    where: WhatsAppNumberWhereUniqueInput
  }

  /**
   * WhatsAppNumber deleteMany
   */
  export type WhatsAppNumberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppNumbers to delete
     */
    where?: WhatsAppNumberWhereInput
    /**
     * Limit how many WhatsAppNumbers to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppNumber.defaultFlow
   */
  export type WhatsAppNumber$defaultFlowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    where?: FlowWhereInput
  }

  /**
   * WhatsAppNumber without action
   */
  export type WhatsAppNumberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppNumber
     */
    select?: WhatsAppNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppNumber
     */
    omit?: WhatsAppNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppNumberInclude<ExtArgs> | null
  }


  /**
   * Model Flow
   */

  export type AggregateFlow = {
    _count: FlowCountAggregateOutputType | null
    _min: FlowMinAggregateOutputType | null
    _max: FlowMaxAggregateOutputType | null
  }

  export type FlowMinAggregateOutputType = {
    id: string | null
    name: string | null
    isActive: boolean | null
    businessId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    DeletedBy: string | null
    DeletedAt: Date | null
    isDeleted: boolean | null
  }

  export type FlowMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isActive: boolean | null
    businessId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    DeletedBy: string | null
    DeletedAt: Date | null
    isDeleted: boolean | null
  }

  export type FlowCountAggregateOutputType = {
    id: number
    name: number
    isActive: number
    businessId: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    DeletedBy: number
    DeletedAt: number
    isDeleted: number
    _all: number
  }


  export type FlowMinAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    DeletedBy?: true
    DeletedAt?: true
    isDeleted?: true
  }

  export type FlowMaxAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    DeletedBy?: true
    DeletedAt?: true
    isDeleted?: true
  }

  export type FlowCountAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    DeletedBy?: true
    DeletedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type FlowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flow to aggregate.
     */
    where?: FlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flows to fetch.
     */
    orderBy?: FlowOrderByWithRelationInput | FlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Flows
    **/
    _count?: true | FlowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlowMaxAggregateInputType
  }

  export type GetFlowAggregateType<T extends FlowAggregateArgs> = {
        [P in keyof T & keyof AggregateFlow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlow[P]>
      : GetScalarType<T[P], AggregateFlow[P]>
  }




  export type FlowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowWhereInput
    orderBy?: FlowOrderByWithAggregationInput | FlowOrderByWithAggregationInput[]
    by: FlowScalarFieldEnum[] | FlowScalarFieldEnum
    having?: FlowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlowCountAggregateInputType | true
    _min?: FlowMinAggregateInputType
    _max?: FlowMaxAggregateInputType
  }

  export type FlowGroupByOutputType = {
    id: string
    name: string
    isActive: boolean
    businessId: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string | null
    DeletedBy: string | null
    DeletedAt: Date | null
    isDeleted: boolean
    _count: FlowCountAggregateOutputType | null
    _min: FlowMinAggregateOutputType | null
    _max: FlowMaxAggregateOutputType | null
  }

  type GetFlowGroupByPayload<T extends FlowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlowGroupByOutputType[P]>
            : GetScalarType<T[P], FlowGroupByOutputType[P]>
        }
      >
    >


  export type FlowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
    business?: boolean | Flow$businessArgs<ExtArgs>
    steps?: boolean | Flow$stepsArgs<ExtArgs>
    sessions?: boolean | Flow$sessionsArgs<ExtArgs>
    whatsappNumbers?: boolean | Flow$whatsappNumbersArgs<ExtArgs>
    _count?: boolean | FlowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flow"]>

  export type FlowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
    business?: boolean | Flow$businessArgs<ExtArgs>
  }, ExtArgs["result"]["flow"]>

  export type FlowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
    business?: boolean | Flow$businessArgs<ExtArgs>
  }, ExtArgs["result"]["flow"]>

  export type FlowSelectScalar = {
    id?: boolean
    name?: boolean
    isActive?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
  }

  export type FlowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isActive" | "businessId" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "DeletedBy" | "DeletedAt" | "isDeleted", ExtArgs["result"]["flow"]>
  export type FlowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | Flow$businessArgs<ExtArgs>
    steps?: boolean | Flow$stepsArgs<ExtArgs>
    sessions?: boolean | Flow$sessionsArgs<ExtArgs>
    whatsappNumbers?: boolean | Flow$whatsappNumbersArgs<ExtArgs>
    _count?: boolean | FlowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FlowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | Flow$businessArgs<ExtArgs>
  }
  export type FlowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | Flow$businessArgs<ExtArgs>
  }

  export type $FlowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Flow"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs> | null
      steps: Prisma.$StepPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      whatsappNumbers: Prisma.$WhatsAppNumberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      isActive: boolean
      businessId: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string | null
      DeletedBy: string | null
      DeletedAt: Date | null
      isDeleted: boolean
    }, ExtArgs["result"]["flow"]>
    composites: {}
  }

  type FlowGetPayload<S extends boolean | null | undefined | FlowDefaultArgs> = $Result.GetResult<Prisma.$FlowPayload, S>

  type FlowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlowCountAggregateInputType | true
    }

  export interface FlowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Flow'], meta: { name: 'Flow' } }
    /**
     * Find zero or one Flow that matches the filter.
     * @param {FlowFindUniqueArgs} args - Arguments to find a Flow
     * @example
     * // Get one Flow
     * const flow = await prisma.flow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlowFindUniqueArgs>(args: SelectSubset<T, FlowFindUniqueArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Flow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlowFindUniqueOrThrowArgs} args - Arguments to find a Flow
     * @example
     * // Get one Flow
     * const flow = await prisma.flow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlowFindUniqueOrThrowArgs>(args: SelectSubset<T, FlowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowFindFirstArgs} args - Arguments to find a Flow
     * @example
     * // Get one Flow
     * const flow = await prisma.flow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlowFindFirstArgs>(args?: SelectSubset<T, FlowFindFirstArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowFindFirstOrThrowArgs} args - Arguments to find a Flow
     * @example
     * // Get one Flow
     * const flow = await prisma.flow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlowFindFirstOrThrowArgs>(args?: SelectSubset<T, FlowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Flows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flows
     * const flows = await prisma.flow.findMany()
     * 
     * // Get first 10 Flows
     * const flows = await prisma.flow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flowWithIdOnly = await prisma.flow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlowFindManyArgs>(args?: SelectSubset<T, FlowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Flow.
     * @param {FlowCreateArgs} args - Arguments to create a Flow.
     * @example
     * // Create one Flow
     * const Flow = await prisma.flow.create({
     *   data: {
     *     // ... data to create a Flow
     *   }
     * })
     * 
     */
    create<T extends FlowCreateArgs>(args: SelectSubset<T, FlowCreateArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Flows.
     * @param {FlowCreateManyArgs} args - Arguments to create many Flows.
     * @example
     * // Create many Flows
     * const flow = await prisma.flow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlowCreateManyArgs>(args?: SelectSubset<T, FlowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Flows and returns the data saved in the database.
     * @param {FlowCreateManyAndReturnArgs} args - Arguments to create many Flows.
     * @example
     * // Create many Flows
     * const flow = await prisma.flow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Flows and only return the `id`
     * const flowWithIdOnly = await prisma.flow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlowCreateManyAndReturnArgs>(args?: SelectSubset<T, FlowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Flow.
     * @param {FlowDeleteArgs} args - Arguments to delete one Flow.
     * @example
     * // Delete one Flow
     * const Flow = await prisma.flow.delete({
     *   where: {
     *     // ... filter to delete one Flow
     *   }
     * })
     * 
     */
    delete<T extends FlowDeleteArgs>(args: SelectSubset<T, FlowDeleteArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Flow.
     * @param {FlowUpdateArgs} args - Arguments to update one Flow.
     * @example
     * // Update one Flow
     * const flow = await prisma.flow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlowUpdateArgs>(args: SelectSubset<T, FlowUpdateArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Flows.
     * @param {FlowDeleteManyArgs} args - Arguments to filter Flows to delete.
     * @example
     * // Delete a few Flows
     * const { count } = await prisma.flow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlowDeleteManyArgs>(args?: SelectSubset<T, FlowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flows
     * const flow = await prisma.flow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlowUpdateManyArgs>(args: SelectSubset<T, FlowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flows and returns the data updated in the database.
     * @param {FlowUpdateManyAndReturnArgs} args - Arguments to update many Flows.
     * @example
     * // Update many Flows
     * const flow = await prisma.flow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Flows and only return the `id`
     * const flowWithIdOnly = await prisma.flow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlowUpdateManyAndReturnArgs>(args: SelectSubset<T, FlowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Flow.
     * @param {FlowUpsertArgs} args - Arguments to update or create a Flow.
     * @example
     * // Update or create a Flow
     * const flow = await prisma.flow.upsert({
     *   create: {
     *     // ... data to create a Flow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flow we want to update
     *   }
     * })
     */
    upsert<T extends FlowUpsertArgs>(args: SelectSubset<T, FlowUpsertArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Flows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowCountArgs} args - Arguments to filter Flows to count.
     * @example
     * // Count the number of Flows
     * const count = await prisma.flow.count({
     *   where: {
     *     // ... the filter for the Flows we want to count
     *   }
     * })
    **/
    count<T extends FlowCountArgs>(
      args?: Subset<T, FlowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlowAggregateArgs>(args: Subset<T, FlowAggregateArgs>): Prisma.PrismaPromise<GetFlowAggregateType<T>>

    /**
     * Group by Flow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlowGroupByArgs['orderBy'] }
        : { orderBy?: FlowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Flow model
   */
  readonly fields: FlowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Flow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends Flow$businessArgs<ExtArgs> = {}>(args?: Subset<T, Flow$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    steps<T extends Flow$stepsArgs<ExtArgs> = {}>(args?: Subset<T, Flow$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends Flow$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Flow$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappNumbers<T extends Flow$whatsappNumbersArgs<ExtArgs> = {}>(args?: Subset<T, Flow$whatsappNumbersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppNumberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Flow model
   */
  interface FlowFieldRefs {
    readonly id: FieldRef<"Flow", 'String'>
    readonly name: FieldRef<"Flow", 'String'>
    readonly isActive: FieldRef<"Flow", 'Boolean'>
    readonly businessId: FieldRef<"Flow", 'String'>
    readonly createdAt: FieldRef<"Flow", 'DateTime'>
    readonly updatedAt: FieldRef<"Flow", 'DateTime'>
    readonly createdBy: FieldRef<"Flow", 'String'>
    readonly updatedBy: FieldRef<"Flow", 'String'>
    readonly DeletedBy: FieldRef<"Flow", 'String'>
    readonly DeletedAt: FieldRef<"Flow", 'DateTime'>
    readonly isDeleted: FieldRef<"Flow", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Flow findUnique
   */
  export type FlowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * Filter, which Flow to fetch.
     */
    where: FlowWhereUniqueInput
  }

  /**
   * Flow findUniqueOrThrow
   */
  export type FlowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * Filter, which Flow to fetch.
     */
    where: FlowWhereUniqueInput
  }

  /**
   * Flow findFirst
   */
  export type FlowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * Filter, which Flow to fetch.
     */
    where?: FlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flows to fetch.
     */
    orderBy?: FlowOrderByWithRelationInput | FlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flows.
     */
    cursor?: FlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flows.
     */
    distinct?: FlowScalarFieldEnum | FlowScalarFieldEnum[]
  }

  /**
   * Flow findFirstOrThrow
   */
  export type FlowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * Filter, which Flow to fetch.
     */
    where?: FlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flows to fetch.
     */
    orderBy?: FlowOrderByWithRelationInput | FlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flows.
     */
    cursor?: FlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flows.
     */
    distinct?: FlowScalarFieldEnum | FlowScalarFieldEnum[]
  }

  /**
   * Flow findMany
   */
  export type FlowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * Filter, which Flows to fetch.
     */
    where?: FlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flows to fetch.
     */
    orderBy?: FlowOrderByWithRelationInput | FlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Flows.
     */
    cursor?: FlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flows.
     */
    skip?: number
    distinct?: FlowScalarFieldEnum | FlowScalarFieldEnum[]
  }

  /**
   * Flow create
   */
  export type FlowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * The data needed to create a Flow.
     */
    data: XOR<FlowCreateInput, FlowUncheckedCreateInput>
  }

  /**
   * Flow createMany
   */
  export type FlowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Flows.
     */
    data: FlowCreateManyInput | FlowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Flow createManyAndReturn
   */
  export type FlowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * The data used to create many Flows.
     */
    data: FlowCreateManyInput | FlowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flow update
   */
  export type FlowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * The data needed to update a Flow.
     */
    data: XOR<FlowUpdateInput, FlowUncheckedUpdateInput>
    /**
     * Choose, which Flow to update.
     */
    where: FlowWhereUniqueInput
  }

  /**
   * Flow updateMany
   */
  export type FlowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Flows.
     */
    data: XOR<FlowUpdateManyMutationInput, FlowUncheckedUpdateManyInput>
    /**
     * Filter which Flows to update
     */
    where?: FlowWhereInput
    /**
     * Limit how many Flows to update.
     */
    limit?: number
  }

  /**
   * Flow updateManyAndReturn
   */
  export type FlowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * The data used to update Flows.
     */
    data: XOR<FlowUpdateManyMutationInput, FlowUncheckedUpdateManyInput>
    /**
     * Filter which Flows to update
     */
    where?: FlowWhereInput
    /**
     * Limit how many Flows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flow upsert
   */
  export type FlowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * The filter to search for the Flow to update in case it exists.
     */
    where: FlowWhereUniqueInput
    /**
     * In case the Flow found by the `where` argument doesn't exist, create a new Flow with this data.
     */
    create: XOR<FlowCreateInput, FlowUncheckedCreateInput>
    /**
     * In case the Flow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlowUpdateInput, FlowUncheckedUpdateInput>
  }

  /**
   * Flow delete
   */
  export type FlowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
    /**
     * Filter which Flow to delete.
     */
    where: FlowWhereUniqueInput
  }

  /**
   * Flow deleteMany
   */
  export type FlowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flows to delete
     */
    where?: FlowWhereInput
    /**
     * Limit how many Flows to delete.
     */
    limit?: number
  }

  /**
   * Flow.business
   */
  export type Flow$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * Flow.steps
   */
  export type Flow$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepInclude<ExtArgs> | null
    where?: StepWhereInput
    orderBy?: StepOrderByWithRelationInput | StepOrderByWithRelationInput[]
    cursor?: StepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StepScalarFieldEnum | StepScalarFieldEnum[]
  }

  /**
   * Flow.sessions
   */
  export type Flow$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Flow.whatsappNumbers
   */
  export type Flow$whatsappNumbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppNumber
     */
    select?: WhatsAppNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppNumber
     */
    omit?: WhatsAppNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppNumberInclude<ExtArgs> | null
    where?: WhatsAppNumberWhereInput
    orderBy?: WhatsAppNumberOrderByWithRelationInput | WhatsAppNumberOrderByWithRelationInput[]
    cursor?: WhatsAppNumberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppNumberScalarFieldEnum | WhatsAppNumberScalarFieldEnum[]
  }

  /**
   * Flow without action
   */
  export type FlowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow
     */
    select?: FlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flow
     */
    omit?: FlowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowInclude<ExtArgs> | null
  }


  /**
   * Model Step
   */

  export type AggregateStep = {
    _count: StepCountAggregateOutputType | null
    _avg: StepAvgAggregateOutputType | null
    _sum: StepSumAggregateOutputType | null
    _min: StepMinAggregateOutputType | null
    _max: StepMaxAggregateOutputType | null
  }

  export type StepAvgAggregateOutputType = {
    order: number | null
  }

  export type StepSumAggregateOutputType = {
    order: number | null
  }

  export type StepMinAggregateOutputType = {
    id: string | null
    flowId: string | null
    order: number | null
    type: $Enums.StepType | null
    message: string | null
    dynamicSource: $Enums.DynamicSource | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    DeletedBy: string | null
    DeletedAt: Date | null
    isDeleted: boolean | null
  }

  export type StepMaxAggregateOutputType = {
    id: string | null
    flowId: string | null
    order: number | null
    type: $Enums.StepType | null
    message: string | null
    dynamicSource: $Enums.DynamicSource | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    DeletedBy: string | null
    DeletedAt: Date | null
    isDeleted: boolean | null
  }

  export type StepCountAggregateOutputType = {
    id: number
    flowId: number
    order: number
    type: number
    message: number
    dynamicSource: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    DeletedBy: number
    DeletedAt: number
    isDeleted: number
    _all: number
  }


  export type StepAvgAggregateInputType = {
    order?: true
  }

  export type StepSumAggregateInputType = {
    order?: true
  }

  export type StepMinAggregateInputType = {
    id?: true
    flowId?: true
    order?: true
    type?: true
    message?: true
    dynamicSource?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    DeletedBy?: true
    DeletedAt?: true
    isDeleted?: true
  }

  export type StepMaxAggregateInputType = {
    id?: true
    flowId?: true
    order?: true
    type?: true
    message?: true
    dynamicSource?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    DeletedBy?: true
    DeletedAt?: true
    isDeleted?: true
  }

  export type StepCountAggregateInputType = {
    id?: true
    flowId?: true
    order?: true
    type?: true
    message?: true
    dynamicSource?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    DeletedBy?: true
    DeletedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type StepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Step to aggregate.
     */
    where?: StepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Steps to fetch.
     */
    orderBy?: StepOrderByWithRelationInput | StepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Steps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Steps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Steps
    **/
    _count?: true | StepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StepMaxAggregateInputType
  }

  export type GetStepAggregateType<T extends StepAggregateArgs> = {
        [P in keyof T & keyof AggregateStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStep[P]>
      : GetScalarType<T[P], AggregateStep[P]>
  }




  export type StepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StepWhereInput
    orderBy?: StepOrderByWithAggregationInput | StepOrderByWithAggregationInput[]
    by: StepScalarFieldEnum[] | StepScalarFieldEnum
    having?: StepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StepCountAggregateInputType | true
    _avg?: StepAvgAggregateInputType
    _sum?: StepSumAggregateInputType
    _min?: StepMinAggregateInputType
    _max?: StepMaxAggregateInputType
  }

  export type StepGroupByOutputType = {
    id: string
    flowId: string
    order: number
    type: $Enums.StepType
    message: string | null
    dynamicSource: $Enums.DynamicSource
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string | null
    DeletedBy: string | null
    DeletedAt: Date | null
    isDeleted: boolean
    _count: StepCountAggregateOutputType | null
    _avg: StepAvgAggregateOutputType | null
    _sum: StepSumAggregateOutputType | null
    _min: StepMinAggregateOutputType | null
    _max: StepMaxAggregateOutputType | null
  }

  type GetStepGroupByPayload<T extends StepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StepGroupByOutputType[P]>
            : GetScalarType<T[P], StepGroupByOutputType[P]>
        }
      >
    >


  export type StepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    order?: boolean
    type?: boolean
    message?: boolean
    dynamicSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    options?: boolean | Step$optionsArgs<ExtArgs>
    sessions?: boolean | Step$sessionsArgs<ExtArgs>
    logs?: boolean | Step$logsArgs<ExtArgs>
    nextStepOptions?: boolean | Step$nextStepOptionsArgs<ExtArgs>
    _count?: boolean | StepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["step"]>

  export type StepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    order?: boolean
    type?: boolean
    message?: boolean
    dynamicSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["step"]>

  export type StepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    order?: boolean
    type?: boolean
    message?: boolean
    dynamicSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["step"]>

  export type StepSelectScalar = {
    id?: boolean
    flowId?: boolean
    order?: boolean
    type?: boolean
    message?: boolean
    dynamicSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
  }

  export type StepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "flowId" | "order" | "type" | "message" | "dynamicSource" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "DeletedBy" | "DeletedAt" | "isDeleted", ExtArgs["result"]["step"]>
  export type StepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    options?: boolean | Step$optionsArgs<ExtArgs>
    sessions?: boolean | Step$sessionsArgs<ExtArgs>
    logs?: boolean | Step$logsArgs<ExtArgs>
    nextStepOptions?: boolean | Step$nextStepOptionsArgs<ExtArgs>
    _count?: boolean | StepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }
  export type StepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
  }

  export type $StepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Step"
    objects: {
      flow: Prisma.$FlowPayload<ExtArgs>
      options: Prisma.$StepOptionPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
      nextStepOptions: Prisma.$StepOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flowId: string
      order: number
      type: $Enums.StepType
      message: string | null
      dynamicSource: $Enums.DynamicSource
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string | null
      DeletedBy: string | null
      DeletedAt: Date | null
      isDeleted: boolean
    }, ExtArgs["result"]["step"]>
    composites: {}
  }

  type StepGetPayload<S extends boolean | null | undefined | StepDefaultArgs> = $Result.GetResult<Prisma.$StepPayload, S>

  type StepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StepCountAggregateInputType | true
    }

  export interface StepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Step'], meta: { name: 'Step' } }
    /**
     * Find zero or one Step that matches the filter.
     * @param {StepFindUniqueArgs} args - Arguments to find a Step
     * @example
     * // Get one Step
     * const step = await prisma.step.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StepFindUniqueArgs>(args: SelectSubset<T, StepFindUniqueArgs<ExtArgs>>): Prisma__StepClient<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Step that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StepFindUniqueOrThrowArgs} args - Arguments to find a Step
     * @example
     * // Get one Step
     * const step = await prisma.step.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StepFindUniqueOrThrowArgs>(args: SelectSubset<T, StepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StepClient<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Step that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepFindFirstArgs} args - Arguments to find a Step
     * @example
     * // Get one Step
     * const step = await prisma.step.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StepFindFirstArgs>(args?: SelectSubset<T, StepFindFirstArgs<ExtArgs>>): Prisma__StepClient<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Step that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepFindFirstOrThrowArgs} args - Arguments to find a Step
     * @example
     * // Get one Step
     * const step = await prisma.step.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StepFindFirstOrThrowArgs>(args?: SelectSubset<T, StepFindFirstOrThrowArgs<ExtArgs>>): Prisma__StepClient<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Steps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Steps
     * const steps = await prisma.step.findMany()
     * 
     * // Get first 10 Steps
     * const steps = await prisma.step.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stepWithIdOnly = await prisma.step.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StepFindManyArgs>(args?: SelectSubset<T, StepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Step.
     * @param {StepCreateArgs} args - Arguments to create a Step.
     * @example
     * // Create one Step
     * const Step = await prisma.step.create({
     *   data: {
     *     // ... data to create a Step
     *   }
     * })
     * 
     */
    create<T extends StepCreateArgs>(args: SelectSubset<T, StepCreateArgs<ExtArgs>>): Prisma__StepClient<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Steps.
     * @param {StepCreateManyArgs} args - Arguments to create many Steps.
     * @example
     * // Create many Steps
     * const step = await prisma.step.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StepCreateManyArgs>(args?: SelectSubset<T, StepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Steps and returns the data saved in the database.
     * @param {StepCreateManyAndReturnArgs} args - Arguments to create many Steps.
     * @example
     * // Create many Steps
     * const step = await prisma.step.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Steps and only return the `id`
     * const stepWithIdOnly = await prisma.step.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StepCreateManyAndReturnArgs>(args?: SelectSubset<T, StepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Step.
     * @param {StepDeleteArgs} args - Arguments to delete one Step.
     * @example
     * // Delete one Step
     * const Step = await prisma.step.delete({
     *   where: {
     *     // ... filter to delete one Step
     *   }
     * })
     * 
     */
    delete<T extends StepDeleteArgs>(args: SelectSubset<T, StepDeleteArgs<ExtArgs>>): Prisma__StepClient<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Step.
     * @param {StepUpdateArgs} args - Arguments to update one Step.
     * @example
     * // Update one Step
     * const step = await prisma.step.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StepUpdateArgs>(args: SelectSubset<T, StepUpdateArgs<ExtArgs>>): Prisma__StepClient<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Steps.
     * @param {StepDeleteManyArgs} args - Arguments to filter Steps to delete.
     * @example
     * // Delete a few Steps
     * const { count } = await prisma.step.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StepDeleteManyArgs>(args?: SelectSubset<T, StepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Steps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Steps
     * const step = await prisma.step.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StepUpdateManyArgs>(args: SelectSubset<T, StepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Steps and returns the data updated in the database.
     * @param {StepUpdateManyAndReturnArgs} args - Arguments to update many Steps.
     * @example
     * // Update many Steps
     * const step = await prisma.step.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Steps and only return the `id`
     * const stepWithIdOnly = await prisma.step.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StepUpdateManyAndReturnArgs>(args: SelectSubset<T, StepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Step.
     * @param {StepUpsertArgs} args - Arguments to update or create a Step.
     * @example
     * // Update or create a Step
     * const step = await prisma.step.upsert({
     *   create: {
     *     // ... data to create a Step
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Step we want to update
     *   }
     * })
     */
    upsert<T extends StepUpsertArgs>(args: SelectSubset<T, StepUpsertArgs<ExtArgs>>): Prisma__StepClient<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Steps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepCountArgs} args - Arguments to filter Steps to count.
     * @example
     * // Count the number of Steps
     * const count = await prisma.step.count({
     *   where: {
     *     // ... the filter for the Steps we want to count
     *   }
     * })
    **/
    count<T extends StepCountArgs>(
      args?: Subset<T, StepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Step.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StepAggregateArgs>(args: Subset<T, StepAggregateArgs>): Prisma.PrismaPromise<GetStepAggregateType<T>>

    /**
     * Group by Step.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StepGroupByArgs['orderBy'] }
        : { orderBy?: StepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Step model
   */
  readonly fields: StepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Step.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flow<T extends FlowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlowDefaultArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    options<T extends Step$optionsArgs<ExtArgs> = {}>(args?: Subset<T, Step$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends Step$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Step$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends Step$logsArgs<ExtArgs> = {}>(args?: Subset<T, Step$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nextStepOptions<T extends Step$nextStepOptionsArgs<ExtArgs> = {}>(args?: Subset<T, Step$nextStepOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Step model
   */
  interface StepFieldRefs {
    readonly id: FieldRef<"Step", 'String'>
    readonly flowId: FieldRef<"Step", 'String'>
    readonly order: FieldRef<"Step", 'Int'>
    readonly type: FieldRef<"Step", 'StepType'>
    readonly message: FieldRef<"Step", 'String'>
    readonly dynamicSource: FieldRef<"Step", 'DynamicSource'>
    readonly createdAt: FieldRef<"Step", 'DateTime'>
    readonly updatedAt: FieldRef<"Step", 'DateTime'>
    readonly createdBy: FieldRef<"Step", 'String'>
    readonly updatedBy: FieldRef<"Step", 'String'>
    readonly DeletedBy: FieldRef<"Step", 'String'>
    readonly DeletedAt: FieldRef<"Step", 'DateTime'>
    readonly isDeleted: FieldRef<"Step", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Step findUnique
   */
  export type StepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepInclude<ExtArgs> | null
    /**
     * Filter, which Step to fetch.
     */
    where: StepWhereUniqueInput
  }

  /**
   * Step findUniqueOrThrow
   */
  export type StepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepInclude<ExtArgs> | null
    /**
     * Filter, which Step to fetch.
     */
    where: StepWhereUniqueInput
  }

  /**
   * Step findFirst
   */
  export type StepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepInclude<ExtArgs> | null
    /**
     * Filter, which Step to fetch.
     */
    where?: StepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Steps to fetch.
     */
    orderBy?: StepOrderByWithRelationInput | StepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Steps.
     */
    cursor?: StepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Steps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Steps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Steps.
     */
    distinct?: StepScalarFieldEnum | StepScalarFieldEnum[]
  }

  /**
   * Step findFirstOrThrow
   */
  export type StepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepInclude<ExtArgs> | null
    /**
     * Filter, which Step to fetch.
     */
    where?: StepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Steps to fetch.
     */
    orderBy?: StepOrderByWithRelationInput | StepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Steps.
     */
    cursor?: StepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Steps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Steps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Steps.
     */
    distinct?: StepScalarFieldEnum | StepScalarFieldEnum[]
  }

  /**
   * Step findMany
   */
  export type StepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepInclude<ExtArgs> | null
    /**
     * Filter, which Steps to fetch.
     */
    where?: StepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Steps to fetch.
     */
    orderBy?: StepOrderByWithRelationInput | StepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Steps.
     */
    cursor?: StepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Steps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Steps.
     */
    skip?: number
    distinct?: StepScalarFieldEnum | StepScalarFieldEnum[]
  }

  /**
   * Step create
   */
  export type StepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepInclude<ExtArgs> | null
    /**
     * The data needed to create a Step.
     */
    data: XOR<StepCreateInput, StepUncheckedCreateInput>
  }

  /**
   * Step createMany
   */
  export type StepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Steps.
     */
    data: StepCreateManyInput | StepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Step createManyAndReturn
   */
  export type StepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * The data used to create many Steps.
     */
    data: StepCreateManyInput | StepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Step update
   */
  export type StepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepInclude<ExtArgs> | null
    /**
     * The data needed to update a Step.
     */
    data: XOR<StepUpdateInput, StepUncheckedUpdateInput>
    /**
     * Choose, which Step to update.
     */
    where: StepWhereUniqueInput
  }

  /**
   * Step updateMany
   */
  export type StepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Steps.
     */
    data: XOR<StepUpdateManyMutationInput, StepUncheckedUpdateManyInput>
    /**
     * Filter which Steps to update
     */
    where?: StepWhereInput
    /**
     * Limit how many Steps to update.
     */
    limit?: number
  }

  /**
   * Step updateManyAndReturn
   */
  export type StepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * The data used to update Steps.
     */
    data: XOR<StepUpdateManyMutationInput, StepUncheckedUpdateManyInput>
    /**
     * Filter which Steps to update
     */
    where?: StepWhereInput
    /**
     * Limit how many Steps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Step upsert
   */
  export type StepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepInclude<ExtArgs> | null
    /**
     * The filter to search for the Step to update in case it exists.
     */
    where: StepWhereUniqueInput
    /**
     * In case the Step found by the `where` argument doesn't exist, create a new Step with this data.
     */
    create: XOR<StepCreateInput, StepUncheckedCreateInput>
    /**
     * In case the Step was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StepUpdateInput, StepUncheckedUpdateInput>
  }

  /**
   * Step delete
   */
  export type StepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepInclude<ExtArgs> | null
    /**
     * Filter which Step to delete.
     */
    where: StepWhereUniqueInput
  }

  /**
   * Step deleteMany
   */
  export type StepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Steps to delete
     */
    where?: StepWhereInput
    /**
     * Limit how many Steps to delete.
     */
    limit?: number
  }

  /**
   * Step.options
   */
  export type Step$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepOption
     */
    select?: StepOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepOption
     */
    omit?: StepOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepOptionInclude<ExtArgs> | null
    where?: StepOptionWhereInput
    orderBy?: StepOptionOrderByWithRelationInput | StepOptionOrderByWithRelationInput[]
    cursor?: StepOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StepOptionScalarFieldEnum | StepOptionScalarFieldEnum[]
  }

  /**
   * Step.sessions
   */
  export type Step$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Step.logs
   */
  export type Step$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Step.nextStepOptions
   */
  export type Step$nextStepOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepOption
     */
    select?: StepOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepOption
     */
    omit?: StepOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepOptionInclude<ExtArgs> | null
    where?: StepOptionWhereInput
    orderBy?: StepOptionOrderByWithRelationInput | StepOptionOrderByWithRelationInput[]
    cursor?: StepOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StepOptionScalarFieldEnum | StepOptionScalarFieldEnum[]
  }

  /**
   * Step without action
   */
  export type StepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepInclude<ExtArgs> | null
  }


  /**
   * Model StepOption
   */

  export type AggregateStepOption = {
    _count: StepOptionCountAggregateOutputType | null
    _min: StepOptionMinAggregateOutputType | null
    _max: StepOptionMaxAggregateOutputType | null
  }

  export type StepOptionMinAggregateOutputType = {
    id: string | null
    stepId: string | null
    label: string | null
    value: string | null
    nextStepId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    DeletedBy: string | null
    DeletedAt: Date | null
    isDeleted: boolean | null
  }

  export type StepOptionMaxAggregateOutputType = {
    id: string | null
    stepId: string | null
    label: string | null
    value: string | null
    nextStepId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    DeletedBy: string | null
    DeletedAt: Date | null
    isDeleted: boolean | null
  }

  export type StepOptionCountAggregateOutputType = {
    id: number
    stepId: number
    label: number
    value: number
    nextStepId: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    DeletedBy: number
    DeletedAt: number
    isDeleted: number
    _all: number
  }


  export type StepOptionMinAggregateInputType = {
    id?: true
    stepId?: true
    label?: true
    value?: true
    nextStepId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    DeletedBy?: true
    DeletedAt?: true
    isDeleted?: true
  }

  export type StepOptionMaxAggregateInputType = {
    id?: true
    stepId?: true
    label?: true
    value?: true
    nextStepId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    DeletedBy?: true
    DeletedAt?: true
    isDeleted?: true
  }

  export type StepOptionCountAggregateInputType = {
    id?: true
    stepId?: true
    label?: true
    value?: true
    nextStepId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    DeletedBy?: true
    DeletedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type StepOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StepOption to aggregate.
     */
    where?: StepOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepOptions to fetch.
     */
    orderBy?: StepOptionOrderByWithRelationInput | StepOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StepOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StepOptions
    **/
    _count?: true | StepOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StepOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StepOptionMaxAggregateInputType
  }

  export type GetStepOptionAggregateType<T extends StepOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateStepOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStepOption[P]>
      : GetScalarType<T[P], AggregateStepOption[P]>
  }




  export type StepOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StepOptionWhereInput
    orderBy?: StepOptionOrderByWithAggregationInput | StepOptionOrderByWithAggregationInput[]
    by: StepOptionScalarFieldEnum[] | StepOptionScalarFieldEnum
    having?: StepOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StepOptionCountAggregateInputType | true
    _min?: StepOptionMinAggregateInputType
    _max?: StepOptionMaxAggregateInputType
  }

  export type StepOptionGroupByOutputType = {
    id: string
    stepId: string
    label: string
    value: string
    nextStepId: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string | null
    DeletedBy: string | null
    DeletedAt: Date | null
    isDeleted: boolean
    _count: StepOptionCountAggregateOutputType | null
    _min: StepOptionMinAggregateOutputType | null
    _max: StepOptionMaxAggregateOutputType | null
  }

  type GetStepOptionGroupByPayload<T extends StepOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StepOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StepOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StepOptionGroupByOutputType[P]>
            : GetScalarType<T[P], StepOptionGroupByOutputType[P]>
        }
      >
    >


  export type StepOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stepId?: boolean
    label?: boolean
    value?: boolean
    nextStepId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
    step?: boolean | StepDefaultArgs<ExtArgs>
    nextStep?: boolean | StepOption$nextStepArgs<ExtArgs>
  }, ExtArgs["result"]["stepOption"]>

  export type StepOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stepId?: boolean
    label?: boolean
    value?: boolean
    nextStepId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
    step?: boolean | StepDefaultArgs<ExtArgs>
    nextStep?: boolean | StepOption$nextStepArgs<ExtArgs>
  }, ExtArgs["result"]["stepOption"]>

  export type StepOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stepId?: boolean
    label?: boolean
    value?: boolean
    nextStepId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
    step?: boolean | StepDefaultArgs<ExtArgs>
    nextStep?: boolean | StepOption$nextStepArgs<ExtArgs>
  }, ExtArgs["result"]["stepOption"]>

  export type StepOptionSelectScalar = {
    id?: boolean
    stepId?: boolean
    label?: boolean
    value?: boolean
    nextStepId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
  }

  export type StepOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stepId" | "label" | "value" | "nextStepId" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "DeletedBy" | "DeletedAt" | "isDeleted", ExtArgs["result"]["stepOption"]>
  export type StepOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    step?: boolean | StepDefaultArgs<ExtArgs>
    nextStep?: boolean | StepOption$nextStepArgs<ExtArgs>
  }
  export type StepOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    step?: boolean | StepDefaultArgs<ExtArgs>
    nextStep?: boolean | StepOption$nextStepArgs<ExtArgs>
  }
  export type StepOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    step?: boolean | StepDefaultArgs<ExtArgs>
    nextStep?: boolean | StepOption$nextStepArgs<ExtArgs>
  }

  export type $StepOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StepOption"
    objects: {
      step: Prisma.$StepPayload<ExtArgs>
      nextStep: Prisma.$StepPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stepId: string
      label: string
      value: string
      nextStepId: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string | null
      DeletedBy: string | null
      DeletedAt: Date | null
      isDeleted: boolean
    }, ExtArgs["result"]["stepOption"]>
    composites: {}
  }

  type StepOptionGetPayload<S extends boolean | null | undefined | StepOptionDefaultArgs> = $Result.GetResult<Prisma.$StepOptionPayload, S>

  type StepOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StepOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StepOptionCountAggregateInputType | true
    }

  export interface StepOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StepOption'], meta: { name: 'StepOption' } }
    /**
     * Find zero or one StepOption that matches the filter.
     * @param {StepOptionFindUniqueArgs} args - Arguments to find a StepOption
     * @example
     * // Get one StepOption
     * const stepOption = await prisma.stepOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StepOptionFindUniqueArgs>(args: SelectSubset<T, StepOptionFindUniqueArgs<ExtArgs>>): Prisma__StepOptionClient<$Result.GetResult<Prisma.$StepOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StepOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StepOptionFindUniqueOrThrowArgs} args - Arguments to find a StepOption
     * @example
     * // Get one StepOption
     * const stepOption = await prisma.stepOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StepOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, StepOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StepOptionClient<$Result.GetResult<Prisma.$StepOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StepOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepOptionFindFirstArgs} args - Arguments to find a StepOption
     * @example
     * // Get one StepOption
     * const stepOption = await prisma.stepOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StepOptionFindFirstArgs>(args?: SelectSubset<T, StepOptionFindFirstArgs<ExtArgs>>): Prisma__StepOptionClient<$Result.GetResult<Prisma.$StepOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StepOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepOptionFindFirstOrThrowArgs} args - Arguments to find a StepOption
     * @example
     * // Get one StepOption
     * const stepOption = await prisma.stepOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StepOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, StepOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StepOptionClient<$Result.GetResult<Prisma.$StepOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StepOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StepOptions
     * const stepOptions = await prisma.stepOption.findMany()
     * 
     * // Get first 10 StepOptions
     * const stepOptions = await prisma.stepOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stepOptionWithIdOnly = await prisma.stepOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StepOptionFindManyArgs>(args?: SelectSubset<T, StepOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StepOption.
     * @param {StepOptionCreateArgs} args - Arguments to create a StepOption.
     * @example
     * // Create one StepOption
     * const StepOption = await prisma.stepOption.create({
     *   data: {
     *     // ... data to create a StepOption
     *   }
     * })
     * 
     */
    create<T extends StepOptionCreateArgs>(args: SelectSubset<T, StepOptionCreateArgs<ExtArgs>>): Prisma__StepOptionClient<$Result.GetResult<Prisma.$StepOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StepOptions.
     * @param {StepOptionCreateManyArgs} args - Arguments to create many StepOptions.
     * @example
     * // Create many StepOptions
     * const stepOption = await prisma.stepOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StepOptionCreateManyArgs>(args?: SelectSubset<T, StepOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StepOptions and returns the data saved in the database.
     * @param {StepOptionCreateManyAndReturnArgs} args - Arguments to create many StepOptions.
     * @example
     * // Create many StepOptions
     * const stepOption = await prisma.stepOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StepOptions and only return the `id`
     * const stepOptionWithIdOnly = await prisma.stepOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StepOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, StepOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StepOption.
     * @param {StepOptionDeleteArgs} args - Arguments to delete one StepOption.
     * @example
     * // Delete one StepOption
     * const StepOption = await prisma.stepOption.delete({
     *   where: {
     *     // ... filter to delete one StepOption
     *   }
     * })
     * 
     */
    delete<T extends StepOptionDeleteArgs>(args: SelectSubset<T, StepOptionDeleteArgs<ExtArgs>>): Prisma__StepOptionClient<$Result.GetResult<Prisma.$StepOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StepOption.
     * @param {StepOptionUpdateArgs} args - Arguments to update one StepOption.
     * @example
     * // Update one StepOption
     * const stepOption = await prisma.stepOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StepOptionUpdateArgs>(args: SelectSubset<T, StepOptionUpdateArgs<ExtArgs>>): Prisma__StepOptionClient<$Result.GetResult<Prisma.$StepOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StepOptions.
     * @param {StepOptionDeleteManyArgs} args - Arguments to filter StepOptions to delete.
     * @example
     * // Delete a few StepOptions
     * const { count } = await prisma.stepOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StepOptionDeleteManyArgs>(args?: SelectSubset<T, StepOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StepOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StepOptions
     * const stepOption = await prisma.stepOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StepOptionUpdateManyArgs>(args: SelectSubset<T, StepOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StepOptions and returns the data updated in the database.
     * @param {StepOptionUpdateManyAndReturnArgs} args - Arguments to update many StepOptions.
     * @example
     * // Update many StepOptions
     * const stepOption = await prisma.stepOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StepOptions and only return the `id`
     * const stepOptionWithIdOnly = await prisma.stepOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StepOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, StepOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StepOption.
     * @param {StepOptionUpsertArgs} args - Arguments to update or create a StepOption.
     * @example
     * // Update or create a StepOption
     * const stepOption = await prisma.stepOption.upsert({
     *   create: {
     *     // ... data to create a StepOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StepOption we want to update
     *   }
     * })
     */
    upsert<T extends StepOptionUpsertArgs>(args: SelectSubset<T, StepOptionUpsertArgs<ExtArgs>>): Prisma__StepOptionClient<$Result.GetResult<Prisma.$StepOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StepOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepOptionCountArgs} args - Arguments to filter StepOptions to count.
     * @example
     * // Count the number of StepOptions
     * const count = await prisma.stepOption.count({
     *   where: {
     *     // ... the filter for the StepOptions we want to count
     *   }
     * })
    **/
    count<T extends StepOptionCountArgs>(
      args?: Subset<T, StepOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StepOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StepOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StepOptionAggregateArgs>(args: Subset<T, StepOptionAggregateArgs>): Prisma.PrismaPromise<GetStepOptionAggregateType<T>>

    /**
     * Group by StepOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StepOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StepOptionGroupByArgs['orderBy'] }
        : { orderBy?: StepOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StepOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStepOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StepOption model
   */
  readonly fields: StepOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StepOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StepOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    step<T extends StepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StepDefaultArgs<ExtArgs>>): Prisma__StepClient<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nextStep<T extends StepOption$nextStepArgs<ExtArgs> = {}>(args?: Subset<T, StepOption$nextStepArgs<ExtArgs>>): Prisma__StepClient<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StepOption model
   */
  interface StepOptionFieldRefs {
    readonly id: FieldRef<"StepOption", 'String'>
    readonly stepId: FieldRef<"StepOption", 'String'>
    readonly label: FieldRef<"StepOption", 'String'>
    readonly value: FieldRef<"StepOption", 'String'>
    readonly nextStepId: FieldRef<"StepOption", 'String'>
    readonly createdAt: FieldRef<"StepOption", 'DateTime'>
    readonly updatedAt: FieldRef<"StepOption", 'DateTime'>
    readonly createdBy: FieldRef<"StepOption", 'String'>
    readonly updatedBy: FieldRef<"StepOption", 'String'>
    readonly DeletedBy: FieldRef<"StepOption", 'String'>
    readonly DeletedAt: FieldRef<"StepOption", 'DateTime'>
    readonly isDeleted: FieldRef<"StepOption", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * StepOption findUnique
   */
  export type StepOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepOption
     */
    select?: StepOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepOption
     */
    omit?: StepOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepOptionInclude<ExtArgs> | null
    /**
     * Filter, which StepOption to fetch.
     */
    where: StepOptionWhereUniqueInput
  }

  /**
   * StepOption findUniqueOrThrow
   */
  export type StepOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepOption
     */
    select?: StepOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepOption
     */
    omit?: StepOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepOptionInclude<ExtArgs> | null
    /**
     * Filter, which StepOption to fetch.
     */
    where: StepOptionWhereUniqueInput
  }

  /**
   * StepOption findFirst
   */
  export type StepOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepOption
     */
    select?: StepOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepOption
     */
    omit?: StepOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepOptionInclude<ExtArgs> | null
    /**
     * Filter, which StepOption to fetch.
     */
    where?: StepOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepOptions to fetch.
     */
    orderBy?: StepOptionOrderByWithRelationInput | StepOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StepOptions.
     */
    cursor?: StepOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StepOptions.
     */
    distinct?: StepOptionScalarFieldEnum | StepOptionScalarFieldEnum[]
  }

  /**
   * StepOption findFirstOrThrow
   */
  export type StepOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepOption
     */
    select?: StepOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepOption
     */
    omit?: StepOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepOptionInclude<ExtArgs> | null
    /**
     * Filter, which StepOption to fetch.
     */
    where?: StepOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepOptions to fetch.
     */
    orderBy?: StepOptionOrderByWithRelationInput | StepOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StepOptions.
     */
    cursor?: StepOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StepOptions.
     */
    distinct?: StepOptionScalarFieldEnum | StepOptionScalarFieldEnum[]
  }

  /**
   * StepOption findMany
   */
  export type StepOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepOption
     */
    select?: StepOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepOption
     */
    omit?: StepOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepOptionInclude<ExtArgs> | null
    /**
     * Filter, which StepOptions to fetch.
     */
    where?: StepOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepOptions to fetch.
     */
    orderBy?: StepOptionOrderByWithRelationInput | StepOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StepOptions.
     */
    cursor?: StepOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepOptions.
     */
    skip?: number
    distinct?: StepOptionScalarFieldEnum | StepOptionScalarFieldEnum[]
  }

  /**
   * StepOption create
   */
  export type StepOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepOption
     */
    select?: StepOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepOption
     */
    omit?: StepOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a StepOption.
     */
    data: XOR<StepOptionCreateInput, StepOptionUncheckedCreateInput>
  }

  /**
   * StepOption createMany
   */
  export type StepOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StepOptions.
     */
    data: StepOptionCreateManyInput | StepOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StepOption createManyAndReturn
   */
  export type StepOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepOption
     */
    select?: StepOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StepOption
     */
    omit?: StepOptionOmit<ExtArgs> | null
    /**
     * The data used to create many StepOptions.
     */
    data: StepOptionCreateManyInput | StepOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StepOption update
   */
  export type StepOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepOption
     */
    select?: StepOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepOption
     */
    omit?: StepOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a StepOption.
     */
    data: XOR<StepOptionUpdateInput, StepOptionUncheckedUpdateInput>
    /**
     * Choose, which StepOption to update.
     */
    where: StepOptionWhereUniqueInput
  }

  /**
   * StepOption updateMany
   */
  export type StepOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StepOptions.
     */
    data: XOR<StepOptionUpdateManyMutationInput, StepOptionUncheckedUpdateManyInput>
    /**
     * Filter which StepOptions to update
     */
    where?: StepOptionWhereInput
    /**
     * Limit how many StepOptions to update.
     */
    limit?: number
  }

  /**
   * StepOption updateManyAndReturn
   */
  export type StepOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepOption
     */
    select?: StepOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StepOption
     */
    omit?: StepOptionOmit<ExtArgs> | null
    /**
     * The data used to update StepOptions.
     */
    data: XOR<StepOptionUpdateManyMutationInput, StepOptionUncheckedUpdateManyInput>
    /**
     * Filter which StepOptions to update
     */
    where?: StepOptionWhereInput
    /**
     * Limit how many StepOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StepOption upsert
   */
  export type StepOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepOption
     */
    select?: StepOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepOption
     */
    omit?: StepOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the StepOption to update in case it exists.
     */
    where: StepOptionWhereUniqueInput
    /**
     * In case the StepOption found by the `where` argument doesn't exist, create a new StepOption with this data.
     */
    create: XOR<StepOptionCreateInput, StepOptionUncheckedCreateInput>
    /**
     * In case the StepOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StepOptionUpdateInput, StepOptionUncheckedUpdateInput>
  }

  /**
   * StepOption delete
   */
  export type StepOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepOption
     */
    select?: StepOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepOption
     */
    omit?: StepOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepOptionInclude<ExtArgs> | null
    /**
     * Filter which StepOption to delete.
     */
    where: StepOptionWhereUniqueInput
  }

  /**
   * StepOption deleteMany
   */
  export type StepOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StepOptions to delete
     */
    where?: StepOptionWhereInput
    /**
     * Limit how many StepOptions to delete.
     */
    limit?: number
  }

  /**
   * StepOption.nextStep
   */
  export type StepOption$nextStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepInclude<ExtArgs> | null
    where?: StepWhereInput
  }

  /**
   * StepOption without action
   */
  export type StepOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepOption
     */
    select?: StepOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepOption
     */
    omit?: StepOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepOptionInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    flowId: string | null
    currentStepId: string | null
    isCompleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    DeletedBy: string | null
    DeletedAt: Date | null
    isDeleted: boolean | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    flowId: string | null
    currentStepId: string | null
    isCompleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    DeletedBy: string | null
    DeletedAt: Date | null
    isDeleted: boolean | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    flowId: number
    currentStepId: number
    isCompleted: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    DeletedBy: number
    DeletedAt: number
    isDeleted: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    flowId?: true
    currentStepId?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    DeletedBy?: true
    DeletedAt?: true
    isDeleted?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    flowId?: true
    currentStepId?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    DeletedBy?: true
    DeletedAt?: true
    isDeleted?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    flowId?: true
    currentStepId?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    DeletedBy?: true
    DeletedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    flowId: string
    currentStepId: string | null
    isCompleted: boolean
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string | null
    DeletedBy: string | null
    DeletedAt: Date | null
    isDeleted: boolean
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    flowId?: boolean
    currentStepId?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentStep?: boolean | Session$currentStepArgs<ExtArgs>
    logs?: boolean | Session$logsArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    flowId?: boolean
    currentStepId?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentStep?: boolean | Session$currentStepArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    flowId?: boolean
    currentStepId?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentStep?: boolean | Session$currentStepArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    flowId?: boolean
    currentStepId?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    DeletedBy?: boolean
    DeletedAt?: boolean
    isDeleted?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "flowId" | "currentStepId" | "isCompleted" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "DeletedBy" | "DeletedAt" | "isDeleted", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentStep?: boolean | Session$currentStepArgs<ExtArgs>
    logs?: boolean | Session$logsArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentStep?: boolean | Session$currentStepArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | FlowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentStep?: boolean | Session$currentStepArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      flow: Prisma.$FlowPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      currentStep: Prisma.$StepPayload<ExtArgs> | null
      logs: Prisma.$LogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      flowId: string
      currentStepId: string | null
      isCompleted: boolean
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string | null
      DeletedBy: string | null
      DeletedAt: Date | null
      isDeleted: boolean
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flow<T extends FlowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlowDefaultArgs<ExtArgs>>): Prisma__FlowClient<$Result.GetResult<Prisma.$FlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currentStep<T extends Session$currentStepArgs<ExtArgs> = {}>(args?: Subset<T, Session$currentStepArgs<ExtArgs>>): Prisma__StepClient<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    logs<T extends Session$logsArgs<ExtArgs> = {}>(args?: Subset<T, Session$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly flowId: FieldRef<"Session", 'String'>
    readonly currentStepId: FieldRef<"Session", 'String'>
    readonly isCompleted: FieldRef<"Session", 'Boolean'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly createdBy: FieldRef<"Session", 'String'>
    readonly updatedBy: FieldRef<"Session", 'String'>
    readonly DeletedBy: FieldRef<"Session", 'String'>
    readonly DeletedAt: FieldRef<"Session", 'DateTime'>
    readonly isDeleted: FieldRef<"Session", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session.currentStep
   */
  export type Session$currentStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepInclude<ExtArgs> | null
    where?: StepWhereInput
  }

  /**
   * Session.logs
   */
  export type Session$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    stepId: string | null
    message: string | null
    direction: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type LogMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    stepId: string | null
    message: string | null
    direction: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    sessionId: number
    stepId: number
    message: number
    direction: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type LogMinAggregateInputType = {
    id?: true
    sessionId?: true
    stepId?: true
    message?: true
    direction?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    sessionId?: true
    stepId?: true
    message?: true
    direction?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    sessionId?: true
    stepId?: true
    message?: true
    direction?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: string
    sessionId: string
    stepId: string | null
    message: string
    direction: string
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    stepId?: boolean
    message?: boolean
    direction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    step?: boolean | Log$stepArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    stepId?: boolean
    message?: boolean
    direction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    step?: boolean | Log$stepArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    stepId?: boolean
    message?: boolean
    direction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    step?: boolean | Log$stepArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectScalar = {
    id?: boolean
    sessionId?: boolean
    stepId?: boolean
    message?: boolean
    direction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type LogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "stepId" | "message" | "direction" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["log"]>
  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    step?: boolean | Log$stepArgs<ExtArgs>
  }
  export type LogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    step?: boolean | Log$stepArgs<ExtArgs>
  }
  export type LogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    step?: boolean | Log$stepArgs<ExtArgs>
  }

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      step: Prisma.$StepPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      stepId: string | null
      message: string
      direction: string
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {LogCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogCreateManyAndReturnArgs>(args?: SelectSubset<T, LogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs and returns the data updated in the database.
     * @param {LogUpdateManyAndReturnArgs} args - Arguments to update many Logs.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LogUpdateManyAndReturnArgs>(args: SelectSubset<T, LogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    step<T extends Log$stepArgs<ExtArgs> = {}>(args?: Subset<T, Log$stepArgs<ExtArgs>>): Prisma__StepClient<$Result.GetResult<Prisma.$StepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'String'>
    readonly sessionId: FieldRef<"Log", 'String'>
    readonly stepId: FieldRef<"Log", 'String'>
    readonly message: FieldRef<"Log", 'String'>
    readonly direction: FieldRef<"Log", 'String'>
    readonly createdAt: FieldRef<"Log", 'DateTime'>
    readonly updatedAt: FieldRef<"Log", 'DateTime'>
    readonly createdBy: FieldRef<"Log", 'String'>
    readonly updatedBy: FieldRef<"Log", 'String'>
    readonly isDeleted: FieldRef<"Log", 'Boolean'>
    readonly deletedAt: FieldRef<"Log", 'DateTime'>
    readonly deletedBy: FieldRef<"Log", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log createManyAndReturn
   */
  export type LogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Log updateManyAndReturn
   */
  export type LogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to delete.
     */
    limit?: number
  }

  /**
   * Log.step
   */
  export type Log$stepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Step
     */
    select?: StepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Step
     */
    omit?: StepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepInclude<ExtArgs> | null
    where?: StepWhereInput
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Model ContactUs
   */

  export type AggregateContactUs = {
    _count: ContactUsCountAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  export type ContactUsMinAggregateOutputType = {
    id: string | null
    customerName: string | null
    email: string | null
    phone: string | null
    businessType: $Enums.BusinessType | null
    message: string | null
    note: string | null
    status: $Enums.ContactStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ContactUsMaxAggregateOutputType = {
    id: string | null
    customerName: string | null
    email: string | null
    phone: string | null
    businessType: $Enums.BusinessType | null
    message: string | null
    note: string | null
    status: $Enums.ContactStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ContactUsCountAggregateOutputType = {
    id: number
    customerName: number
    email: number
    phone: number
    businessType: number
    message: number
    note: number
    status: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type ContactUsMinAggregateInputType = {
    id?: true
    customerName?: true
    email?: true
    phone?: true
    businessType?: true
    message?: true
    note?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ContactUsMaxAggregateInputType = {
    id?: true
    customerName?: true
    email?: true
    phone?: true
    businessType?: true
    message?: true
    note?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ContactUsCountAggregateInputType = {
    id?: true
    customerName?: true
    email?: true
    phone?: true
    businessType?: true
    message?: true
    note?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type ContactUsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactUs to aggregate.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contactuses
    **/
    _count?: true | ContactUsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactUsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactUsMaxAggregateInputType
  }

  export type GetContactUsAggregateType<T extends ContactUsAggregateArgs> = {
        [P in keyof T & keyof AggregateContactUs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactUs[P]>
      : GetScalarType<T[P], AggregateContactUs[P]>
  }




  export type ContactUsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactUsWhereInput
    orderBy?: ContactUsOrderByWithAggregationInput | ContactUsOrderByWithAggregationInput[]
    by: ContactUsScalarFieldEnum[] | ContactUsScalarFieldEnum
    having?: ContactUsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactUsCountAggregateInputType | true
    _min?: ContactUsMinAggregateInputType
    _max?: ContactUsMaxAggregateInputType
  }

  export type ContactUsGroupByOutputType = {
    id: string
    customerName: string
    email: string
    phone: string | null
    businessType: $Enums.BusinessType
    message: string
    note: string | null
    status: $Enums.ContactStatus
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: ContactUsCountAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  type GetContactUsGroupByPayload<T extends ContactUsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactUsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactUsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
        }
      >
    >


  export type ContactUsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerName?: boolean
    email?: boolean
    phone?: boolean
    businessType?: boolean
    message?: boolean
    note?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["contactUs"]>

  export type ContactUsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerName?: boolean
    email?: boolean
    phone?: boolean
    businessType?: boolean
    message?: boolean
    note?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["contactUs"]>

  export type ContactUsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerName?: boolean
    email?: boolean
    phone?: boolean
    businessType?: boolean
    message?: boolean
    note?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["contactUs"]>

  export type ContactUsSelectScalar = {
    id?: boolean
    customerName?: boolean
    email?: boolean
    phone?: boolean
    businessType?: boolean
    message?: boolean
    note?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type ContactUsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerName" | "email" | "phone" | "businessType" | "message" | "note" | "status" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["contactUs"]>

  export type $ContactUsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactUs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerName: string
      email: string
      phone: string | null
      businessType: $Enums.BusinessType
      message: string
      note: string | null
      status: $Enums.ContactStatus
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["contactUs"]>
    composites: {}
  }

  type ContactUsGetPayload<S extends boolean | null | undefined | ContactUsDefaultArgs> = $Result.GetResult<Prisma.$ContactUsPayload, S>

  type ContactUsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactUsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactUsCountAggregateInputType | true
    }

  export interface ContactUsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactUs'], meta: { name: 'ContactUs' } }
    /**
     * Find zero or one ContactUs that matches the filter.
     * @param {ContactUsFindUniqueArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactUsFindUniqueArgs>(args: SelectSubset<T, ContactUsFindUniqueArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactUs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactUsFindUniqueOrThrowArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactUsFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactUsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactUs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindFirstArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactUsFindFirstArgs>(args?: SelectSubset<T, ContactUsFindFirstArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactUs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindFirstOrThrowArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactUsFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactUsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contactuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contactuses
     * const contactuses = await prisma.contactUs.findMany()
     * 
     * // Get first 10 Contactuses
     * const contactuses = await prisma.contactUs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactUsWithIdOnly = await prisma.contactUs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactUsFindManyArgs>(args?: SelectSubset<T, ContactUsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactUs.
     * @param {ContactUsCreateArgs} args - Arguments to create a ContactUs.
     * @example
     * // Create one ContactUs
     * const ContactUs = await prisma.contactUs.create({
     *   data: {
     *     // ... data to create a ContactUs
     *   }
     * })
     * 
     */
    create<T extends ContactUsCreateArgs>(args: SelectSubset<T, ContactUsCreateArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contactuses.
     * @param {ContactUsCreateManyArgs} args - Arguments to create many Contactuses.
     * @example
     * // Create many Contactuses
     * const contactUs = await prisma.contactUs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactUsCreateManyArgs>(args?: SelectSubset<T, ContactUsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contactuses and returns the data saved in the database.
     * @param {ContactUsCreateManyAndReturnArgs} args - Arguments to create many Contactuses.
     * @example
     * // Create many Contactuses
     * const contactUs = await prisma.contactUs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contactuses and only return the `id`
     * const contactUsWithIdOnly = await prisma.contactUs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactUsCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactUsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactUs.
     * @param {ContactUsDeleteArgs} args - Arguments to delete one ContactUs.
     * @example
     * // Delete one ContactUs
     * const ContactUs = await prisma.contactUs.delete({
     *   where: {
     *     // ... filter to delete one ContactUs
     *   }
     * })
     * 
     */
    delete<T extends ContactUsDeleteArgs>(args: SelectSubset<T, ContactUsDeleteArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactUs.
     * @param {ContactUsUpdateArgs} args - Arguments to update one ContactUs.
     * @example
     * // Update one ContactUs
     * const contactUs = await prisma.contactUs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUsUpdateArgs>(args: SelectSubset<T, ContactUsUpdateArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contactuses.
     * @param {ContactUsDeleteManyArgs} args - Arguments to filter Contactuses to delete.
     * @example
     * // Delete a few Contactuses
     * const { count } = await prisma.contactUs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactUsDeleteManyArgs>(args?: SelectSubset<T, ContactUsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contactuses
     * const contactUs = await prisma.contactUs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUsUpdateManyArgs>(args: SelectSubset<T, ContactUsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contactuses and returns the data updated in the database.
     * @param {ContactUsUpdateManyAndReturnArgs} args - Arguments to update many Contactuses.
     * @example
     * // Update many Contactuses
     * const contactUs = await prisma.contactUs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contactuses and only return the `id`
     * const contactUsWithIdOnly = await prisma.contactUs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUsUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactUs.
     * @param {ContactUsUpsertArgs} args - Arguments to update or create a ContactUs.
     * @example
     * // Update or create a ContactUs
     * const contactUs = await prisma.contactUs.upsert({
     *   create: {
     *     // ... data to create a ContactUs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactUs we want to update
     *   }
     * })
     */
    upsert<T extends ContactUsUpsertArgs>(args: SelectSubset<T, ContactUsUpsertArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsCountArgs} args - Arguments to filter Contactuses to count.
     * @example
     * // Count the number of Contactuses
     * const count = await prisma.contactUs.count({
     *   where: {
     *     // ... the filter for the Contactuses we want to count
     *   }
     * })
    **/
    count<T extends ContactUsCountArgs>(
      args?: Subset<T, ContactUsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactUsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactUsAggregateArgs>(args: Subset<T, ContactUsAggregateArgs>): Prisma.PrismaPromise<GetContactUsAggregateType<T>>

    /**
     * Group by ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactUsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactUsGroupByArgs['orderBy'] }
        : { orderBy?: ContactUsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactUsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactUsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactUs model
   */
  readonly fields: ContactUsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactUs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactUsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactUs model
   */
  interface ContactUsFieldRefs {
    readonly id: FieldRef<"ContactUs", 'String'>
    readonly customerName: FieldRef<"ContactUs", 'String'>
    readonly email: FieldRef<"ContactUs", 'String'>
    readonly phone: FieldRef<"ContactUs", 'String'>
    readonly businessType: FieldRef<"ContactUs", 'BusinessType'>
    readonly message: FieldRef<"ContactUs", 'String'>
    readonly note: FieldRef<"ContactUs", 'String'>
    readonly status: FieldRef<"ContactUs", 'ContactStatus'>
    readonly createdAt: FieldRef<"ContactUs", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactUs", 'DateTime'>
    readonly createdBy: FieldRef<"ContactUs", 'String'>
    readonly updatedBy: FieldRef<"ContactUs", 'String'>
    readonly isDeleted: FieldRef<"ContactUs", 'Boolean'>
    readonly deletedAt: FieldRef<"ContactUs", 'DateTime'>
    readonly deletedBy: FieldRef<"ContactUs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContactUs findUnique
   */
  export type ContactUsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs findUniqueOrThrow
   */
  export type ContactUsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs findFirst
   */
  export type ContactUsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactuses.
     */
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * ContactUs findFirstOrThrow
   */
  export type ContactUsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactuses.
     */
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * ContactUs findMany
   */
  export type ContactUsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which Contactuses to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * ContactUs create
   */
  export type ContactUsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactUs.
     */
    data: XOR<ContactUsCreateInput, ContactUsUncheckedCreateInput>
  }

  /**
   * ContactUs createMany
   */
  export type ContactUsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contactuses.
     */
    data: ContactUsCreateManyInput | ContactUsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactUs createManyAndReturn
   */
  export type ContactUsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * The data used to create many Contactuses.
     */
    data: ContactUsCreateManyInput | ContactUsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactUs update
   */
  export type ContactUsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactUs.
     */
    data: XOR<ContactUsUpdateInput, ContactUsUncheckedUpdateInput>
    /**
     * Choose, which ContactUs to update.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs updateMany
   */
  export type ContactUsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contactuses.
     */
    data: XOR<ContactUsUpdateManyMutationInput, ContactUsUncheckedUpdateManyInput>
    /**
     * Filter which Contactuses to update
     */
    where?: ContactUsWhereInput
    /**
     * Limit how many Contactuses to update.
     */
    limit?: number
  }

  /**
   * ContactUs updateManyAndReturn
   */
  export type ContactUsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * The data used to update Contactuses.
     */
    data: XOR<ContactUsUpdateManyMutationInput, ContactUsUncheckedUpdateManyInput>
    /**
     * Filter which Contactuses to update
     */
    where?: ContactUsWhereInput
    /**
     * Limit how many Contactuses to update.
     */
    limit?: number
  }

  /**
   * ContactUs upsert
   */
  export type ContactUsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactUs to update in case it exists.
     */
    where: ContactUsWhereUniqueInput
    /**
     * In case the ContactUs found by the `where` argument doesn't exist, create a new ContactUs with this data.
     */
    create: XOR<ContactUsCreateInput, ContactUsUncheckedCreateInput>
    /**
     * In case the ContactUs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUsUpdateInput, ContactUsUncheckedUpdateInput>
  }

  /**
   * ContactUs delete
   */
  export type ContactUsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter which ContactUs to delete.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs deleteMany
   */
  export type ContactUsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contactuses to delete
     */
    where?: ContactUsWhereInput
    /**
     * Limit how many Contactuses to delete.
     */
    limit?: number
  }

  /**
   * ContactUs without action
   */
  export type ContactUsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
  }


  /**
   * Model BookDemo
   */

  export type AggregateBookDemo = {
    _count: BookDemoCountAggregateOutputType | null
    _min: BookDemoMinAggregateOutputType | null
    _max: BookDemoMaxAggregateOutputType | null
  }

  export type BookDemoMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    businessType: $Enums.BusinessType | null
    message: string | null
    note: string | null
    status: $Enums.DemoStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type BookDemoMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    businessType: $Enums.BusinessType | null
    message: string | null
    note: string | null
    status: $Enums.DemoStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type BookDemoCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    businessType: number
    message: number
    note: number
    status: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type BookDemoMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    businessType?: true
    message?: true
    note?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type BookDemoMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    businessType?: true
    message?: true
    note?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type BookDemoCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    businessType?: true
    message?: true
    note?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type BookDemoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookDemo to aggregate.
     */
    where?: BookDemoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookDemos to fetch.
     */
    orderBy?: BookDemoOrderByWithRelationInput | BookDemoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookDemoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookDemos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookDemos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookDemos
    **/
    _count?: true | BookDemoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookDemoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookDemoMaxAggregateInputType
  }

  export type GetBookDemoAggregateType<T extends BookDemoAggregateArgs> = {
        [P in keyof T & keyof AggregateBookDemo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookDemo[P]>
      : GetScalarType<T[P], AggregateBookDemo[P]>
  }




  export type BookDemoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookDemoWhereInput
    orderBy?: BookDemoOrderByWithAggregationInput | BookDemoOrderByWithAggregationInput[]
    by: BookDemoScalarFieldEnum[] | BookDemoScalarFieldEnum
    having?: BookDemoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookDemoCountAggregateInputType | true
    _min?: BookDemoMinAggregateInputType
    _max?: BookDemoMaxAggregateInputType
  }

  export type BookDemoGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    businessType: $Enums.BusinessType
    message: string
    note: string | null
    status: $Enums.DemoStatus
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: BookDemoCountAggregateOutputType | null
    _min: BookDemoMinAggregateOutputType | null
    _max: BookDemoMaxAggregateOutputType | null
  }

  type GetBookDemoGroupByPayload<T extends BookDemoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookDemoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookDemoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookDemoGroupByOutputType[P]>
            : GetScalarType<T[P], BookDemoGroupByOutputType[P]>
        }
      >
    >


  export type BookDemoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    businessType?: boolean
    message?: boolean
    note?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["bookDemo"]>

  export type BookDemoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    businessType?: boolean
    message?: boolean
    note?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["bookDemo"]>

  export type BookDemoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    businessType?: boolean
    message?: boolean
    note?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["bookDemo"]>

  export type BookDemoSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    businessType?: boolean
    message?: boolean
    note?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type BookDemoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "businessType" | "message" | "note" | "status" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["bookDemo"]>

  export type $BookDemoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookDemo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      businessType: $Enums.BusinessType
      message: string
      note: string | null
      status: $Enums.DemoStatus
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["bookDemo"]>
    composites: {}
  }

  type BookDemoGetPayload<S extends boolean | null | undefined | BookDemoDefaultArgs> = $Result.GetResult<Prisma.$BookDemoPayload, S>

  type BookDemoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookDemoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookDemoCountAggregateInputType | true
    }

  export interface BookDemoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookDemo'], meta: { name: 'BookDemo' } }
    /**
     * Find zero or one BookDemo that matches the filter.
     * @param {BookDemoFindUniqueArgs} args - Arguments to find a BookDemo
     * @example
     * // Get one BookDemo
     * const bookDemo = await prisma.bookDemo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookDemoFindUniqueArgs>(args: SelectSubset<T, BookDemoFindUniqueArgs<ExtArgs>>): Prisma__BookDemoClient<$Result.GetResult<Prisma.$BookDemoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookDemo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookDemoFindUniqueOrThrowArgs} args - Arguments to find a BookDemo
     * @example
     * // Get one BookDemo
     * const bookDemo = await prisma.bookDemo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookDemoFindUniqueOrThrowArgs>(args: SelectSubset<T, BookDemoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookDemoClient<$Result.GetResult<Prisma.$BookDemoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookDemo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookDemoFindFirstArgs} args - Arguments to find a BookDemo
     * @example
     * // Get one BookDemo
     * const bookDemo = await prisma.bookDemo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookDemoFindFirstArgs>(args?: SelectSubset<T, BookDemoFindFirstArgs<ExtArgs>>): Prisma__BookDemoClient<$Result.GetResult<Prisma.$BookDemoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookDemo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookDemoFindFirstOrThrowArgs} args - Arguments to find a BookDemo
     * @example
     * // Get one BookDemo
     * const bookDemo = await prisma.bookDemo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookDemoFindFirstOrThrowArgs>(args?: SelectSubset<T, BookDemoFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookDemoClient<$Result.GetResult<Prisma.$BookDemoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookDemos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookDemoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookDemos
     * const bookDemos = await prisma.bookDemo.findMany()
     * 
     * // Get first 10 BookDemos
     * const bookDemos = await prisma.bookDemo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookDemoWithIdOnly = await prisma.bookDemo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookDemoFindManyArgs>(args?: SelectSubset<T, BookDemoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookDemoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookDemo.
     * @param {BookDemoCreateArgs} args - Arguments to create a BookDemo.
     * @example
     * // Create one BookDemo
     * const BookDemo = await prisma.bookDemo.create({
     *   data: {
     *     // ... data to create a BookDemo
     *   }
     * })
     * 
     */
    create<T extends BookDemoCreateArgs>(args: SelectSubset<T, BookDemoCreateArgs<ExtArgs>>): Prisma__BookDemoClient<$Result.GetResult<Prisma.$BookDemoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookDemos.
     * @param {BookDemoCreateManyArgs} args - Arguments to create many BookDemos.
     * @example
     * // Create many BookDemos
     * const bookDemo = await prisma.bookDemo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookDemoCreateManyArgs>(args?: SelectSubset<T, BookDemoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookDemos and returns the data saved in the database.
     * @param {BookDemoCreateManyAndReturnArgs} args - Arguments to create many BookDemos.
     * @example
     * // Create many BookDemos
     * const bookDemo = await prisma.bookDemo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookDemos and only return the `id`
     * const bookDemoWithIdOnly = await prisma.bookDemo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookDemoCreateManyAndReturnArgs>(args?: SelectSubset<T, BookDemoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookDemoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookDemo.
     * @param {BookDemoDeleteArgs} args - Arguments to delete one BookDemo.
     * @example
     * // Delete one BookDemo
     * const BookDemo = await prisma.bookDemo.delete({
     *   where: {
     *     // ... filter to delete one BookDemo
     *   }
     * })
     * 
     */
    delete<T extends BookDemoDeleteArgs>(args: SelectSubset<T, BookDemoDeleteArgs<ExtArgs>>): Prisma__BookDemoClient<$Result.GetResult<Prisma.$BookDemoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookDemo.
     * @param {BookDemoUpdateArgs} args - Arguments to update one BookDemo.
     * @example
     * // Update one BookDemo
     * const bookDemo = await prisma.bookDemo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookDemoUpdateArgs>(args: SelectSubset<T, BookDemoUpdateArgs<ExtArgs>>): Prisma__BookDemoClient<$Result.GetResult<Prisma.$BookDemoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookDemos.
     * @param {BookDemoDeleteManyArgs} args - Arguments to filter BookDemos to delete.
     * @example
     * // Delete a few BookDemos
     * const { count } = await prisma.bookDemo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookDemoDeleteManyArgs>(args?: SelectSubset<T, BookDemoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookDemos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookDemoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookDemos
     * const bookDemo = await prisma.bookDemo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookDemoUpdateManyArgs>(args: SelectSubset<T, BookDemoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookDemos and returns the data updated in the database.
     * @param {BookDemoUpdateManyAndReturnArgs} args - Arguments to update many BookDemos.
     * @example
     * // Update many BookDemos
     * const bookDemo = await prisma.bookDemo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookDemos and only return the `id`
     * const bookDemoWithIdOnly = await prisma.bookDemo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookDemoUpdateManyAndReturnArgs>(args: SelectSubset<T, BookDemoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookDemoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookDemo.
     * @param {BookDemoUpsertArgs} args - Arguments to update or create a BookDemo.
     * @example
     * // Update or create a BookDemo
     * const bookDemo = await prisma.bookDemo.upsert({
     *   create: {
     *     // ... data to create a BookDemo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookDemo we want to update
     *   }
     * })
     */
    upsert<T extends BookDemoUpsertArgs>(args: SelectSubset<T, BookDemoUpsertArgs<ExtArgs>>): Prisma__BookDemoClient<$Result.GetResult<Prisma.$BookDemoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookDemos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookDemoCountArgs} args - Arguments to filter BookDemos to count.
     * @example
     * // Count the number of BookDemos
     * const count = await prisma.bookDemo.count({
     *   where: {
     *     // ... the filter for the BookDemos we want to count
     *   }
     * })
    **/
    count<T extends BookDemoCountArgs>(
      args?: Subset<T, BookDemoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookDemoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookDemo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookDemoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookDemoAggregateArgs>(args: Subset<T, BookDemoAggregateArgs>): Prisma.PrismaPromise<GetBookDemoAggregateType<T>>

    /**
     * Group by BookDemo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookDemoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookDemoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookDemoGroupByArgs['orderBy'] }
        : { orderBy?: BookDemoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookDemoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookDemoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookDemo model
   */
  readonly fields: BookDemoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookDemo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookDemoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookDemo model
   */
  interface BookDemoFieldRefs {
    readonly id: FieldRef<"BookDemo", 'String'>
    readonly name: FieldRef<"BookDemo", 'String'>
    readonly email: FieldRef<"BookDemo", 'String'>
    readonly phone: FieldRef<"BookDemo", 'String'>
    readonly businessType: FieldRef<"BookDemo", 'BusinessType'>
    readonly message: FieldRef<"BookDemo", 'String'>
    readonly note: FieldRef<"BookDemo", 'String'>
    readonly status: FieldRef<"BookDemo", 'DemoStatus'>
    readonly createdAt: FieldRef<"BookDemo", 'DateTime'>
    readonly updatedAt: FieldRef<"BookDemo", 'DateTime'>
    readonly createdBy: FieldRef<"BookDemo", 'String'>
    readonly updatedBy: FieldRef<"BookDemo", 'String'>
    readonly isDeleted: FieldRef<"BookDemo", 'Boolean'>
    readonly deletedAt: FieldRef<"BookDemo", 'DateTime'>
    readonly deletedBy: FieldRef<"BookDemo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BookDemo findUnique
   */
  export type BookDemoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookDemo
     */
    select?: BookDemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookDemo
     */
    omit?: BookDemoOmit<ExtArgs> | null
    /**
     * Filter, which BookDemo to fetch.
     */
    where: BookDemoWhereUniqueInput
  }

  /**
   * BookDemo findUniqueOrThrow
   */
  export type BookDemoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookDemo
     */
    select?: BookDemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookDemo
     */
    omit?: BookDemoOmit<ExtArgs> | null
    /**
     * Filter, which BookDemo to fetch.
     */
    where: BookDemoWhereUniqueInput
  }

  /**
   * BookDemo findFirst
   */
  export type BookDemoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookDemo
     */
    select?: BookDemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookDemo
     */
    omit?: BookDemoOmit<ExtArgs> | null
    /**
     * Filter, which BookDemo to fetch.
     */
    where?: BookDemoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookDemos to fetch.
     */
    orderBy?: BookDemoOrderByWithRelationInput | BookDemoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookDemos.
     */
    cursor?: BookDemoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookDemos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookDemos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookDemos.
     */
    distinct?: BookDemoScalarFieldEnum | BookDemoScalarFieldEnum[]
  }

  /**
   * BookDemo findFirstOrThrow
   */
  export type BookDemoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookDemo
     */
    select?: BookDemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookDemo
     */
    omit?: BookDemoOmit<ExtArgs> | null
    /**
     * Filter, which BookDemo to fetch.
     */
    where?: BookDemoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookDemos to fetch.
     */
    orderBy?: BookDemoOrderByWithRelationInput | BookDemoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookDemos.
     */
    cursor?: BookDemoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookDemos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookDemos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookDemos.
     */
    distinct?: BookDemoScalarFieldEnum | BookDemoScalarFieldEnum[]
  }

  /**
   * BookDemo findMany
   */
  export type BookDemoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookDemo
     */
    select?: BookDemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookDemo
     */
    omit?: BookDemoOmit<ExtArgs> | null
    /**
     * Filter, which BookDemos to fetch.
     */
    where?: BookDemoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookDemos to fetch.
     */
    orderBy?: BookDemoOrderByWithRelationInput | BookDemoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookDemos.
     */
    cursor?: BookDemoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookDemos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookDemos.
     */
    skip?: number
    distinct?: BookDemoScalarFieldEnum | BookDemoScalarFieldEnum[]
  }

  /**
   * BookDemo create
   */
  export type BookDemoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookDemo
     */
    select?: BookDemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookDemo
     */
    omit?: BookDemoOmit<ExtArgs> | null
    /**
     * The data needed to create a BookDemo.
     */
    data: XOR<BookDemoCreateInput, BookDemoUncheckedCreateInput>
  }

  /**
   * BookDemo createMany
   */
  export type BookDemoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookDemos.
     */
    data: BookDemoCreateManyInput | BookDemoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookDemo createManyAndReturn
   */
  export type BookDemoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookDemo
     */
    select?: BookDemoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookDemo
     */
    omit?: BookDemoOmit<ExtArgs> | null
    /**
     * The data used to create many BookDemos.
     */
    data: BookDemoCreateManyInput | BookDemoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookDemo update
   */
  export type BookDemoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookDemo
     */
    select?: BookDemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookDemo
     */
    omit?: BookDemoOmit<ExtArgs> | null
    /**
     * The data needed to update a BookDemo.
     */
    data: XOR<BookDemoUpdateInput, BookDemoUncheckedUpdateInput>
    /**
     * Choose, which BookDemo to update.
     */
    where: BookDemoWhereUniqueInput
  }

  /**
   * BookDemo updateMany
   */
  export type BookDemoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookDemos.
     */
    data: XOR<BookDemoUpdateManyMutationInput, BookDemoUncheckedUpdateManyInput>
    /**
     * Filter which BookDemos to update
     */
    where?: BookDemoWhereInput
    /**
     * Limit how many BookDemos to update.
     */
    limit?: number
  }

  /**
   * BookDemo updateManyAndReturn
   */
  export type BookDemoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookDemo
     */
    select?: BookDemoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookDemo
     */
    omit?: BookDemoOmit<ExtArgs> | null
    /**
     * The data used to update BookDemos.
     */
    data: XOR<BookDemoUpdateManyMutationInput, BookDemoUncheckedUpdateManyInput>
    /**
     * Filter which BookDemos to update
     */
    where?: BookDemoWhereInput
    /**
     * Limit how many BookDemos to update.
     */
    limit?: number
  }

  /**
   * BookDemo upsert
   */
  export type BookDemoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookDemo
     */
    select?: BookDemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookDemo
     */
    omit?: BookDemoOmit<ExtArgs> | null
    /**
     * The filter to search for the BookDemo to update in case it exists.
     */
    where: BookDemoWhereUniqueInput
    /**
     * In case the BookDemo found by the `where` argument doesn't exist, create a new BookDemo with this data.
     */
    create: XOR<BookDemoCreateInput, BookDemoUncheckedCreateInput>
    /**
     * In case the BookDemo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookDemoUpdateInput, BookDemoUncheckedUpdateInput>
  }

  /**
   * BookDemo delete
   */
  export type BookDemoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookDemo
     */
    select?: BookDemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookDemo
     */
    omit?: BookDemoOmit<ExtArgs> | null
    /**
     * Filter which BookDemo to delete.
     */
    where: BookDemoWhereUniqueInput
  }

  /**
   * BookDemo deleteMany
   */
  export type BookDemoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookDemos to delete
     */
    where?: BookDemoWhereInput
    /**
     * Limit how many BookDemos to delete.
     */
    limit?: number
  }

  /**
   * BookDemo without action
   */
  export type BookDemoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookDemo
     */
    select?: BookDemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookDemo
     */
    omit?: BookDemoOmit<ExtArgs> | null
  }


  /**
   * Model FAQ
   */

  export type AggregateFAQ = {
    _count: FAQCountAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  export type FAQMinAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type FAQMaxAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type FAQCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type FAQMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type FAQMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type FAQCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type FAQAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQ to aggregate.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FAQS
    **/
    _count?: true | FAQCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FAQMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FAQMaxAggregateInputType
  }

  export type GetFAQAggregateType<T extends FAQAggregateArgs> = {
        [P in keyof T & keyof AggregateFAQ]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFAQ[P]>
      : GetScalarType<T[P], AggregateFAQ[P]>
  }




  export type FAQGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQWhereInput
    orderBy?: FAQOrderByWithAggregationInput | FAQOrderByWithAggregationInput[]
    by: FAQScalarFieldEnum[] | FAQScalarFieldEnum
    having?: FAQScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FAQCountAggregateInputType | true
    _min?: FAQMinAggregateInputType
    _max?: FAQMaxAggregateInputType
  }

  export type FAQGroupByOutputType = {
    id: string
    question: string
    answer: string
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: FAQCountAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  type GetFAQGroupByPayload<T extends FAQGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FAQGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FAQGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FAQGroupByOutputType[P]>
            : GetScalarType<T[P], FAQGroupByOutputType[P]>
        }
      >
    >


  export type FAQSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type FAQOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "answer" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["fAQ"]>

  export type $FAQPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FAQ"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      answer: string
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["fAQ"]>
    composites: {}
  }

  type FAQGetPayload<S extends boolean | null | undefined | FAQDefaultArgs> = $Result.GetResult<Prisma.$FAQPayload, S>

  type FAQCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FAQFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FAQCountAggregateInputType | true
    }

  export interface FAQDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FAQ'], meta: { name: 'FAQ' } }
    /**
     * Find zero or one FAQ that matches the filter.
     * @param {FAQFindUniqueArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FAQFindUniqueArgs>(args: SelectSubset<T, FAQFindUniqueArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FAQ that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FAQFindUniqueOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FAQFindUniqueOrThrowArgs>(args: SelectSubset<T, FAQFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FAQ that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FAQFindFirstArgs>(args?: SelectSubset<T, FAQFindFirstArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FAQ that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FAQFindFirstOrThrowArgs>(args?: SelectSubset<T, FAQFindFirstOrThrowArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FAQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FAQS
     * const fAQS = await prisma.fAQ.findMany()
     * 
     * // Get first 10 FAQS
     * const fAQS = await prisma.fAQ.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fAQWithIdOnly = await prisma.fAQ.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FAQFindManyArgs>(args?: SelectSubset<T, FAQFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FAQ.
     * @param {FAQCreateArgs} args - Arguments to create a FAQ.
     * @example
     * // Create one FAQ
     * const FAQ = await prisma.fAQ.create({
     *   data: {
     *     // ... data to create a FAQ
     *   }
     * })
     * 
     */
    create<T extends FAQCreateArgs>(args: SelectSubset<T, FAQCreateArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FAQS.
     * @param {FAQCreateManyArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FAQCreateManyArgs>(args?: SelectSubset<T, FAQCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FAQS and returns the data saved in the database.
     * @param {FAQCreateManyAndReturnArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FAQS and only return the `id`
     * const fAQWithIdOnly = await prisma.fAQ.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FAQCreateManyAndReturnArgs>(args?: SelectSubset<T, FAQCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FAQ.
     * @param {FAQDeleteArgs} args - Arguments to delete one FAQ.
     * @example
     * // Delete one FAQ
     * const FAQ = await prisma.fAQ.delete({
     *   where: {
     *     // ... filter to delete one FAQ
     *   }
     * })
     * 
     */
    delete<T extends FAQDeleteArgs>(args: SelectSubset<T, FAQDeleteArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FAQ.
     * @param {FAQUpdateArgs} args - Arguments to update one FAQ.
     * @example
     * // Update one FAQ
     * const fAQ = await prisma.fAQ.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FAQUpdateArgs>(args: SelectSubset<T, FAQUpdateArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FAQS.
     * @param {FAQDeleteManyArgs} args - Arguments to filter FAQS to delete.
     * @example
     * // Delete a few FAQS
     * const { count } = await prisma.fAQ.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FAQDeleteManyArgs>(args?: SelectSubset<T, FAQDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FAQS
     * const fAQ = await prisma.fAQ.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FAQUpdateManyArgs>(args: SelectSubset<T, FAQUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQS and returns the data updated in the database.
     * @param {FAQUpdateManyAndReturnArgs} args - Arguments to update many FAQS.
     * @example
     * // Update many FAQS
     * const fAQ = await prisma.fAQ.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FAQS and only return the `id`
     * const fAQWithIdOnly = await prisma.fAQ.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FAQUpdateManyAndReturnArgs>(args: SelectSubset<T, FAQUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FAQ.
     * @param {FAQUpsertArgs} args - Arguments to update or create a FAQ.
     * @example
     * // Update or create a FAQ
     * const fAQ = await prisma.fAQ.upsert({
     *   create: {
     *     // ... data to create a FAQ
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FAQ we want to update
     *   }
     * })
     */
    upsert<T extends FAQUpsertArgs>(args: SelectSubset<T, FAQUpsertArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQCountArgs} args - Arguments to filter FAQS to count.
     * @example
     * // Count the number of FAQS
     * const count = await prisma.fAQ.count({
     *   where: {
     *     // ... the filter for the FAQS we want to count
     *   }
     * })
    **/
    count<T extends FAQCountArgs>(
      args?: Subset<T, FAQCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FAQCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FAQAggregateArgs>(args: Subset<T, FAQAggregateArgs>): Prisma.PrismaPromise<GetFAQAggregateType<T>>

    /**
     * Group by FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FAQGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FAQGroupByArgs['orderBy'] }
        : { orderBy?: FAQGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FAQGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFAQGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FAQ model
   */
  readonly fields: FAQFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FAQ.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FAQClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FAQ model
   */
  interface FAQFieldRefs {
    readonly id: FieldRef<"FAQ", 'String'>
    readonly question: FieldRef<"FAQ", 'String'>
    readonly answer: FieldRef<"FAQ", 'String'>
    readonly createdAt: FieldRef<"FAQ", 'DateTime'>
    readonly updatedAt: FieldRef<"FAQ", 'DateTime'>
    readonly createdBy: FieldRef<"FAQ", 'String'>
    readonly updatedBy: FieldRef<"FAQ", 'String'>
    readonly isDeleted: FieldRef<"FAQ", 'Boolean'>
    readonly deletedAt: FieldRef<"FAQ", 'DateTime'>
    readonly deletedBy: FieldRef<"FAQ", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FAQ findUnique
   */
  export type FAQFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ findUniqueOrThrow
   */
  export type FAQFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ findFirst
   */
  export type FAQFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ findFirstOrThrow
   */
  export type FAQFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ findMany
   */
  export type FAQFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQS to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ create
   */
  export type FAQCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The data needed to create a FAQ.
     */
    data: XOR<FAQCreateInput, FAQUncheckedCreateInput>
  }

  /**
   * FAQ createMany
   */
  export type FAQCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FAQ createManyAndReturn
   */
  export type FAQCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FAQ update
   */
  export type FAQUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The data needed to update a FAQ.
     */
    data: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
    /**
     * Choose, which FAQ to update.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ updateMany
   */
  export type FAQUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FAQS.
     */
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyInput>
    /**
     * Filter which FAQS to update
     */
    where?: FAQWhereInput
    /**
     * Limit how many FAQS to update.
     */
    limit?: number
  }

  /**
   * FAQ updateManyAndReturn
   */
  export type FAQUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The data used to update FAQS.
     */
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyInput>
    /**
     * Filter which FAQS to update
     */
    where?: FAQWhereInput
    /**
     * Limit how many FAQS to update.
     */
    limit?: number
  }

  /**
   * FAQ upsert
   */
  export type FAQUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The filter to search for the FAQ to update in case it exists.
     */
    where: FAQWhereUniqueInput
    /**
     * In case the FAQ found by the `where` argument doesn't exist, create a new FAQ with this data.
     */
    create: XOR<FAQCreateInput, FAQUncheckedCreateInput>
    /**
     * In case the FAQ was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
  }

  /**
   * FAQ delete
   */
  export type FAQDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter which FAQ to delete.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ deleteMany
   */
  export type FAQDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQS to delete
     */
    where?: FAQWhereInput
    /**
     * Limit how many FAQS to delete.
     */
    limit?: number
  }

  /**
   * FAQ without action
   */
  export type FAQDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
  }


  /**
   * Model TermsCondition
   */

  export type AggregateTermsCondition = {
    _count: TermsConditionCountAggregateOutputType | null
    _min: TermsConditionMinAggregateOutputType | null
    _max: TermsConditionMaxAggregateOutputType | null
  }

  export type TermsConditionMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type TermsConditionMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type TermsConditionCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type TermsConditionMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type TermsConditionMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type TermsConditionCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type TermsConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TermsCondition to aggregate.
     */
    where?: TermsConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsConditions to fetch.
     */
    orderBy?: TermsConditionOrderByWithRelationInput | TermsConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TermsConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TermsConditions
    **/
    _count?: true | TermsConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TermsConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TermsConditionMaxAggregateInputType
  }

  export type GetTermsConditionAggregateType<T extends TermsConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateTermsCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTermsCondition[P]>
      : GetScalarType<T[P], AggregateTermsCondition[P]>
  }




  export type TermsConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TermsConditionWhereInput
    orderBy?: TermsConditionOrderByWithAggregationInput | TermsConditionOrderByWithAggregationInput[]
    by: TermsConditionScalarFieldEnum[] | TermsConditionScalarFieldEnum
    having?: TermsConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TermsConditionCountAggregateInputType | true
    _min?: TermsConditionMinAggregateInputType
    _max?: TermsConditionMaxAggregateInputType
  }

  export type TermsConditionGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: TermsConditionCountAggregateOutputType | null
    _min: TermsConditionMinAggregateOutputType | null
    _max: TermsConditionMaxAggregateOutputType | null
  }

  type GetTermsConditionGroupByPayload<T extends TermsConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TermsConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TermsConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TermsConditionGroupByOutputType[P]>
            : GetScalarType<T[P], TermsConditionGroupByOutputType[P]>
        }
      >
    >


  export type TermsConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["termsCondition"]>

  export type TermsConditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["termsCondition"]>

  export type TermsConditionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["termsCondition"]>

  export type TermsConditionSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type TermsConditionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["termsCondition"]>

  export type $TermsConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TermsCondition"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["termsCondition"]>
    composites: {}
  }

  type TermsConditionGetPayload<S extends boolean | null | undefined | TermsConditionDefaultArgs> = $Result.GetResult<Prisma.$TermsConditionPayload, S>

  type TermsConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TermsConditionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TermsConditionCountAggregateInputType | true
    }

  export interface TermsConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TermsCondition'], meta: { name: 'TermsCondition' } }
    /**
     * Find zero or one TermsCondition that matches the filter.
     * @param {TermsConditionFindUniqueArgs} args - Arguments to find a TermsCondition
     * @example
     * // Get one TermsCondition
     * const termsCondition = await prisma.termsCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TermsConditionFindUniqueArgs>(args: SelectSubset<T, TermsConditionFindUniqueArgs<ExtArgs>>): Prisma__TermsConditionClient<$Result.GetResult<Prisma.$TermsConditionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TermsCondition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TermsConditionFindUniqueOrThrowArgs} args - Arguments to find a TermsCondition
     * @example
     * // Get one TermsCondition
     * const termsCondition = await prisma.termsCondition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TermsConditionFindUniqueOrThrowArgs>(args: SelectSubset<T, TermsConditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TermsConditionClient<$Result.GetResult<Prisma.$TermsConditionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TermsCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionFindFirstArgs} args - Arguments to find a TermsCondition
     * @example
     * // Get one TermsCondition
     * const termsCondition = await prisma.termsCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TermsConditionFindFirstArgs>(args?: SelectSubset<T, TermsConditionFindFirstArgs<ExtArgs>>): Prisma__TermsConditionClient<$Result.GetResult<Prisma.$TermsConditionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TermsCondition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionFindFirstOrThrowArgs} args - Arguments to find a TermsCondition
     * @example
     * // Get one TermsCondition
     * const termsCondition = await prisma.termsCondition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TermsConditionFindFirstOrThrowArgs>(args?: SelectSubset<T, TermsConditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TermsConditionClient<$Result.GetResult<Prisma.$TermsConditionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TermsConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TermsConditions
     * const termsConditions = await prisma.termsCondition.findMany()
     * 
     * // Get first 10 TermsConditions
     * const termsConditions = await prisma.termsCondition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const termsConditionWithIdOnly = await prisma.termsCondition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TermsConditionFindManyArgs>(args?: SelectSubset<T, TermsConditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermsConditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TermsCondition.
     * @param {TermsConditionCreateArgs} args - Arguments to create a TermsCondition.
     * @example
     * // Create one TermsCondition
     * const TermsCondition = await prisma.termsCondition.create({
     *   data: {
     *     // ... data to create a TermsCondition
     *   }
     * })
     * 
     */
    create<T extends TermsConditionCreateArgs>(args: SelectSubset<T, TermsConditionCreateArgs<ExtArgs>>): Prisma__TermsConditionClient<$Result.GetResult<Prisma.$TermsConditionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TermsConditions.
     * @param {TermsConditionCreateManyArgs} args - Arguments to create many TermsConditions.
     * @example
     * // Create many TermsConditions
     * const termsCondition = await prisma.termsCondition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TermsConditionCreateManyArgs>(args?: SelectSubset<T, TermsConditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TermsConditions and returns the data saved in the database.
     * @param {TermsConditionCreateManyAndReturnArgs} args - Arguments to create many TermsConditions.
     * @example
     * // Create many TermsConditions
     * const termsCondition = await prisma.termsCondition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TermsConditions and only return the `id`
     * const termsConditionWithIdOnly = await prisma.termsCondition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TermsConditionCreateManyAndReturnArgs>(args?: SelectSubset<T, TermsConditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermsConditionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TermsCondition.
     * @param {TermsConditionDeleteArgs} args - Arguments to delete one TermsCondition.
     * @example
     * // Delete one TermsCondition
     * const TermsCondition = await prisma.termsCondition.delete({
     *   where: {
     *     // ... filter to delete one TermsCondition
     *   }
     * })
     * 
     */
    delete<T extends TermsConditionDeleteArgs>(args: SelectSubset<T, TermsConditionDeleteArgs<ExtArgs>>): Prisma__TermsConditionClient<$Result.GetResult<Prisma.$TermsConditionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TermsCondition.
     * @param {TermsConditionUpdateArgs} args - Arguments to update one TermsCondition.
     * @example
     * // Update one TermsCondition
     * const termsCondition = await prisma.termsCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TermsConditionUpdateArgs>(args: SelectSubset<T, TermsConditionUpdateArgs<ExtArgs>>): Prisma__TermsConditionClient<$Result.GetResult<Prisma.$TermsConditionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TermsConditions.
     * @param {TermsConditionDeleteManyArgs} args - Arguments to filter TermsConditions to delete.
     * @example
     * // Delete a few TermsConditions
     * const { count } = await prisma.termsCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TermsConditionDeleteManyArgs>(args?: SelectSubset<T, TermsConditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TermsConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TermsConditions
     * const termsCondition = await prisma.termsCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TermsConditionUpdateManyArgs>(args: SelectSubset<T, TermsConditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TermsConditions and returns the data updated in the database.
     * @param {TermsConditionUpdateManyAndReturnArgs} args - Arguments to update many TermsConditions.
     * @example
     * // Update many TermsConditions
     * const termsCondition = await prisma.termsCondition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TermsConditions and only return the `id`
     * const termsConditionWithIdOnly = await prisma.termsCondition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TermsConditionUpdateManyAndReturnArgs>(args: SelectSubset<T, TermsConditionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermsConditionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TermsCondition.
     * @param {TermsConditionUpsertArgs} args - Arguments to update or create a TermsCondition.
     * @example
     * // Update or create a TermsCondition
     * const termsCondition = await prisma.termsCondition.upsert({
     *   create: {
     *     // ... data to create a TermsCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TermsCondition we want to update
     *   }
     * })
     */
    upsert<T extends TermsConditionUpsertArgs>(args: SelectSubset<T, TermsConditionUpsertArgs<ExtArgs>>): Prisma__TermsConditionClient<$Result.GetResult<Prisma.$TermsConditionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TermsConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionCountArgs} args - Arguments to filter TermsConditions to count.
     * @example
     * // Count the number of TermsConditions
     * const count = await prisma.termsCondition.count({
     *   where: {
     *     // ... the filter for the TermsConditions we want to count
     *   }
     * })
    **/
    count<T extends TermsConditionCountArgs>(
      args?: Subset<T, TermsConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermsConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TermsCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TermsConditionAggregateArgs>(args: Subset<T, TermsConditionAggregateArgs>): Prisma.PrismaPromise<GetTermsConditionAggregateType<T>>

    /**
     * Group by TermsCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TermsConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermsConditionGroupByArgs['orderBy'] }
        : { orderBy?: TermsConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TermsConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTermsConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TermsCondition model
   */
  readonly fields: TermsConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TermsCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermsConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TermsCondition model
   */
  interface TermsConditionFieldRefs {
    readonly id: FieldRef<"TermsCondition", 'String'>
    readonly content: FieldRef<"TermsCondition", 'String'>
    readonly createdAt: FieldRef<"TermsCondition", 'DateTime'>
    readonly updatedAt: FieldRef<"TermsCondition", 'DateTime'>
    readonly createdBy: FieldRef<"TermsCondition", 'String'>
    readonly updatedBy: FieldRef<"TermsCondition", 'String'>
    readonly isDeleted: FieldRef<"TermsCondition", 'Boolean'>
    readonly deletedAt: FieldRef<"TermsCondition", 'DateTime'>
    readonly deletedBy: FieldRef<"TermsCondition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TermsCondition findUnique
   */
  export type TermsConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsCondition
     */
    select?: TermsConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsCondition
     */
    omit?: TermsConditionOmit<ExtArgs> | null
    /**
     * Filter, which TermsCondition to fetch.
     */
    where: TermsConditionWhereUniqueInput
  }

  /**
   * TermsCondition findUniqueOrThrow
   */
  export type TermsConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsCondition
     */
    select?: TermsConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsCondition
     */
    omit?: TermsConditionOmit<ExtArgs> | null
    /**
     * Filter, which TermsCondition to fetch.
     */
    where: TermsConditionWhereUniqueInput
  }

  /**
   * TermsCondition findFirst
   */
  export type TermsConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsCondition
     */
    select?: TermsConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsCondition
     */
    omit?: TermsConditionOmit<ExtArgs> | null
    /**
     * Filter, which TermsCondition to fetch.
     */
    where?: TermsConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsConditions to fetch.
     */
    orderBy?: TermsConditionOrderByWithRelationInput | TermsConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TermsConditions.
     */
    cursor?: TermsConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TermsConditions.
     */
    distinct?: TermsConditionScalarFieldEnum | TermsConditionScalarFieldEnum[]
  }

  /**
   * TermsCondition findFirstOrThrow
   */
  export type TermsConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsCondition
     */
    select?: TermsConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsCondition
     */
    omit?: TermsConditionOmit<ExtArgs> | null
    /**
     * Filter, which TermsCondition to fetch.
     */
    where?: TermsConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsConditions to fetch.
     */
    orderBy?: TermsConditionOrderByWithRelationInput | TermsConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TermsConditions.
     */
    cursor?: TermsConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TermsConditions.
     */
    distinct?: TermsConditionScalarFieldEnum | TermsConditionScalarFieldEnum[]
  }

  /**
   * TermsCondition findMany
   */
  export type TermsConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsCondition
     */
    select?: TermsConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsCondition
     */
    omit?: TermsConditionOmit<ExtArgs> | null
    /**
     * Filter, which TermsConditions to fetch.
     */
    where?: TermsConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsConditions to fetch.
     */
    orderBy?: TermsConditionOrderByWithRelationInput | TermsConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TermsConditions.
     */
    cursor?: TermsConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsConditions.
     */
    skip?: number
    distinct?: TermsConditionScalarFieldEnum | TermsConditionScalarFieldEnum[]
  }

  /**
   * TermsCondition create
   */
  export type TermsConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsCondition
     */
    select?: TermsConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsCondition
     */
    omit?: TermsConditionOmit<ExtArgs> | null
    /**
     * The data needed to create a TermsCondition.
     */
    data: XOR<TermsConditionCreateInput, TermsConditionUncheckedCreateInput>
  }

  /**
   * TermsCondition createMany
   */
  export type TermsConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TermsConditions.
     */
    data: TermsConditionCreateManyInput | TermsConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TermsCondition createManyAndReturn
   */
  export type TermsConditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsCondition
     */
    select?: TermsConditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TermsCondition
     */
    omit?: TermsConditionOmit<ExtArgs> | null
    /**
     * The data used to create many TermsConditions.
     */
    data: TermsConditionCreateManyInput | TermsConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TermsCondition update
   */
  export type TermsConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsCondition
     */
    select?: TermsConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsCondition
     */
    omit?: TermsConditionOmit<ExtArgs> | null
    /**
     * The data needed to update a TermsCondition.
     */
    data: XOR<TermsConditionUpdateInput, TermsConditionUncheckedUpdateInput>
    /**
     * Choose, which TermsCondition to update.
     */
    where: TermsConditionWhereUniqueInput
  }

  /**
   * TermsCondition updateMany
   */
  export type TermsConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TermsConditions.
     */
    data: XOR<TermsConditionUpdateManyMutationInput, TermsConditionUncheckedUpdateManyInput>
    /**
     * Filter which TermsConditions to update
     */
    where?: TermsConditionWhereInput
    /**
     * Limit how many TermsConditions to update.
     */
    limit?: number
  }

  /**
   * TermsCondition updateManyAndReturn
   */
  export type TermsConditionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsCondition
     */
    select?: TermsConditionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TermsCondition
     */
    omit?: TermsConditionOmit<ExtArgs> | null
    /**
     * The data used to update TermsConditions.
     */
    data: XOR<TermsConditionUpdateManyMutationInput, TermsConditionUncheckedUpdateManyInput>
    /**
     * Filter which TermsConditions to update
     */
    where?: TermsConditionWhereInput
    /**
     * Limit how many TermsConditions to update.
     */
    limit?: number
  }

  /**
   * TermsCondition upsert
   */
  export type TermsConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsCondition
     */
    select?: TermsConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsCondition
     */
    omit?: TermsConditionOmit<ExtArgs> | null
    /**
     * The filter to search for the TermsCondition to update in case it exists.
     */
    where: TermsConditionWhereUniqueInput
    /**
     * In case the TermsCondition found by the `where` argument doesn't exist, create a new TermsCondition with this data.
     */
    create: XOR<TermsConditionCreateInput, TermsConditionUncheckedCreateInput>
    /**
     * In case the TermsCondition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermsConditionUpdateInput, TermsConditionUncheckedUpdateInput>
  }

  /**
   * TermsCondition delete
   */
  export type TermsConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsCondition
     */
    select?: TermsConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsCondition
     */
    omit?: TermsConditionOmit<ExtArgs> | null
    /**
     * Filter which TermsCondition to delete.
     */
    where: TermsConditionWhereUniqueInput
  }

  /**
   * TermsCondition deleteMany
   */
  export type TermsConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TermsConditions to delete
     */
    where?: TermsConditionWhereInput
    /**
     * Limit how many TermsConditions to delete.
     */
    limit?: number
  }

  /**
   * TermsCondition without action
   */
  export type TermsConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsCondition
     */
    select?: TermsConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsCondition
     */
    omit?: TermsConditionOmit<ExtArgs> | null
  }


  /**
   * Model PrivacyPolicy
   */

  export type AggregatePrivacyPolicy = {
    _count: PrivacyPolicyCountAggregateOutputType | null
    _min: PrivacyPolicyMinAggregateOutputType | null
    _max: PrivacyPolicyMaxAggregateOutputType | null
  }

  export type PrivacyPolicyMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type PrivacyPolicyMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type PrivacyPolicyCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type PrivacyPolicyMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type PrivacyPolicyMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type PrivacyPolicyCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type PrivacyPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivacyPolicy to aggregate.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrivacyPolicies
    **/
    _count?: true | PrivacyPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivacyPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivacyPolicyMaxAggregateInputType
  }

  export type GetPrivacyPolicyAggregateType<T extends PrivacyPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivacyPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivacyPolicy[P]>
      : GetScalarType<T[P], AggregatePrivacyPolicy[P]>
  }




  export type PrivacyPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivacyPolicyWhereInput
    orderBy?: PrivacyPolicyOrderByWithAggregationInput | PrivacyPolicyOrderByWithAggregationInput[]
    by: PrivacyPolicyScalarFieldEnum[] | PrivacyPolicyScalarFieldEnum
    having?: PrivacyPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivacyPolicyCountAggregateInputType | true
    _min?: PrivacyPolicyMinAggregateInputType
    _max?: PrivacyPolicyMaxAggregateInputType
  }

  export type PrivacyPolicyGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: PrivacyPolicyCountAggregateOutputType | null
    _min: PrivacyPolicyMinAggregateOutputType | null
    _max: PrivacyPolicyMaxAggregateOutputType | null
  }

  type GetPrivacyPolicyGroupByPayload<T extends PrivacyPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivacyPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivacyPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivacyPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PrivacyPolicyGroupByOutputType[P]>
        }
      >
    >


  export type PrivacyPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["privacyPolicy"]>

  export type PrivacyPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["privacyPolicy"]>

  export type PrivacyPolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["privacyPolicy"]>

  export type PrivacyPolicySelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type PrivacyPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "isDeleted" | "deletedAt" | "deletedBy", ExtArgs["result"]["privacyPolicy"]>

  export type $PrivacyPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrivacyPolicy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["privacyPolicy"]>
    composites: {}
  }

  type PrivacyPolicyGetPayload<S extends boolean | null | undefined | PrivacyPolicyDefaultArgs> = $Result.GetResult<Prisma.$PrivacyPolicyPayload, S>

  type PrivacyPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivacyPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivacyPolicyCountAggregateInputType | true
    }

  export interface PrivacyPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivacyPolicy'], meta: { name: 'PrivacyPolicy' } }
    /**
     * Find zero or one PrivacyPolicy that matches the filter.
     * @param {PrivacyPolicyFindUniqueArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivacyPolicyFindUniqueArgs>(args: SelectSubset<T, PrivacyPolicyFindUniqueArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrivacyPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivacyPolicyFindUniqueOrThrowArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivacyPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivacyPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivacyPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyFindFirstArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivacyPolicyFindFirstArgs>(args?: SelectSubset<T, PrivacyPolicyFindFirstArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivacyPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyFindFirstOrThrowArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivacyPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivacyPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrivacyPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrivacyPolicies
     * const privacyPolicies = await prisma.privacyPolicy.findMany()
     * 
     * // Get first 10 PrivacyPolicies
     * const privacyPolicies = await prisma.privacyPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privacyPolicyWithIdOnly = await prisma.privacyPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivacyPolicyFindManyArgs>(args?: SelectSubset<T, PrivacyPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrivacyPolicy.
     * @param {PrivacyPolicyCreateArgs} args - Arguments to create a PrivacyPolicy.
     * @example
     * // Create one PrivacyPolicy
     * const PrivacyPolicy = await prisma.privacyPolicy.create({
     *   data: {
     *     // ... data to create a PrivacyPolicy
     *   }
     * })
     * 
     */
    create<T extends PrivacyPolicyCreateArgs>(args: SelectSubset<T, PrivacyPolicyCreateArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrivacyPolicies.
     * @param {PrivacyPolicyCreateManyArgs} args - Arguments to create many PrivacyPolicies.
     * @example
     * // Create many PrivacyPolicies
     * const privacyPolicy = await prisma.privacyPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivacyPolicyCreateManyArgs>(args?: SelectSubset<T, PrivacyPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrivacyPolicies and returns the data saved in the database.
     * @param {PrivacyPolicyCreateManyAndReturnArgs} args - Arguments to create many PrivacyPolicies.
     * @example
     * // Create many PrivacyPolicies
     * const privacyPolicy = await prisma.privacyPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrivacyPolicies and only return the `id`
     * const privacyPolicyWithIdOnly = await prisma.privacyPolicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrivacyPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, PrivacyPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrivacyPolicy.
     * @param {PrivacyPolicyDeleteArgs} args - Arguments to delete one PrivacyPolicy.
     * @example
     * // Delete one PrivacyPolicy
     * const PrivacyPolicy = await prisma.privacyPolicy.delete({
     *   where: {
     *     // ... filter to delete one PrivacyPolicy
     *   }
     * })
     * 
     */
    delete<T extends PrivacyPolicyDeleteArgs>(args: SelectSubset<T, PrivacyPolicyDeleteArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrivacyPolicy.
     * @param {PrivacyPolicyUpdateArgs} args - Arguments to update one PrivacyPolicy.
     * @example
     * // Update one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivacyPolicyUpdateArgs>(args: SelectSubset<T, PrivacyPolicyUpdateArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrivacyPolicies.
     * @param {PrivacyPolicyDeleteManyArgs} args - Arguments to filter PrivacyPolicies to delete.
     * @example
     * // Delete a few PrivacyPolicies
     * const { count } = await prisma.privacyPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivacyPolicyDeleteManyArgs>(args?: SelectSubset<T, PrivacyPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivacyPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrivacyPolicies
     * const privacyPolicy = await prisma.privacyPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivacyPolicyUpdateManyArgs>(args: SelectSubset<T, PrivacyPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivacyPolicies and returns the data updated in the database.
     * @param {PrivacyPolicyUpdateManyAndReturnArgs} args - Arguments to update many PrivacyPolicies.
     * @example
     * // Update many PrivacyPolicies
     * const privacyPolicy = await prisma.privacyPolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrivacyPolicies and only return the `id`
     * const privacyPolicyWithIdOnly = await prisma.privacyPolicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrivacyPolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, PrivacyPolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrivacyPolicy.
     * @param {PrivacyPolicyUpsertArgs} args - Arguments to update or create a PrivacyPolicy.
     * @example
     * // Update or create a PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.upsert({
     *   create: {
     *     // ... data to create a PrivacyPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrivacyPolicy we want to update
     *   }
     * })
     */
    upsert<T extends PrivacyPolicyUpsertArgs>(args: SelectSubset<T, PrivacyPolicyUpsertArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrivacyPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyCountArgs} args - Arguments to filter PrivacyPolicies to count.
     * @example
     * // Count the number of PrivacyPolicies
     * const count = await prisma.privacyPolicy.count({
     *   where: {
     *     // ... the filter for the PrivacyPolicies we want to count
     *   }
     * })
    **/
    count<T extends PrivacyPolicyCountArgs>(
      args?: Subset<T, PrivacyPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivacyPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrivacyPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivacyPolicyAggregateArgs>(args: Subset<T, PrivacyPolicyAggregateArgs>): Prisma.PrismaPromise<GetPrivacyPolicyAggregateType<T>>

    /**
     * Group by PrivacyPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivacyPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivacyPolicyGroupByArgs['orderBy'] }
        : { orderBy?: PrivacyPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivacyPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivacyPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrivacyPolicy model
   */
  readonly fields: PrivacyPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrivacyPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivacyPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrivacyPolicy model
   */
  interface PrivacyPolicyFieldRefs {
    readonly id: FieldRef<"PrivacyPolicy", 'String'>
    readonly content: FieldRef<"PrivacyPolicy", 'String'>
    readonly createdAt: FieldRef<"PrivacyPolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"PrivacyPolicy", 'DateTime'>
    readonly createdBy: FieldRef<"PrivacyPolicy", 'String'>
    readonly updatedBy: FieldRef<"PrivacyPolicy", 'String'>
    readonly isDeleted: FieldRef<"PrivacyPolicy", 'Boolean'>
    readonly deletedAt: FieldRef<"PrivacyPolicy", 'DateTime'>
    readonly deletedBy: FieldRef<"PrivacyPolicy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PrivacyPolicy findUnique
   */
  export type PrivacyPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy findUniqueOrThrow
   */
  export type PrivacyPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy findFirst
   */
  export type PrivacyPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivacyPolicies.
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivacyPolicies.
     */
    distinct?: PrivacyPolicyScalarFieldEnum | PrivacyPolicyScalarFieldEnum[]
  }

  /**
   * PrivacyPolicy findFirstOrThrow
   */
  export type PrivacyPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivacyPolicies.
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivacyPolicies.
     */
    distinct?: PrivacyPolicyScalarFieldEnum | PrivacyPolicyScalarFieldEnum[]
  }

  /**
   * PrivacyPolicy findMany
   */
  export type PrivacyPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicies to fetch.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrivacyPolicies.
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    distinct?: PrivacyPolicyScalarFieldEnum | PrivacyPolicyScalarFieldEnum[]
  }

  /**
   * PrivacyPolicy create
   */
  export type PrivacyPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * The data needed to create a PrivacyPolicy.
     */
    data: XOR<PrivacyPolicyCreateInput, PrivacyPolicyUncheckedCreateInput>
  }

  /**
   * PrivacyPolicy createMany
   */
  export type PrivacyPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrivacyPolicies.
     */
    data: PrivacyPolicyCreateManyInput | PrivacyPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivacyPolicy createManyAndReturn
   */
  export type PrivacyPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * The data used to create many PrivacyPolicies.
     */
    data: PrivacyPolicyCreateManyInput | PrivacyPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivacyPolicy update
   */
  export type PrivacyPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * The data needed to update a PrivacyPolicy.
     */
    data: XOR<PrivacyPolicyUpdateInput, PrivacyPolicyUncheckedUpdateInput>
    /**
     * Choose, which PrivacyPolicy to update.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy updateMany
   */
  export type PrivacyPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrivacyPolicies.
     */
    data: XOR<PrivacyPolicyUpdateManyMutationInput, PrivacyPolicyUncheckedUpdateManyInput>
    /**
     * Filter which PrivacyPolicies to update
     */
    where?: PrivacyPolicyWhereInput
    /**
     * Limit how many PrivacyPolicies to update.
     */
    limit?: number
  }

  /**
   * PrivacyPolicy updateManyAndReturn
   */
  export type PrivacyPolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * The data used to update PrivacyPolicies.
     */
    data: XOR<PrivacyPolicyUpdateManyMutationInput, PrivacyPolicyUncheckedUpdateManyInput>
    /**
     * Filter which PrivacyPolicies to update
     */
    where?: PrivacyPolicyWhereInput
    /**
     * Limit how many PrivacyPolicies to update.
     */
    limit?: number
  }

  /**
   * PrivacyPolicy upsert
   */
  export type PrivacyPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * The filter to search for the PrivacyPolicy to update in case it exists.
     */
    where: PrivacyPolicyWhereUniqueInput
    /**
     * In case the PrivacyPolicy found by the `where` argument doesn't exist, create a new PrivacyPolicy with this data.
     */
    create: XOR<PrivacyPolicyCreateInput, PrivacyPolicyUncheckedCreateInput>
    /**
     * In case the PrivacyPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivacyPolicyUpdateInput, PrivacyPolicyUncheckedUpdateInput>
  }

  /**
   * PrivacyPolicy delete
   */
  export type PrivacyPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter which PrivacyPolicy to delete.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy deleteMany
   */
  export type PrivacyPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivacyPolicies to delete
     */
    where?: PrivacyPolicyWhereInput
    /**
     * Limit how many PrivacyPolicies to delete.
     */
    limit?: number
  }

  /**
   * PrivacyPolicy without action
   */
  export type PrivacyPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    userName: string | null
    userRole: $Enums.UserRole | null
    action: $Enums.AlertAction | null
    activity: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    userName: string | null
    userRole: $Enums.UserRole | null
    action: $Enums.AlertAction | null
    activity: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    userName: number
    userRole: number
    action: number
    activity: number
    isRead: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    userName?: true
    userRole?: true
    action?: true
    activity?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    userName?: true
    userRole?: true
    action?: true
    activity?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    userName?: true
    userRole?: true
    action?: true
    activity?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    userName: string
    userRole: $Enums.UserRole
    action: $Enums.AlertAction
    activity: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    userId: string | null
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    userRole?: boolean
    action?: boolean
    activity?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    userRole?: boolean
    action?: boolean
    activity?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    userRole?: boolean
    action?: boolean
    activity?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    userName?: boolean
    userRole?: boolean
    action?: boolean
    activity?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type AlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userName" | "userRole" | "action" | "activity" | "isRead" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["alert"]>

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userName: string
      userRole: $Enums.UserRole
      action: $Enums.AlertAction
      activity: string
      isRead: boolean
      createdAt: Date
      updatedAt: Date
      userId: string | null
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {AlertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts and returns the data updated in the database.
     * @param {AlertUpdateManyAndReturnArgs} args - Arguments to update many Alerts.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlertUpdateManyAndReturnArgs>(args: SelectSubset<T, AlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly userName: FieldRef<"Alert", 'String'>
    readonly userRole: FieldRef<"Alert", 'UserRole'>
    readonly action: FieldRef<"Alert", 'AlertAction'>
    readonly activity: FieldRef<"Alert", 'String'>
    readonly isRead: FieldRef<"Alert", 'Boolean'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
    readonly updatedAt: FieldRef<"Alert", 'DateTime'>
    readonly userId: FieldRef<"Alert", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert createManyAndReturn
   */
  export type AlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to update.
     */
    limit?: number
  }

  /**
   * Alert updateManyAndReturn
   */
  export type AlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to update.
     */
    limit?: number
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to delete.
     */
    limit?: number
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    phone: 'phone',
    role: 'role',
    branchId: 'branchId',
    subscriberId: 'subscriberId',
    imageUrl: 'imageUrl',
    isActive: 'isActive',
    availability: 'availability',
    usesBranchSchedule: 'usesBranchSchedule',
    managerId: 'managerId',
    x: 'x',
    instagram: 'instagram',
    fb: 'fb',
    whatsapp: 'whatsapp',
    language: 'language',
    isLoggedIn: 'isLoggedIn',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MaintenanceSettingScalarFieldEnum: {
    id: 'id',
    isEnabled: 'isEnabled',
    updatedById: 'updatedById',
    updatedByName: 'updatedByName',
    updatedByRole: 'updatedByRole',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type MaintenanceSettingScalarFieldEnum = (typeof MaintenanceSettingScalarFieldEnum)[keyof typeof MaintenanceSettingScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    description: 'description',
    price: 'price',
    noOfBranches: 'noOfBranches',
    noOfAdmins: 'noOfAdmins',
    noOfStaffManagers: 'noOfStaffManagers',
    noOfServiceProviders: 'noOfServiceProviders',
    noOfReceptionists: 'noOfReceptionists',
    whatsappBot: 'whatsappBot',
    manualReminder: 'manualReminder',
    automatedReminder: 'automatedReminder',
    googleReviewLink: 'googleReviewLink',
    promotions: 'promotions',
    selfServiceTablet: 'selfServiceTablet',
    basicDashboard: 'basicDashboard',
    fullAccessDashboard: 'fullAccessDashboard',
    subscriberId: 'subscriberId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const SubscriberSubscriptionScalarFieldEnum: {
    id: 'id',
    subscriberId: 'subscriberId',
    subscriptionId: 'subscriptionId',
    type: 'type',
    validity: 'validity',
    price: 'price',
    features: 'features',
    startDate: 'startDate',
    businessId: 'businessId',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type SubscriberSubscriptionScalarFieldEnum = (typeof SubscriberSubscriptionScalarFieldEnum)[keyof typeof SubscriberSubscriptionScalarFieldEnum]


  export const DiscountScalarFieldEnum: {
    id: 'id',
    code: 'code',
    group: 'group',
    packageType: 'packageType',
    discountType: 'discountType',
    value: 'value',
    usageLimit: 'usageLimit',
    usageCount: 'usageCount',
    startDate: 'startDate',
    expiryDate: 'expiryDate',
    isManuallyExpired: 'isManuallyExpired',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type DiscountScalarFieldEnum = (typeof DiscountScalarFieldEnum)[keyof typeof DiscountScalarFieldEnum]


  export const SubscriptionDiscountLogScalarFieldEnum: {
    id: 'id',
    subscriberSubscriptionId: 'subscriberSubscriptionId',
    discountId: 'discountId',
    discountCode: 'discountCode',
    discountType: 'discountType',
    discountValue: 'discountValue',
    discountedAmount: 'discountedAmount',
    originalPrice: 'originalPrice',
    finalPrice: 'finalPrice',
    appliedAt: 'appliedAt',
    createdBy: 'createdBy'
  };

  export type SubscriptionDiscountLogScalarFieldEnum = (typeof SubscriptionDiscountLogScalarFieldEnum)[keyof typeof SubscriptionDiscountLogScalarFieldEnum]


  export const BusinessScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    name: 'name',
    image: 'image',
    websiteLink: 'websiteLink',
    phoneNumber: 'phoneNumber',
    businessType: 'businessType',
    subscriptionId: 'subscriptionId',
    subscriptionType: 'subscriptionType',
    subscriptionPrice: 'subscriptionPrice',
    subscriptionValidity: 'subscriptionValidity',
    discountCodeId: 'discountCodeId',
    subscriberId: 'subscriberId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type BusinessScalarFieldEnum = (typeof BusinessScalarFieldEnum)[keyof typeof BusinessScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subscriberId: 'subscriberId',
    businessId: 'businessId',
    location: 'location',
    phone: 'phone',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const ScheduleHourScalarFieldEnum: {
    id: 'id',
    ownerType: 'ownerType',
    ownerId: 'ownerId',
    dayOfWeek: 'dayOfWeek',
    openTime: 'openTime',
    closeTime: 'closeTime',
    isClosed: 'isClosed',
    inheritanceMode: 'inheritanceMode',
    staffId: 'staffId',
    businessId: 'businessId',
    branchId: 'branchId',
    lastModifiedBy: 'lastModifiedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type ScheduleHourScalarFieldEnum = (typeof ScheduleHourScalarFieldEnum)[keyof typeof ScheduleHourScalarFieldEnum]


  export const StaffStatusLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    timestamp: 'timestamp'
  };

  export type StaffStatusLogScalarFieldEnum = (typeof StaffStatusLogScalarFieldEnum)[keyof typeof StaffStatusLogScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    staffId: 'staffId',
    date: 'date',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const VacationScalarFieldEnum: {
    id: 'id',
    staffId: 'staffId',
    startDate: 'startDate',
    endDate: 'endDate',
    reason: 'reason',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type VacationScalarFieldEnum = (typeof VacationScalarFieldEnum)[keyof typeof VacationScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    providerId: 'providerId',
    duration: 'duration',
    price: 'price',
    bufferTime: 'bufferTime',
    status: 'status',
    frequency: 'frequency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const UserOnServiceScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    providerId: 'providerId'
  };

  export type UserOnServiceScalarFieldEnum = (typeof UserOnServiceScalarFieldEnum)[keyof typeof UserOnServiceScalarFieldEnum]


  export const ServiceBranchScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    branchId: 'branchId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type ServiceBranchScalarFieldEnum = (typeof ServiceBranchScalarFieldEnum)[keyof typeof ServiceBranchScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    consumerId: 'consumerId',
    branchId: 'branchId',
    serviceProviderId: 'serviceProviderId',
    appointmentTime: 'appointmentTime',
    appointmentDate: 'appointmentDate',
    appointmentTimeSlot: 'appointmentTimeSlot',
    reminderMinutesBefore: 'reminderMinutesBefore',
    discountId: 'discountId',
    note: 'note',
    status: 'status',
    bookingType: 'bookingType',
    review: 'review',
    rating: 'rating',
    isManual: 'isManual',
    price: 'price',
    subscriberSubscriptionId: 'subscriberSubscriptionId',
    promotionId: 'promotionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    value: 'value',
    limit: 'limit',
    status: 'status',
    startDate: 'startDate',
    expiryDate: 'expiryDate',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const TabletAccountScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    branchId: 'branchId',
    loginLink: 'loginLink',
    loginToken: 'loginToken',
    isActive: 'isActive',
    isLoggedIn: 'isLoggedIn',
    lastActivityAt: 'lastActivityAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type TabletAccountScalarFieldEnum = (typeof TabletAccountScalarFieldEnum)[keyof typeof TabletAccountScalarFieldEnum]


  export const WhatsappAdScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    targetDate: 'targetDate',
    customerType: 'customerType',
    branchId: 'branchId',
    serviceId: 'serviceId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type WhatsappAdScalarFieldEnum = (typeof WhatsappAdScalarFieldEnum)[keyof typeof WhatsappAdScalarFieldEnum]


  export const WhatsAppNumberScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    phoneNumber: 'phoneNumber',
    phoneNumberId: 'phoneNumberId',
    wabaId: 'wabaId',
    accessToken: 'accessToken',
    isVerified: 'isVerified',
    defaultFlowId: 'defaultFlowId',
    otp: 'otp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted'
  };

  export type WhatsAppNumberScalarFieldEnum = (typeof WhatsAppNumberScalarFieldEnum)[keyof typeof WhatsAppNumberScalarFieldEnum]


  export const FlowScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isActive: 'isActive',
    businessId: 'businessId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    DeletedBy: 'DeletedBy',
    DeletedAt: 'DeletedAt',
    isDeleted: 'isDeleted'
  };

  export type FlowScalarFieldEnum = (typeof FlowScalarFieldEnum)[keyof typeof FlowScalarFieldEnum]


  export const StepScalarFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    order: 'order',
    type: 'type',
    message: 'message',
    dynamicSource: 'dynamicSource',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    DeletedBy: 'DeletedBy',
    DeletedAt: 'DeletedAt',
    isDeleted: 'isDeleted'
  };

  export type StepScalarFieldEnum = (typeof StepScalarFieldEnum)[keyof typeof StepScalarFieldEnum]


  export const StepOptionScalarFieldEnum: {
    id: 'id',
    stepId: 'stepId',
    label: 'label',
    value: 'value',
    nextStepId: 'nextStepId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    DeletedBy: 'DeletedBy',
    DeletedAt: 'DeletedAt',
    isDeleted: 'isDeleted'
  };

  export type StepOptionScalarFieldEnum = (typeof StepOptionScalarFieldEnum)[keyof typeof StepOptionScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    flowId: 'flowId',
    currentStepId: 'currentStepId',
    isCompleted: 'isCompleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    DeletedBy: 'DeletedBy',
    DeletedAt: 'DeletedAt',
    isDeleted: 'isDeleted'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    stepId: 'stepId',
    message: 'message',
    direction: 'direction',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const ContactUsScalarFieldEnum: {
    id: 'id',
    customerName: 'customerName',
    email: 'email',
    phone: 'phone',
    businessType: 'businessType',
    message: 'message',
    note: 'note',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type ContactUsScalarFieldEnum = (typeof ContactUsScalarFieldEnum)[keyof typeof ContactUsScalarFieldEnum]


  export const BookDemoScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    businessType: 'businessType',
    message: 'message',
    note: 'note',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type BookDemoScalarFieldEnum = (typeof BookDemoScalarFieldEnum)[keyof typeof BookDemoScalarFieldEnum]


  export const FAQScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type FAQScalarFieldEnum = (typeof FAQScalarFieldEnum)[keyof typeof FAQScalarFieldEnum]


  export const TermsConditionScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type TermsConditionScalarFieldEnum = (typeof TermsConditionScalarFieldEnum)[keyof typeof TermsConditionScalarFieldEnum]


  export const PrivacyPolicyScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type PrivacyPolicyScalarFieldEnum = (typeof PrivacyPolicyScalarFieldEnum)[keyof typeof PrivacyPolicyScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    userName: 'userName',
    userRole: 'userRole',
    action: 'action',
    activity: 'activity',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SubscriptionType'
   */
  export type EnumSubscriptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionType'>
    


  /**
   * Reference to a field of type 'SubscriptionType[]'
   */
  export type ListEnumSubscriptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'SubscriptionValidity'
   */
  export type EnumSubscriptionValidityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionValidity'>
    


  /**
   * Reference to a field of type 'SubscriptionValidity[]'
   */
  export type ListEnumSubscriptionValidityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionValidity[]'>
    


  /**
   * Reference to a field of type 'DiscountGroup'
   */
  export type EnumDiscountGroupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountGroup'>
    


  /**
   * Reference to a field of type 'DiscountGroup[]'
   */
  export type ListEnumDiscountGroupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountGroup[]'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'DiscountType[]'
   */
  export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


  /**
   * Reference to a field of type 'BusinessType'
   */
  export type EnumBusinessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusinessType'>
    


  /**
   * Reference to a field of type 'BusinessType[]'
   */
  export type ListEnumBusinessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusinessType[]'>
    


  /**
   * Reference to a field of type 'BusinessStatus'
   */
  export type EnumBusinessStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusinessStatus'>
    


  /**
   * Reference to a field of type 'BusinessStatus[]'
   */
  export type ListEnumBusinessStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusinessStatus[]'>
    


  /**
   * Reference to a field of type 'ScheduleOwnerType'
   */
  export type EnumScheduleOwnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleOwnerType'>
    


  /**
   * Reference to a field of type 'ScheduleOwnerType[]'
   */
  export type ListEnumScheduleOwnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleOwnerType[]'>
    


  /**
   * Reference to a field of type 'WeekDay'
   */
  export type EnumWeekDayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeekDay'>
    


  /**
   * Reference to a field of type 'WeekDay[]'
   */
  export type ListEnumWeekDayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeekDay[]'>
    


  /**
   * Reference to a field of type 'ScheduleInheritanceMode'
   */
  export type EnumScheduleInheritanceModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleInheritanceMode'>
    


  /**
   * Reference to a field of type 'ScheduleInheritanceMode[]'
   */
  export type ListEnumScheduleInheritanceModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleInheritanceMode[]'>
    


  /**
   * Reference to a field of type 'StaffStatus'
   */
  export type EnumStaffStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaffStatus'>
    


  /**
   * Reference to a field of type 'StaffStatus[]'
   */
  export type ListEnumStaffStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaffStatus[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'VacationStatus'
   */
  export type EnumVacationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VacationStatus'>
    


  /**
   * Reference to a field of type 'VacationStatus[]'
   */
  export type ListEnumVacationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VacationStatus[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'AppointmentBookingType'
   */
  export type EnumAppointmentBookingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentBookingType'>
    


  /**
   * Reference to a field of type 'AppointmentBookingType[]'
   */
  export type ListEnumAppointmentBookingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentBookingType[]'>
    


  /**
   * Reference to a field of type 'AdTargetType'
   */
  export type EnumAdTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdTargetType'>
    


  /**
   * Reference to a field of type 'AdTargetType[]'
   */
  export type ListEnumAdTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdTargetType[]'>
    


  /**
   * Reference to a field of type 'AdStatus'
   */
  export type EnumAdStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdStatus'>
    


  /**
   * Reference to a field of type 'AdStatus[]'
   */
  export type ListEnumAdStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdStatus[]'>
    


  /**
   * Reference to a field of type 'StepType'
   */
  export type EnumStepTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StepType'>
    


  /**
   * Reference to a field of type 'StepType[]'
   */
  export type ListEnumStepTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StepType[]'>
    


  /**
   * Reference to a field of type 'DynamicSource'
   */
  export type EnumDynamicSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DynamicSource'>
    


  /**
   * Reference to a field of type 'DynamicSource[]'
   */
  export type ListEnumDynamicSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DynamicSource[]'>
    


  /**
   * Reference to a field of type 'ContactStatus'
   */
  export type EnumContactStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactStatus'>
    


  /**
   * Reference to a field of type 'ContactStatus[]'
   */
  export type ListEnumContactStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactStatus[]'>
    


  /**
   * Reference to a field of type 'DemoStatus'
   */
  export type EnumDemoStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DemoStatus'>
    


  /**
   * Reference to a field of type 'DemoStatus[]'
   */
  export type ListEnumDemoStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DemoStatus[]'>
    


  /**
   * Reference to a field of type 'AlertAction'
   */
  export type EnumAlertActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertAction'>
    


  /**
   * Reference to a field of type 'AlertAction[]'
   */
  export type ListEnumAlertActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertAction[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    branchId?: StringNullableFilter<"User"> | string | null
    subscriberId?: StringNullableFilter<"User"> | string | null
    imageUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    availability?: JsonNullableFilter<"User">
    usesBranchSchedule?: BoolFilter<"User"> | boolean
    managerId?: StringNullableFilter<"User"> | string | null
    x?: StringNullableFilter<"User"> | string | null
    instagram?: StringNullableFilter<"User"> | string | null
    fb?: StringNullableFilter<"User"> | string | null
    whatsapp?: StringNullableFilter<"User"> | string | null
    language?: StringNullableFilter<"User"> | string | null
    isLoggedIn?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdBy?: StringNullableFilter<"User"> | string | null
    updatedBy?: StringNullableFilter<"User"> | string | null
    isDeleted?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedBy?: StringNullableFilter<"User"> | string | null
    subscriber?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subscriberMembers?: UserListRelationFilter
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    services?: UserOnServiceListRelationFilter
    appointmentsAsConsumer?: AppointmentListRelationFilter
    appointmentsAsProvider?: AppointmentListRelationFilter
    businesses?: BusinessListRelationFilter
    ownedBranches?: BranchListRelationFilter
    subscriberSubscriptions?: SubscriberSubscriptionListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    assignedWhatsappAds?: WhatsappAdListRelationFilter
    scheduleHours?: ScheduleHourListRelationFilter
    sessions?: SessionListRelationFilter
    attendanceRecords?: AttendanceListRelationFilter
    vacations?: VacationListRelationFilter
    staffMembers?: UserListRelationFilter
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    statusLogs?: StaffStatusLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    branchId?: SortOrderInput | SortOrder
    subscriberId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    availability?: SortOrderInput | SortOrder
    usesBranchSchedule?: SortOrder
    managerId?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    fb?: SortOrderInput | SortOrder
    whatsapp?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    isLoggedIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    subscriber?: UserOrderByWithRelationInput
    subscriberMembers?: UserOrderByRelationAggregateInput
    branch?: BranchOrderByWithRelationInput
    services?: UserOnServiceOrderByRelationAggregateInput
    appointmentsAsConsumer?: AppointmentOrderByRelationAggregateInput
    appointmentsAsProvider?: AppointmentOrderByRelationAggregateInput
    businesses?: BusinessOrderByRelationAggregateInput
    ownedBranches?: BranchOrderByRelationAggregateInput
    subscriberSubscriptions?: SubscriberSubscriptionOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    assignedWhatsappAds?: WhatsappAdOrderByRelationAggregateInput
    scheduleHours?: ScheduleHourOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    attendanceRecords?: AttendanceOrderByRelationAggregateInput
    vacations?: VacationOrderByRelationAggregateInput
    staffMembers?: UserOrderByRelationAggregateInput
    manager?: UserOrderByWithRelationInput
    statusLogs?: StaffStatusLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    branchId?: StringNullableFilter<"User"> | string | null
    subscriberId?: StringNullableFilter<"User"> | string | null
    imageUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    availability?: JsonNullableFilter<"User">
    usesBranchSchedule?: BoolFilter<"User"> | boolean
    managerId?: StringNullableFilter<"User"> | string | null
    x?: StringNullableFilter<"User"> | string | null
    instagram?: StringNullableFilter<"User"> | string | null
    fb?: StringNullableFilter<"User"> | string | null
    whatsapp?: StringNullableFilter<"User"> | string | null
    language?: StringNullableFilter<"User"> | string | null
    isLoggedIn?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdBy?: StringNullableFilter<"User"> | string | null
    updatedBy?: StringNullableFilter<"User"> | string | null
    isDeleted?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedBy?: StringNullableFilter<"User"> | string | null
    subscriber?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subscriberMembers?: UserListRelationFilter
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    services?: UserOnServiceListRelationFilter
    appointmentsAsConsumer?: AppointmentListRelationFilter
    appointmentsAsProvider?: AppointmentListRelationFilter
    businesses?: BusinessListRelationFilter
    ownedBranches?: BranchListRelationFilter
    subscriberSubscriptions?: SubscriberSubscriptionListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    assignedWhatsappAds?: WhatsappAdListRelationFilter
    scheduleHours?: ScheduleHourListRelationFilter
    sessions?: SessionListRelationFilter
    attendanceRecords?: AttendanceListRelationFilter
    vacations?: VacationListRelationFilter
    staffMembers?: UserListRelationFilter
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    statusLogs?: StaffStatusLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    branchId?: SortOrderInput | SortOrder
    subscriberId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    availability?: SortOrderInput | SortOrder
    usesBranchSchedule?: SortOrder
    managerId?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    fb?: SortOrderInput | SortOrder
    whatsapp?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    isLoggedIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    branchId?: StringNullableWithAggregatesFilter<"User"> | string | null
    subscriberId?: StringNullableWithAggregatesFilter<"User"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    availability?: JsonNullableWithAggregatesFilter<"User">
    usesBranchSchedule?: BoolWithAggregatesFilter<"User"> | boolean
    managerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    x?: StringNullableWithAggregatesFilter<"User"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"User"> | string | null
    fb?: StringNullableWithAggregatesFilter<"User"> | string | null
    whatsapp?: StringNullableWithAggregatesFilter<"User"> | string | null
    language?: StringNullableWithAggregatesFilter<"User"> | string | null
    isLoggedIn?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"User"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type MaintenanceSettingWhereInput = {
    AND?: MaintenanceSettingWhereInput | MaintenanceSettingWhereInput[]
    OR?: MaintenanceSettingWhereInput[]
    NOT?: MaintenanceSettingWhereInput | MaintenanceSettingWhereInput[]
    id?: StringFilter<"MaintenanceSetting"> | string
    isEnabled?: BoolFilter<"MaintenanceSetting"> | boolean
    updatedById?: StringNullableFilter<"MaintenanceSetting"> | string | null
    updatedByName?: StringNullableFilter<"MaintenanceSetting"> | string | null
    updatedByRole?: EnumUserRoleNullableFilter<"MaintenanceSetting"> | $Enums.UserRole | null
    createdAt?: DateTimeFilter<"MaintenanceSetting"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceSetting"> | Date | string
    createdBy?: StringNullableFilter<"MaintenanceSetting"> | string | null
    updatedBy?: StringNullableFilter<"MaintenanceSetting"> | string | null
    isDeleted?: BoolFilter<"MaintenanceSetting"> | boolean
    deletedAt?: DateTimeNullableFilter<"MaintenanceSetting"> | Date | string | null
    deletedBy?: StringNullableFilter<"MaintenanceSetting"> | string | null
  }

  export type MaintenanceSettingOrderByWithRelationInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    updatedByName?: SortOrderInput | SortOrder
    updatedByRole?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
  }

  export type MaintenanceSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceSettingWhereInput | MaintenanceSettingWhereInput[]
    OR?: MaintenanceSettingWhereInput[]
    NOT?: MaintenanceSettingWhereInput | MaintenanceSettingWhereInput[]
    isEnabled?: BoolFilter<"MaintenanceSetting"> | boolean
    updatedById?: StringNullableFilter<"MaintenanceSetting"> | string | null
    updatedByName?: StringNullableFilter<"MaintenanceSetting"> | string | null
    updatedByRole?: EnumUserRoleNullableFilter<"MaintenanceSetting"> | $Enums.UserRole | null
    createdAt?: DateTimeFilter<"MaintenanceSetting"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceSetting"> | Date | string
    createdBy?: StringNullableFilter<"MaintenanceSetting"> | string | null
    updatedBy?: StringNullableFilter<"MaintenanceSetting"> | string | null
    isDeleted?: BoolFilter<"MaintenanceSetting"> | boolean
    deletedAt?: DateTimeNullableFilter<"MaintenanceSetting"> | Date | string | null
    deletedBy?: StringNullableFilter<"MaintenanceSetting"> | string | null
  }, "id">

  export type MaintenanceSettingOrderByWithAggregationInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    updatedByName?: SortOrderInput | SortOrder
    updatedByRole?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: MaintenanceSettingCountOrderByAggregateInput
    _max?: MaintenanceSettingMaxOrderByAggregateInput
    _min?: MaintenanceSettingMinOrderByAggregateInput
  }

  export type MaintenanceSettingScalarWhereWithAggregatesInput = {
    AND?: MaintenanceSettingScalarWhereWithAggregatesInput | MaintenanceSettingScalarWhereWithAggregatesInput[]
    OR?: MaintenanceSettingScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceSettingScalarWhereWithAggregatesInput | MaintenanceSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceSetting"> | string
    isEnabled?: BoolWithAggregatesFilter<"MaintenanceSetting"> | boolean
    updatedById?: StringNullableWithAggregatesFilter<"MaintenanceSetting"> | string | null
    updatedByName?: StringNullableWithAggregatesFilter<"MaintenanceSetting"> | string | null
    updatedByRole?: EnumUserRoleNullableWithAggregatesFilter<"MaintenanceSetting"> | $Enums.UserRole | null
    createdAt?: DateTimeWithAggregatesFilter<"MaintenanceSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaintenanceSetting"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"MaintenanceSetting"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"MaintenanceSetting"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"MaintenanceSetting"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"MaintenanceSetting"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"MaintenanceSetting"> | string | null
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    type?: EnumSubscriptionTypeFilter<"Subscription"> | $Enums.SubscriptionType
    description?: StringFilter<"Subscription"> | string
    price?: FloatFilter<"Subscription"> | number
    noOfBranches?: IntFilter<"Subscription"> | number
    noOfAdmins?: IntFilter<"Subscription"> | number
    noOfStaffManagers?: IntFilter<"Subscription"> | number
    noOfServiceProviders?: IntFilter<"Subscription"> | number
    noOfReceptionists?: IntFilter<"Subscription"> | number
    whatsappBot?: BoolFilter<"Subscription"> | boolean
    manualReminder?: BoolFilter<"Subscription"> | boolean
    automatedReminder?: BoolFilter<"Subscription"> | boolean
    googleReviewLink?: BoolFilter<"Subscription"> | boolean
    promotions?: BoolFilter<"Subscription"> | boolean
    selfServiceTablet?: BoolFilter<"Subscription"> | boolean
    basicDashboard?: BoolFilter<"Subscription"> | boolean
    fullAccessDashboard?: BoolFilter<"Subscription"> | boolean
    subscriberId?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    createdBy?: StringNullableFilter<"Subscription"> | string | null
    updatedBy?: StringNullableFilter<"Subscription"> | string | null
    isDeleted?: BoolFilter<"Subscription"> | boolean
    deletedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    deletedBy?: StringNullableFilter<"Subscription"> | string | null
    subscriber?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subscriberSubscriptions?: SubscriberSubscriptionListRelationFilter
    businesses?: BusinessListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    price?: SortOrder
    noOfBranches?: SortOrder
    noOfAdmins?: SortOrder
    noOfStaffManagers?: SortOrder
    noOfServiceProviders?: SortOrder
    noOfReceptionists?: SortOrder
    whatsappBot?: SortOrder
    manualReminder?: SortOrder
    automatedReminder?: SortOrder
    googleReviewLink?: SortOrder
    promotions?: SortOrder
    selfServiceTablet?: SortOrder
    basicDashboard?: SortOrder
    fullAccessDashboard?: SortOrder
    subscriberId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    subscriber?: UserOrderByWithRelationInput
    subscriberSubscriptions?: SubscriberSubscriptionOrderByRelationAggregateInput
    businesses?: BusinessOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subscriberId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    type?: EnumSubscriptionTypeFilter<"Subscription"> | $Enums.SubscriptionType
    description?: StringFilter<"Subscription"> | string
    price?: FloatFilter<"Subscription"> | number
    noOfBranches?: IntFilter<"Subscription"> | number
    noOfAdmins?: IntFilter<"Subscription"> | number
    noOfStaffManagers?: IntFilter<"Subscription"> | number
    noOfServiceProviders?: IntFilter<"Subscription"> | number
    noOfReceptionists?: IntFilter<"Subscription"> | number
    whatsappBot?: BoolFilter<"Subscription"> | boolean
    manualReminder?: BoolFilter<"Subscription"> | boolean
    automatedReminder?: BoolFilter<"Subscription"> | boolean
    googleReviewLink?: BoolFilter<"Subscription"> | boolean
    promotions?: BoolFilter<"Subscription"> | boolean
    selfServiceTablet?: BoolFilter<"Subscription"> | boolean
    basicDashboard?: BoolFilter<"Subscription"> | boolean
    fullAccessDashboard?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    createdBy?: StringNullableFilter<"Subscription"> | string | null
    updatedBy?: StringNullableFilter<"Subscription"> | string | null
    isDeleted?: BoolFilter<"Subscription"> | boolean
    deletedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    deletedBy?: StringNullableFilter<"Subscription"> | string | null
    subscriber?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subscriberSubscriptions?: SubscriberSubscriptionListRelationFilter
    businesses?: BusinessListRelationFilter
  }, "id" | "subscriberId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    price?: SortOrder
    noOfBranches?: SortOrder
    noOfAdmins?: SortOrder
    noOfStaffManagers?: SortOrder
    noOfServiceProviders?: SortOrder
    noOfReceptionists?: SortOrder
    whatsappBot?: SortOrder
    manualReminder?: SortOrder
    automatedReminder?: SortOrder
    googleReviewLink?: SortOrder
    promotions?: SortOrder
    selfServiceTablet?: SortOrder
    basicDashboard?: SortOrder
    fullAccessDashboard?: SortOrder
    subscriberId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    type?: EnumSubscriptionTypeWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionType
    description?: StringWithAggregatesFilter<"Subscription"> | string
    price?: FloatWithAggregatesFilter<"Subscription"> | number
    noOfBranches?: IntWithAggregatesFilter<"Subscription"> | number
    noOfAdmins?: IntWithAggregatesFilter<"Subscription"> | number
    noOfStaffManagers?: IntWithAggregatesFilter<"Subscription"> | number
    noOfServiceProviders?: IntWithAggregatesFilter<"Subscription"> | number
    noOfReceptionists?: IntWithAggregatesFilter<"Subscription"> | number
    whatsappBot?: BoolWithAggregatesFilter<"Subscription"> | boolean
    manualReminder?: BoolWithAggregatesFilter<"Subscription"> | boolean
    automatedReminder?: BoolWithAggregatesFilter<"Subscription"> | boolean
    googleReviewLink?: BoolWithAggregatesFilter<"Subscription"> | boolean
    promotions?: BoolWithAggregatesFilter<"Subscription"> | boolean
    selfServiceTablet?: BoolWithAggregatesFilter<"Subscription"> | boolean
    basicDashboard?: BoolWithAggregatesFilter<"Subscription"> | boolean
    fullAccessDashboard?: BoolWithAggregatesFilter<"Subscription"> | boolean
    subscriberId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Subscription"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
  }

  export type SubscriberSubscriptionWhereInput = {
    AND?: SubscriberSubscriptionWhereInput | SubscriberSubscriptionWhereInput[]
    OR?: SubscriberSubscriptionWhereInput[]
    NOT?: SubscriberSubscriptionWhereInput | SubscriberSubscriptionWhereInput[]
    id?: StringFilter<"SubscriberSubscription"> | string
    subscriberId?: StringFilter<"SubscriberSubscription"> | string
    subscriptionId?: StringFilter<"SubscriberSubscription"> | string
    type?: EnumSubscriptionTypeFilter<"SubscriberSubscription"> | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFilter<"SubscriberSubscription"> | $Enums.SubscriptionValidity
    price?: FloatFilter<"SubscriberSubscription"> | number
    features?: JsonFilter<"SubscriberSubscription">
    startDate?: DateTimeFilter<"SubscriberSubscription"> | Date | string
    businessId?: StringNullableFilter<"SubscriberSubscription"> | string | null
    endDate?: DateTimeNullableFilter<"SubscriberSubscription"> | Date | string | null
    isActive?: BoolFilter<"SubscriberSubscription"> | boolean
    createdAt?: DateTimeFilter<"SubscriberSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriberSubscription"> | Date | string
    createdBy?: StringNullableFilter<"SubscriberSubscription"> | string | null
    updatedBy?: StringNullableFilter<"SubscriberSubscription"> | string | null
    isDeleted?: BoolFilter<"SubscriberSubscription"> | boolean
    deletedAt?: DateTimeNullableFilter<"SubscriberSubscription"> | Date | string | null
    deletedBy?: StringNullableFilter<"SubscriberSubscription"> | string | null
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    subscriber?: XOR<UserScalarRelationFilter, UserWhereInput>
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
    appointments?: AppointmentListRelationFilter
    discountLogs?: SubscriptionDiscountLogListRelationFilter
  }

  export type SubscriberSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    subscriptionId?: SortOrder
    type?: SortOrder
    validity?: SortOrder
    price?: SortOrder
    features?: SortOrder
    startDate?: SortOrder
    businessId?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    business?: BusinessOrderByWithRelationInput
    subscriber?: UserOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    discountLogs?: SubscriptionDiscountLogOrderByRelationAggregateInput
  }

  export type SubscriberSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriberSubscriptionWhereInput | SubscriberSubscriptionWhereInput[]
    OR?: SubscriberSubscriptionWhereInput[]
    NOT?: SubscriberSubscriptionWhereInput | SubscriberSubscriptionWhereInput[]
    subscriberId?: StringFilter<"SubscriberSubscription"> | string
    subscriptionId?: StringFilter<"SubscriberSubscription"> | string
    type?: EnumSubscriptionTypeFilter<"SubscriberSubscription"> | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFilter<"SubscriberSubscription"> | $Enums.SubscriptionValidity
    price?: FloatFilter<"SubscriberSubscription"> | number
    features?: JsonFilter<"SubscriberSubscription">
    startDate?: DateTimeFilter<"SubscriberSubscription"> | Date | string
    businessId?: StringNullableFilter<"SubscriberSubscription"> | string | null
    endDate?: DateTimeNullableFilter<"SubscriberSubscription"> | Date | string | null
    isActive?: BoolFilter<"SubscriberSubscription"> | boolean
    createdAt?: DateTimeFilter<"SubscriberSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriberSubscription"> | Date | string
    createdBy?: StringNullableFilter<"SubscriberSubscription"> | string | null
    updatedBy?: StringNullableFilter<"SubscriberSubscription"> | string | null
    isDeleted?: BoolFilter<"SubscriberSubscription"> | boolean
    deletedAt?: DateTimeNullableFilter<"SubscriberSubscription"> | Date | string | null
    deletedBy?: StringNullableFilter<"SubscriberSubscription"> | string | null
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    subscriber?: XOR<UserScalarRelationFilter, UserWhereInput>
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
    appointments?: AppointmentListRelationFilter
    discountLogs?: SubscriptionDiscountLogListRelationFilter
  }, "id">

  export type SubscriberSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    subscriptionId?: SortOrder
    type?: SortOrder
    validity?: SortOrder
    price?: SortOrder
    features?: SortOrder
    startDate?: SortOrder
    businessId?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: SubscriberSubscriptionCountOrderByAggregateInput
    _avg?: SubscriberSubscriptionAvgOrderByAggregateInput
    _max?: SubscriberSubscriptionMaxOrderByAggregateInput
    _min?: SubscriberSubscriptionMinOrderByAggregateInput
    _sum?: SubscriberSubscriptionSumOrderByAggregateInput
  }

  export type SubscriberSubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriberSubscriptionScalarWhereWithAggregatesInput | SubscriberSubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriberSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriberSubscriptionScalarWhereWithAggregatesInput | SubscriberSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriberSubscription"> | string
    subscriberId?: StringWithAggregatesFilter<"SubscriberSubscription"> | string
    subscriptionId?: StringWithAggregatesFilter<"SubscriberSubscription"> | string
    type?: EnumSubscriptionTypeWithAggregatesFilter<"SubscriberSubscription"> | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityWithAggregatesFilter<"SubscriberSubscription"> | $Enums.SubscriptionValidity
    price?: FloatWithAggregatesFilter<"SubscriberSubscription"> | number
    features?: JsonWithAggregatesFilter<"SubscriberSubscription">
    startDate?: DateTimeWithAggregatesFilter<"SubscriberSubscription"> | Date | string
    businessId?: StringNullableWithAggregatesFilter<"SubscriberSubscription"> | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"SubscriberSubscription"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"SubscriberSubscription"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SubscriberSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriberSubscription"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"SubscriberSubscription"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"SubscriberSubscription"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"SubscriberSubscription"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"SubscriberSubscription"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"SubscriberSubscription"> | string | null
  }

  export type DiscountWhereInput = {
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    id?: StringFilter<"Discount"> | string
    code?: StringFilter<"Discount"> | string
    group?: EnumDiscountGroupFilter<"Discount"> | $Enums.DiscountGroup
    packageType?: EnumSubscriptionTypeFilter<"Discount"> | $Enums.SubscriptionType
    discountType?: EnumDiscountTypeFilter<"Discount"> | $Enums.DiscountType
    value?: FloatFilter<"Discount"> | number
    usageLimit?: IntNullableFilter<"Discount"> | number | null
    usageCount?: IntFilter<"Discount"> | number
    startDate?: DateTimeFilter<"Discount"> | Date | string
    expiryDate?: DateTimeFilter<"Discount"> | Date | string
    isManuallyExpired?: BoolFilter<"Discount"> | boolean
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    updatedAt?: DateTimeFilter<"Discount"> | Date | string
    createdBy?: StringNullableFilter<"Discount"> | string | null
    updatedBy?: StringNullableFilter<"Discount"> | string | null
    isDeleted?: BoolFilter<"Discount"> | boolean
    deletedAt?: DateTimeNullableFilter<"Discount"> | Date | string | null
    deletedBy?: StringNullableFilter<"Discount"> | string | null
    businesses?: BusinessListRelationFilter
    appointments?: AppointmentListRelationFilter
    subscriptionDiscountLogs?: SubscriptionDiscountLogListRelationFilter
  }

  export type DiscountOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    group?: SortOrder
    packageType?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    isManuallyExpired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    businesses?: BusinessOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    subscriptionDiscountLogs?: SubscriptionDiscountLogOrderByRelationAggregateInput
  }

  export type DiscountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    group?: EnumDiscountGroupFilter<"Discount"> | $Enums.DiscountGroup
    packageType?: EnumSubscriptionTypeFilter<"Discount"> | $Enums.SubscriptionType
    discountType?: EnumDiscountTypeFilter<"Discount"> | $Enums.DiscountType
    value?: FloatFilter<"Discount"> | number
    usageLimit?: IntNullableFilter<"Discount"> | number | null
    usageCount?: IntFilter<"Discount"> | number
    startDate?: DateTimeFilter<"Discount"> | Date | string
    expiryDate?: DateTimeFilter<"Discount"> | Date | string
    isManuallyExpired?: BoolFilter<"Discount"> | boolean
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    updatedAt?: DateTimeFilter<"Discount"> | Date | string
    createdBy?: StringNullableFilter<"Discount"> | string | null
    updatedBy?: StringNullableFilter<"Discount"> | string | null
    isDeleted?: BoolFilter<"Discount"> | boolean
    deletedAt?: DateTimeNullableFilter<"Discount"> | Date | string | null
    deletedBy?: StringNullableFilter<"Discount"> | string | null
    businesses?: BusinessListRelationFilter
    appointments?: AppointmentListRelationFilter
    subscriptionDiscountLogs?: SubscriptionDiscountLogListRelationFilter
  }, "id" | "code">

  export type DiscountOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    group?: SortOrder
    packageType?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    isManuallyExpired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: DiscountCountOrderByAggregateInput
    _avg?: DiscountAvgOrderByAggregateInput
    _max?: DiscountMaxOrderByAggregateInput
    _min?: DiscountMinOrderByAggregateInput
    _sum?: DiscountSumOrderByAggregateInput
  }

  export type DiscountScalarWhereWithAggregatesInput = {
    AND?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    OR?: DiscountScalarWhereWithAggregatesInput[]
    NOT?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Discount"> | string
    code?: StringWithAggregatesFilter<"Discount"> | string
    group?: EnumDiscountGroupWithAggregatesFilter<"Discount"> | $Enums.DiscountGroup
    packageType?: EnumSubscriptionTypeWithAggregatesFilter<"Discount"> | $Enums.SubscriptionType
    discountType?: EnumDiscountTypeWithAggregatesFilter<"Discount"> | $Enums.DiscountType
    value?: FloatWithAggregatesFilter<"Discount"> | number
    usageLimit?: IntNullableWithAggregatesFilter<"Discount"> | number | null
    usageCount?: IntWithAggregatesFilter<"Discount"> | number
    startDate?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
    expiryDate?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
    isManuallyExpired?: BoolWithAggregatesFilter<"Discount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Discount"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Discount"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Discount"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Discount"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Discount"> | string | null
  }

  export type SubscriptionDiscountLogWhereInput = {
    AND?: SubscriptionDiscountLogWhereInput | SubscriptionDiscountLogWhereInput[]
    OR?: SubscriptionDiscountLogWhereInput[]
    NOT?: SubscriptionDiscountLogWhereInput | SubscriptionDiscountLogWhereInput[]
    id?: StringFilter<"SubscriptionDiscountLog"> | string
    subscriberSubscriptionId?: StringFilter<"SubscriptionDiscountLog"> | string
    discountId?: StringFilter<"SubscriptionDiscountLog"> | string
    discountCode?: StringFilter<"SubscriptionDiscountLog"> | string
    discountType?: EnumDiscountTypeFilter<"SubscriptionDiscountLog"> | $Enums.DiscountType
    discountValue?: FloatFilter<"SubscriptionDiscountLog"> | number
    discountedAmount?: FloatFilter<"SubscriptionDiscountLog"> | number
    originalPrice?: FloatFilter<"SubscriptionDiscountLog"> | number
    finalPrice?: FloatFilter<"SubscriptionDiscountLog"> | number
    appliedAt?: DateTimeFilter<"SubscriptionDiscountLog"> | Date | string
    createdBy?: StringNullableFilter<"SubscriptionDiscountLog"> | string | null
    subscriberSubscription?: XOR<SubscriberSubscriptionScalarRelationFilter, SubscriberSubscriptionWhereInput>
    discount?: XOR<DiscountScalarRelationFilter, DiscountWhereInput>
  }

  export type SubscriptionDiscountLogOrderByWithRelationInput = {
    id?: SortOrder
    subscriberSubscriptionId?: SortOrder
    discountId?: SortOrder
    discountCode?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountedAmount?: SortOrder
    originalPrice?: SortOrder
    finalPrice?: SortOrder
    appliedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    subscriberSubscription?: SubscriberSubscriptionOrderByWithRelationInput
    discount?: DiscountOrderByWithRelationInput
  }

  export type SubscriptionDiscountLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionDiscountLogWhereInput | SubscriptionDiscountLogWhereInput[]
    OR?: SubscriptionDiscountLogWhereInput[]
    NOT?: SubscriptionDiscountLogWhereInput | SubscriptionDiscountLogWhereInput[]
    subscriberSubscriptionId?: StringFilter<"SubscriptionDiscountLog"> | string
    discountId?: StringFilter<"SubscriptionDiscountLog"> | string
    discountCode?: StringFilter<"SubscriptionDiscountLog"> | string
    discountType?: EnumDiscountTypeFilter<"SubscriptionDiscountLog"> | $Enums.DiscountType
    discountValue?: FloatFilter<"SubscriptionDiscountLog"> | number
    discountedAmount?: FloatFilter<"SubscriptionDiscountLog"> | number
    originalPrice?: FloatFilter<"SubscriptionDiscountLog"> | number
    finalPrice?: FloatFilter<"SubscriptionDiscountLog"> | number
    appliedAt?: DateTimeFilter<"SubscriptionDiscountLog"> | Date | string
    createdBy?: StringNullableFilter<"SubscriptionDiscountLog"> | string | null
    subscriberSubscription?: XOR<SubscriberSubscriptionScalarRelationFilter, SubscriberSubscriptionWhereInput>
    discount?: XOR<DiscountScalarRelationFilter, DiscountWhereInput>
  }, "id">

  export type SubscriptionDiscountLogOrderByWithAggregationInput = {
    id?: SortOrder
    subscriberSubscriptionId?: SortOrder
    discountId?: SortOrder
    discountCode?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountedAmount?: SortOrder
    originalPrice?: SortOrder
    finalPrice?: SortOrder
    appliedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: SubscriptionDiscountLogCountOrderByAggregateInput
    _avg?: SubscriptionDiscountLogAvgOrderByAggregateInput
    _max?: SubscriptionDiscountLogMaxOrderByAggregateInput
    _min?: SubscriptionDiscountLogMinOrderByAggregateInput
    _sum?: SubscriptionDiscountLogSumOrderByAggregateInput
  }

  export type SubscriptionDiscountLogScalarWhereWithAggregatesInput = {
    AND?: SubscriptionDiscountLogScalarWhereWithAggregatesInput | SubscriptionDiscountLogScalarWhereWithAggregatesInput[]
    OR?: SubscriptionDiscountLogScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionDiscountLogScalarWhereWithAggregatesInput | SubscriptionDiscountLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionDiscountLog"> | string
    subscriberSubscriptionId?: StringWithAggregatesFilter<"SubscriptionDiscountLog"> | string
    discountId?: StringWithAggregatesFilter<"SubscriptionDiscountLog"> | string
    discountCode?: StringWithAggregatesFilter<"SubscriptionDiscountLog"> | string
    discountType?: EnumDiscountTypeWithAggregatesFilter<"SubscriptionDiscountLog"> | $Enums.DiscountType
    discountValue?: FloatWithAggregatesFilter<"SubscriptionDiscountLog"> | number
    discountedAmount?: FloatWithAggregatesFilter<"SubscriptionDiscountLog"> | number
    originalPrice?: FloatWithAggregatesFilter<"SubscriptionDiscountLog"> | number
    finalPrice?: FloatWithAggregatesFilter<"SubscriptionDiscountLog"> | number
    appliedAt?: DateTimeWithAggregatesFilter<"SubscriptionDiscountLog"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"SubscriptionDiscountLog"> | string | null
  }

  export type BusinessWhereInput = {
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    id?: StringFilter<"Business"> | string
    businessId?: IntFilter<"Business"> | number
    name?: StringFilter<"Business"> | string
    image?: StringNullableFilter<"Business"> | string | null
    websiteLink?: StringNullableFilter<"Business"> | string | null
    phoneNumber?: StringNullableFilter<"Business"> | string | null
    businessType?: EnumBusinessTypeFilter<"Business"> | $Enums.BusinessType
    subscriptionId?: StringNullableFilter<"Business"> | string | null
    subscriptionType?: EnumSubscriptionTypeNullableFilter<"Business"> | $Enums.SubscriptionType | null
    subscriptionPrice?: FloatNullableFilter<"Business"> | number | null
    subscriptionValidity?: EnumSubscriptionValidityNullableFilter<"Business"> | $Enums.SubscriptionValidity | null
    discountCodeId?: StringNullableFilter<"Business"> | string | null
    subscriberId?: StringNullableFilter<"Business"> | string | null
    status?: EnumBusinessStatusFilter<"Business"> | $Enums.BusinessStatus
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    createdBy?: StringNullableFilter<"Business"> | string | null
    updatedBy?: StringNullableFilter<"Business"> | string | null
    isDeleted?: BoolFilter<"Business"> | boolean
    deletedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    deletedBy?: StringNullableFilter<"Business"> | string | null
    flows?: FlowListRelationFilter
    whatsappNumbers?: WhatsAppNumberListRelationFilter
    subscriber?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    discountCode?: XOR<DiscountNullableScalarRelationFilter, DiscountWhereInput> | null
    branches?: BranchListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    subscriberSubscriptions?: SubscriberSubscriptionListRelationFilter
    scheduleHours?: ScheduleHourListRelationFilter
  }

  export type BusinessOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    image?: SortOrderInput | SortOrder
    websiteLink?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    businessType?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    subscriptionType?: SortOrderInput | SortOrder
    subscriptionPrice?: SortOrderInput | SortOrder
    subscriptionValidity?: SortOrderInput | SortOrder
    discountCodeId?: SortOrderInput | SortOrder
    subscriberId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    flows?: FlowOrderByRelationAggregateInput
    whatsappNumbers?: WhatsAppNumberOrderByRelationAggregateInput
    subscriber?: UserOrderByWithRelationInput
    discountCode?: DiscountOrderByWithRelationInput
    branches?: BranchOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    subscriberSubscriptions?: SubscriberSubscriptionOrderByRelationAggregateInput
    scheduleHours?: ScheduleHourOrderByRelationAggregateInput
  }

  export type BusinessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessId?: number
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    name?: StringFilter<"Business"> | string
    image?: StringNullableFilter<"Business"> | string | null
    websiteLink?: StringNullableFilter<"Business"> | string | null
    phoneNumber?: StringNullableFilter<"Business"> | string | null
    businessType?: EnumBusinessTypeFilter<"Business"> | $Enums.BusinessType
    subscriptionId?: StringNullableFilter<"Business"> | string | null
    subscriptionType?: EnumSubscriptionTypeNullableFilter<"Business"> | $Enums.SubscriptionType | null
    subscriptionPrice?: FloatNullableFilter<"Business"> | number | null
    subscriptionValidity?: EnumSubscriptionValidityNullableFilter<"Business"> | $Enums.SubscriptionValidity | null
    discountCodeId?: StringNullableFilter<"Business"> | string | null
    subscriberId?: StringNullableFilter<"Business"> | string | null
    status?: EnumBusinessStatusFilter<"Business"> | $Enums.BusinessStatus
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    createdBy?: StringNullableFilter<"Business"> | string | null
    updatedBy?: StringNullableFilter<"Business"> | string | null
    isDeleted?: BoolFilter<"Business"> | boolean
    deletedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    deletedBy?: StringNullableFilter<"Business"> | string | null
    flows?: FlowListRelationFilter
    whatsappNumbers?: WhatsAppNumberListRelationFilter
    subscriber?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    discountCode?: XOR<DiscountNullableScalarRelationFilter, DiscountWhereInput> | null
    branches?: BranchListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    subscriberSubscriptions?: SubscriberSubscriptionListRelationFilter
    scheduleHours?: ScheduleHourListRelationFilter
  }, "id" | "businessId">

  export type BusinessOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    image?: SortOrderInput | SortOrder
    websiteLink?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    businessType?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    subscriptionType?: SortOrderInput | SortOrder
    subscriptionPrice?: SortOrderInput | SortOrder
    subscriptionValidity?: SortOrderInput | SortOrder
    discountCodeId?: SortOrderInput | SortOrder
    subscriberId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: BusinessCountOrderByAggregateInput
    _avg?: BusinessAvgOrderByAggregateInput
    _max?: BusinessMaxOrderByAggregateInput
    _min?: BusinessMinOrderByAggregateInput
    _sum?: BusinessSumOrderByAggregateInput
  }

  export type BusinessScalarWhereWithAggregatesInput = {
    AND?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    OR?: BusinessScalarWhereWithAggregatesInput[]
    NOT?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Business"> | string
    businessId?: IntWithAggregatesFilter<"Business"> | number
    name?: StringWithAggregatesFilter<"Business"> | string
    image?: StringNullableWithAggregatesFilter<"Business"> | string | null
    websiteLink?: StringNullableWithAggregatesFilter<"Business"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Business"> | string | null
    businessType?: EnumBusinessTypeWithAggregatesFilter<"Business"> | $Enums.BusinessType
    subscriptionId?: StringNullableWithAggregatesFilter<"Business"> | string | null
    subscriptionType?: EnumSubscriptionTypeNullableWithAggregatesFilter<"Business"> | $Enums.SubscriptionType | null
    subscriptionPrice?: FloatNullableWithAggregatesFilter<"Business"> | number | null
    subscriptionValidity?: EnumSubscriptionValidityNullableWithAggregatesFilter<"Business"> | $Enums.SubscriptionValidity | null
    discountCodeId?: StringNullableWithAggregatesFilter<"Business"> | string | null
    subscriberId?: StringNullableWithAggregatesFilter<"Business"> | string | null
    status?: EnumBusinessStatusWithAggregatesFilter<"Business"> | $Enums.BusinessStatus
    createdAt?: DateTimeWithAggregatesFilter<"Business"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Business"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Business"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Business"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Business"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Business"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Business"> | string | null
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    subscriberId?: StringFilter<"Branch"> | string
    businessId?: StringNullableFilter<"Branch"> | string | null
    location?: StringNullableFilter<"Branch"> | string | null
    phone?: StringNullableFilter<"Branch"> | string | null
    status?: BoolFilter<"Branch"> | boolean
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    createdBy?: StringNullableFilter<"Branch"> | string | null
    updatedBy?: StringNullableFilter<"Branch"> | string | null
    isDeleted?: BoolFilter<"Branch"> | boolean
    deletedAt?: DateTimeNullableFilter<"Branch"> | Date | string | null
    deletedBy?: StringNullableFilter<"Branch"> | string | null
    subscriber?: XOR<UserScalarRelationFilter, UserWhereInput>
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    users?: UserListRelationFilter
    serviceBranches?: ServiceBranchListRelationFilter
    appointments?: AppointmentListRelationFilter
    promotions?: PromotionListRelationFilter
    tabletAccounts?: TabletAccountListRelationFilter
    whatsappAds?: WhatsappAdListRelationFilter
    scheduleHours?: ScheduleHourListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subscriberId?: SortOrder
    businessId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    subscriber?: UserOrderByWithRelationInput
    business?: BusinessOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    serviceBranches?: ServiceBranchOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    promotions?: PromotionOrderByRelationAggregateInput
    tabletAccounts?: TabletAccountOrderByRelationAggregateInput
    whatsappAds?: WhatsappAdOrderByRelationAggregateInput
    scheduleHours?: ScheduleHourOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    name?: StringFilter<"Branch"> | string
    subscriberId?: StringFilter<"Branch"> | string
    businessId?: StringNullableFilter<"Branch"> | string | null
    location?: StringNullableFilter<"Branch"> | string | null
    phone?: StringNullableFilter<"Branch"> | string | null
    status?: BoolFilter<"Branch"> | boolean
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    createdBy?: StringNullableFilter<"Branch"> | string | null
    updatedBy?: StringNullableFilter<"Branch"> | string | null
    isDeleted?: BoolFilter<"Branch"> | boolean
    deletedAt?: DateTimeNullableFilter<"Branch"> | Date | string | null
    deletedBy?: StringNullableFilter<"Branch"> | string | null
    subscriber?: XOR<UserScalarRelationFilter, UserWhereInput>
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    users?: UserListRelationFilter
    serviceBranches?: ServiceBranchListRelationFilter
    appointments?: AppointmentListRelationFilter
    promotions?: PromotionListRelationFilter
    tabletAccounts?: TabletAccountListRelationFilter
    whatsappAds?: WhatsappAdListRelationFilter
    scheduleHours?: ScheduleHourListRelationFilter
  }, "id">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subscriberId?: SortOrder
    businessId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: BranchCountOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Branch"> | string
    name?: StringWithAggregatesFilter<"Branch"> | string
    subscriberId?: StringWithAggregatesFilter<"Branch"> | string
    businessId?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    location?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    status?: BoolWithAggregatesFilter<"Branch"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Branch"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Branch"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Branch"> | string | null
  }

  export type ScheduleHourWhereInput = {
    AND?: ScheduleHourWhereInput | ScheduleHourWhereInput[]
    OR?: ScheduleHourWhereInput[]
    NOT?: ScheduleHourWhereInput | ScheduleHourWhereInput[]
    id?: StringFilter<"ScheduleHour"> | string
    ownerType?: EnumScheduleOwnerTypeFilter<"ScheduleHour"> | $Enums.ScheduleOwnerType
    ownerId?: StringFilter<"ScheduleHour"> | string
    dayOfWeek?: EnumWeekDayFilter<"ScheduleHour"> | $Enums.WeekDay
    openTime?: StringFilter<"ScheduleHour"> | string
    closeTime?: StringFilter<"ScheduleHour"> | string
    isClosed?: BoolFilter<"ScheduleHour"> | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFilter<"ScheduleHour"> | $Enums.ScheduleInheritanceMode
    staffId?: StringNullableFilter<"ScheduleHour"> | string | null
    businessId?: StringNullableFilter<"ScheduleHour"> | string | null
    branchId?: StringNullableFilter<"ScheduleHour"> | string | null
    lastModifiedBy?: StringNullableFilter<"ScheduleHour"> | string | null
    createdAt?: DateTimeFilter<"ScheduleHour"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleHour"> | Date | string
    createdBy?: StringNullableFilter<"ScheduleHour"> | string | null
    updatedBy?: StringNullableFilter<"ScheduleHour"> | string | null
    isDeleted?: BoolFilter<"ScheduleHour"> | boolean
    deletedAt?: DateTimeNullableFilter<"ScheduleHour"> | Date | string | null
    deletedBy?: StringNullableFilter<"ScheduleHour"> | string | null
    staff?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
  }

  export type ScheduleHourOrderByWithRelationInput = {
    id?: SortOrder
    ownerType?: SortOrder
    ownerId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    isClosed?: SortOrder
    inheritanceMode?: SortOrder
    staffId?: SortOrderInput | SortOrder
    businessId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    lastModifiedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    staff?: UserOrderByWithRelationInput
    business?: BusinessOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type ScheduleHourWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ownerType_ownerId_dayOfWeek?: ScheduleHourOwnerTypeOwnerIdDayOfWeekCompoundUniqueInput
    AND?: ScheduleHourWhereInput | ScheduleHourWhereInput[]
    OR?: ScheduleHourWhereInput[]
    NOT?: ScheduleHourWhereInput | ScheduleHourWhereInput[]
    ownerType?: EnumScheduleOwnerTypeFilter<"ScheduleHour"> | $Enums.ScheduleOwnerType
    ownerId?: StringFilter<"ScheduleHour"> | string
    dayOfWeek?: EnumWeekDayFilter<"ScheduleHour"> | $Enums.WeekDay
    openTime?: StringFilter<"ScheduleHour"> | string
    closeTime?: StringFilter<"ScheduleHour"> | string
    isClosed?: BoolFilter<"ScheduleHour"> | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFilter<"ScheduleHour"> | $Enums.ScheduleInheritanceMode
    staffId?: StringNullableFilter<"ScheduleHour"> | string | null
    businessId?: StringNullableFilter<"ScheduleHour"> | string | null
    branchId?: StringNullableFilter<"ScheduleHour"> | string | null
    lastModifiedBy?: StringNullableFilter<"ScheduleHour"> | string | null
    createdAt?: DateTimeFilter<"ScheduleHour"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleHour"> | Date | string
    createdBy?: StringNullableFilter<"ScheduleHour"> | string | null
    updatedBy?: StringNullableFilter<"ScheduleHour"> | string | null
    isDeleted?: BoolFilter<"ScheduleHour"> | boolean
    deletedAt?: DateTimeNullableFilter<"ScheduleHour"> | Date | string | null
    deletedBy?: StringNullableFilter<"ScheduleHour"> | string | null
    staff?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
  }, "id" | "ownerType_ownerId_dayOfWeek">

  export type ScheduleHourOrderByWithAggregationInput = {
    id?: SortOrder
    ownerType?: SortOrder
    ownerId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    isClosed?: SortOrder
    inheritanceMode?: SortOrder
    staffId?: SortOrderInput | SortOrder
    businessId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    lastModifiedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: ScheduleHourCountOrderByAggregateInput
    _max?: ScheduleHourMaxOrderByAggregateInput
    _min?: ScheduleHourMinOrderByAggregateInput
  }

  export type ScheduleHourScalarWhereWithAggregatesInput = {
    AND?: ScheduleHourScalarWhereWithAggregatesInput | ScheduleHourScalarWhereWithAggregatesInput[]
    OR?: ScheduleHourScalarWhereWithAggregatesInput[]
    NOT?: ScheduleHourScalarWhereWithAggregatesInput | ScheduleHourScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduleHour"> | string
    ownerType?: EnumScheduleOwnerTypeWithAggregatesFilter<"ScheduleHour"> | $Enums.ScheduleOwnerType
    ownerId?: StringWithAggregatesFilter<"ScheduleHour"> | string
    dayOfWeek?: EnumWeekDayWithAggregatesFilter<"ScheduleHour"> | $Enums.WeekDay
    openTime?: StringWithAggregatesFilter<"ScheduleHour"> | string
    closeTime?: StringWithAggregatesFilter<"ScheduleHour"> | string
    isClosed?: BoolWithAggregatesFilter<"ScheduleHour"> | boolean
    inheritanceMode?: EnumScheduleInheritanceModeWithAggregatesFilter<"ScheduleHour"> | $Enums.ScheduleInheritanceMode
    staffId?: StringNullableWithAggregatesFilter<"ScheduleHour"> | string | null
    businessId?: StringNullableWithAggregatesFilter<"ScheduleHour"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"ScheduleHour"> | string | null
    lastModifiedBy?: StringNullableWithAggregatesFilter<"ScheduleHour"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ScheduleHour"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduleHour"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"ScheduleHour"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"ScheduleHour"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"ScheduleHour"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ScheduleHour"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"ScheduleHour"> | string | null
  }

  export type StaffStatusLogWhereInput = {
    AND?: StaffStatusLogWhereInput | StaffStatusLogWhereInput[]
    OR?: StaffStatusLogWhereInput[]
    NOT?: StaffStatusLogWhereInput | StaffStatusLogWhereInput[]
    id?: StringFilter<"StaffStatusLog"> | string
    userId?: StringFilter<"StaffStatusLog"> | string
    status?: EnumStaffStatusFilter<"StaffStatusLog"> | $Enums.StaffStatus
    timestamp?: DateTimeFilter<"StaffStatusLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StaffStatusLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type StaffStatusLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StaffStatusLogWhereInput | StaffStatusLogWhereInput[]
    OR?: StaffStatusLogWhereInput[]
    NOT?: StaffStatusLogWhereInput | StaffStatusLogWhereInput[]
    userId?: StringFilter<"StaffStatusLog"> | string
    status?: EnumStaffStatusFilter<"StaffStatusLog"> | $Enums.StaffStatus
    timestamp?: DateTimeFilter<"StaffStatusLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type StaffStatusLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    _count?: StaffStatusLogCountOrderByAggregateInput
    _max?: StaffStatusLogMaxOrderByAggregateInput
    _min?: StaffStatusLogMinOrderByAggregateInput
  }

  export type StaffStatusLogScalarWhereWithAggregatesInput = {
    AND?: StaffStatusLogScalarWhereWithAggregatesInput | StaffStatusLogScalarWhereWithAggregatesInput[]
    OR?: StaffStatusLogScalarWhereWithAggregatesInput[]
    NOT?: StaffStatusLogScalarWhereWithAggregatesInput | StaffStatusLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StaffStatusLog"> | string
    userId?: StringWithAggregatesFilter<"StaffStatusLog"> | string
    status?: EnumStaffStatusWithAggregatesFilter<"StaffStatusLog"> | $Enums.StaffStatus
    timestamp?: DateTimeWithAggregatesFilter<"StaffStatusLog"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    staffId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    notes?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    createdBy?: StringNullableFilter<"Attendance"> | string | null
    updatedBy?: StringNullableFilter<"Attendance"> | string | null
    isDeleted?: BoolFilter<"Attendance"> | boolean
    deletedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    deletedBy?: StringNullableFilter<"Attendance"> | string | null
    staff?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    staff?: UserOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    staffId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    notes?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    createdBy?: StringNullableFilter<"Attendance"> | string | null
    updatedBy?: StringNullableFilter<"Attendance"> | string | null
    isDeleted?: BoolFilter<"Attendance"> | boolean
    deletedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    deletedBy?: StringNullableFilter<"Attendance"> | string | null
    staff?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    staffId?: StringWithAggregatesFilter<"Attendance"> | string
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"Attendance"> | $Enums.AttendanceStatus
    notes?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Attendance"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
  }

  export type VacationWhereInput = {
    AND?: VacationWhereInput | VacationWhereInput[]
    OR?: VacationWhereInput[]
    NOT?: VacationWhereInput | VacationWhereInput[]
    id?: StringFilter<"Vacation"> | string
    staffId?: StringFilter<"Vacation"> | string
    startDate?: DateTimeFilter<"Vacation"> | Date | string
    endDate?: DateTimeFilter<"Vacation"> | Date | string
    reason?: StringNullableFilter<"Vacation"> | string | null
    status?: EnumVacationStatusFilter<"Vacation"> | $Enums.VacationStatus
    createdAt?: DateTimeFilter<"Vacation"> | Date | string
    updatedAt?: DateTimeFilter<"Vacation"> | Date | string
    createdBy?: StringNullableFilter<"Vacation"> | string | null
    updatedBy?: StringNullableFilter<"Vacation"> | string | null
    isDeleted?: BoolFilter<"Vacation"> | boolean
    deletedAt?: DateTimeNullableFilter<"Vacation"> | Date | string | null
    deletedBy?: StringNullableFilter<"Vacation"> | string | null
    staff?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VacationOrderByWithRelationInput = {
    id?: SortOrder
    staffId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    staff?: UserOrderByWithRelationInput
  }

  export type VacationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VacationWhereInput | VacationWhereInput[]
    OR?: VacationWhereInput[]
    NOT?: VacationWhereInput | VacationWhereInput[]
    staffId?: StringFilter<"Vacation"> | string
    startDate?: DateTimeFilter<"Vacation"> | Date | string
    endDate?: DateTimeFilter<"Vacation"> | Date | string
    reason?: StringNullableFilter<"Vacation"> | string | null
    status?: EnumVacationStatusFilter<"Vacation"> | $Enums.VacationStatus
    createdAt?: DateTimeFilter<"Vacation"> | Date | string
    updatedAt?: DateTimeFilter<"Vacation"> | Date | string
    createdBy?: StringNullableFilter<"Vacation"> | string | null
    updatedBy?: StringNullableFilter<"Vacation"> | string | null
    isDeleted?: BoolFilter<"Vacation"> | boolean
    deletedAt?: DateTimeNullableFilter<"Vacation"> | Date | string | null
    deletedBy?: StringNullableFilter<"Vacation"> | string | null
    staff?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type VacationOrderByWithAggregationInput = {
    id?: SortOrder
    staffId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: VacationCountOrderByAggregateInput
    _max?: VacationMaxOrderByAggregateInput
    _min?: VacationMinOrderByAggregateInput
  }

  export type VacationScalarWhereWithAggregatesInput = {
    AND?: VacationScalarWhereWithAggregatesInput | VacationScalarWhereWithAggregatesInput[]
    OR?: VacationScalarWhereWithAggregatesInput[]
    NOT?: VacationScalarWhereWithAggregatesInput | VacationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vacation"> | string
    staffId?: StringWithAggregatesFilter<"Vacation"> | string
    startDate?: DateTimeWithAggregatesFilter<"Vacation"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Vacation"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"Vacation"> | string | null
    status?: EnumVacationStatusWithAggregatesFilter<"Vacation"> | $Enums.VacationStatus
    createdAt?: DateTimeWithAggregatesFilter<"Vacation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vacation"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Vacation"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Vacation"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Vacation"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Vacation"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Vacation"> | string | null
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    providerId?: StringNullableFilter<"Service"> | string | null
    duration?: IntFilter<"Service"> | number
    price?: FloatFilter<"Service"> | number
    bufferTime?: IntFilter<"Service"> | number
    status?: BoolFilter<"Service"> | boolean
    frequency?: IntNullableFilter<"Service"> | number | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    createdBy?: StringNullableFilter<"Service"> | string | null
    updatedBy?: StringNullableFilter<"Service"> | string | null
    isDeleted?: BoolFilter<"Service"> | boolean
    deletedAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    deletedBy?: StringNullableFilter<"Service"> | string | null
    providers?: UserOnServiceListRelationFilter
    branches?: ServiceBranchListRelationFilter
    appointments?: AppointmentListRelationFilter
    whatsappAds?: WhatsappAdListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    providerId?: SortOrderInput | SortOrder
    duration?: SortOrder
    price?: SortOrder
    bufferTime?: SortOrder
    status?: SortOrder
    frequency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    providers?: UserOnServiceOrderByRelationAggregateInput
    branches?: ServiceBranchOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    whatsappAds?: WhatsappAdOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    providerId?: StringNullableFilter<"Service"> | string | null
    duration?: IntFilter<"Service"> | number
    price?: FloatFilter<"Service"> | number
    bufferTime?: IntFilter<"Service"> | number
    status?: BoolFilter<"Service"> | boolean
    frequency?: IntNullableFilter<"Service"> | number | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    createdBy?: StringNullableFilter<"Service"> | string | null
    updatedBy?: StringNullableFilter<"Service"> | string | null
    isDeleted?: BoolFilter<"Service"> | boolean
    deletedAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    deletedBy?: StringNullableFilter<"Service"> | string | null
    providers?: UserOnServiceListRelationFilter
    branches?: ServiceBranchListRelationFilter
    appointments?: AppointmentListRelationFilter
    whatsappAds?: WhatsappAdListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    providerId?: SortOrderInput | SortOrder
    duration?: SortOrder
    price?: SortOrder
    bufferTime?: SortOrder
    status?: SortOrder
    frequency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    providerId?: StringNullableWithAggregatesFilter<"Service"> | string | null
    duration?: IntWithAggregatesFilter<"Service"> | number
    price?: FloatWithAggregatesFilter<"Service"> | number
    bufferTime?: IntWithAggregatesFilter<"Service"> | number
    status?: BoolWithAggregatesFilter<"Service"> | boolean
    frequency?: IntNullableWithAggregatesFilter<"Service"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Service"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Service"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Service"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Service"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Service"> | string | null
  }

  export type UserOnServiceWhereInput = {
    AND?: UserOnServiceWhereInput | UserOnServiceWhereInput[]
    OR?: UserOnServiceWhereInput[]
    NOT?: UserOnServiceWhereInput | UserOnServiceWhereInput[]
    id?: StringFilter<"UserOnService"> | string
    serviceId?: StringFilter<"UserOnService"> | string
    providerId?: StringFilter<"UserOnService"> | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserOnServiceOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    service?: ServiceOrderByWithRelationInput
    provider?: UserOrderByWithRelationInput
  }

  export type UserOnServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserOnServiceWhereInput | UserOnServiceWhereInput[]
    OR?: UserOnServiceWhereInput[]
    NOT?: UserOnServiceWhereInput | UserOnServiceWhereInput[]
    serviceId?: StringFilter<"UserOnService"> | string
    providerId?: StringFilter<"UserOnService"> | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserOnServiceOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    _count?: UserOnServiceCountOrderByAggregateInput
    _max?: UserOnServiceMaxOrderByAggregateInput
    _min?: UserOnServiceMinOrderByAggregateInput
  }

  export type UserOnServiceScalarWhereWithAggregatesInput = {
    AND?: UserOnServiceScalarWhereWithAggregatesInput | UserOnServiceScalarWhereWithAggregatesInput[]
    OR?: UserOnServiceScalarWhereWithAggregatesInput[]
    NOT?: UserOnServiceScalarWhereWithAggregatesInput | UserOnServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserOnService"> | string
    serviceId?: StringWithAggregatesFilter<"UserOnService"> | string
    providerId?: StringWithAggregatesFilter<"UserOnService"> | string
  }

  export type ServiceBranchWhereInput = {
    AND?: ServiceBranchWhereInput | ServiceBranchWhereInput[]
    OR?: ServiceBranchWhereInput[]
    NOT?: ServiceBranchWhereInput | ServiceBranchWhereInput[]
    id?: StringFilter<"ServiceBranch"> | string
    serviceId?: StringFilter<"ServiceBranch"> | string
    branchId?: StringFilter<"ServiceBranch"> | string
    createdAt?: DateTimeFilter<"ServiceBranch"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceBranch"> | Date | string
    createdBy?: StringNullableFilter<"ServiceBranch"> | string | null
    updatedBy?: StringNullableFilter<"ServiceBranch"> | string | null
    isDeleted?: BoolFilter<"ServiceBranch"> | boolean
    deletedAt?: DateTimeNullableFilter<"ServiceBranch"> | Date | string | null
    deletedBy?: StringNullableFilter<"ServiceBranch"> | string | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }

  export type ServiceBranchOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    service?: ServiceOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type ServiceBranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serviceId_branchId?: ServiceBranchServiceIdBranchIdCompoundUniqueInput
    AND?: ServiceBranchWhereInput | ServiceBranchWhereInput[]
    OR?: ServiceBranchWhereInput[]
    NOT?: ServiceBranchWhereInput | ServiceBranchWhereInput[]
    serviceId?: StringFilter<"ServiceBranch"> | string
    branchId?: StringFilter<"ServiceBranch"> | string
    createdAt?: DateTimeFilter<"ServiceBranch"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceBranch"> | Date | string
    createdBy?: StringNullableFilter<"ServiceBranch"> | string | null
    updatedBy?: StringNullableFilter<"ServiceBranch"> | string | null
    isDeleted?: BoolFilter<"ServiceBranch"> | boolean
    deletedAt?: DateTimeNullableFilter<"ServiceBranch"> | Date | string | null
    deletedBy?: StringNullableFilter<"ServiceBranch"> | string | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }, "id" | "serviceId_branchId">

  export type ServiceBranchOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: ServiceBranchCountOrderByAggregateInput
    _max?: ServiceBranchMaxOrderByAggregateInput
    _min?: ServiceBranchMinOrderByAggregateInput
  }

  export type ServiceBranchScalarWhereWithAggregatesInput = {
    AND?: ServiceBranchScalarWhereWithAggregatesInput | ServiceBranchScalarWhereWithAggregatesInput[]
    OR?: ServiceBranchScalarWhereWithAggregatesInput[]
    NOT?: ServiceBranchScalarWhereWithAggregatesInput | ServiceBranchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceBranch"> | string
    serviceId?: StringWithAggregatesFilter<"ServiceBranch"> | string
    branchId?: StringWithAggregatesFilter<"ServiceBranch"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ServiceBranch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceBranch"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"ServiceBranch"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"ServiceBranch"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"ServiceBranch"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ServiceBranch"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"ServiceBranch"> | string | null
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    serviceId?: StringFilter<"Appointment"> | string
    consumerId?: StringFilter<"Appointment"> | string
    branchId?: StringFilter<"Appointment"> | string
    serviceProviderId?: StringNullableFilter<"Appointment"> | string | null
    appointmentTime?: DateTimeFilter<"Appointment"> | Date | string
    appointmentDate?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    appointmentTimeSlot?: StringNullableFilter<"Appointment"> | string | null
    reminderMinutesBefore?: IntNullableFilter<"Appointment"> | number | null
    discountId?: StringNullableFilter<"Appointment"> | string | null
    note?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    bookingType?: EnumAppointmentBookingTypeNullableFilter<"Appointment"> | $Enums.AppointmentBookingType | null
    review?: StringNullableFilter<"Appointment"> | string | null
    rating?: IntNullableFilter<"Appointment"> | number | null
    isManual?: BoolFilter<"Appointment"> | boolean
    price?: IntNullableFilter<"Appointment"> | number | null
    subscriberSubscriptionId?: StringNullableFilter<"Appointment"> | string | null
    promotionId?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    createdBy?: StringNullableFilter<"Appointment"> | string | null
    updatedBy?: StringNullableFilter<"Appointment"> | string | null
    isDeleted?: BoolFilter<"Appointment"> | boolean
    deletedAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    deletedBy?: StringNullableFilter<"Appointment"> | string | null
    promotion?: XOR<PromotionNullableScalarRelationFilter, PromotionWhereInput> | null
    subscriberSubscription?: XOR<SubscriberSubscriptionNullableScalarRelationFilter, SubscriberSubscriptionWhereInput> | null
    discount?: XOR<DiscountNullableScalarRelationFilter, DiscountWhereInput> | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    consumer?: XOR<UserScalarRelationFilter, UserWhereInput>
    serviceProvider?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    consumerId?: SortOrder
    branchId?: SortOrder
    serviceProviderId?: SortOrderInput | SortOrder
    appointmentTime?: SortOrder
    appointmentDate?: SortOrderInput | SortOrder
    appointmentTimeSlot?: SortOrderInput | SortOrder
    reminderMinutesBefore?: SortOrderInput | SortOrder
    discountId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    status?: SortOrder
    bookingType?: SortOrderInput | SortOrder
    review?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    isManual?: SortOrder
    price?: SortOrderInput | SortOrder
    subscriberSubscriptionId?: SortOrderInput | SortOrder
    promotionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    promotion?: PromotionOrderByWithRelationInput
    subscriberSubscription?: SubscriberSubscriptionOrderByWithRelationInput
    discount?: DiscountOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    consumer?: UserOrderByWithRelationInput
    serviceProvider?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    serviceId?: StringFilter<"Appointment"> | string
    consumerId?: StringFilter<"Appointment"> | string
    branchId?: StringFilter<"Appointment"> | string
    serviceProviderId?: StringNullableFilter<"Appointment"> | string | null
    appointmentTime?: DateTimeFilter<"Appointment"> | Date | string
    appointmentDate?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    appointmentTimeSlot?: StringNullableFilter<"Appointment"> | string | null
    reminderMinutesBefore?: IntNullableFilter<"Appointment"> | number | null
    discountId?: StringNullableFilter<"Appointment"> | string | null
    note?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    bookingType?: EnumAppointmentBookingTypeNullableFilter<"Appointment"> | $Enums.AppointmentBookingType | null
    review?: StringNullableFilter<"Appointment"> | string | null
    rating?: IntNullableFilter<"Appointment"> | number | null
    isManual?: BoolFilter<"Appointment"> | boolean
    price?: IntNullableFilter<"Appointment"> | number | null
    subscriberSubscriptionId?: StringNullableFilter<"Appointment"> | string | null
    promotionId?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    createdBy?: StringNullableFilter<"Appointment"> | string | null
    updatedBy?: StringNullableFilter<"Appointment"> | string | null
    isDeleted?: BoolFilter<"Appointment"> | boolean
    deletedAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    deletedBy?: StringNullableFilter<"Appointment"> | string | null
    promotion?: XOR<PromotionNullableScalarRelationFilter, PromotionWhereInput> | null
    subscriberSubscription?: XOR<SubscriberSubscriptionNullableScalarRelationFilter, SubscriberSubscriptionWhereInput> | null
    discount?: XOR<DiscountNullableScalarRelationFilter, DiscountWhereInput> | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    consumer?: XOR<UserScalarRelationFilter, UserWhereInput>
    serviceProvider?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    consumerId?: SortOrder
    branchId?: SortOrder
    serviceProviderId?: SortOrderInput | SortOrder
    appointmentTime?: SortOrder
    appointmentDate?: SortOrderInput | SortOrder
    appointmentTimeSlot?: SortOrderInput | SortOrder
    reminderMinutesBefore?: SortOrderInput | SortOrder
    discountId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    status?: SortOrder
    bookingType?: SortOrderInput | SortOrder
    review?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    isManual?: SortOrder
    price?: SortOrderInput | SortOrder
    subscriberSubscriptionId?: SortOrderInput | SortOrder
    promotionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    serviceId?: StringWithAggregatesFilter<"Appointment"> | string
    consumerId?: StringWithAggregatesFilter<"Appointment"> | string
    branchId?: StringWithAggregatesFilter<"Appointment"> | string
    serviceProviderId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    appointmentTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    appointmentDate?: DateTimeNullableWithAggregatesFilter<"Appointment"> | Date | string | null
    appointmentTimeSlot?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    reminderMinutesBefore?: IntNullableWithAggregatesFilter<"Appointment"> | number | null
    discountId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    note?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    bookingType?: EnumAppointmentBookingTypeNullableWithAggregatesFilter<"Appointment"> | $Enums.AppointmentBookingType | null
    review?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    rating?: IntNullableWithAggregatesFilter<"Appointment"> | number | null
    isManual?: BoolWithAggregatesFilter<"Appointment"> | boolean
    price?: IntNullableWithAggregatesFilter<"Appointment"> | number | null
    subscriberSubscriptionId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    promotionId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Appointment"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Appointment"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: StringFilter<"Promotion"> | string
    name?: StringFilter<"Promotion"> | string
    type?: EnumDiscountTypeFilter<"Promotion"> | $Enums.DiscountType
    value?: FloatFilter<"Promotion"> | number
    limit?: IntNullableFilter<"Promotion"> | number | null
    status?: BoolFilter<"Promotion"> | boolean
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    expiryDate?: DateTimeFilter<"Promotion"> | Date | string
    imageUrl?: StringNullableFilter<"Promotion"> | string | null
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    createdBy?: StringNullableFilter<"Promotion"> | string | null
    updatedBy?: StringNullableFilter<"Promotion"> | string | null
    isDeleted?: BoolFilter<"Promotion"> | boolean
    deletedAt?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    deletedBy?: StringNullableFilter<"Promotion"> | string | null
    branches?: BranchListRelationFilter
    appointments?: AppointmentListRelationFilter
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    limit?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    branches?: BranchOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    name?: StringFilter<"Promotion"> | string
    type?: EnumDiscountTypeFilter<"Promotion"> | $Enums.DiscountType
    value?: FloatFilter<"Promotion"> | number
    limit?: IntNullableFilter<"Promotion"> | number | null
    status?: BoolFilter<"Promotion"> | boolean
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    expiryDate?: DateTimeFilter<"Promotion"> | Date | string
    imageUrl?: StringNullableFilter<"Promotion"> | string | null
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    createdBy?: StringNullableFilter<"Promotion"> | string | null
    updatedBy?: StringNullableFilter<"Promotion"> | string | null
    isDeleted?: BoolFilter<"Promotion"> | boolean
    deletedAt?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    deletedBy?: StringNullableFilter<"Promotion"> | string | null
    branches?: BranchListRelationFilter
    appointments?: AppointmentListRelationFilter
  }, "id">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    limit?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _avg?: PromotionAvgOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
    _sum?: PromotionSumOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Promotion"> | string
    name?: StringWithAggregatesFilter<"Promotion"> | string
    type?: EnumDiscountTypeWithAggregatesFilter<"Promotion"> | $Enums.DiscountType
    value?: FloatWithAggregatesFilter<"Promotion"> | number
    limit?: IntNullableWithAggregatesFilter<"Promotion"> | number | null
    status?: BoolWithAggregatesFilter<"Promotion"> | boolean
    startDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    expiryDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    imageUrl?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Promotion"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Promotion"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
  }

  export type TabletAccountWhereInput = {
    AND?: TabletAccountWhereInput | TabletAccountWhereInput[]
    OR?: TabletAccountWhereInput[]
    NOT?: TabletAccountWhereInput | TabletAccountWhereInput[]
    id?: StringFilter<"TabletAccount"> | string
    username?: StringFilter<"TabletAccount"> | string
    password?: StringFilter<"TabletAccount"> | string
    branchId?: StringFilter<"TabletAccount"> | string
    loginLink?: StringNullableFilter<"TabletAccount"> | string | null
    loginToken?: StringFilter<"TabletAccount"> | string
    isActive?: BoolFilter<"TabletAccount"> | boolean
    isLoggedIn?: BoolFilter<"TabletAccount"> | boolean
    lastActivityAt?: DateTimeNullableFilter<"TabletAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"TabletAccount"> | Date | string
    updatedAt?: DateTimeFilter<"TabletAccount"> | Date | string
    createdBy?: StringNullableFilter<"TabletAccount"> | string | null
    updatedBy?: StringNullableFilter<"TabletAccount"> | string | null
    isDeleted?: BoolFilter<"TabletAccount"> | boolean
    deletedAt?: DateTimeNullableFilter<"TabletAccount"> | Date | string | null
    deletedBy?: StringNullableFilter<"TabletAccount"> | string | null
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }

  export type TabletAccountOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    loginLink?: SortOrderInput | SortOrder
    loginToken?: SortOrder
    isActive?: SortOrder
    isLoggedIn?: SortOrder
    lastActivityAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
  }

  export type TabletAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: TabletAccountWhereInput | TabletAccountWhereInput[]
    OR?: TabletAccountWhereInput[]
    NOT?: TabletAccountWhereInput | TabletAccountWhereInput[]
    password?: StringFilter<"TabletAccount"> | string
    branchId?: StringFilter<"TabletAccount"> | string
    loginLink?: StringNullableFilter<"TabletAccount"> | string | null
    loginToken?: StringFilter<"TabletAccount"> | string
    isActive?: BoolFilter<"TabletAccount"> | boolean
    isLoggedIn?: BoolFilter<"TabletAccount"> | boolean
    lastActivityAt?: DateTimeNullableFilter<"TabletAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"TabletAccount"> | Date | string
    updatedAt?: DateTimeFilter<"TabletAccount"> | Date | string
    createdBy?: StringNullableFilter<"TabletAccount"> | string | null
    updatedBy?: StringNullableFilter<"TabletAccount"> | string | null
    isDeleted?: BoolFilter<"TabletAccount"> | boolean
    deletedAt?: DateTimeNullableFilter<"TabletAccount"> | Date | string | null
    deletedBy?: StringNullableFilter<"TabletAccount"> | string | null
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }, "id" | "username">

  export type TabletAccountOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    loginLink?: SortOrderInput | SortOrder
    loginToken?: SortOrder
    isActive?: SortOrder
    isLoggedIn?: SortOrder
    lastActivityAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: TabletAccountCountOrderByAggregateInput
    _max?: TabletAccountMaxOrderByAggregateInput
    _min?: TabletAccountMinOrderByAggregateInput
  }

  export type TabletAccountScalarWhereWithAggregatesInput = {
    AND?: TabletAccountScalarWhereWithAggregatesInput | TabletAccountScalarWhereWithAggregatesInput[]
    OR?: TabletAccountScalarWhereWithAggregatesInput[]
    NOT?: TabletAccountScalarWhereWithAggregatesInput | TabletAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TabletAccount"> | string
    username?: StringWithAggregatesFilter<"TabletAccount"> | string
    password?: StringWithAggregatesFilter<"TabletAccount"> | string
    branchId?: StringWithAggregatesFilter<"TabletAccount"> | string
    loginLink?: StringNullableWithAggregatesFilter<"TabletAccount"> | string | null
    loginToken?: StringWithAggregatesFilter<"TabletAccount"> | string
    isActive?: BoolWithAggregatesFilter<"TabletAccount"> | boolean
    isLoggedIn?: BoolWithAggregatesFilter<"TabletAccount"> | boolean
    lastActivityAt?: DateTimeNullableWithAggregatesFilter<"TabletAccount"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TabletAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TabletAccount"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"TabletAccount"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"TabletAccount"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"TabletAccount"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"TabletAccount"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"TabletAccount"> | string | null
  }

  export type WhatsappAdWhereInput = {
    AND?: WhatsappAdWhereInput | WhatsappAdWhereInput[]
    OR?: WhatsappAdWhereInput[]
    NOT?: WhatsappAdWhereInput | WhatsappAdWhereInput[]
    id?: StringFilter<"WhatsappAd"> | string
    name?: StringFilter<"WhatsappAd"> | string
    description?: StringNullableFilter<"WhatsappAd"> | string | null
    imageUrl?: StringNullableFilter<"WhatsappAd"> | string | null
    targetDate?: DateTimeFilter<"WhatsappAd"> | Date | string
    customerType?: EnumAdTargetTypeFilter<"WhatsappAd"> | $Enums.AdTargetType
    branchId?: StringFilter<"WhatsappAd"> | string
    serviceId?: StringNullableFilter<"WhatsappAd"> | string | null
    status?: EnumAdStatusFilter<"WhatsappAd"> | $Enums.AdStatus
    createdAt?: DateTimeFilter<"WhatsappAd"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappAd"> | Date | string
    createdBy?: StringNullableFilter<"WhatsappAd"> | string | null
    updatedBy?: StringNullableFilter<"WhatsappAd"> | string | null
    isDeleted?: BoolFilter<"WhatsappAd"> | boolean
    deletedAt?: DateTimeNullableFilter<"WhatsappAd"> | Date | string | null
    deletedBy?: StringNullableFilter<"WhatsappAd"> | string | null
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
    assignedCustomers?: UserListRelationFilter
  }

  export type WhatsappAdOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    targetDate?: SortOrder
    customerType?: SortOrder
    branchId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    assignedCustomers?: UserOrderByRelationAggregateInput
  }

  export type WhatsappAdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhatsappAdWhereInput | WhatsappAdWhereInput[]
    OR?: WhatsappAdWhereInput[]
    NOT?: WhatsappAdWhereInput | WhatsappAdWhereInput[]
    name?: StringFilter<"WhatsappAd"> | string
    description?: StringNullableFilter<"WhatsappAd"> | string | null
    imageUrl?: StringNullableFilter<"WhatsappAd"> | string | null
    targetDate?: DateTimeFilter<"WhatsappAd"> | Date | string
    customerType?: EnumAdTargetTypeFilter<"WhatsappAd"> | $Enums.AdTargetType
    branchId?: StringFilter<"WhatsappAd"> | string
    serviceId?: StringNullableFilter<"WhatsappAd"> | string | null
    status?: EnumAdStatusFilter<"WhatsappAd"> | $Enums.AdStatus
    createdAt?: DateTimeFilter<"WhatsappAd"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappAd"> | Date | string
    createdBy?: StringNullableFilter<"WhatsappAd"> | string | null
    updatedBy?: StringNullableFilter<"WhatsappAd"> | string | null
    isDeleted?: BoolFilter<"WhatsappAd"> | boolean
    deletedAt?: DateTimeNullableFilter<"WhatsappAd"> | Date | string | null
    deletedBy?: StringNullableFilter<"WhatsappAd"> | string | null
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
    assignedCustomers?: UserListRelationFilter
  }, "id">

  export type WhatsappAdOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    targetDate?: SortOrder
    customerType?: SortOrder
    branchId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: WhatsappAdCountOrderByAggregateInput
    _max?: WhatsappAdMaxOrderByAggregateInput
    _min?: WhatsappAdMinOrderByAggregateInput
  }

  export type WhatsappAdScalarWhereWithAggregatesInput = {
    AND?: WhatsappAdScalarWhereWithAggregatesInput | WhatsappAdScalarWhereWithAggregatesInput[]
    OR?: WhatsappAdScalarWhereWithAggregatesInput[]
    NOT?: WhatsappAdScalarWhereWithAggregatesInput | WhatsappAdScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsappAd"> | string
    name?: StringWithAggregatesFilter<"WhatsappAd"> | string
    description?: StringNullableWithAggregatesFilter<"WhatsappAd"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"WhatsappAd"> | string | null
    targetDate?: DateTimeWithAggregatesFilter<"WhatsappAd"> | Date | string
    customerType?: EnumAdTargetTypeWithAggregatesFilter<"WhatsappAd"> | $Enums.AdTargetType
    branchId?: StringWithAggregatesFilter<"WhatsappAd"> | string
    serviceId?: StringNullableWithAggregatesFilter<"WhatsappAd"> | string | null
    status?: EnumAdStatusWithAggregatesFilter<"WhatsappAd"> | $Enums.AdStatus
    createdAt?: DateTimeWithAggregatesFilter<"WhatsappAd"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsappAd"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"WhatsappAd"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"WhatsappAd"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"WhatsappAd"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"WhatsappAd"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"WhatsappAd"> | string | null
  }

  export type WhatsAppNumberWhereInput = {
    AND?: WhatsAppNumberWhereInput | WhatsAppNumberWhereInput[]
    OR?: WhatsAppNumberWhereInput[]
    NOT?: WhatsAppNumberWhereInput | WhatsAppNumberWhereInput[]
    id?: StringFilter<"WhatsAppNumber"> | string
    businessId?: StringFilter<"WhatsAppNumber"> | string
    phoneNumber?: StringFilter<"WhatsAppNumber"> | string
    phoneNumberId?: StringNullableFilter<"WhatsAppNumber"> | string | null
    wabaId?: StringNullableFilter<"WhatsAppNumber"> | string | null
    accessToken?: StringNullableFilter<"WhatsAppNumber"> | string | null
    isVerified?: BoolFilter<"WhatsAppNumber"> | boolean
    defaultFlowId?: StringNullableFilter<"WhatsAppNumber"> | string | null
    otp?: IntNullableFilter<"WhatsAppNumber"> | number | null
    createdAt?: DateTimeFilter<"WhatsAppNumber"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppNumber"> | Date | string
    isDeleted?: BoolFilter<"WhatsAppNumber"> | boolean
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    defaultFlow?: XOR<FlowNullableScalarRelationFilter, FlowWhereInput> | null
  }

  export type WhatsAppNumberOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberId?: SortOrderInput | SortOrder
    wabaId?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    defaultFlowId?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    business?: BusinessOrderByWithRelationInput
    defaultFlow?: FlowOrderByWithRelationInput
  }

  export type WhatsAppNumberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhatsAppNumberWhereInput | WhatsAppNumberWhereInput[]
    OR?: WhatsAppNumberWhereInput[]
    NOT?: WhatsAppNumberWhereInput | WhatsAppNumberWhereInput[]
    businessId?: StringFilter<"WhatsAppNumber"> | string
    phoneNumber?: StringFilter<"WhatsAppNumber"> | string
    phoneNumberId?: StringNullableFilter<"WhatsAppNumber"> | string | null
    wabaId?: StringNullableFilter<"WhatsAppNumber"> | string | null
    accessToken?: StringNullableFilter<"WhatsAppNumber"> | string | null
    isVerified?: BoolFilter<"WhatsAppNumber"> | boolean
    defaultFlowId?: StringNullableFilter<"WhatsAppNumber"> | string | null
    otp?: IntNullableFilter<"WhatsAppNumber"> | number | null
    createdAt?: DateTimeFilter<"WhatsAppNumber"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppNumber"> | Date | string
    isDeleted?: BoolFilter<"WhatsAppNumber"> | boolean
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    defaultFlow?: XOR<FlowNullableScalarRelationFilter, FlowWhereInput> | null
  }, "id">

  export type WhatsAppNumberOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberId?: SortOrderInput | SortOrder
    wabaId?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    defaultFlowId?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    _count?: WhatsAppNumberCountOrderByAggregateInput
    _avg?: WhatsAppNumberAvgOrderByAggregateInput
    _max?: WhatsAppNumberMaxOrderByAggregateInput
    _min?: WhatsAppNumberMinOrderByAggregateInput
    _sum?: WhatsAppNumberSumOrderByAggregateInput
  }

  export type WhatsAppNumberScalarWhereWithAggregatesInput = {
    AND?: WhatsAppNumberScalarWhereWithAggregatesInput | WhatsAppNumberScalarWhereWithAggregatesInput[]
    OR?: WhatsAppNumberScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppNumberScalarWhereWithAggregatesInput | WhatsAppNumberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppNumber"> | string
    businessId?: StringWithAggregatesFilter<"WhatsAppNumber"> | string
    phoneNumber?: StringWithAggregatesFilter<"WhatsAppNumber"> | string
    phoneNumberId?: StringNullableWithAggregatesFilter<"WhatsAppNumber"> | string | null
    wabaId?: StringNullableWithAggregatesFilter<"WhatsAppNumber"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"WhatsAppNumber"> | string | null
    isVerified?: BoolWithAggregatesFilter<"WhatsAppNumber"> | boolean
    defaultFlowId?: StringNullableWithAggregatesFilter<"WhatsAppNumber"> | string | null
    otp?: IntNullableWithAggregatesFilter<"WhatsAppNumber"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppNumber"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppNumber"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"WhatsAppNumber"> | boolean
  }

  export type FlowWhereInput = {
    AND?: FlowWhereInput | FlowWhereInput[]
    OR?: FlowWhereInput[]
    NOT?: FlowWhereInput | FlowWhereInput[]
    id?: StringFilter<"Flow"> | string
    name?: StringFilter<"Flow"> | string
    isActive?: BoolFilter<"Flow"> | boolean
    businessId?: StringNullableFilter<"Flow"> | string | null
    createdAt?: DateTimeFilter<"Flow"> | Date | string
    updatedAt?: DateTimeFilter<"Flow"> | Date | string
    createdBy?: StringFilter<"Flow"> | string
    updatedBy?: StringNullableFilter<"Flow"> | string | null
    DeletedBy?: StringNullableFilter<"Flow"> | string | null
    DeletedAt?: DateTimeNullableFilter<"Flow"> | Date | string | null
    isDeleted?: BoolFilter<"Flow"> | boolean
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    steps?: StepListRelationFilter
    sessions?: SessionListRelationFilter
    whatsappNumbers?: WhatsAppNumberListRelationFilter
  }

  export type FlowOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    businessId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    DeletedBy?: SortOrderInput | SortOrder
    DeletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    business?: BusinessOrderByWithRelationInput
    steps?: StepOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    whatsappNumbers?: WhatsAppNumberOrderByRelationAggregateInput
  }

  export type FlowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlowWhereInput | FlowWhereInput[]
    OR?: FlowWhereInput[]
    NOT?: FlowWhereInput | FlowWhereInput[]
    name?: StringFilter<"Flow"> | string
    isActive?: BoolFilter<"Flow"> | boolean
    businessId?: StringNullableFilter<"Flow"> | string | null
    createdAt?: DateTimeFilter<"Flow"> | Date | string
    updatedAt?: DateTimeFilter<"Flow"> | Date | string
    createdBy?: StringFilter<"Flow"> | string
    updatedBy?: StringNullableFilter<"Flow"> | string | null
    DeletedBy?: StringNullableFilter<"Flow"> | string | null
    DeletedAt?: DateTimeNullableFilter<"Flow"> | Date | string | null
    isDeleted?: BoolFilter<"Flow"> | boolean
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    steps?: StepListRelationFilter
    sessions?: SessionListRelationFilter
    whatsappNumbers?: WhatsAppNumberListRelationFilter
  }, "id">

  export type FlowOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    businessId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    DeletedBy?: SortOrderInput | SortOrder
    DeletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: FlowCountOrderByAggregateInput
    _max?: FlowMaxOrderByAggregateInput
    _min?: FlowMinOrderByAggregateInput
  }

  export type FlowScalarWhereWithAggregatesInput = {
    AND?: FlowScalarWhereWithAggregatesInput | FlowScalarWhereWithAggregatesInput[]
    OR?: FlowScalarWhereWithAggregatesInput[]
    NOT?: FlowScalarWhereWithAggregatesInput | FlowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Flow"> | string
    name?: StringWithAggregatesFilter<"Flow"> | string
    isActive?: BoolWithAggregatesFilter<"Flow"> | boolean
    businessId?: StringNullableWithAggregatesFilter<"Flow"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Flow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Flow"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Flow"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"Flow"> | string | null
    DeletedBy?: StringNullableWithAggregatesFilter<"Flow"> | string | null
    DeletedAt?: DateTimeNullableWithAggregatesFilter<"Flow"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Flow"> | boolean
  }

  export type StepWhereInput = {
    AND?: StepWhereInput | StepWhereInput[]
    OR?: StepWhereInput[]
    NOT?: StepWhereInput | StepWhereInput[]
    id?: StringFilter<"Step"> | string
    flowId?: StringFilter<"Step"> | string
    order?: IntFilter<"Step"> | number
    type?: EnumStepTypeFilter<"Step"> | $Enums.StepType
    message?: StringNullableFilter<"Step"> | string | null
    dynamicSource?: EnumDynamicSourceFilter<"Step"> | $Enums.DynamicSource
    createdAt?: DateTimeFilter<"Step"> | Date | string
    updatedAt?: DateTimeFilter<"Step"> | Date | string
    createdBy?: StringFilter<"Step"> | string
    updatedBy?: StringNullableFilter<"Step"> | string | null
    DeletedBy?: StringNullableFilter<"Step"> | string | null
    DeletedAt?: DateTimeNullableFilter<"Step"> | Date | string | null
    isDeleted?: BoolFilter<"Step"> | boolean
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
    options?: StepOptionListRelationFilter
    sessions?: SessionListRelationFilter
    logs?: LogListRelationFilter
    nextStepOptions?: StepOptionListRelationFilter
  }

  export type StepOrderByWithRelationInput = {
    id?: SortOrder
    flowId?: SortOrder
    order?: SortOrder
    type?: SortOrder
    message?: SortOrderInput | SortOrder
    dynamicSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    DeletedBy?: SortOrderInput | SortOrder
    DeletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    flow?: FlowOrderByWithRelationInput
    options?: StepOptionOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    nextStepOptions?: StepOptionOrderByRelationAggregateInput
  }

  export type StepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StepWhereInput | StepWhereInput[]
    OR?: StepWhereInput[]
    NOT?: StepWhereInput | StepWhereInput[]
    flowId?: StringFilter<"Step"> | string
    order?: IntFilter<"Step"> | number
    type?: EnumStepTypeFilter<"Step"> | $Enums.StepType
    message?: StringNullableFilter<"Step"> | string | null
    dynamicSource?: EnumDynamicSourceFilter<"Step"> | $Enums.DynamicSource
    createdAt?: DateTimeFilter<"Step"> | Date | string
    updatedAt?: DateTimeFilter<"Step"> | Date | string
    createdBy?: StringFilter<"Step"> | string
    updatedBy?: StringNullableFilter<"Step"> | string | null
    DeletedBy?: StringNullableFilter<"Step"> | string | null
    DeletedAt?: DateTimeNullableFilter<"Step"> | Date | string | null
    isDeleted?: BoolFilter<"Step"> | boolean
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
    options?: StepOptionListRelationFilter
    sessions?: SessionListRelationFilter
    logs?: LogListRelationFilter
    nextStepOptions?: StepOptionListRelationFilter
  }, "id">

  export type StepOrderByWithAggregationInput = {
    id?: SortOrder
    flowId?: SortOrder
    order?: SortOrder
    type?: SortOrder
    message?: SortOrderInput | SortOrder
    dynamicSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    DeletedBy?: SortOrderInput | SortOrder
    DeletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: StepCountOrderByAggregateInput
    _avg?: StepAvgOrderByAggregateInput
    _max?: StepMaxOrderByAggregateInput
    _min?: StepMinOrderByAggregateInput
    _sum?: StepSumOrderByAggregateInput
  }

  export type StepScalarWhereWithAggregatesInput = {
    AND?: StepScalarWhereWithAggregatesInput | StepScalarWhereWithAggregatesInput[]
    OR?: StepScalarWhereWithAggregatesInput[]
    NOT?: StepScalarWhereWithAggregatesInput | StepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Step"> | string
    flowId?: StringWithAggregatesFilter<"Step"> | string
    order?: IntWithAggregatesFilter<"Step"> | number
    type?: EnumStepTypeWithAggregatesFilter<"Step"> | $Enums.StepType
    message?: StringNullableWithAggregatesFilter<"Step"> | string | null
    dynamicSource?: EnumDynamicSourceWithAggregatesFilter<"Step"> | $Enums.DynamicSource
    createdAt?: DateTimeWithAggregatesFilter<"Step"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Step"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Step"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"Step"> | string | null
    DeletedBy?: StringNullableWithAggregatesFilter<"Step"> | string | null
    DeletedAt?: DateTimeNullableWithAggregatesFilter<"Step"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Step"> | boolean
  }

  export type StepOptionWhereInput = {
    AND?: StepOptionWhereInput | StepOptionWhereInput[]
    OR?: StepOptionWhereInput[]
    NOT?: StepOptionWhereInput | StepOptionWhereInput[]
    id?: StringFilter<"StepOption"> | string
    stepId?: StringFilter<"StepOption"> | string
    label?: StringFilter<"StepOption"> | string
    value?: StringFilter<"StepOption"> | string
    nextStepId?: StringNullableFilter<"StepOption"> | string | null
    createdAt?: DateTimeFilter<"StepOption"> | Date | string
    updatedAt?: DateTimeFilter<"StepOption"> | Date | string
    createdBy?: StringFilter<"StepOption"> | string
    updatedBy?: StringNullableFilter<"StepOption"> | string | null
    DeletedBy?: StringNullableFilter<"StepOption"> | string | null
    DeletedAt?: DateTimeNullableFilter<"StepOption"> | Date | string | null
    isDeleted?: BoolFilter<"StepOption"> | boolean
    step?: XOR<StepScalarRelationFilter, StepWhereInput>
    nextStep?: XOR<StepNullableScalarRelationFilter, StepWhereInput> | null
  }

  export type StepOptionOrderByWithRelationInput = {
    id?: SortOrder
    stepId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    nextStepId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    DeletedBy?: SortOrderInput | SortOrder
    DeletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    step?: StepOrderByWithRelationInput
    nextStep?: StepOrderByWithRelationInput
  }

  export type StepOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StepOptionWhereInput | StepOptionWhereInput[]
    OR?: StepOptionWhereInput[]
    NOT?: StepOptionWhereInput | StepOptionWhereInput[]
    stepId?: StringFilter<"StepOption"> | string
    label?: StringFilter<"StepOption"> | string
    value?: StringFilter<"StepOption"> | string
    nextStepId?: StringNullableFilter<"StepOption"> | string | null
    createdAt?: DateTimeFilter<"StepOption"> | Date | string
    updatedAt?: DateTimeFilter<"StepOption"> | Date | string
    createdBy?: StringFilter<"StepOption"> | string
    updatedBy?: StringNullableFilter<"StepOption"> | string | null
    DeletedBy?: StringNullableFilter<"StepOption"> | string | null
    DeletedAt?: DateTimeNullableFilter<"StepOption"> | Date | string | null
    isDeleted?: BoolFilter<"StepOption"> | boolean
    step?: XOR<StepScalarRelationFilter, StepWhereInput>
    nextStep?: XOR<StepNullableScalarRelationFilter, StepWhereInput> | null
  }, "id">

  export type StepOptionOrderByWithAggregationInput = {
    id?: SortOrder
    stepId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    nextStepId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    DeletedBy?: SortOrderInput | SortOrder
    DeletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: StepOptionCountOrderByAggregateInput
    _max?: StepOptionMaxOrderByAggregateInput
    _min?: StepOptionMinOrderByAggregateInput
  }

  export type StepOptionScalarWhereWithAggregatesInput = {
    AND?: StepOptionScalarWhereWithAggregatesInput | StepOptionScalarWhereWithAggregatesInput[]
    OR?: StepOptionScalarWhereWithAggregatesInput[]
    NOT?: StepOptionScalarWhereWithAggregatesInput | StepOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StepOption"> | string
    stepId?: StringWithAggregatesFilter<"StepOption"> | string
    label?: StringWithAggregatesFilter<"StepOption"> | string
    value?: StringWithAggregatesFilter<"StepOption"> | string
    nextStepId?: StringNullableWithAggregatesFilter<"StepOption"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StepOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StepOption"> | Date | string
    createdBy?: StringWithAggregatesFilter<"StepOption"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"StepOption"> | string | null
    DeletedBy?: StringNullableWithAggregatesFilter<"StepOption"> | string | null
    DeletedAt?: DateTimeNullableWithAggregatesFilter<"StepOption"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"StepOption"> | boolean
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    flowId?: StringFilter<"Session"> | string
    currentStepId?: StringNullableFilter<"Session"> | string | null
    isCompleted?: BoolFilter<"Session"> | boolean
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    createdBy?: StringFilter<"Session"> | string
    updatedBy?: StringNullableFilter<"Session"> | string | null
    DeletedBy?: StringNullableFilter<"Session"> | string | null
    DeletedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    isDeleted?: BoolFilter<"Session"> | boolean
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    currentStep?: XOR<StepNullableScalarRelationFilter, StepWhereInput> | null
    logs?: LogListRelationFilter
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    flowId?: SortOrder
    currentStepId?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    DeletedBy?: SortOrderInput | SortOrder
    DeletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    flow?: FlowOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    currentStep?: StepOrderByWithRelationInput
    logs?: LogOrderByRelationAggregateInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    flowId?: StringFilter<"Session"> | string
    currentStepId?: StringNullableFilter<"Session"> | string | null
    isCompleted?: BoolFilter<"Session"> | boolean
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    createdBy?: StringFilter<"Session"> | string
    updatedBy?: StringNullableFilter<"Session"> | string | null
    DeletedBy?: StringNullableFilter<"Session"> | string | null
    DeletedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    isDeleted?: BoolFilter<"Session"> | boolean
    flow?: XOR<FlowScalarRelationFilter, FlowWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    currentStep?: XOR<StepNullableScalarRelationFilter, StepWhereInput> | null
    logs?: LogListRelationFilter
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    flowId?: SortOrder
    currentStepId?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    DeletedBy?: SortOrderInput | SortOrder
    DeletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    flowId?: StringWithAggregatesFilter<"Session"> | string
    currentStepId?: StringNullableWithAggregatesFilter<"Session"> | string | null
    isCompleted?: BoolWithAggregatesFilter<"Session"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Session"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"Session"> | string | null
    DeletedBy?: StringNullableWithAggregatesFilter<"Session"> | string | null
    DeletedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Session"> | boolean
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: StringFilter<"Log"> | string
    sessionId?: StringFilter<"Log"> | string
    stepId?: StringNullableFilter<"Log"> | string | null
    message?: StringFilter<"Log"> | string
    direction?: StringFilter<"Log"> | string
    createdAt?: DateTimeFilter<"Log"> | Date | string
    updatedAt?: DateTimeFilter<"Log"> | Date | string
    createdBy?: StringNullableFilter<"Log"> | string | null
    updatedBy?: StringNullableFilter<"Log"> | string | null
    isDeleted?: BoolFilter<"Log"> | boolean
    deletedAt?: DateTimeNullableFilter<"Log"> | Date | string | null
    deletedBy?: StringNullableFilter<"Log"> | string | null
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    step?: XOR<StepNullableScalarRelationFilter, StepWhereInput> | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    stepId?: SortOrderInput | SortOrder
    message?: SortOrder
    direction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    session?: SessionOrderByWithRelationInput
    step?: StepOrderByWithRelationInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    sessionId?: StringFilter<"Log"> | string
    stepId?: StringNullableFilter<"Log"> | string | null
    message?: StringFilter<"Log"> | string
    direction?: StringFilter<"Log"> | string
    createdAt?: DateTimeFilter<"Log"> | Date | string
    updatedAt?: DateTimeFilter<"Log"> | Date | string
    createdBy?: StringNullableFilter<"Log"> | string | null
    updatedBy?: StringNullableFilter<"Log"> | string | null
    isDeleted?: BoolFilter<"Log"> | boolean
    deletedAt?: DateTimeNullableFilter<"Log"> | Date | string | null
    deletedBy?: StringNullableFilter<"Log"> | string | null
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    step?: XOR<StepNullableScalarRelationFilter, StepWhereInput> | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    stepId?: SortOrderInput | SortOrder
    message?: SortOrder
    direction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: LogCountOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Log"> | string
    sessionId?: StringWithAggregatesFilter<"Log"> | string
    stepId?: StringNullableWithAggregatesFilter<"Log"> | string | null
    message?: StringWithAggregatesFilter<"Log"> | string
    direction?: StringWithAggregatesFilter<"Log"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Log"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Log"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Log"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Log"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Log"> | string | null
  }

  export type ContactUsWhereInput = {
    AND?: ContactUsWhereInput | ContactUsWhereInput[]
    OR?: ContactUsWhereInput[]
    NOT?: ContactUsWhereInput | ContactUsWhereInput[]
    id?: StringFilter<"ContactUs"> | string
    customerName?: StringFilter<"ContactUs"> | string
    email?: StringFilter<"ContactUs"> | string
    phone?: StringNullableFilter<"ContactUs"> | string | null
    businessType?: EnumBusinessTypeFilter<"ContactUs"> | $Enums.BusinessType
    message?: StringFilter<"ContactUs"> | string
    note?: StringNullableFilter<"ContactUs"> | string | null
    status?: EnumContactStatusFilter<"ContactUs"> | $Enums.ContactStatus
    createdAt?: DateTimeFilter<"ContactUs"> | Date | string
    updatedAt?: DateTimeFilter<"ContactUs"> | Date | string
    createdBy?: StringNullableFilter<"ContactUs"> | string | null
    updatedBy?: StringNullableFilter<"ContactUs"> | string | null
    isDeleted?: BoolFilter<"ContactUs"> | boolean
    deletedAt?: DateTimeNullableFilter<"ContactUs"> | Date | string | null
    deletedBy?: StringNullableFilter<"ContactUs"> | string | null
  }

  export type ContactUsOrderByWithRelationInput = {
    id?: SortOrder
    customerName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    businessType?: SortOrder
    message?: SortOrder
    note?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
  }

  export type ContactUsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactUsWhereInput | ContactUsWhereInput[]
    OR?: ContactUsWhereInput[]
    NOT?: ContactUsWhereInput | ContactUsWhereInput[]
    customerName?: StringFilter<"ContactUs"> | string
    email?: StringFilter<"ContactUs"> | string
    phone?: StringNullableFilter<"ContactUs"> | string | null
    businessType?: EnumBusinessTypeFilter<"ContactUs"> | $Enums.BusinessType
    message?: StringFilter<"ContactUs"> | string
    note?: StringNullableFilter<"ContactUs"> | string | null
    status?: EnumContactStatusFilter<"ContactUs"> | $Enums.ContactStatus
    createdAt?: DateTimeFilter<"ContactUs"> | Date | string
    updatedAt?: DateTimeFilter<"ContactUs"> | Date | string
    createdBy?: StringNullableFilter<"ContactUs"> | string | null
    updatedBy?: StringNullableFilter<"ContactUs"> | string | null
    isDeleted?: BoolFilter<"ContactUs"> | boolean
    deletedAt?: DateTimeNullableFilter<"ContactUs"> | Date | string | null
    deletedBy?: StringNullableFilter<"ContactUs"> | string | null
  }, "id">

  export type ContactUsOrderByWithAggregationInput = {
    id?: SortOrder
    customerName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    businessType?: SortOrder
    message?: SortOrder
    note?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: ContactUsCountOrderByAggregateInput
    _max?: ContactUsMaxOrderByAggregateInput
    _min?: ContactUsMinOrderByAggregateInput
  }

  export type ContactUsScalarWhereWithAggregatesInput = {
    AND?: ContactUsScalarWhereWithAggregatesInput | ContactUsScalarWhereWithAggregatesInput[]
    OR?: ContactUsScalarWhereWithAggregatesInput[]
    NOT?: ContactUsScalarWhereWithAggregatesInput | ContactUsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactUs"> | string
    customerName?: StringWithAggregatesFilter<"ContactUs"> | string
    email?: StringWithAggregatesFilter<"ContactUs"> | string
    phone?: StringNullableWithAggregatesFilter<"ContactUs"> | string | null
    businessType?: EnumBusinessTypeWithAggregatesFilter<"ContactUs"> | $Enums.BusinessType
    message?: StringWithAggregatesFilter<"ContactUs"> | string
    note?: StringNullableWithAggregatesFilter<"ContactUs"> | string | null
    status?: EnumContactStatusWithAggregatesFilter<"ContactUs"> | $Enums.ContactStatus
    createdAt?: DateTimeWithAggregatesFilter<"ContactUs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactUs"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"ContactUs"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"ContactUs"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"ContactUs"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ContactUs"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"ContactUs"> | string | null
  }

  export type BookDemoWhereInput = {
    AND?: BookDemoWhereInput | BookDemoWhereInput[]
    OR?: BookDemoWhereInput[]
    NOT?: BookDemoWhereInput | BookDemoWhereInput[]
    id?: StringFilter<"BookDemo"> | string
    name?: StringFilter<"BookDemo"> | string
    email?: StringFilter<"BookDemo"> | string
    phone?: StringNullableFilter<"BookDemo"> | string | null
    businessType?: EnumBusinessTypeFilter<"BookDemo"> | $Enums.BusinessType
    message?: StringFilter<"BookDemo"> | string
    note?: StringNullableFilter<"BookDemo"> | string | null
    status?: EnumDemoStatusFilter<"BookDemo"> | $Enums.DemoStatus
    createdAt?: DateTimeFilter<"BookDemo"> | Date | string
    updatedAt?: DateTimeFilter<"BookDemo"> | Date | string
    createdBy?: StringNullableFilter<"BookDemo"> | string | null
    updatedBy?: StringNullableFilter<"BookDemo"> | string | null
    isDeleted?: BoolFilter<"BookDemo"> | boolean
    deletedAt?: DateTimeNullableFilter<"BookDemo"> | Date | string | null
    deletedBy?: StringNullableFilter<"BookDemo"> | string | null
  }

  export type BookDemoOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    businessType?: SortOrder
    message?: SortOrder
    note?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
  }

  export type BookDemoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookDemoWhereInput | BookDemoWhereInput[]
    OR?: BookDemoWhereInput[]
    NOT?: BookDemoWhereInput | BookDemoWhereInput[]
    name?: StringFilter<"BookDemo"> | string
    email?: StringFilter<"BookDemo"> | string
    phone?: StringNullableFilter<"BookDemo"> | string | null
    businessType?: EnumBusinessTypeFilter<"BookDemo"> | $Enums.BusinessType
    message?: StringFilter<"BookDemo"> | string
    note?: StringNullableFilter<"BookDemo"> | string | null
    status?: EnumDemoStatusFilter<"BookDemo"> | $Enums.DemoStatus
    createdAt?: DateTimeFilter<"BookDemo"> | Date | string
    updatedAt?: DateTimeFilter<"BookDemo"> | Date | string
    createdBy?: StringNullableFilter<"BookDemo"> | string | null
    updatedBy?: StringNullableFilter<"BookDemo"> | string | null
    isDeleted?: BoolFilter<"BookDemo"> | boolean
    deletedAt?: DateTimeNullableFilter<"BookDemo"> | Date | string | null
    deletedBy?: StringNullableFilter<"BookDemo"> | string | null
  }, "id">

  export type BookDemoOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    businessType?: SortOrder
    message?: SortOrder
    note?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: BookDemoCountOrderByAggregateInput
    _max?: BookDemoMaxOrderByAggregateInput
    _min?: BookDemoMinOrderByAggregateInput
  }

  export type BookDemoScalarWhereWithAggregatesInput = {
    AND?: BookDemoScalarWhereWithAggregatesInput | BookDemoScalarWhereWithAggregatesInput[]
    OR?: BookDemoScalarWhereWithAggregatesInput[]
    NOT?: BookDemoScalarWhereWithAggregatesInput | BookDemoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookDemo"> | string
    name?: StringWithAggregatesFilter<"BookDemo"> | string
    email?: StringWithAggregatesFilter<"BookDemo"> | string
    phone?: StringNullableWithAggregatesFilter<"BookDemo"> | string | null
    businessType?: EnumBusinessTypeWithAggregatesFilter<"BookDemo"> | $Enums.BusinessType
    message?: StringWithAggregatesFilter<"BookDemo"> | string
    note?: StringNullableWithAggregatesFilter<"BookDemo"> | string | null
    status?: EnumDemoStatusWithAggregatesFilter<"BookDemo"> | $Enums.DemoStatus
    createdAt?: DateTimeWithAggregatesFilter<"BookDemo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BookDemo"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"BookDemo"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"BookDemo"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"BookDemo"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"BookDemo"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"BookDemo"> | string | null
  }

  export type FAQWhereInput = {
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    id?: StringFilter<"FAQ"> | string
    question?: StringFilter<"FAQ"> | string
    answer?: StringFilter<"FAQ"> | string
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeFilter<"FAQ"> | Date | string
    createdBy?: StringNullableFilter<"FAQ"> | string | null
    updatedBy?: StringNullableFilter<"FAQ"> | string | null
    isDeleted?: BoolFilter<"FAQ"> | boolean
    deletedAt?: DateTimeNullableFilter<"FAQ"> | Date | string | null
    deletedBy?: StringNullableFilter<"FAQ"> | string | null
  }

  export type FAQOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
  }

  export type FAQWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    question?: StringFilter<"FAQ"> | string
    answer?: StringFilter<"FAQ"> | string
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeFilter<"FAQ"> | Date | string
    createdBy?: StringNullableFilter<"FAQ"> | string | null
    updatedBy?: StringNullableFilter<"FAQ"> | string | null
    isDeleted?: BoolFilter<"FAQ"> | boolean
    deletedAt?: DateTimeNullableFilter<"FAQ"> | Date | string | null
    deletedBy?: StringNullableFilter<"FAQ"> | string | null
  }, "id">

  export type FAQOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: FAQCountOrderByAggregateInput
    _max?: FAQMaxOrderByAggregateInput
    _min?: FAQMinOrderByAggregateInput
  }

  export type FAQScalarWhereWithAggregatesInput = {
    AND?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    OR?: FAQScalarWhereWithAggregatesInput[]
    NOT?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FAQ"> | string
    question?: StringWithAggregatesFilter<"FAQ"> | string
    answer?: StringWithAggregatesFilter<"FAQ"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FAQ"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"FAQ"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"FAQ"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"FAQ"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"FAQ"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"FAQ"> | string | null
  }

  export type TermsConditionWhereInput = {
    AND?: TermsConditionWhereInput | TermsConditionWhereInput[]
    OR?: TermsConditionWhereInput[]
    NOT?: TermsConditionWhereInput | TermsConditionWhereInput[]
    id?: StringFilter<"TermsCondition"> | string
    content?: StringFilter<"TermsCondition"> | string
    createdAt?: DateTimeFilter<"TermsCondition"> | Date | string
    updatedAt?: DateTimeFilter<"TermsCondition"> | Date | string
    createdBy?: StringNullableFilter<"TermsCondition"> | string | null
    updatedBy?: StringNullableFilter<"TermsCondition"> | string | null
    isDeleted?: BoolFilter<"TermsCondition"> | boolean
    deletedAt?: DateTimeNullableFilter<"TermsCondition"> | Date | string | null
    deletedBy?: StringNullableFilter<"TermsCondition"> | string | null
  }

  export type TermsConditionOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
  }

  export type TermsConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TermsConditionWhereInput | TermsConditionWhereInput[]
    OR?: TermsConditionWhereInput[]
    NOT?: TermsConditionWhereInput | TermsConditionWhereInput[]
    content?: StringFilter<"TermsCondition"> | string
    createdAt?: DateTimeFilter<"TermsCondition"> | Date | string
    updatedAt?: DateTimeFilter<"TermsCondition"> | Date | string
    createdBy?: StringNullableFilter<"TermsCondition"> | string | null
    updatedBy?: StringNullableFilter<"TermsCondition"> | string | null
    isDeleted?: BoolFilter<"TermsCondition"> | boolean
    deletedAt?: DateTimeNullableFilter<"TermsCondition"> | Date | string | null
    deletedBy?: StringNullableFilter<"TermsCondition"> | string | null
  }, "id">

  export type TermsConditionOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: TermsConditionCountOrderByAggregateInput
    _max?: TermsConditionMaxOrderByAggregateInput
    _min?: TermsConditionMinOrderByAggregateInput
  }

  export type TermsConditionScalarWhereWithAggregatesInput = {
    AND?: TermsConditionScalarWhereWithAggregatesInput | TermsConditionScalarWhereWithAggregatesInput[]
    OR?: TermsConditionScalarWhereWithAggregatesInput[]
    NOT?: TermsConditionScalarWhereWithAggregatesInput | TermsConditionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TermsCondition"> | string
    content?: StringWithAggregatesFilter<"TermsCondition"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TermsCondition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TermsCondition"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"TermsCondition"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"TermsCondition"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"TermsCondition"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"TermsCondition"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"TermsCondition"> | string | null
  }

  export type PrivacyPolicyWhereInput = {
    AND?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    OR?: PrivacyPolicyWhereInput[]
    NOT?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    id?: StringFilter<"PrivacyPolicy"> | string
    content?: StringFilter<"PrivacyPolicy"> | string
    createdAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
    createdBy?: StringNullableFilter<"PrivacyPolicy"> | string | null
    updatedBy?: StringNullableFilter<"PrivacyPolicy"> | string | null
    isDeleted?: BoolFilter<"PrivacyPolicy"> | boolean
    deletedAt?: DateTimeNullableFilter<"PrivacyPolicy"> | Date | string | null
    deletedBy?: StringNullableFilter<"PrivacyPolicy"> | string | null
  }

  export type PrivacyPolicyOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
  }

  export type PrivacyPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    OR?: PrivacyPolicyWhereInput[]
    NOT?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    content?: StringFilter<"PrivacyPolicy"> | string
    createdAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
    createdBy?: StringNullableFilter<"PrivacyPolicy"> | string | null
    updatedBy?: StringNullableFilter<"PrivacyPolicy"> | string | null
    isDeleted?: BoolFilter<"PrivacyPolicy"> | boolean
    deletedAt?: DateTimeNullableFilter<"PrivacyPolicy"> | Date | string | null
    deletedBy?: StringNullableFilter<"PrivacyPolicy"> | string | null
  }, "id">

  export type PrivacyPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: PrivacyPolicyCountOrderByAggregateInput
    _max?: PrivacyPolicyMaxOrderByAggregateInput
    _min?: PrivacyPolicyMinOrderByAggregateInput
  }

  export type PrivacyPolicyScalarWhereWithAggregatesInput = {
    AND?: PrivacyPolicyScalarWhereWithAggregatesInput | PrivacyPolicyScalarWhereWithAggregatesInput[]
    OR?: PrivacyPolicyScalarWhereWithAggregatesInput[]
    NOT?: PrivacyPolicyScalarWhereWithAggregatesInput | PrivacyPolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrivacyPolicy"> | string
    content?: StringWithAggregatesFilter<"PrivacyPolicy"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PrivacyPolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrivacyPolicy"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"PrivacyPolicy"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"PrivacyPolicy"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"PrivacyPolicy"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PrivacyPolicy"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"PrivacyPolicy"> | string | null
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    userName?: StringFilter<"Alert"> | string
    userRole?: EnumUserRoleFilter<"Alert"> | $Enums.UserRole
    action?: EnumAlertActionFilter<"Alert"> | $Enums.AlertAction
    activity?: StringFilter<"Alert"> | string
    isRead?: BoolFilter<"Alert"> | boolean
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    userId?: StringNullableFilter<"Alert"> | string | null
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    activity?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    userName?: StringFilter<"Alert"> | string
    userRole?: EnumUserRoleFilter<"Alert"> | $Enums.UserRole
    action?: EnumAlertActionFilter<"Alert"> | $Enums.AlertAction
    activity?: StringFilter<"Alert"> | string
    isRead?: BoolFilter<"Alert"> | boolean
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    userId?: StringNullableFilter<"Alert"> | string | null
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    activity?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: AlertCountOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    userName?: StringWithAggregatesFilter<"Alert"> | string
    userRole?: EnumUserRoleWithAggregatesFilter<"Alert"> | $Enums.UserRole
    action?: EnumAlertActionWithAggregatesFilter<"Alert"> | $Enums.AlertAction
    activity?: StringWithAggregatesFilter<"Alert"> | string
    isRead?: BoolWithAggregatesFilter<"Alert"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"Alert"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceSettingCreateInput = {
    id?: string
    isEnabled?: boolean
    updatedById?: string | null
    updatedByName?: string | null
    updatedByRole?: $Enums.UserRole | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type MaintenanceSettingUncheckedCreateInput = {
    id?: string
    isEnabled?: boolean
    updatedById?: string | null
    updatedByName?: string | null
    updatedByRole?: $Enums.UserRole | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type MaintenanceSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByRole?: NullableEnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByRole?: NullableEnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceSettingCreateManyInput = {
    id?: string
    isEnabled?: boolean
    updatedById?: string | null
    updatedByName?: string | null
    updatedByRole?: $Enums.UserRole | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type MaintenanceSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByRole?: NullableEnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByRole?: NullableEnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionCreateInput = {
    id?: string
    type: $Enums.SubscriptionType
    description: string
    price: number
    noOfBranches: number
    noOfAdmins: number
    noOfStaffManagers: number
    noOfServiceProviders: number
    noOfReceptionists: number
    whatsappBot: boolean
    manualReminder: boolean
    automatedReminder: boolean
    googleReviewLink: boolean
    promotions: boolean
    selfServiceTablet: boolean
    basicDashboard: boolean
    fullAccessDashboard: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriptionInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriptionInput
    businesses?: BusinessCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    type: $Enums.SubscriptionType
    description: string
    price: number
    noOfBranches: number
    noOfAdmins: number
    noOfStaffManagers: number
    noOfServiceProviders: number
    noOfReceptionists: number
    whatsappBot: boolean
    manualReminder: boolean
    automatedReminder: boolean
    googleReviewLink: boolean
    promotions: boolean
    selfServiceTablet: boolean
    basicDashboard: boolean
    fullAccessDashboard: boolean
    subscriberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriptionInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    noOfBranches?: IntFieldUpdateOperationsInput | number
    noOfAdmins?: IntFieldUpdateOperationsInput | number
    noOfStaffManagers?: IntFieldUpdateOperationsInput | number
    noOfServiceProviders?: IntFieldUpdateOperationsInput | number
    noOfReceptionists?: IntFieldUpdateOperationsInput | number
    whatsappBot?: BoolFieldUpdateOperationsInput | boolean
    manualReminder?: BoolFieldUpdateOperationsInput | boolean
    automatedReminder?: BoolFieldUpdateOperationsInput | boolean
    googleReviewLink?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    selfServiceTablet?: BoolFieldUpdateOperationsInput | boolean
    basicDashboard?: BoolFieldUpdateOperationsInput | boolean
    fullAccessDashboard?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriptionNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriptionNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    noOfBranches?: IntFieldUpdateOperationsInput | number
    noOfAdmins?: IntFieldUpdateOperationsInput | number
    noOfStaffManagers?: IntFieldUpdateOperationsInput | number
    noOfServiceProviders?: IntFieldUpdateOperationsInput | number
    noOfReceptionists?: IntFieldUpdateOperationsInput | number
    whatsappBot?: BoolFieldUpdateOperationsInput | boolean
    manualReminder?: BoolFieldUpdateOperationsInput | boolean
    automatedReminder?: BoolFieldUpdateOperationsInput | boolean
    googleReviewLink?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    selfServiceTablet?: BoolFieldUpdateOperationsInput | boolean
    basicDashboard?: BoolFieldUpdateOperationsInput | boolean
    fullAccessDashboard?: BoolFieldUpdateOperationsInput | boolean
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriptionNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    type: $Enums.SubscriptionType
    description: string
    price: number
    noOfBranches: number
    noOfAdmins: number
    noOfStaffManagers: number
    noOfServiceProviders: number
    noOfReceptionists: number
    whatsappBot: boolean
    manualReminder: boolean
    automatedReminder: boolean
    googleReviewLink: boolean
    promotions: boolean
    selfServiceTablet: boolean
    basicDashboard: boolean
    fullAccessDashboard: boolean
    subscriberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    noOfBranches?: IntFieldUpdateOperationsInput | number
    noOfAdmins?: IntFieldUpdateOperationsInput | number
    noOfStaffManagers?: IntFieldUpdateOperationsInput | number
    noOfServiceProviders?: IntFieldUpdateOperationsInput | number
    noOfReceptionists?: IntFieldUpdateOperationsInput | number
    whatsappBot?: BoolFieldUpdateOperationsInput | boolean
    manualReminder?: BoolFieldUpdateOperationsInput | boolean
    automatedReminder?: BoolFieldUpdateOperationsInput | boolean
    googleReviewLink?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    selfServiceTablet?: BoolFieldUpdateOperationsInput | boolean
    basicDashboard?: BoolFieldUpdateOperationsInput | boolean
    fullAccessDashboard?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    noOfBranches?: IntFieldUpdateOperationsInput | number
    noOfAdmins?: IntFieldUpdateOperationsInput | number
    noOfStaffManagers?: IntFieldUpdateOperationsInput | number
    noOfServiceProviders?: IntFieldUpdateOperationsInput | number
    noOfReceptionists?: IntFieldUpdateOperationsInput | number
    whatsappBot?: BoolFieldUpdateOperationsInput | boolean
    manualReminder?: BoolFieldUpdateOperationsInput | boolean
    automatedReminder?: BoolFieldUpdateOperationsInput | boolean
    googleReviewLink?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    selfServiceTablet?: BoolFieldUpdateOperationsInput | boolean
    basicDashboard?: BoolFieldUpdateOperationsInput | boolean
    fullAccessDashboard?: BoolFieldUpdateOperationsInput | boolean
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriberSubscriptionCreateInput = {
    id?: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    business?: BusinessCreateNestedOneWithoutSubscriberSubscriptionsInput
    subscriber: UserCreateNestedOneWithoutSubscriberSubscriptionsInput
    subscription: SubscriptionCreateNestedOneWithoutSubscriberSubscriptionsInput
    appointments?: AppointmentCreateNestedManyWithoutSubscriberSubscriptionInput
    discountLogs?: SubscriptionDiscountLogCreateNestedManyWithoutSubscriberSubscriptionInput
  }

  export type SubscriberSubscriptionUncheckedCreateInput = {
    id?: string
    subscriberId: string
    subscriptionId: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    businessId?: string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSubscriberSubscriptionInput
    discountLogs?: SubscriptionDiscountLogUncheckedCreateNestedManyWithoutSubscriberSubscriptionInput
  }

  export type SubscriberSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessUpdateOneWithoutSubscriberSubscriptionsNestedInput
    subscriber?: UserUpdateOneRequiredWithoutSubscriberSubscriptionsNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutSubscriberSubscriptionsNestedInput
    appointments?: AppointmentUpdateManyWithoutSubscriberSubscriptionNestedInput
    discountLogs?: SubscriptionDiscountLogUpdateManyWithoutSubscriberSubscriptionNestedInput
  }

  export type SubscriberSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutSubscriberSubscriptionNestedInput
    discountLogs?: SubscriptionDiscountLogUncheckedUpdateManyWithoutSubscriberSubscriptionNestedInput
  }

  export type SubscriberSubscriptionCreateManyInput = {
    id?: string
    subscriberId: string
    subscriptionId: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    businessId?: string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type SubscriberSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriberSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DiscountCreateInput = {
    id?: string
    code: string
    group: $Enums.DiscountGroup
    packageType: $Enums.SubscriptionType
    discountType: $Enums.DiscountType
    value: number
    usageLimit?: number | null
    usageCount?: number
    startDate: Date | string
    expiryDate: Date | string
    isManuallyExpired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    businesses?: BusinessCreateNestedManyWithoutDiscountCodeInput
    appointments?: AppointmentCreateNestedManyWithoutDiscountInput
    subscriptionDiscountLogs?: SubscriptionDiscountLogCreateNestedManyWithoutDiscountInput
  }

  export type DiscountUncheckedCreateInput = {
    id?: string
    code: string
    group: $Enums.DiscountGroup
    packageType: $Enums.SubscriptionType
    discountType: $Enums.DiscountType
    value: number
    usageLimit?: number | null
    usageCount?: number
    startDate: Date | string
    expiryDate: Date | string
    isManuallyExpired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    businesses?: BusinessUncheckedCreateNestedManyWithoutDiscountCodeInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDiscountInput
    subscriptionDiscountLogs?: SubscriptionDiscountLogUncheckedCreateNestedManyWithoutDiscountInput
  }

  export type DiscountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    group?: EnumDiscountGroupFieldUpdateOperationsInput | $Enums.DiscountGroup
    packageType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isManuallyExpired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    businesses?: BusinessUpdateManyWithoutDiscountCodeNestedInput
    appointments?: AppointmentUpdateManyWithoutDiscountNestedInput
    subscriptionDiscountLogs?: SubscriptionDiscountLogUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    group?: EnumDiscountGroupFieldUpdateOperationsInput | $Enums.DiscountGroup
    packageType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isManuallyExpired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    businesses?: BusinessUncheckedUpdateManyWithoutDiscountCodeNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDiscountNestedInput
    subscriptionDiscountLogs?: SubscriptionDiscountLogUncheckedUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountCreateManyInput = {
    id?: string
    code: string
    group: $Enums.DiscountGroup
    packageType: $Enums.SubscriptionType
    discountType: $Enums.DiscountType
    value: number
    usageLimit?: number | null
    usageCount?: number
    startDate: Date | string
    expiryDate: Date | string
    isManuallyExpired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type DiscountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    group?: EnumDiscountGroupFieldUpdateOperationsInput | $Enums.DiscountGroup
    packageType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isManuallyExpired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DiscountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    group?: EnumDiscountGroupFieldUpdateOperationsInput | $Enums.DiscountGroup
    packageType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isManuallyExpired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionDiscountLogCreateInput = {
    id?: string
    discountCode: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountedAmount: number
    originalPrice: number
    finalPrice: number
    appliedAt?: Date | string
    createdBy?: string | null
    subscriberSubscription: SubscriberSubscriptionCreateNestedOneWithoutDiscountLogsInput
    discount: DiscountCreateNestedOneWithoutSubscriptionDiscountLogsInput
  }

  export type SubscriptionDiscountLogUncheckedCreateInput = {
    id?: string
    subscriberSubscriptionId: string
    discountId: string
    discountCode: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountedAmount: number
    originalPrice: number
    finalPrice: number
    appliedAt?: Date | string
    createdBy?: string | null
  }

  export type SubscriptionDiscountLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountedAmount?: FloatFieldUpdateOperationsInput | number
    originalPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberSubscription?: SubscriberSubscriptionUpdateOneRequiredWithoutDiscountLogsNestedInput
    discount?: DiscountUpdateOneRequiredWithoutSubscriptionDiscountLogsNestedInput
  }

  export type SubscriptionDiscountLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberSubscriptionId?: StringFieldUpdateOperationsInput | string
    discountId?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountedAmount?: FloatFieldUpdateOperationsInput | number
    originalPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionDiscountLogCreateManyInput = {
    id?: string
    subscriberSubscriptionId: string
    discountId: string
    discountCode: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountedAmount: number
    originalPrice: number
    finalPrice: number
    appliedAt?: Date | string
    createdBy?: string | null
  }

  export type SubscriptionDiscountLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountedAmount?: FloatFieldUpdateOperationsInput | number
    originalPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionDiscountLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberSubscriptionId?: StringFieldUpdateOperationsInput | string
    discountId?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountedAmount?: FloatFieldUpdateOperationsInput | number
    originalPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessCreateInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowCreateNestedManyWithoutBusinessInput
    whatsappNumbers?: WhatsAppNumberCreateNestedManyWithoutBusinessInput
    subscriber?: UserCreateNestedOneWithoutBusinessesInput
    discountCode?: DiscountCreateNestedOneWithoutBusinessesInput
    branches?: BranchCreateNestedManyWithoutBusinessInput
    subscription?: SubscriptionCreateNestedOneWithoutBusinessesInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    discountCodeId?: string | null
    subscriberId?: string | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowUncheckedCreateNestedManyWithoutBusinessInput
    whatsappNumbers?: WhatsAppNumberUncheckedCreateNestedManyWithoutBusinessInput
    branches?: BranchUncheckedCreateNestedManyWithoutBusinessInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUpdateManyWithoutBusinessNestedInput
    whatsappNumbers?: WhatsAppNumberUpdateManyWithoutBusinessNestedInput
    subscriber?: UserUpdateOneWithoutBusinessesNestedInput
    discountCode?: DiscountUpdateOneWithoutBusinessesNestedInput
    branches?: BranchUpdateManyWithoutBusinessNestedInput
    subscription?: SubscriptionUpdateOneWithoutBusinessesNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    discountCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUncheckedUpdateManyWithoutBusinessNestedInput
    whatsappNumbers?: WhatsAppNumberUncheckedUpdateManyWithoutBusinessNestedInput
    branches?: BranchUncheckedUpdateManyWithoutBusinessNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateManyInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    discountCodeId?: string | null
    subscriberId?: string | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type BusinessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    discountCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BranchCreateInput = {
    id?: string
    name: string
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber: UserCreateNestedOneWithoutOwnedBranchesInput
    business?: BusinessCreateNestedOneWithoutBranchesInput
    users?: UserCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    promotions?: PromotionCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: string
    name: string
    subscriberId: string
    businessId?: string | null
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountUncheckedCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneRequiredWithoutOwnedBranchesNestedInput
    business?: BusinessUpdateOneWithoutBranchesNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUncheckedUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUncheckedUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: string
    name: string
    subscriberId: string
    businessId?: string | null
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type BranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleHourCreateInput = {
    id?: string
    ownerType: $Enums.ScheduleOwnerType
    ownerId: string
    dayOfWeek: $Enums.WeekDay
    openTime: string
    closeTime: string
    isClosed?: boolean
    inheritanceMode?: $Enums.ScheduleInheritanceMode
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    staff?: UserCreateNestedOneWithoutScheduleHoursInput
    business?: BusinessCreateNestedOneWithoutScheduleHoursInput
    branch?: BranchCreateNestedOneWithoutScheduleHoursInput
  }

  export type ScheduleHourUncheckedCreateInput = {
    id?: string
    ownerType: $Enums.ScheduleOwnerType
    ownerId: string
    dayOfWeek: $Enums.WeekDay
    openTime: string
    closeTime: string
    isClosed?: boolean
    inheritanceMode?: $Enums.ScheduleInheritanceMode
    staffId?: string | null
    businessId?: string | null
    branchId?: string | null
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ScheduleHourUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumScheduleOwnerTypeFieldUpdateOperationsInput | $Enums.ScheduleOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFieldUpdateOperationsInput | $Enums.ScheduleInheritanceMode
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: UserUpdateOneWithoutScheduleHoursNestedInput
    business?: BusinessUpdateOneWithoutScheduleHoursNestedInput
    branch?: BranchUpdateOneWithoutScheduleHoursNestedInput
  }

  export type ScheduleHourUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumScheduleOwnerTypeFieldUpdateOperationsInput | $Enums.ScheduleOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFieldUpdateOperationsInput | $Enums.ScheduleInheritanceMode
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleHourCreateManyInput = {
    id?: string
    ownerType: $Enums.ScheduleOwnerType
    ownerId: string
    dayOfWeek: $Enums.WeekDay
    openTime: string
    closeTime: string
    isClosed?: boolean
    inheritanceMode?: $Enums.ScheduleInheritanceMode
    staffId?: string | null
    businessId?: string | null
    branchId?: string | null
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ScheduleHourUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumScheduleOwnerTypeFieldUpdateOperationsInput | $Enums.ScheduleOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFieldUpdateOperationsInput | $Enums.ScheduleInheritanceMode
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleHourUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumScheduleOwnerTypeFieldUpdateOperationsInput | $Enums.ScheduleOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFieldUpdateOperationsInput | $Enums.ScheduleInheritanceMode
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StaffStatusLogCreateInput = {
    id?: string
    status: $Enums.StaffStatus
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutStatusLogsInput
  }

  export type StaffStatusLogUncheckedCreateInput = {
    id?: string
    userId: string
    status: $Enums.StaffStatus
    timestamp?: Date | string
  }

  export type StaffStatusLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStaffStatusFieldUpdateOperationsInput | $Enums.StaffStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStatusLogsNestedInput
  }

  export type StaffStatusLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStaffStatusFieldUpdateOperationsInput | $Enums.StaffStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffStatusLogCreateManyInput = {
    id?: string
    userId: string
    status: $Enums.StaffStatus
    timestamp?: Date | string
  }

  export type StaffStatusLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStaffStatusFieldUpdateOperationsInput | $Enums.StaffStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffStatusLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStaffStatusFieldUpdateOperationsInput | $Enums.StaffStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    staff: UserCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    staffId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: UserUpdateOneRequiredWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceCreateManyInput = {
    id?: string
    staffId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VacationCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status: $Enums.VacationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    staff: UserCreateNestedOneWithoutVacationsInput
  }

  export type VacationUncheckedCreateInput = {
    id?: string
    staffId: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status: $Enums.VacationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type VacationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVacationStatusFieldUpdateOperationsInput | $Enums.VacationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: UserUpdateOneRequiredWithoutVacationsNestedInput
  }

  export type VacationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVacationStatusFieldUpdateOperationsInput | $Enums.VacationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VacationCreateManyInput = {
    id?: string
    staffId: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status: $Enums.VacationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type VacationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVacationStatusFieldUpdateOperationsInput | $Enums.VacationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VacationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVacationStatusFieldUpdateOperationsInput | $Enums.VacationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    providerId?: string | null
    duration: number
    price: number
    bufferTime: number
    status?: boolean
    frequency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    providers?: UserOnServiceCreateNestedManyWithoutServiceInput
    branches?: ServiceBranchCreateNestedManyWithoutServiceInput
    appointments?: AppointmentCreateNestedManyWithoutServiceInput
    whatsappAds?: WhatsappAdCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    providerId?: string | null
    duration: number
    price: number
    bufferTime: number
    status?: boolean
    frequency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    providers?: UserOnServiceUncheckedCreateNestedManyWithoutServiceInput
    branches?: ServiceBranchUncheckedCreateNestedManyWithoutServiceInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutServiceInput
    whatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    bufferTime?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: UserOnServiceUpdateManyWithoutServiceNestedInput
    branches?: ServiceBranchUpdateManyWithoutServiceNestedInput
    appointments?: AppointmentUpdateManyWithoutServiceNestedInput
    whatsappAds?: WhatsappAdUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    bufferTime?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: UserOnServiceUncheckedUpdateManyWithoutServiceNestedInput
    branches?: ServiceBranchUncheckedUpdateManyWithoutServiceNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutServiceNestedInput
    whatsappAds?: WhatsappAdUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    providerId?: string | null
    duration: number
    price: number
    bufferTime: number
    status?: boolean
    frequency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    bufferTime?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    bufferTime?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserOnServiceCreateInput = {
    id?: string
    service: ServiceCreateNestedOneWithoutProvidersInput
    provider: UserCreateNestedOneWithoutServicesInput
  }

  export type UserOnServiceUncheckedCreateInput = {
    id?: string
    serviceId: string
    providerId: string
  }

  export type UserOnServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: ServiceUpdateOneRequiredWithoutProvidersNestedInput
    provider?: UserUpdateOneRequiredWithoutServicesNestedInput
  }

  export type UserOnServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type UserOnServiceCreateManyInput = {
    id?: string
    serviceId: string
    providerId: string
  }

  export type UserOnServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserOnServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceBranchCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    service: ServiceCreateNestedOneWithoutBranchesInput
    branch: BranchCreateNestedOneWithoutServiceBranchesInput
  }

  export type ServiceBranchUncheckedCreateInput = {
    id?: string
    serviceId: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ServiceBranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceUpdateOneRequiredWithoutBranchesNestedInput
    branch?: BranchUpdateOneRequiredWithoutServiceBranchesNestedInput
  }

  export type ServiceBranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceBranchCreateManyInput = {
    id?: string
    serviceId: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ServiceBranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceBranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentCreateInput = {
    id?: string
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    promotion?: PromotionCreateNestedOneWithoutAppointmentsInput
    subscriberSubscription?: SubscriberSubscriptionCreateNestedOneWithoutAppointmentsInput
    discount?: DiscountCreateNestedOneWithoutAppointmentsInput
    service: ServiceCreateNestedOneWithoutAppointmentsInput
    consumer: UserCreateNestedOneWithoutAppointmentsAsConsumerInput
    serviceProvider?: UserCreateNestedOneWithoutAppointmentsAsProviderInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    serviceId: string
    consumerId: string
    branchId: string
    serviceProviderId?: string | null
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    discountId?: string | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    subscriberSubscriptionId?: string | null
    promotionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotion?: PromotionUpdateOneWithoutAppointmentsNestedInput
    subscriberSubscription?: SubscriberSubscriptionUpdateOneWithoutAppointmentsNestedInput
    discount?: DiscountUpdateOneWithoutAppointmentsNestedInput
    service?: ServiceUpdateOneRequiredWithoutAppointmentsNestedInput
    consumer?: UserUpdateOneRequiredWithoutAppointmentsAsConsumerNestedInput
    serviceProvider?: UserUpdateOneWithoutAppointmentsAsProviderNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    consumerId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    subscriberSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentCreateManyInput = {
    id?: string
    serviceId: string
    consumerId: string
    branchId: string
    serviceProviderId?: string | null
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    discountId?: string | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    subscriberSubscriptionId?: string | null
    promotionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    consumerId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    subscriberSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionCreateInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: number
    limit?: number | null
    status?: boolean
    startDate: Date | string
    expiryDate: Date | string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    branches?: BranchCreateNestedManyWithoutPromotionsInput
    appointments?: AppointmentCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: number
    limit?: number | null
    status?: boolean
    startDate: Date | string
    expiryDate: Date | string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    branches?: BranchUncheckedCreateNestedManyWithoutPromotionsInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branches?: BranchUpdateManyWithoutPromotionsNestedInput
    appointments?: AppointmentUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branches?: BranchUncheckedUpdateManyWithoutPromotionsNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionCreateManyInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: number
    limit?: number | null
    status?: boolean
    startDate: Date | string
    expiryDate: Date | string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TabletAccountCreateInput = {
    id?: string
    username: string
    password: string
    loginLink?: string | null
    loginToken: string
    isActive?: boolean
    isLoggedIn?: boolean
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    branch: BranchCreateNestedOneWithoutTabletAccountsInput
  }

  export type TabletAccountUncheckedCreateInput = {
    id?: string
    username: string
    password: string
    branchId: string
    loginLink?: string | null
    loginToken: string
    isActive?: boolean
    isLoggedIn?: boolean
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TabletAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    loginLink?: NullableStringFieldUpdateOperationsInput | string | null
    loginToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneRequiredWithoutTabletAccountsNestedInput
  }

  export type TabletAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    loginLink?: NullableStringFieldUpdateOperationsInput | string | null
    loginToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TabletAccountCreateManyInput = {
    id?: string
    username: string
    password: string
    branchId: string
    loginLink?: string | null
    loginToken: string
    isActive?: boolean
    isLoggedIn?: boolean
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TabletAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    loginLink?: NullableStringFieldUpdateOperationsInput | string | null
    loginToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TabletAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    loginLink?: NullableStringFieldUpdateOperationsInput | string | null
    loginToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsappAdCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    targetDate: Date | string
    customerType: $Enums.AdTargetType
    status?: $Enums.AdStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    branch: BranchCreateNestedOneWithoutWhatsappAdsInput
    service?: ServiceCreateNestedOneWithoutWhatsappAdsInput
    assignedCustomers?: UserCreateNestedManyWithoutAssignedWhatsappAdsInput
  }

  export type WhatsappAdUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    targetDate: Date | string
    customerType: $Enums.AdTargetType
    branchId: string
    serviceId?: string | null
    status?: $Enums.AdStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    assignedCustomers?: UserUncheckedCreateNestedManyWithoutAssignedWhatsappAdsInput
  }

  export type WhatsappAdUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerType?: EnumAdTargetTypeFieldUpdateOperationsInput | $Enums.AdTargetType
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneRequiredWithoutWhatsappAdsNestedInput
    service?: ServiceUpdateOneWithoutWhatsappAdsNestedInput
    assignedCustomers?: UserUpdateManyWithoutAssignedWhatsappAdsNestedInput
  }

  export type WhatsappAdUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerType?: EnumAdTargetTypeFieldUpdateOperationsInput | $Enums.AdTargetType
    branchId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedCustomers?: UserUncheckedUpdateManyWithoutAssignedWhatsappAdsNestedInput
  }

  export type WhatsappAdCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    targetDate: Date | string
    customerType: $Enums.AdTargetType
    branchId: string
    serviceId?: string | null
    status?: $Enums.AdStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type WhatsappAdUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerType?: EnumAdTargetTypeFieldUpdateOperationsInput | $Enums.AdTargetType
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsappAdUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerType?: EnumAdTargetTypeFieldUpdateOperationsInput | $Enums.AdTargetType
    branchId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsAppNumberCreateInput = {
    id?: string
    phoneNumber: string
    phoneNumberId?: string | null
    wabaId?: string | null
    accessToken?: string | null
    isVerified?: boolean
    otp?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    business: BusinessCreateNestedOneWithoutWhatsappNumbersInput
    defaultFlow?: FlowCreateNestedOneWithoutWhatsappNumbersInput
  }

  export type WhatsAppNumberUncheckedCreateInput = {
    id?: string
    businessId: string
    phoneNumber: string
    phoneNumberId?: string | null
    wabaId?: string | null
    accessToken?: string | null
    isVerified?: boolean
    defaultFlowId?: string | null
    otp?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type WhatsAppNumberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: NullableStringFieldUpdateOperationsInput | string | null
    wabaId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    business?: BusinessUpdateOneRequiredWithoutWhatsappNumbersNestedInput
    defaultFlow?: FlowUpdateOneWithoutWhatsappNumbersNestedInput
  }

  export type WhatsAppNumberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: NullableStringFieldUpdateOperationsInput | string | null
    wabaId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    defaultFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WhatsAppNumberCreateManyInput = {
    id?: string
    businessId: string
    phoneNumber: string
    phoneNumberId?: string | null
    wabaId?: string | null
    accessToken?: string | null
    isVerified?: boolean
    defaultFlowId?: string | null
    otp?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type WhatsAppNumberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: NullableStringFieldUpdateOperationsInput | string | null
    wabaId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WhatsAppNumberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: NullableStringFieldUpdateOperationsInput | string | null
    wabaId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    defaultFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FlowCreateInput = {
    id?: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    business?: BusinessCreateNestedOneWithoutFlowsInput
    steps?: StepCreateNestedManyWithoutFlowInput
    sessions?: SessionCreateNestedManyWithoutFlowInput
    whatsappNumbers?: WhatsAppNumberCreateNestedManyWithoutDefaultFlowInput
  }

  export type FlowUncheckedCreateInput = {
    id?: string
    name: string
    isActive?: boolean
    businessId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    steps?: StepUncheckedCreateNestedManyWithoutFlowInput
    sessions?: SessionUncheckedCreateNestedManyWithoutFlowInput
    whatsappNumbers?: WhatsAppNumberUncheckedCreateNestedManyWithoutDefaultFlowInput
  }

  export type FlowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    business?: BusinessUpdateOneWithoutFlowsNestedInput
    steps?: StepUpdateManyWithoutFlowNestedInput
    sessions?: SessionUpdateManyWithoutFlowNestedInput
    whatsappNumbers?: WhatsAppNumberUpdateManyWithoutDefaultFlowNestedInput
  }

  export type FlowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    steps?: StepUncheckedUpdateManyWithoutFlowNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutFlowNestedInput
    whatsappNumbers?: WhatsAppNumberUncheckedUpdateManyWithoutDefaultFlowNestedInput
  }

  export type FlowCreateManyInput = {
    id?: string
    name: string
    isActive?: boolean
    businessId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type FlowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FlowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StepCreateInput = {
    id?: string
    order: number
    type: $Enums.StepType
    message?: string | null
    dynamicSource?: $Enums.DynamicSource
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    flow: FlowCreateNestedOneWithoutStepsInput
    options?: StepOptionCreateNestedManyWithoutStepInput
    sessions?: SessionCreateNestedManyWithoutCurrentStepInput
    logs?: LogCreateNestedManyWithoutStepInput
    nextStepOptions?: StepOptionCreateNestedManyWithoutNextStepInput
  }

  export type StepUncheckedCreateInput = {
    id?: string
    flowId: string
    order: number
    type: $Enums.StepType
    message?: string | null
    dynamicSource?: $Enums.DynamicSource
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    options?: StepOptionUncheckedCreateNestedManyWithoutStepInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCurrentStepInput
    logs?: LogUncheckedCreateNestedManyWithoutStepInput
    nextStepOptions?: StepOptionUncheckedCreateNestedManyWithoutNextStepInput
  }

  export type StepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    flow?: FlowUpdateOneRequiredWithoutStepsNestedInput
    options?: StepOptionUpdateManyWithoutStepNestedInput
    sessions?: SessionUpdateManyWithoutCurrentStepNestedInput
    logs?: LogUpdateManyWithoutStepNestedInput
    nextStepOptions?: StepOptionUpdateManyWithoutNextStepNestedInput
  }

  export type StepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    options?: StepOptionUncheckedUpdateManyWithoutStepNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCurrentStepNestedInput
    logs?: LogUncheckedUpdateManyWithoutStepNestedInput
    nextStepOptions?: StepOptionUncheckedUpdateManyWithoutNextStepNestedInput
  }

  export type StepCreateManyInput = {
    id?: string
    flowId: string
    order: number
    type: $Enums.StepType
    message?: string | null
    dynamicSource?: $Enums.DynamicSource
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type StepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StepOptionCreateInput = {
    id?: string
    label: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    step: StepCreateNestedOneWithoutOptionsInput
    nextStep?: StepCreateNestedOneWithoutNextStepOptionsInput
  }

  export type StepOptionUncheckedCreateInput = {
    id?: string
    stepId: string
    label: string
    value: string
    nextStepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type StepOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    step?: StepUpdateOneRequiredWithoutOptionsNestedInput
    nextStep?: StepUpdateOneWithoutNextStepOptionsNestedInput
  }

  export type StepOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    nextStepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StepOptionCreateManyInput = {
    id?: string
    stepId: string
    label: string
    value: string
    nextStepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type StepOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StepOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    nextStepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionCreateInput = {
    id?: string
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    flow: FlowCreateNestedOneWithoutSessionsInput
    user: UserCreateNestedOneWithoutSessionsInput
    currentStep?: StepCreateNestedOneWithoutSessionsInput
    logs?: LogCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    flowId: string
    currentStepId?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    logs?: LogUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    flow?: FlowUpdateOneRequiredWithoutSessionsNestedInput
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    currentStep?: StepUpdateOneWithoutSessionsNestedInput
    logs?: LogUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    logs?: LogUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    flowId: string
    currentStepId?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LogCreateInput = {
    id?: string
    message: string
    direction: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    session: SessionCreateNestedOneWithoutLogsInput
    step?: StepCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateInput = {
    id?: string
    sessionId: string
    stepId?: string | null
    message: string
    direction: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type LogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUpdateOneRequiredWithoutLogsNestedInput
    step?: StepUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    stepId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogCreateManyInput = {
    id?: string
    sessionId: string
    stepId?: string | null
    message: string
    direction: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type LogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    stepId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUsCreateInput = {
    id?: string
    customerName: string
    email: string
    phone?: string | null
    businessType: $Enums.BusinessType
    message: string
    note?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ContactUsUncheckedCreateInput = {
    id?: string
    customerName: string
    email: string
    phone?: string | null
    businessType: $Enums.BusinessType
    message: string
    note?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ContactUsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    message?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    message?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUsCreateManyInput = {
    id?: string
    customerName: string
    email: string
    phone?: string | null
    businessType: $Enums.BusinessType
    message: string
    note?: string | null
    status?: $Enums.ContactStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ContactUsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    message?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    message?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookDemoCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    businessType: $Enums.BusinessType
    message: string
    note?: string | null
    status?: $Enums.DemoStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type BookDemoUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    businessType: $Enums.BusinessType
    message: string
    note?: string | null
    status?: $Enums.DemoStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type BookDemoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    message?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDemoStatusFieldUpdateOperationsInput | $Enums.DemoStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookDemoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    message?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDemoStatusFieldUpdateOperationsInput | $Enums.DemoStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookDemoCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    businessType: $Enums.BusinessType
    message: string
    note?: string | null
    status?: $Enums.DemoStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type BookDemoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    message?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDemoStatusFieldUpdateOperationsInput | $Enums.DemoStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookDemoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    message?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDemoStatusFieldUpdateOperationsInput | $Enums.DemoStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FAQCreateInput = {
    id?: string
    question: string
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type FAQUncheckedCreateInput = {
    id?: string
    question: string
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type FAQUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FAQUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FAQCreateManyInput = {
    id?: string
    question: string
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type FAQUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FAQUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TermsConditionCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TermsConditionUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TermsConditionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TermsConditionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TermsConditionCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TermsConditionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TermsConditionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrivacyPolicyCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PrivacyPolicyUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PrivacyPolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrivacyPolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrivacyPolicyCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PrivacyPolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrivacyPolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertCreateInput = {
    id?: string
    userName: string
    userRole: $Enums.UserRole
    action: $Enums.AlertAction
    activity: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    userName: string
    userRole: $Enums.UserRole
    action: $Enums.AlertAction
    activity: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    action?: EnumAlertActionFieldUpdateOperationsInput | $Enums.AlertAction
    activity?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    action?: EnumAlertActionFieldUpdateOperationsInput | $Enums.AlertAction
    activity?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertCreateManyInput = {
    id?: string
    userName: string
    userRole: $Enums.UserRole
    action: $Enums.AlertAction
    activity: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    action?: EnumAlertActionFieldUpdateOperationsInput | $Enums.AlertAction
    activity?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    action?: EnumAlertActionFieldUpdateOperationsInput | $Enums.AlertAction
    activity?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type BranchNullableScalarRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type UserOnServiceListRelationFilter = {
    every?: UserOnServiceWhereInput
    some?: UserOnServiceWhereInput
    none?: UserOnServiceWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type BusinessListRelationFilter = {
    every?: BusinessWhereInput
    some?: BusinessWhereInput
    none?: BusinessWhereInput
  }

  export type BranchListRelationFilter = {
    every?: BranchWhereInput
    some?: BranchWhereInput
    none?: BranchWhereInput
  }

  export type SubscriberSubscriptionListRelationFilter = {
    every?: SubscriberSubscriptionWhereInput
    some?: SubscriberSubscriptionWhereInput
    none?: SubscriberSubscriptionWhereInput
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type WhatsappAdListRelationFilter = {
    every?: WhatsappAdWhereInput
    some?: WhatsappAdWhereInput
    none?: WhatsappAdWhereInput
  }

  export type ScheduleHourListRelationFilter = {
    every?: ScheduleHourWhereInput
    some?: ScheduleHourWhereInput
    none?: ScheduleHourWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type VacationListRelationFilter = {
    every?: VacationWhereInput
    some?: VacationWhereInput
    none?: VacationWhereInput
  }

  export type StaffStatusLogListRelationFilter = {
    every?: StaffStatusLogWhereInput
    some?: StaffStatusLogWhereInput
    none?: StaffStatusLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOnServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriberSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsappAdOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleHourOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VacationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffStatusLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    subscriberId?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    availability?: SortOrder
    usesBranchSchedule?: SortOrder
    managerId?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    fb?: SortOrder
    whatsapp?: SortOrder
    language?: SortOrder
    isLoggedIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    subscriberId?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    usesBranchSchedule?: SortOrder
    managerId?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    fb?: SortOrder
    whatsapp?: SortOrder
    language?: SortOrder
    isLoggedIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    subscriberId?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    usesBranchSchedule?: SortOrder
    managerId?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    fb?: SortOrder
    whatsapp?: SortOrder
    language?: SortOrder
    isLoggedIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserRoleNullableFilter<$PrismaModel> | $Enums.UserRole | null
  }

  export type MaintenanceSettingCountOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    updatedById?: SortOrder
    updatedByName?: SortOrder
    updatedByRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type MaintenanceSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    updatedById?: SortOrder
    updatedByName?: SortOrder
    updatedByRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type MaintenanceSettingMinOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    updatedById?: SortOrder
    updatedByName?: SortOrder
    updatedByRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumUserRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserRole | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumUserRoleNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeFilter<$PrismaModel> | $Enums.SubscriptionType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    price?: SortOrder
    noOfBranches?: SortOrder
    noOfAdmins?: SortOrder
    noOfStaffManagers?: SortOrder
    noOfServiceProviders?: SortOrder
    noOfReceptionists?: SortOrder
    whatsappBot?: SortOrder
    manualReminder?: SortOrder
    automatedReminder?: SortOrder
    googleReviewLink?: SortOrder
    promotions?: SortOrder
    selfServiceTablet?: SortOrder
    basicDashboard?: SortOrder
    fullAccessDashboard?: SortOrder
    subscriberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    price?: SortOrder
    noOfBranches?: SortOrder
    noOfAdmins?: SortOrder
    noOfStaffManagers?: SortOrder
    noOfServiceProviders?: SortOrder
    noOfReceptionists?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    price?: SortOrder
    noOfBranches?: SortOrder
    noOfAdmins?: SortOrder
    noOfStaffManagers?: SortOrder
    noOfServiceProviders?: SortOrder
    noOfReceptionists?: SortOrder
    whatsappBot?: SortOrder
    manualReminder?: SortOrder
    automatedReminder?: SortOrder
    googleReviewLink?: SortOrder
    promotions?: SortOrder
    selfServiceTablet?: SortOrder
    basicDashboard?: SortOrder
    fullAccessDashboard?: SortOrder
    subscriberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    price?: SortOrder
    noOfBranches?: SortOrder
    noOfAdmins?: SortOrder
    noOfStaffManagers?: SortOrder
    noOfServiceProviders?: SortOrder
    noOfReceptionists?: SortOrder
    whatsappBot?: SortOrder
    manualReminder?: SortOrder
    automatedReminder?: SortOrder
    googleReviewLink?: SortOrder
    promotions?: SortOrder
    selfServiceTablet?: SortOrder
    basicDashboard?: SortOrder
    fullAccessDashboard?: SortOrder
    subscriberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    price?: SortOrder
    noOfBranches?: SortOrder
    noOfAdmins?: SortOrder
    noOfStaffManagers?: SortOrder
    noOfServiceProviders?: SortOrder
    noOfReceptionists?: SortOrder
  }

  export type EnumSubscriptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumSubscriptionValidityFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionValidity | EnumSubscriptionValidityFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionValidityFilter<$PrismaModel> | $Enums.SubscriptionValidity
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BusinessNullableScalarRelationFilter = {
    is?: BusinessWhereInput | null
    isNot?: BusinessWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type SubscriptionDiscountLogListRelationFilter = {
    every?: SubscriptionDiscountLogWhereInput
    some?: SubscriptionDiscountLogWhereInput
    none?: SubscriptionDiscountLogWhereInput
  }

  export type SubscriptionDiscountLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriberSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    subscriptionId?: SortOrder
    type?: SortOrder
    validity?: SortOrder
    price?: SortOrder
    features?: SortOrder
    startDate?: SortOrder
    businessId?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type SubscriberSubscriptionAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type SubscriberSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    subscriptionId?: SortOrder
    type?: SortOrder
    validity?: SortOrder
    price?: SortOrder
    startDate?: SortOrder
    businessId?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type SubscriberSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    subscriptionId?: SortOrder
    type?: SortOrder
    validity?: SortOrder
    price?: SortOrder
    startDate?: SortOrder
    businessId?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type SubscriberSubscriptionSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumSubscriptionValidityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionValidity | EnumSubscriptionValidityFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionValidityWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionValidity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionValidityFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionValidityFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumDiscountGroupFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountGroup | EnumDiscountGroupFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountGroup[] | ListEnumDiscountGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountGroup[] | ListEnumDiscountGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountGroupFilter<$PrismaModel> | $Enums.DiscountGroup
  }

  export type EnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DiscountCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    group?: SortOrder
    packageType?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    isManuallyExpired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type DiscountAvgOrderByAggregateInput = {
    value?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
  }

  export type DiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    group?: SortOrder
    packageType?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    isManuallyExpired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type DiscountMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    group?: SortOrder
    packageType?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    isManuallyExpired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type DiscountSumOrderByAggregateInput = {
    value?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
  }

  export type EnumDiscountGroupWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountGroup | EnumDiscountGroupFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountGroup[] | ListEnumDiscountGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountGroup[] | ListEnumDiscountGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountGroupWithAggregatesFilter<$PrismaModel> | $Enums.DiscountGroup
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountGroupFilter<$PrismaModel>
    _max?: NestedEnumDiscountGroupFilter<$PrismaModel>
  }

  export type EnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SubscriberSubscriptionScalarRelationFilter = {
    is?: SubscriberSubscriptionWhereInput
    isNot?: SubscriberSubscriptionWhereInput
  }

  export type DiscountScalarRelationFilter = {
    is?: DiscountWhereInput
    isNot?: DiscountWhereInput
  }

  export type SubscriptionDiscountLogCountOrderByAggregateInput = {
    id?: SortOrder
    subscriberSubscriptionId?: SortOrder
    discountId?: SortOrder
    discountCode?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountedAmount?: SortOrder
    originalPrice?: SortOrder
    finalPrice?: SortOrder
    appliedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type SubscriptionDiscountLogAvgOrderByAggregateInput = {
    discountValue?: SortOrder
    discountedAmount?: SortOrder
    originalPrice?: SortOrder
    finalPrice?: SortOrder
  }

  export type SubscriptionDiscountLogMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriberSubscriptionId?: SortOrder
    discountId?: SortOrder
    discountCode?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountedAmount?: SortOrder
    originalPrice?: SortOrder
    finalPrice?: SortOrder
    appliedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type SubscriptionDiscountLogMinOrderByAggregateInput = {
    id?: SortOrder
    subscriberSubscriptionId?: SortOrder
    discountId?: SortOrder
    discountCode?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountedAmount?: SortOrder
    originalPrice?: SortOrder
    finalPrice?: SortOrder
    appliedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type SubscriptionDiscountLogSumOrderByAggregateInput = {
    discountValue?: SortOrder
    discountedAmount?: SortOrder
    originalPrice?: SortOrder
    finalPrice?: SortOrder
  }

  export type EnumBusinessTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessType | EnumBusinessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessTypeFilter<$PrismaModel> | $Enums.BusinessType
  }

  export type EnumSubscriptionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionTypeNullableFilter<$PrismaModel> | $Enums.SubscriptionType | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumSubscriptionValidityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionValidity | EnumSubscriptionValidityFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionValidityNullableFilter<$PrismaModel> | $Enums.SubscriptionValidity | null
  }

  export type EnumBusinessStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessStatus | EnumBusinessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessStatusFilter<$PrismaModel> | $Enums.BusinessStatus
  }

  export type FlowListRelationFilter = {
    every?: FlowWhereInput
    some?: FlowWhereInput
    none?: FlowWhereInput
  }

  export type WhatsAppNumberListRelationFilter = {
    every?: WhatsAppNumberWhereInput
    some?: WhatsAppNumberWhereInput
    none?: WhatsAppNumberWhereInput
  }

  export type DiscountNullableScalarRelationFilter = {
    is?: DiscountWhereInput | null
    isNot?: DiscountWhereInput | null
  }

  export type FlowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppNumberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    image?: SortOrder
    websiteLink?: SortOrder
    phoneNumber?: SortOrder
    businessType?: SortOrder
    subscriptionId?: SortOrder
    subscriptionType?: SortOrder
    subscriptionPrice?: SortOrder
    subscriptionValidity?: SortOrder
    discountCodeId?: SortOrder
    subscriberId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type BusinessAvgOrderByAggregateInput = {
    businessId?: SortOrder
    subscriptionPrice?: SortOrder
  }

  export type BusinessMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    image?: SortOrder
    websiteLink?: SortOrder
    phoneNumber?: SortOrder
    businessType?: SortOrder
    subscriptionId?: SortOrder
    subscriptionType?: SortOrder
    subscriptionPrice?: SortOrder
    subscriptionValidity?: SortOrder
    discountCodeId?: SortOrder
    subscriberId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type BusinessMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    image?: SortOrder
    websiteLink?: SortOrder
    phoneNumber?: SortOrder
    businessType?: SortOrder
    subscriptionId?: SortOrder
    subscriptionType?: SortOrder
    subscriptionPrice?: SortOrder
    subscriptionValidity?: SortOrder
    discountCodeId?: SortOrder
    subscriberId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type BusinessSumOrderByAggregateInput = {
    businessId?: SortOrder
    subscriptionPrice?: SortOrder
  }

  export type EnumBusinessTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessType | EnumBusinessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessTypeWithAggregatesFilter<$PrismaModel> | $Enums.BusinessType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBusinessTypeFilter<$PrismaModel>
    _max?: NestedEnumBusinessTypeFilter<$PrismaModel>
  }

  export type EnumSubscriptionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTypeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionValidityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionValidity | EnumSubscriptionValidityFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionValidityNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionValidity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionValidityNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionValidityNullableFilter<$PrismaModel>
  }

  export type EnumBusinessStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessStatus | EnumBusinessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessStatusWithAggregatesFilter<$PrismaModel> | $Enums.BusinessStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBusinessStatusFilter<$PrismaModel>
    _max?: NestedEnumBusinessStatusFilter<$PrismaModel>
  }

  export type ServiceBranchListRelationFilter = {
    every?: ServiceBranchWhereInput
    some?: ServiceBranchWhereInput
    none?: ServiceBranchWhereInput
  }

  export type PromotionListRelationFilter = {
    every?: PromotionWhereInput
    some?: PromotionWhereInput
    none?: PromotionWhereInput
  }

  export type TabletAccountListRelationFilter = {
    every?: TabletAccountWhereInput
    some?: TabletAccountWhereInput
    none?: TabletAccountWhereInput
  }

  export type ServiceBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromotionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TabletAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subscriberId?: SortOrder
    businessId?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subscriberId?: SortOrder
    businessId?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subscriberId?: SortOrder
    businessId?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumScheduleOwnerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleOwnerType | EnumScheduleOwnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleOwnerType[] | ListEnumScheduleOwnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleOwnerType[] | ListEnumScheduleOwnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleOwnerTypeFilter<$PrismaModel> | $Enums.ScheduleOwnerType
  }

  export type EnumWeekDayFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDay | EnumWeekDayFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel>
    not?: NestedEnumWeekDayFilter<$PrismaModel> | $Enums.WeekDay
  }

  export type EnumScheduleInheritanceModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleInheritanceMode | EnumScheduleInheritanceModeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleInheritanceMode[] | ListEnumScheduleInheritanceModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleInheritanceMode[] | ListEnumScheduleInheritanceModeFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleInheritanceModeFilter<$PrismaModel> | $Enums.ScheduleInheritanceMode
  }

  export type ScheduleHourOwnerTypeOwnerIdDayOfWeekCompoundUniqueInput = {
    ownerType: $Enums.ScheduleOwnerType
    ownerId: string
    dayOfWeek: $Enums.WeekDay
  }

  export type ScheduleHourCountOrderByAggregateInput = {
    id?: SortOrder
    ownerType?: SortOrder
    ownerId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    isClosed?: SortOrder
    inheritanceMode?: SortOrder
    staffId?: SortOrder
    businessId?: SortOrder
    branchId?: SortOrder
    lastModifiedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ScheduleHourMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerType?: SortOrder
    ownerId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    isClosed?: SortOrder
    inheritanceMode?: SortOrder
    staffId?: SortOrder
    businessId?: SortOrder
    branchId?: SortOrder
    lastModifiedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ScheduleHourMinOrderByAggregateInput = {
    id?: SortOrder
    ownerType?: SortOrder
    ownerId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    isClosed?: SortOrder
    inheritanceMode?: SortOrder
    staffId?: SortOrder
    businessId?: SortOrder
    branchId?: SortOrder
    lastModifiedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumScheduleOwnerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleOwnerType | EnumScheduleOwnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleOwnerType[] | ListEnumScheduleOwnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleOwnerType[] | ListEnumScheduleOwnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleOwnerTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleOwnerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleOwnerTypeFilter<$PrismaModel>
    _max?: NestedEnumScheduleOwnerTypeFilter<$PrismaModel>
  }

  export type EnumWeekDayWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDay | EnumWeekDayFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel>
    not?: NestedEnumWeekDayWithAggregatesFilter<$PrismaModel> | $Enums.WeekDay
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeekDayFilter<$PrismaModel>
    _max?: NestedEnumWeekDayFilter<$PrismaModel>
  }

  export type EnumScheduleInheritanceModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleInheritanceMode | EnumScheduleInheritanceModeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleInheritanceMode[] | ListEnumScheduleInheritanceModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleInheritanceMode[] | ListEnumScheduleInheritanceModeFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleInheritanceModeWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleInheritanceMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleInheritanceModeFilter<$PrismaModel>
    _max?: NestedEnumScheduleInheritanceModeFilter<$PrismaModel>
  }

  export type EnumStaffStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffStatus | EnumStaffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StaffStatus[] | ListEnumStaffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffStatus[] | ListEnumStaffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffStatusFilter<$PrismaModel> | $Enums.StaffStatus
  }

  export type StaffStatusLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
  }

  export type StaffStatusLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
  }

  export type StaffStatusLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumStaffStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffStatus | EnumStaffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StaffStatus[] | ListEnumStaffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffStatus[] | ListEnumStaffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffStatusWithAggregatesFilter<$PrismaModel> | $Enums.StaffStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStaffStatusFilter<$PrismaModel>
    _max?: NestedEnumStaffStatusFilter<$PrismaModel>
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type EnumVacationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VacationStatus | EnumVacationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VacationStatus[] | ListEnumVacationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VacationStatus[] | ListEnumVacationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVacationStatusFilter<$PrismaModel> | $Enums.VacationStatus
  }

  export type VacationCountOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type VacationMaxOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type VacationMinOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumVacationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VacationStatus | EnumVacationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VacationStatus[] | ListEnumVacationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VacationStatus[] | ListEnumVacationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVacationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VacationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVacationStatusFilter<$PrismaModel>
    _max?: NestedEnumVacationStatusFilter<$PrismaModel>
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    providerId?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    bufferTime?: SortOrder
    status?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
    bufferTime?: SortOrder
    frequency?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    providerId?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    bufferTime?: SortOrder
    status?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    providerId?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    bufferTime?: SortOrder
    status?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
    bufferTime?: SortOrder
    frequency?: SortOrder
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type UserOnServiceCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
  }

  export type UserOnServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
  }

  export type UserOnServiceMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
  }

  export type BranchScalarRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type ServiceBranchServiceIdBranchIdCompoundUniqueInput = {
    serviceId: string
    branchId: string
  }

  export type ServiceBranchCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ServiceBranchMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ServiceBranchMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type EnumAppointmentBookingTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentBookingType | EnumAppointmentBookingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AppointmentBookingType[] | ListEnumAppointmentBookingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AppointmentBookingType[] | ListEnumAppointmentBookingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAppointmentBookingTypeNullableFilter<$PrismaModel> | $Enums.AppointmentBookingType | null
  }

  export type PromotionNullableScalarRelationFilter = {
    is?: PromotionWhereInput | null
    isNot?: PromotionWhereInput | null
  }

  export type SubscriberSubscriptionNullableScalarRelationFilter = {
    is?: SubscriberSubscriptionWhereInput | null
    isNot?: SubscriberSubscriptionWhereInput | null
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    consumerId?: SortOrder
    branchId?: SortOrder
    serviceProviderId?: SortOrder
    appointmentTime?: SortOrder
    appointmentDate?: SortOrder
    appointmentTimeSlot?: SortOrder
    reminderMinutesBefore?: SortOrder
    discountId?: SortOrder
    note?: SortOrder
    status?: SortOrder
    bookingType?: SortOrder
    review?: SortOrder
    rating?: SortOrder
    isManual?: SortOrder
    price?: SortOrder
    subscriberSubscriptionId?: SortOrder
    promotionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    reminderMinutesBefore?: SortOrder
    rating?: SortOrder
    price?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    consumerId?: SortOrder
    branchId?: SortOrder
    serviceProviderId?: SortOrder
    appointmentTime?: SortOrder
    appointmentDate?: SortOrder
    appointmentTimeSlot?: SortOrder
    reminderMinutesBefore?: SortOrder
    discountId?: SortOrder
    note?: SortOrder
    status?: SortOrder
    bookingType?: SortOrder
    review?: SortOrder
    rating?: SortOrder
    isManual?: SortOrder
    price?: SortOrder
    subscriberSubscriptionId?: SortOrder
    promotionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    consumerId?: SortOrder
    branchId?: SortOrder
    serviceProviderId?: SortOrder
    appointmentTime?: SortOrder
    appointmentDate?: SortOrder
    appointmentTimeSlot?: SortOrder
    reminderMinutesBefore?: SortOrder
    discountId?: SortOrder
    note?: SortOrder
    status?: SortOrder
    bookingType?: SortOrder
    review?: SortOrder
    rating?: SortOrder
    isManual?: SortOrder
    price?: SortOrder
    subscriberSubscriptionId?: SortOrder
    promotionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    reminderMinutesBefore?: SortOrder
    rating?: SortOrder
    price?: SortOrder
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type EnumAppointmentBookingTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentBookingType | EnumAppointmentBookingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AppointmentBookingType[] | ListEnumAppointmentBookingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AppointmentBookingType[] | ListEnumAppointmentBookingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAppointmentBookingTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentBookingType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAppointmentBookingTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumAppointmentBookingTypeNullableFilter<$PrismaModel>
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    limit?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type PromotionAvgOrderByAggregateInput = {
    value?: SortOrder
    limit?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    limit?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    limit?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type PromotionSumOrderByAggregateInput = {
    value?: SortOrder
    limit?: SortOrder
  }

  export type TabletAccountCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    loginLink?: SortOrder
    loginToken?: SortOrder
    isActive?: SortOrder
    isLoggedIn?: SortOrder
    lastActivityAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type TabletAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    loginLink?: SortOrder
    loginToken?: SortOrder
    isActive?: SortOrder
    isLoggedIn?: SortOrder
    lastActivityAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type TabletAccountMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    loginLink?: SortOrder
    loginToken?: SortOrder
    isActive?: SortOrder
    isLoggedIn?: SortOrder
    lastActivityAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumAdTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdTargetType | EnumAdTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdTargetType[] | ListEnumAdTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdTargetType[] | ListEnumAdTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdTargetTypeFilter<$PrismaModel> | $Enums.AdTargetType
  }

  export type EnumAdStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdStatus | EnumAdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdStatusFilter<$PrismaModel> | $Enums.AdStatus
  }

  export type ServiceNullableScalarRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type WhatsappAdCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    targetDate?: SortOrder
    customerType?: SortOrder
    branchId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type WhatsappAdMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    targetDate?: SortOrder
    customerType?: SortOrder
    branchId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type WhatsappAdMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    targetDate?: SortOrder
    customerType?: SortOrder
    branchId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumAdTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdTargetType | EnumAdTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdTargetType[] | ListEnumAdTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdTargetType[] | ListEnumAdTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdTargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumAdTargetTypeFilter<$PrismaModel>
  }

  export type EnumAdStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdStatus | EnumAdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdStatusFilter<$PrismaModel>
    _max?: NestedEnumAdStatusFilter<$PrismaModel>
  }

  export type BusinessScalarRelationFilter = {
    is?: BusinessWhereInput
    isNot?: BusinessWhereInput
  }

  export type FlowNullableScalarRelationFilter = {
    is?: FlowWhereInput | null
    isNot?: FlowWhereInput | null
  }

  export type WhatsAppNumberCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberId?: SortOrder
    wabaId?: SortOrder
    accessToken?: SortOrder
    isVerified?: SortOrder
    defaultFlowId?: SortOrder
    otp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type WhatsAppNumberAvgOrderByAggregateInput = {
    otp?: SortOrder
  }

  export type WhatsAppNumberMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberId?: SortOrder
    wabaId?: SortOrder
    accessToken?: SortOrder
    isVerified?: SortOrder
    defaultFlowId?: SortOrder
    otp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type WhatsAppNumberMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberId?: SortOrder
    wabaId?: SortOrder
    accessToken?: SortOrder
    isVerified?: SortOrder
    defaultFlowId?: SortOrder
    otp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type WhatsAppNumberSumOrderByAggregateInput = {
    otp?: SortOrder
  }

  export type StepListRelationFilter = {
    every?: StepWhereInput
    some?: StepWhereInput
    none?: StepWhereInput
  }

  export type StepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlowCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    DeletedBy?: SortOrder
    DeletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type FlowMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    DeletedBy?: SortOrder
    DeletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type FlowMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    DeletedBy?: SortOrder
    DeletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type EnumStepTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StepType | EnumStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStepTypeFilter<$PrismaModel> | $Enums.StepType
  }

  export type EnumDynamicSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.DynamicSource | EnumDynamicSourceFieldRefInput<$PrismaModel>
    in?: $Enums.DynamicSource[] | ListEnumDynamicSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.DynamicSource[] | ListEnumDynamicSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumDynamicSourceFilter<$PrismaModel> | $Enums.DynamicSource
  }

  export type FlowScalarRelationFilter = {
    is?: FlowWhereInput
    isNot?: FlowWhereInput
  }

  export type StepOptionListRelationFilter = {
    every?: StepOptionWhereInput
    some?: StepOptionWhereInput
    none?: StepOptionWhereInput
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type StepOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StepCountOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    order?: SortOrder
    type?: SortOrder
    message?: SortOrder
    dynamicSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    DeletedBy?: SortOrder
    DeletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type StepAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type StepMaxOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    order?: SortOrder
    type?: SortOrder
    message?: SortOrder
    dynamicSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    DeletedBy?: SortOrder
    DeletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type StepMinOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    order?: SortOrder
    type?: SortOrder
    message?: SortOrder
    dynamicSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    DeletedBy?: SortOrder
    DeletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type StepSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumStepTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StepType | EnumStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStepTypeWithAggregatesFilter<$PrismaModel> | $Enums.StepType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStepTypeFilter<$PrismaModel>
    _max?: NestedEnumStepTypeFilter<$PrismaModel>
  }

  export type EnumDynamicSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DynamicSource | EnumDynamicSourceFieldRefInput<$PrismaModel>
    in?: $Enums.DynamicSource[] | ListEnumDynamicSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.DynamicSource[] | ListEnumDynamicSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumDynamicSourceWithAggregatesFilter<$PrismaModel> | $Enums.DynamicSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDynamicSourceFilter<$PrismaModel>
    _max?: NestedEnumDynamicSourceFilter<$PrismaModel>
  }

  export type StepScalarRelationFilter = {
    is?: StepWhereInput
    isNot?: StepWhereInput
  }

  export type StepNullableScalarRelationFilter = {
    is?: StepWhereInput | null
    isNot?: StepWhereInput | null
  }

  export type StepOptionCountOrderByAggregateInput = {
    id?: SortOrder
    stepId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    nextStepId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    DeletedBy?: SortOrder
    DeletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type StepOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    stepId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    nextStepId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    DeletedBy?: SortOrder
    DeletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type StepOptionMinOrderByAggregateInput = {
    id?: SortOrder
    stepId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    nextStepId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    DeletedBy?: SortOrder
    DeletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    flowId?: SortOrder
    currentStepId?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    DeletedBy?: SortOrder
    DeletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    flowId?: SortOrder
    currentStepId?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    DeletedBy?: SortOrder
    DeletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    flowId?: SortOrder
    currentStepId?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    DeletedBy?: SortOrder
    DeletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type SessionScalarRelationFilter = {
    is?: SessionWhereInput
    isNot?: SessionWhereInput
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    stepId?: SortOrder
    message?: SortOrder
    direction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    stepId?: SortOrder
    message?: SortOrder
    direction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    stepId?: SortOrder
    message?: SortOrder
    direction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumContactStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusFilter<$PrismaModel> | $Enums.ContactStatus
  }

  export type ContactUsCountOrderByAggregateInput = {
    id?: SortOrder
    customerName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    businessType?: SortOrder
    message?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ContactUsMaxOrderByAggregateInput = {
    id?: SortOrder
    customerName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    businessType?: SortOrder
    message?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ContactUsMinOrderByAggregateInput = {
    id?: SortOrder
    customerName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    businessType?: SortOrder
    message?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumContactStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContactStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactStatusFilter<$PrismaModel>
    _max?: NestedEnumContactStatusFilter<$PrismaModel>
  }

  export type EnumDemoStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DemoStatus | EnumDemoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DemoStatus[] | ListEnumDemoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DemoStatus[] | ListEnumDemoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDemoStatusFilter<$PrismaModel> | $Enums.DemoStatus
  }

  export type BookDemoCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    businessType?: SortOrder
    message?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type BookDemoMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    businessType?: SortOrder
    message?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type BookDemoMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    businessType?: SortOrder
    message?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumDemoStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DemoStatus | EnumDemoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DemoStatus[] | ListEnumDemoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DemoStatus[] | ListEnumDemoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDemoStatusWithAggregatesFilter<$PrismaModel> | $Enums.DemoStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDemoStatusFilter<$PrismaModel>
    _max?: NestedEnumDemoStatusFilter<$PrismaModel>
  }

  export type FAQCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type FAQMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type FAQMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type TermsConditionCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type TermsConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type TermsConditionMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type PrivacyPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type PrivacyPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type PrivacyPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumAlertActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertAction | EnumAlertActionFieldRefInput<$PrismaModel>
    in?: $Enums.AlertAction[] | ListEnumAlertActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertAction[] | ListEnumAlertActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertActionFilter<$PrismaModel> | $Enums.AlertAction
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    activity?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    activity?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    activity?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumAlertActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertAction | EnumAlertActionFieldRefInput<$PrismaModel>
    in?: $Enums.AlertAction[] | ListEnumAlertActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertAction[] | ListEnumAlertActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertActionWithAggregatesFilter<$PrismaModel> | $Enums.AlertAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertActionFilter<$PrismaModel>
    _max?: NestedEnumAlertActionFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutSubscriberMembersInput = {
    create?: XOR<UserCreateWithoutSubscriberMembersInput, UserUncheckedCreateWithoutSubscriberMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriberMembersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutSubscriberInput = {
    create?: XOR<UserCreateWithoutSubscriberInput, UserUncheckedCreateWithoutSubscriberInput> | UserCreateWithoutSubscriberInput[] | UserUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubscriberInput | UserCreateOrConnectWithoutSubscriberInput[]
    createMany?: UserCreateManySubscriberInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BranchCreateNestedOneWithoutUsersInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    connect?: BranchWhereUniqueInput
  }

  export type UserOnServiceCreateNestedManyWithoutProviderInput = {
    create?: XOR<UserOnServiceCreateWithoutProviderInput, UserOnServiceUncheckedCreateWithoutProviderInput> | UserOnServiceCreateWithoutProviderInput[] | UserOnServiceUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: UserOnServiceCreateOrConnectWithoutProviderInput | UserOnServiceCreateOrConnectWithoutProviderInput[]
    createMany?: UserOnServiceCreateManyProviderInputEnvelope
    connect?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutConsumerInput = {
    create?: XOR<AppointmentCreateWithoutConsumerInput, AppointmentUncheckedCreateWithoutConsumerInput> | AppointmentCreateWithoutConsumerInput[] | AppointmentUncheckedCreateWithoutConsumerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutConsumerInput | AppointmentCreateOrConnectWithoutConsumerInput[]
    createMany?: AppointmentCreateManyConsumerInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput> | AppointmentCreateWithoutServiceProviderInput[] | AppointmentUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceProviderInput | AppointmentCreateOrConnectWithoutServiceProviderInput[]
    createMany?: AppointmentCreateManyServiceProviderInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BusinessCreateNestedManyWithoutSubscriberInput = {
    create?: XOR<BusinessCreateWithoutSubscriberInput, BusinessUncheckedCreateWithoutSubscriberInput> | BusinessCreateWithoutSubscriberInput[] | BusinessUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriberInput | BusinessCreateOrConnectWithoutSubscriberInput[]
    createMany?: BusinessCreateManySubscriberInputEnvelope
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type BranchCreateNestedManyWithoutSubscriberInput = {
    create?: XOR<BranchCreateWithoutSubscriberInput, BranchUncheckedCreateWithoutSubscriberInput> | BranchCreateWithoutSubscriberInput[] | BranchUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutSubscriberInput | BranchCreateOrConnectWithoutSubscriberInput[]
    createMany?: BranchCreateManySubscriberInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutSubscriberInput, SubscriberSubscriptionUncheckedCreateWithoutSubscriberInput> | SubscriberSubscriptionCreateWithoutSubscriberInput[] | SubscriberSubscriptionUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutSubscriberInput | SubscriberSubscriptionCreateOrConnectWithoutSubscriberInput[]
    createMany?: SubscriberSubscriptionCreateManySubscriberInputEnvelope
    connect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutSubscriberInput = {
    create?: XOR<SubscriptionCreateWithoutSubscriberInput, SubscriptionUncheckedCreateWithoutSubscriberInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSubscriberInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type WhatsappAdCreateNestedManyWithoutAssignedCustomersInput = {
    create?: XOR<WhatsappAdCreateWithoutAssignedCustomersInput, WhatsappAdUncheckedCreateWithoutAssignedCustomersInput> | WhatsappAdCreateWithoutAssignedCustomersInput[] | WhatsappAdUncheckedCreateWithoutAssignedCustomersInput[]
    connectOrCreate?: WhatsappAdCreateOrConnectWithoutAssignedCustomersInput | WhatsappAdCreateOrConnectWithoutAssignedCustomersInput[]
    connect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
  }

  export type ScheduleHourCreateNestedManyWithoutStaffInput = {
    create?: XOR<ScheduleHourCreateWithoutStaffInput, ScheduleHourUncheckedCreateWithoutStaffInput> | ScheduleHourCreateWithoutStaffInput[] | ScheduleHourUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ScheduleHourCreateOrConnectWithoutStaffInput | ScheduleHourCreateOrConnectWithoutStaffInput[]
    createMany?: ScheduleHourCreateManyStaffInputEnvelope
    connect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutStaffInput = {
    create?: XOR<AttendanceCreateWithoutStaffInput, AttendanceUncheckedCreateWithoutStaffInput> | AttendanceCreateWithoutStaffInput[] | AttendanceUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStaffInput | AttendanceCreateOrConnectWithoutStaffInput[]
    createMany?: AttendanceCreateManyStaffInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type VacationCreateNestedManyWithoutStaffInput = {
    create?: XOR<VacationCreateWithoutStaffInput, VacationUncheckedCreateWithoutStaffInput> | VacationCreateWithoutStaffInput[] | VacationUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: VacationCreateOrConnectWithoutStaffInput | VacationCreateOrConnectWithoutStaffInput[]
    createMany?: VacationCreateManyStaffInputEnvelope
    connect?: VacationWhereUniqueInput | VacationWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutStaffMembersInput = {
    create?: XOR<UserCreateWithoutStaffMembersInput, UserUncheckedCreateWithoutStaffMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffMembersInput
    connect?: UserWhereUniqueInput
  }

  export type StaffStatusLogCreateNestedManyWithoutUserInput = {
    create?: XOR<StaffStatusLogCreateWithoutUserInput, StaffStatusLogUncheckedCreateWithoutUserInput> | StaffStatusLogCreateWithoutUserInput[] | StaffStatusLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffStatusLogCreateOrConnectWithoutUserInput | StaffStatusLogCreateOrConnectWithoutUserInput[]
    createMany?: StaffStatusLogCreateManyUserInputEnvelope
    connect?: StaffStatusLogWhereUniqueInput | StaffStatusLogWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSubscriberInput = {
    create?: XOR<UserCreateWithoutSubscriberInput, UserUncheckedCreateWithoutSubscriberInput> | UserCreateWithoutSubscriberInput[] | UserUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubscriberInput | UserCreateOrConnectWithoutSubscriberInput[]
    createMany?: UserCreateManySubscriberInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserOnServiceUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<UserOnServiceCreateWithoutProviderInput, UserOnServiceUncheckedCreateWithoutProviderInput> | UserOnServiceCreateWithoutProviderInput[] | UserOnServiceUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: UserOnServiceCreateOrConnectWithoutProviderInput | UserOnServiceCreateOrConnectWithoutProviderInput[]
    createMany?: UserOnServiceCreateManyProviderInputEnvelope
    connect?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutConsumerInput = {
    create?: XOR<AppointmentCreateWithoutConsumerInput, AppointmentUncheckedCreateWithoutConsumerInput> | AppointmentCreateWithoutConsumerInput[] | AppointmentUncheckedCreateWithoutConsumerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutConsumerInput | AppointmentCreateOrConnectWithoutConsumerInput[]
    createMany?: AppointmentCreateManyConsumerInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput> | AppointmentCreateWithoutServiceProviderInput[] | AppointmentUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceProviderInput | AppointmentCreateOrConnectWithoutServiceProviderInput[]
    createMany?: AppointmentCreateManyServiceProviderInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BusinessUncheckedCreateNestedManyWithoutSubscriberInput = {
    create?: XOR<BusinessCreateWithoutSubscriberInput, BusinessUncheckedCreateWithoutSubscriberInput> | BusinessCreateWithoutSubscriberInput[] | BusinessUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriberInput | BusinessCreateOrConnectWithoutSubscriberInput[]
    createMany?: BusinessCreateManySubscriberInputEnvelope
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutSubscriberInput = {
    create?: XOR<BranchCreateWithoutSubscriberInput, BranchUncheckedCreateWithoutSubscriberInput> | BranchCreateWithoutSubscriberInput[] | BranchUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutSubscriberInput | BranchCreateOrConnectWithoutSubscriberInput[]
    createMany?: BranchCreateManySubscriberInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutSubscriberInput, SubscriberSubscriptionUncheckedCreateWithoutSubscriberInput> | SubscriberSubscriptionCreateWithoutSubscriberInput[] | SubscriberSubscriptionUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutSubscriberInput | SubscriberSubscriptionCreateOrConnectWithoutSubscriberInput[]
    createMany?: SubscriberSubscriptionCreateManySubscriberInputEnvelope
    connect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput = {
    create?: XOR<SubscriptionCreateWithoutSubscriberInput, SubscriptionUncheckedCreateWithoutSubscriberInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSubscriberInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput = {
    create?: XOR<WhatsappAdCreateWithoutAssignedCustomersInput, WhatsappAdUncheckedCreateWithoutAssignedCustomersInput> | WhatsappAdCreateWithoutAssignedCustomersInput[] | WhatsappAdUncheckedCreateWithoutAssignedCustomersInput[]
    connectOrCreate?: WhatsappAdCreateOrConnectWithoutAssignedCustomersInput | WhatsappAdCreateOrConnectWithoutAssignedCustomersInput[]
    connect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
  }

  export type ScheduleHourUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<ScheduleHourCreateWithoutStaffInput, ScheduleHourUncheckedCreateWithoutStaffInput> | ScheduleHourCreateWithoutStaffInput[] | ScheduleHourUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ScheduleHourCreateOrConnectWithoutStaffInput | ScheduleHourCreateOrConnectWithoutStaffInput[]
    createMany?: ScheduleHourCreateManyStaffInputEnvelope
    connect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<AttendanceCreateWithoutStaffInput, AttendanceUncheckedCreateWithoutStaffInput> | AttendanceCreateWithoutStaffInput[] | AttendanceUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStaffInput | AttendanceCreateOrConnectWithoutStaffInput[]
    createMany?: AttendanceCreateManyStaffInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type VacationUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<VacationCreateWithoutStaffInput, VacationUncheckedCreateWithoutStaffInput> | VacationCreateWithoutStaffInput[] | VacationUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: VacationCreateOrConnectWithoutStaffInput | VacationCreateOrConnectWithoutStaffInput[]
    createMany?: VacationCreateManyStaffInputEnvelope
    connect?: VacationWhereUniqueInput | VacationWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StaffStatusLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StaffStatusLogCreateWithoutUserInput, StaffStatusLogUncheckedCreateWithoutUserInput> | StaffStatusLogCreateWithoutUserInput[] | StaffStatusLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffStatusLogCreateOrConnectWithoutUserInput | StaffStatusLogCreateOrConnectWithoutUserInput[]
    createMany?: StaffStatusLogCreateManyUserInputEnvelope
    connect?: StaffStatusLogWhereUniqueInput | StaffStatusLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneWithoutSubscriberMembersNestedInput = {
    create?: XOR<UserCreateWithoutSubscriberMembersInput, UserUncheckedCreateWithoutSubscriberMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriberMembersInput
    upsert?: UserUpsertWithoutSubscriberMembersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriberMembersInput, UserUpdateWithoutSubscriberMembersInput>, UserUncheckedUpdateWithoutSubscriberMembersInput>
  }

  export type UserUpdateManyWithoutSubscriberNestedInput = {
    create?: XOR<UserCreateWithoutSubscriberInput, UserUncheckedCreateWithoutSubscriberInput> | UserCreateWithoutSubscriberInput[] | UserUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubscriberInput | UserCreateOrConnectWithoutSubscriberInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSubscriberInput | UserUpsertWithWhereUniqueWithoutSubscriberInput[]
    createMany?: UserCreateManySubscriberInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSubscriberInput | UserUpdateWithWhereUniqueWithoutSubscriberInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSubscriberInput | UserUpdateManyWithWhereWithoutSubscriberInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BranchUpdateOneWithoutUsersNestedInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    upsert?: BranchUpsertWithoutUsersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUsersInput, BranchUpdateWithoutUsersInput>, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type UserOnServiceUpdateManyWithoutProviderNestedInput = {
    create?: XOR<UserOnServiceCreateWithoutProviderInput, UserOnServiceUncheckedCreateWithoutProviderInput> | UserOnServiceCreateWithoutProviderInput[] | UserOnServiceUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: UserOnServiceCreateOrConnectWithoutProviderInput | UserOnServiceCreateOrConnectWithoutProviderInput[]
    upsert?: UserOnServiceUpsertWithWhereUniqueWithoutProviderInput | UserOnServiceUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: UserOnServiceCreateManyProviderInputEnvelope
    set?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    disconnect?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    delete?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    connect?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    update?: UserOnServiceUpdateWithWhereUniqueWithoutProviderInput | UserOnServiceUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: UserOnServiceUpdateManyWithWhereWithoutProviderInput | UserOnServiceUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: UserOnServiceScalarWhereInput | UserOnServiceScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutConsumerNestedInput = {
    create?: XOR<AppointmentCreateWithoutConsumerInput, AppointmentUncheckedCreateWithoutConsumerInput> | AppointmentCreateWithoutConsumerInput[] | AppointmentUncheckedCreateWithoutConsumerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutConsumerInput | AppointmentCreateOrConnectWithoutConsumerInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutConsumerInput | AppointmentUpsertWithWhereUniqueWithoutConsumerInput[]
    createMany?: AppointmentCreateManyConsumerInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutConsumerInput | AppointmentUpdateWithWhereUniqueWithoutConsumerInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutConsumerInput | AppointmentUpdateManyWithWhereWithoutConsumerInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput> | AppointmentCreateWithoutServiceProviderInput[] | AppointmentUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceProviderInput | AppointmentCreateOrConnectWithoutServiceProviderInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput | AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: AppointmentCreateManyServiceProviderInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput | AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutServiceProviderInput | AppointmentUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BusinessUpdateManyWithoutSubscriberNestedInput = {
    create?: XOR<BusinessCreateWithoutSubscriberInput, BusinessUncheckedCreateWithoutSubscriberInput> | BusinessCreateWithoutSubscriberInput[] | BusinessUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriberInput | BusinessCreateOrConnectWithoutSubscriberInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutSubscriberInput | BusinessUpsertWithWhereUniqueWithoutSubscriberInput[]
    createMany?: BusinessCreateManySubscriberInputEnvelope
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutSubscriberInput | BusinessUpdateWithWhereUniqueWithoutSubscriberInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutSubscriberInput | BusinessUpdateManyWithWhereWithoutSubscriberInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type BranchUpdateManyWithoutSubscriberNestedInput = {
    create?: XOR<BranchCreateWithoutSubscriberInput, BranchUncheckedCreateWithoutSubscriberInput> | BranchCreateWithoutSubscriberInput[] | BranchUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutSubscriberInput | BranchCreateOrConnectWithoutSubscriberInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutSubscriberInput | BranchUpsertWithWhereUniqueWithoutSubscriberInput[]
    createMany?: BranchCreateManySubscriberInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutSubscriberInput | BranchUpdateWithWhereUniqueWithoutSubscriberInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutSubscriberInput | BranchUpdateManyWithWhereWithoutSubscriberInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutSubscriberInput, SubscriberSubscriptionUncheckedCreateWithoutSubscriberInput> | SubscriberSubscriptionCreateWithoutSubscriberInput[] | SubscriberSubscriptionUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutSubscriberInput | SubscriberSubscriptionCreateOrConnectWithoutSubscriberInput[]
    upsert?: SubscriberSubscriptionUpsertWithWhereUniqueWithoutSubscriberInput | SubscriberSubscriptionUpsertWithWhereUniqueWithoutSubscriberInput[]
    createMany?: SubscriberSubscriptionCreateManySubscriberInputEnvelope
    set?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    disconnect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    delete?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    connect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    update?: SubscriberSubscriptionUpdateWithWhereUniqueWithoutSubscriberInput | SubscriberSubscriptionUpdateWithWhereUniqueWithoutSubscriberInput[]
    updateMany?: SubscriberSubscriptionUpdateManyWithWhereWithoutSubscriberInput | SubscriberSubscriptionUpdateManyWithWhereWithoutSubscriberInput[]
    deleteMany?: SubscriberSubscriptionScalarWhereInput | SubscriberSubscriptionScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutSubscriberNestedInput = {
    create?: XOR<SubscriptionCreateWithoutSubscriberInput, SubscriptionUncheckedCreateWithoutSubscriberInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSubscriberInput
    upsert?: SubscriptionUpsertWithoutSubscriberInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutSubscriberInput, SubscriptionUpdateWithoutSubscriberInput>, SubscriptionUncheckedUpdateWithoutSubscriberInput>
  }

  export type WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput = {
    create?: XOR<WhatsappAdCreateWithoutAssignedCustomersInput, WhatsappAdUncheckedCreateWithoutAssignedCustomersInput> | WhatsappAdCreateWithoutAssignedCustomersInput[] | WhatsappAdUncheckedCreateWithoutAssignedCustomersInput[]
    connectOrCreate?: WhatsappAdCreateOrConnectWithoutAssignedCustomersInput | WhatsappAdCreateOrConnectWithoutAssignedCustomersInput[]
    upsert?: WhatsappAdUpsertWithWhereUniqueWithoutAssignedCustomersInput | WhatsappAdUpsertWithWhereUniqueWithoutAssignedCustomersInput[]
    set?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    disconnect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    delete?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    connect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    update?: WhatsappAdUpdateWithWhereUniqueWithoutAssignedCustomersInput | WhatsappAdUpdateWithWhereUniqueWithoutAssignedCustomersInput[]
    updateMany?: WhatsappAdUpdateManyWithWhereWithoutAssignedCustomersInput | WhatsappAdUpdateManyWithWhereWithoutAssignedCustomersInput[]
    deleteMany?: WhatsappAdScalarWhereInput | WhatsappAdScalarWhereInput[]
  }

  export type ScheduleHourUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ScheduleHourCreateWithoutStaffInput, ScheduleHourUncheckedCreateWithoutStaffInput> | ScheduleHourCreateWithoutStaffInput[] | ScheduleHourUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ScheduleHourCreateOrConnectWithoutStaffInput | ScheduleHourCreateOrConnectWithoutStaffInput[]
    upsert?: ScheduleHourUpsertWithWhereUniqueWithoutStaffInput | ScheduleHourUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ScheduleHourCreateManyStaffInputEnvelope
    set?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    disconnect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    delete?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    connect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    update?: ScheduleHourUpdateWithWhereUniqueWithoutStaffInput | ScheduleHourUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ScheduleHourUpdateManyWithWhereWithoutStaffInput | ScheduleHourUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ScheduleHourScalarWhereInput | ScheduleHourScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutStaffNestedInput = {
    create?: XOR<AttendanceCreateWithoutStaffInput, AttendanceUncheckedCreateWithoutStaffInput> | AttendanceCreateWithoutStaffInput[] | AttendanceUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStaffInput | AttendanceCreateOrConnectWithoutStaffInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutStaffInput | AttendanceUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: AttendanceCreateManyStaffInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutStaffInput | AttendanceUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutStaffInput | AttendanceUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type VacationUpdateManyWithoutStaffNestedInput = {
    create?: XOR<VacationCreateWithoutStaffInput, VacationUncheckedCreateWithoutStaffInput> | VacationCreateWithoutStaffInput[] | VacationUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: VacationCreateOrConnectWithoutStaffInput | VacationCreateOrConnectWithoutStaffInput[]
    upsert?: VacationUpsertWithWhereUniqueWithoutStaffInput | VacationUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: VacationCreateManyStaffInputEnvelope
    set?: VacationWhereUniqueInput | VacationWhereUniqueInput[]
    disconnect?: VacationWhereUniqueInput | VacationWhereUniqueInput[]
    delete?: VacationWhereUniqueInput | VacationWhereUniqueInput[]
    connect?: VacationWhereUniqueInput | VacationWhereUniqueInput[]
    update?: VacationUpdateWithWhereUniqueWithoutStaffInput | VacationUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: VacationUpdateManyWithWhereWithoutStaffInput | VacationUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: VacationScalarWhereInput | VacationScalarWhereInput[]
  }

  export type UserUpdateManyWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagerInput | UserUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagerInput | UserUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagerInput | UserUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUpdateOneWithoutStaffMembersNestedInput = {
    create?: XOR<UserCreateWithoutStaffMembersInput, UserUncheckedCreateWithoutStaffMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffMembersInput
    upsert?: UserUpsertWithoutStaffMembersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffMembersInput, UserUpdateWithoutStaffMembersInput>, UserUncheckedUpdateWithoutStaffMembersInput>
  }

  export type StaffStatusLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<StaffStatusLogCreateWithoutUserInput, StaffStatusLogUncheckedCreateWithoutUserInput> | StaffStatusLogCreateWithoutUserInput[] | StaffStatusLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffStatusLogCreateOrConnectWithoutUserInput | StaffStatusLogCreateOrConnectWithoutUserInput[]
    upsert?: StaffStatusLogUpsertWithWhereUniqueWithoutUserInput | StaffStatusLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StaffStatusLogCreateManyUserInputEnvelope
    set?: StaffStatusLogWhereUniqueInput | StaffStatusLogWhereUniqueInput[]
    disconnect?: StaffStatusLogWhereUniqueInput | StaffStatusLogWhereUniqueInput[]
    delete?: StaffStatusLogWhereUniqueInput | StaffStatusLogWhereUniqueInput[]
    connect?: StaffStatusLogWhereUniqueInput | StaffStatusLogWhereUniqueInput[]
    update?: StaffStatusLogUpdateWithWhereUniqueWithoutUserInput | StaffStatusLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StaffStatusLogUpdateManyWithWhereWithoutUserInput | StaffStatusLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StaffStatusLogScalarWhereInput | StaffStatusLogScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSubscriberNestedInput = {
    create?: XOR<UserCreateWithoutSubscriberInput, UserUncheckedCreateWithoutSubscriberInput> | UserCreateWithoutSubscriberInput[] | UserUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubscriberInput | UserCreateOrConnectWithoutSubscriberInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSubscriberInput | UserUpsertWithWhereUniqueWithoutSubscriberInput[]
    createMany?: UserCreateManySubscriberInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSubscriberInput | UserUpdateWithWhereUniqueWithoutSubscriberInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSubscriberInput | UserUpdateManyWithWhereWithoutSubscriberInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<UserOnServiceCreateWithoutProviderInput, UserOnServiceUncheckedCreateWithoutProviderInput> | UserOnServiceCreateWithoutProviderInput[] | UserOnServiceUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: UserOnServiceCreateOrConnectWithoutProviderInput | UserOnServiceCreateOrConnectWithoutProviderInput[]
    upsert?: UserOnServiceUpsertWithWhereUniqueWithoutProviderInput | UserOnServiceUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: UserOnServiceCreateManyProviderInputEnvelope
    set?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    disconnect?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    delete?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    connect?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    update?: UserOnServiceUpdateWithWhereUniqueWithoutProviderInput | UserOnServiceUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: UserOnServiceUpdateManyWithWhereWithoutProviderInput | UserOnServiceUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: UserOnServiceScalarWhereInput | UserOnServiceScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutConsumerNestedInput = {
    create?: XOR<AppointmentCreateWithoutConsumerInput, AppointmentUncheckedCreateWithoutConsumerInput> | AppointmentCreateWithoutConsumerInput[] | AppointmentUncheckedCreateWithoutConsumerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutConsumerInput | AppointmentCreateOrConnectWithoutConsumerInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutConsumerInput | AppointmentUpsertWithWhereUniqueWithoutConsumerInput[]
    createMany?: AppointmentCreateManyConsumerInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutConsumerInput | AppointmentUpdateWithWhereUniqueWithoutConsumerInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutConsumerInput | AppointmentUpdateManyWithWhereWithoutConsumerInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput> | AppointmentCreateWithoutServiceProviderInput[] | AppointmentUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceProviderInput | AppointmentCreateOrConnectWithoutServiceProviderInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput | AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: AppointmentCreateManyServiceProviderInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput | AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutServiceProviderInput | AppointmentUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BusinessUncheckedUpdateManyWithoutSubscriberNestedInput = {
    create?: XOR<BusinessCreateWithoutSubscriberInput, BusinessUncheckedCreateWithoutSubscriberInput> | BusinessCreateWithoutSubscriberInput[] | BusinessUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriberInput | BusinessCreateOrConnectWithoutSubscriberInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutSubscriberInput | BusinessUpsertWithWhereUniqueWithoutSubscriberInput[]
    createMany?: BusinessCreateManySubscriberInputEnvelope
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutSubscriberInput | BusinessUpdateWithWhereUniqueWithoutSubscriberInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutSubscriberInput | BusinessUpdateManyWithWhereWithoutSubscriberInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutSubscriberNestedInput = {
    create?: XOR<BranchCreateWithoutSubscriberInput, BranchUncheckedCreateWithoutSubscriberInput> | BranchCreateWithoutSubscriberInput[] | BranchUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutSubscriberInput | BranchCreateOrConnectWithoutSubscriberInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutSubscriberInput | BranchUpsertWithWhereUniqueWithoutSubscriberInput[]
    createMany?: BranchCreateManySubscriberInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutSubscriberInput | BranchUpdateWithWhereUniqueWithoutSubscriberInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutSubscriberInput | BranchUpdateManyWithWhereWithoutSubscriberInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutSubscriberInput, SubscriberSubscriptionUncheckedCreateWithoutSubscriberInput> | SubscriberSubscriptionCreateWithoutSubscriberInput[] | SubscriberSubscriptionUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutSubscriberInput | SubscriberSubscriptionCreateOrConnectWithoutSubscriberInput[]
    upsert?: SubscriberSubscriptionUpsertWithWhereUniqueWithoutSubscriberInput | SubscriberSubscriptionUpsertWithWhereUniqueWithoutSubscriberInput[]
    createMany?: SubscriberSubscriptionCreateManySubscriberInputEnvelope
    set?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    disconnect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    delete?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    connect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    update?: SubscriberSubscriptionUpdateWithWhereUniqueWithoutSubscriberInput | SubscriberSubscriptionUpdateWithWhereUniqueWithoutSubscriberInput[]
    updateMany?: SubscriberSubscriptionUpdateManyWithWhereWithoutSubscriberInput | SubscriberSubscriptionUpdateManyWithWhereWithoutSubscriberInput[]
    deleteMany?: SubscriberSubscriptionScalarWhereInput | SubscriberSubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput = {
    create?: XOR<SubscriptionCreateWithoutSubscriberInput, SubscriptionUncheckedCreateWithoutSubscriberInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSubscriberInput
    upsert?: SubscriptionUpsertWithoutSubscriberInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutSubscriberInput, SubscriptionUpdateWithoutSubscriberInput>, SubscriptionUncheckedUpdateWithoutSubscriberInput>
  }

  export type WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput = {
    create?: XOR<WhatsappAdCreateWithoutAssignedCustomersInput, WhatsappAdUncheckedCreateWithoutAssignedCustomersInput> | WhatsappAdCreateWithoutAssignedCustomersInput[] | WhatsappAdUncheckedCreateWithoutAssignedCustomersInput[]
    connectOrCreate?: WhatsappAdCreateOrConnectWithoutAssignedCustomersInput | WhatsappAdCreateOrConnectWithoutAssignedCustomersInput[]
    upsert?: WhatsappAdUpsertWithWhereUniqueWithoutAssignedCustomersInput | WhatsappAdUpsertWithWhereUniqueWithoutAssignedCustomersInput[]
    set?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    disconnect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    delete?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    connect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    update?: WhatsappAdUpdateWithWhereUniqueWithoutAssignedCustomersInput | WhatsappAdUpdateWithWhereUniqueWithoutAssignedCustomersInput[]
    updateMany?: WhatsappAdUpdateManyWithWhereWithoutAssignedCustomersInput | WhatsappAdUpdateManyWithWhereWithoutAssignedCustomersInput[]
    deleteMany?: WhatsappAdScalarWhereInput | WhatsappAdScalarWhereInput[]
  }

  export type ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ScheduleHourCreateWithoutStaffInput, ScheduleHourUncheckedCreateWithoutStaffInput> | ScheduleHourCreateWithoutStaffInput[] | ScheduleHourUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ScheduleHourCreateOrConnectWithoutStaffInput | ScheduleHourCreateOrConnectWithoutStaffInput[]
    upsert?: ScheduleHourUpsertWithWhereUniqueWithoutStaffInput | ScheduleHourUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ScheduleHourCreateManyStaffInputEnvelope
    set?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    disconnect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    delete?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    connect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    update?: ScheduleHourUpdateWithWhereUniqueWithoutStaffInput | ScheduleHourUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ScheduleHourUpdateManyWithWhereWithoutStaffInput | ScheduleHourUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ScheduleHourScalarWhereInput | ScheduleHourScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<AttendanceCreateWithoutStaffInput, AttendanceUncheckedCreateWithoutStaffInput> | AttendanceCreateWithoutStaffInput[] | AttendanceUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStaffInput | AttendanceCreateOrConnectWithoutStaffInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutStaffInput | AttendanceUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: AttendanceCreateManyStaffInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutStaffInput | AttendanceUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutStaffInput | AttendanceUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type VacationUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<VacationCreateWithoutStaffInput, VacationUncheckedCreateWithoutStaffInput> | VacationCreateWithoutStaffInput[] | VacationUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: VacationCreateOrConnectWithoutStaffInput | VacationCreateOrConnectWithoutStaffInput[]
    upsert?: VacationUpsertWithWhereUniqueWithoutStaffInput | VacationUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: VacationCreateManyStaffInputEnvelope
    set?: VacationWhereUniqueInput | VacationWhereUniqueInput[]
    disconnect?: VacationWhereUniqueInput | VacationWhereUniqueInput[]
    delete?: VacationWhereUniqueInput | VacationWhereUniqueInput[]
    connect?: VacationWhereUniqueInput | VacationWhereUniqueInput[]
    update?: VacationUpdateWithWhereUniqueWithoutStaffInput | VacationUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: VacationUpdateManyWithWhereWithoutStaffInput | VacationUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: VacationScalarWhereInput | VacationScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagerInput | UserUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagerInput | UserUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagerInput | UserUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StaffStatusLogCreateWithoutUserInput, StaffStatusLogUncheckedCreateWithoutUserInput> | StaffStatusLogCreateWithoutUserInput[] | StaffStatusLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffStatusLogCreateOrConnectWithoutUserInput | StaffStatusLogCreateOrConnectWithoutUserInput[]
    upsert?: StaffStatusLogUpsertWithWhereUniqueWithoutUserInput | StaffStatusLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StaffStatusLogCreateManyUserInputEnvelope
    set?: StaffStatusLogWhereUniqueInput | StaffStatusLogWhereUniqueInput[]
    disconnect?: StaffStatusLogWhereUniqueInput | StaffStatusLogWhereUniqueInput[]
    delete?: StaffStatusLogWhereUniqueInput | StaffStatusLogWhereUniqueInput[]
    connect?: StaffStatusLogWhereUniqueInput | StaffStatusLogWhereUniqueInput[]
    update?: StaffStatusLogUpdateWithWhereUniqueWithoutUserInput | StaffStatusLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StaffStatusLogUpdateManyWithWhereWithoutUserInput | StaffStatusLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StaffStatusLogScalarWhereInput | StaffStatusLogScalarWhereInput[]
  }

  export type NullableEnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole | null
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriberSubscriptionCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutSubscriptionInput, SubscriberSubscriptionUncheckedCreateWithoutSubscriptionInput> | SubscriberSubscriptionCreateWithoutSubscriptionInput[] | SubscriberSubscriptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutSubscriptionInput | SubscriberSubscriptionCreateOrConnectWithoutSubscriptionInput[]
    createMany?: SubscriberSubscriptionCreateManySubscriptionInputEnvelope
    connect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
  }

  export type BusinessCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<BusinessCreateWithoutSubscriptionInput, BusinessUncheckedCreateWithoutSubscriptionInput> | BusinessCreateWithoutSubscriptionInput[] | BusinessUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriptionInput | BusinessCreateOrConnectWithoutSubscriptionInput[]
    createMany?: BusinessCreateManySubscriptionInputEnvelope
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutSubscriptionInput, SubscriberSubscriptionUncheckedCreateWithoutSubscriptionInput> | SubscriberSubscriptionCreateWithoutSubscriptionInput[] | SubscriberSubscriptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutSubscriptionInput | SubscriberSubscriptionCreateOrConnectWithoutSubscriptionInput[]
    createMany?: SubscriberSubscriptionCreateManySubscriptionInputEnvelope
    connect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
  }

  export type BusinessUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<BusinessCreateWithoutSubscriptionInput, BusinessUncheckedCreateWithoutSubscriptionInput> | BusinessCreateWithoutSubscriptionInput[] | BusinessUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriptionInput | BusinessCreateOrConnectWithoutSubscriptionInput[]
    createMany?: BusinessCreateManySubscriptionInputEnvelope
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type EnumSubscriptionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionInput, UserUpdateWithoutSubscriptionInput>, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriberSubscriptionUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutSubscriptionInput, SubscriberSubscriptionUncheckedCreateWithoutSubscriptionInput> | SubscriberSubscriptionCreateWithoutSubscriptionInput[] | SubscriberSubscriptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutSubscriptionInput | SubscriberSubscriptionCreateOrConnectWithoutSubscriptionInput[]
    upsert?: SubscriberSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput | SubscriberSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: SubscriberSubscriptionCreateManySubscriptionInputEnvelope
    set?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    disconnect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    delete?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    connect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    update?: SubscriberSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput | SubscriberSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: SubscriberSubscriptionUpdateManyWithWhereWithoutSubscriptionInput | SubscriberSubscriptionUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: SubscriberSubscriptionScalarWhereInput | SubscriberSubscriptionScalarWhereInput[]
  }

  export type BusinessUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<BusinessCreateWithoutSubscriptionInput, BusinessUncheckedCreateWithoutSubscriptionInput> | BusinessCreateWithoutSubscriptionInput[] | BusinessUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriptionInput | BusinessCreateOrConnectWithoutSubscriptionInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutSubscriptionInput | BusinessUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: BusinessCreateManySubscriptionInputEnvelope
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutSubscriptionInput | BusinessUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutSubscriptionInput | BusinessUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutSubscriptionInput, SubscriberSubscriptionUncheckedCreateWithoutSubscriptionInput> | SubscriberSubscriptionCreateWithoutSubscriptionInput[] | SubscriberSubscriptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutSubscriptionInput | SubscriberSubscriptionCreateOrConnectWithoutSubscriptionInput[]
    upsert?: SubscriberSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput | SubscriberSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: SubscriberSubscriptionCreateManySubscriptionInputEnvelope
    set?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    disconnect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    delete?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    connect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    update?: SubscriberSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput | SubscriberSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: SubscriberSubscriptionUpdateManyWithWhereWithoutSubscriptionInput | SubscriberSubscriptionUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: SubscriberSubscriptionScalarWhereInput | SubscriberSubscriptionScalarWhereInput[]
  }

  export type BusinessUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<BusinessCreateWithoutSubscriptionInput, BusinessUncheckedCreateWithoutSubscriptionInput> | BusinessCreateWithoutSubscriptionInput[] | BusinessUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriptionInput | BusinessCreateOrConnectWithoutSubscriptionInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutSubscriptionInput | BusinessUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: BusinessCreateManySubscriptionInputEnvelope
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutSubscriptionInput | BusinessUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutSubscriptionInput | BusinessUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type BusinessCreateNestedOneWithoutSubscriberSubscriptionsInput = {
    create?: XOR<BusinessCreateWithoutSubscriberSubscriptionsInput, BusinessUncheckedCreateWithoutSubscriberSubscriptionsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriberSubscriptionsInput
    connect?: BusinessWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSubscriberSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriberSubscriptionsInput, UserUncheckedCreateWithoutSubscriberSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriberSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutSubscriberSubscriptionsInput = {
    create?: XOR<SubscriptionCreateWithoutSubscriberSubscriptionsInput, SubscriptionUncheckedCreateWithoutSubscriberSubscriptionsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSubscriberSubscriptionsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutSubscriberSubscriptionInput = {
    create?: XOR<AppointmentCreateWithoutSubscriberSubscriptionInput, AppointmentUncheckedCreateWithoutSubscriberSubscriptionInput> | AppointmentCreateWithoutSubscriberSubscriptionInput[] | AppointmentUncheckedCreateWithoutSubscriberSubscriptionInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutSubscriberSubscriptionInput | AppointmentCreateOrConnectWithoutSubscriberSubscriptionInput[]
    createMany?: AppointmentCreateManySubscriberSubscriptionInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type SubscriptionDiscountLogCreateNestedManyWithoutSubscriberSubscriptionInput = {
    create?: XOR<SubscriptionDiscountLogCreateWithoutSubscriberSubscriptionInput, SubscriptionDiscountLogUncheckedCreateWithoutSubscriberSubscriptionInput> | SubscriptionDiscountLogCreateWithoutSubscriberSubscriptionInput[] | SubscriptionDiscountLogUncheckedCreateWithoutSubscriberSubscriptionInput[]
    connectOrCreate?: SubscriptionDiscountLogCreateOrConnectWithoutSubscriberSubscriptionInput | SubscriptionDiscountLogCreateOrConnectWithoutSubscriberSubscriptionInput[]
    createMany?: SubscriptionDiscountLogCreateManySubscriberSubscriptionInputEnvelope
    connect?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutSubscriberSubscriptionInput = {
    create?: XOR<AppointmentCreateWithoutSubscriberSubscriptionInput, AppointmentUncheckedCreateWithoutSubscriberSubscriptionInput> | AppointmentCreateWithoutSubscriberSubscriptionInput[] | AppointmentUncheckedCreateWithoutSubscriberSubscriptionInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutSubscriberSubscriptionInput | AppointmentCreateOrConnectWithoutSubscriberSubscriptionInput[]
    createMany?: AppointmentCreateManySubscriberSubscriptionInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type SubscriptionDiscountLogUncheckedCreateNestedManyWithoutSubscriberSubscriptionInput = {
    create?: XOR<SubscriptionDiscountLogCreateWithoutSubscriberSubscriptionInput, SubscriptionDiscountLogUncheckedCreateWithoutSubscriberSubscriptionInput> | SubscriptionDiscountLogCreateWithoutSubscriberSubscriptionInput[] | SubscriptionDiscountLogUncheckedCreateWithoutSubscriberSubscriptionInput[]
    connectOrCreate?: SubscriptionDiscountLogCreateOrConnectWithoutSubscriberSubscriptionInput | SubscriptionDiscountLogCreateOrConnectWithoutSubscriberSubscriptionInput[]
    createMany?: SubscriptionDiscountLogCreateManySubscriberSubscriptionInputEnvelope
    connect?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
  }

  export type EnumSubscriptionValidityFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionValidity
  }

  export type BusinessUpdateOneWithoutSubscriberSubscriptionsNestedInput = {
    create?: XOR<BusinessCreateWithoutSubscriberSubscriptionsInput, BusinessUncheckedCreateWithoutSubscriberSubscriptionsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriberSubscriptionsInput
    upsert?: BusinessUpsertWithoutSubscriberSubscriptionsInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutSubscriberSubscriptionsInput, BusinessUpdateWithoutSubscriberSubscriptionsInput>, BusinessUncheckedUpdateWithoutSubscriberSubscriptionsInput>
  }

  export type UserUpdateOneRequiredWithoutSubscriberSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriberSubscriptionsInput, UserUncheckedCreateWithoutSubscriberSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriberSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriberSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriberSubscriptionsInput, UserUpdateWithoutSubscriberSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriberSubscriptionsInput>
  }

  export type SubscriptionUpdateOneRequiredWithoutSubscriberSubscriptionsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutSubscriberSubscriptionsInput, SubscriptionUncheckedCreateWithoutSubscriberSubscriptionsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSubscriberSubscriptionsInput
    upsert?: SubscriptionUpsertWithoutSubscriberSubscriptionsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutSubscriberSubscriptionsInput, SubscriptionUpdateWithoutSubscriberSubscriptionsInput>, SubscriptionUncheckedUpdateWithoutSubscriberSubscriptionsInput>
  }

  export type AppointmentUpdateManyWithoutSubscriberSubscriptionNestedInput = {
    create?: XOR<AppointmentCreateWithoutSubscriberSubscriptionInput, AppointmentUncheckedCreateWithoutSubscriberSubscriptionInput> | AppointmentCreateWithoutSubscriberSubscriptionInput[] | AppointmentUncheckedCreateWithoutSubscriberSubscriptionInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutSubscriberSubscriptionInput | AppointmentCreateOrConnectWithoutSubscriberSubscriptionInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutSubscriberSubscriptionInput | AppointmentUpsertWithWhereUniqueWithoutSubscriberSubscriptionInput[]
    createMany?: AppointmentCreateManySubscriberSubscriptionInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutSubscriberSubscriptionInput | AppointmentUpdateWithWhereUniqueWithoutSubscriberSubscriptionInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutSubscriberSubscriptionInput | AppointmentUpdateManyWithWhereWithoutSubscriberSubscriptionInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type SubscriptionDiscountLogUpdateManyWithoutSubscriberSubscriptionNestedInput = {
    create?: XOR<SubscriptionDiscountLogCreateWithoutSubscriberSubscriptionInput, SubscriptionDiscountLogUncheckedCreateWithoutSubscriberSubscriptionInput> | SubscriptionDiscountLogCreateWithoutSubscriberSubscriptionInput[] | SubscriptionDiscountLogUncheckedCreateWithoutSubscriberSubscriptionInput[]
    connectOrCreate?: SubscriptionDiscountLogCreateOrConnectWithoutSubscriberSubscriptionInput | SubscriptionDiscountLogCreateOrConnectWithoutSubscriberSubscriptionInput[]
    upsert?: SubscriptionDiscountLogUpsertWithWhereUniqueWithoutSubscriberSubscriptionInput | SubscriptionDiscountLogUpsertWithWhereUniqueWithoutSubscriberSubscriptionInput[]
    createMany?: SubscriptionDiscountLogCreateManySubscriberSubscriptionInputEnvelope
    set?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    disconnect?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    delete?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    connect?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    update?: SubscriptionDiscountLogUpdateWithWhereUniqueWithoutSubscriberSubscriptionInput | SubscriptionDiscountLogUpdateWithWhereUniqueWithoutSubscriberSubscriptionInput[]
    updateMany?: SubscriptionDiscountLogUpdateManyWithWhereWithoutSubscriberSubscriptionInput | SubscriptionDiscountLogUpdateManyWithWhereWithoutSubscriberSubscriptionInput[]
    deleteMany?: SubscriptionDiscountLogScalarWhereInput | SubscriptionDiscountLogScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutSubscriberSubscriptionNestedInput = {
    create?: XOR<AppointmentCreateWithoutSubscriberSubscriptionInput, AppointmentUncheckedCreateWithoutSubscriberSubscriptionInput> | AppointmentCreateWithoutSubscriberSubscriptionInput[] | AppointmentUncheckedCreateWithoutSubscriberSubscriptionInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutSubscriberSubscriptionInput | AppointmentCreateOrConnectWithoutSubscriberSubscriptionInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutSubscriberSubscriptionInput | AppointmentUpsertWithWhereUniqueWithoutSubscriberSubscriptionInput[]
    createMany?: AppointmentCreateManySubscriberSubscriptionInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutSubscriberSubscriptionInput | AppointmentUpdateWithWhereUniqueWithoutSubscriberSubscriptionInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutSubscriberSubscriptionInput | AppointmentUpdateManyWithWhereWithoutSubscriberSubscriptionInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type SubscriptionDiscountLogUncheckedUpdateManyWithoutSubscriberSubscriptionNestedInput = {
    create?: XOR<SubscriptionDiscountLogCreateWithoutSubscriberSubscriptionInput, SubscriptionDiscountLogUncheckedCreateWithoutSubscriberSubscriptionInput> | SubscriptionDiscountLogCreateWithoutSubscriberSubscriptionInput[] | SubscriptionDiscountLogUncheckedCreateWithoutSubscriberSubscriptionInput[]
    connectOrCreate?: SubscriptionDiscountLogCreateOrConnectWithoutSubscriberSubscriptionInput | SubscriptionDiscountLogCreateOrConnectWithoutSubscriberSubscriptionInput[]
    upsert?: SubscriptionDiscountLogUpsertWithWhereUniqueWithoutSubscriberSubscriptionInput | SubscriptionDiscountLogUpsertWithWhereUniqueWithoutSubscriberSubscriptionInput[]
    createMany?: SubscriptionDiscountLogCreateManySubscriberSubscriptionInputEnvelope
    set?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    disconnect?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    delete?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    connect?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    update?: SubscriptionDiscountLogUpdateWithWhereUniqueWithoutSubscriberSubscriptionInput | SubscriptionDiscountLogUpdateWithWhereUniqueWithoutSubscriberSubscriptionInput[]
    updateMany?: SubscriptionDiscountLogUpdateManyWithWhereWithoutSubscriberSubscriptionInput | SubscriptionDiscountLogUpdateManyWithWhereWithoutSubscriberSubscriptionInput[]
    deleteMany?: SubscriptionDiscountLogScalarWhereInput | SubscriptionDiscountLogScalarWhereInput[]
  }

  export type BusinessCreateNestedManyWithoutDiscountCodeInput = {
    create?: XOR<BusinessCreateWithoutDiscountCodeInput, BusinessUncheckedCreateWithoutDiscountCodeInput> | BusinessCreateWithoutDiscountCodeInput[] | BusinessUncheckedCreateWithoutDiscountCodeInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutDiscountCodeInput | BusinessCreateOrConnectWithoutDiscountCodeInput[]
    createMany?: BusinessCreateManyDiscountCodeInputEnvelope
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutDiscountInput = {
    create?: XOR<AppointmentCreateWithoutDiscountInput, AppointmentUncheckedCreateWithoutDiscountInput> | AppointmentCreateWithoutDiscountInput[] | AppointmentUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDiscountInput | AppointmentCreateOrConnectWithoutDiscountInput[]
    createMany?: AppointmentCreateManyDiscountInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type SubscriptionDiscountLogCreateNestedManyWithoutDiscountInput = {
    create?: XOR<SubscriptionDiscountLogCreateWithoutDiscountInput, SubscriptionDiscountLogUncheckedCreateWithoutDiscountInput> | SubscriptionDiscountLogCreateWithoutDiscountInput[] | SubscriptionDiscountLogUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: SubscriptionDiscountLogCreateOrConnectWithoutDiscountInput | SubscriptionDiscountLogCreateOrConnectWithoutDiscountInput[]
    createMany?: SubscriptionDiscountLogCreateManyDiscountInputEnvelope
    connect?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
  }

  export type BusinessUncheckedCreateNestedManyWithoutDiscountCodeInput = {
    create?: XOR<BusinessCreateWithoutDiscountCodeInput, BusinessUncheckedCreateWithoutDiscountCodeInput> | BusinessCreateWithoutDiscountCodeInput[] | BusinessUncheckedCreateWithoutDiscountCodeInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutDiscountCodeInput | BusinessCreateOrConnectWithoutDiscountCodeInput[]
    createMany?: BusinessCreateManyDiscountCodeInputEnvelope
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDiscountInput = {
    create?: XOR<AppointmentCreateWithoutDiscountInput, AppointmentUncheckedCreateWithoutDiscountInput> | AppointmentCreateWithoutDiscountInput[] | AppointmentUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDiscountInput | AppointmentCreateOrConnectWithoutDiscountInput[]
    createMany?: AppointmentCreateManyDiscountInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type SubscriptionDiscountLogUncheckedCreateNestedManyWithoutDiscountInput = {
    create?: XOR<SubscriptionDiscountLogCreateWithoutDiscountInput, SubscriptionDiscountLogUncheckedCreateWithoutDiscountInput> | SubscriptionDiscountLogCreateWithoutDiscountInput[] | SubscriptionDiscountLogUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: SubscriptionDiscountLogCreateOrConnectWithoutDiscountInput | SubscriptionDiscountLogCreateOrConnectWithoutDiscountInput[]
    createMany?: SubscriptionDiscountLogCreateManyDiscountInputEnvelope
    connect?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
  }

  export type EnumDiscountGroupFieldUpdateOperationsInput = {
    set?: $Enums.DiscountGroup
  }

  export type EnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BusinessUpdateManyWithoutDiscountCodeNestedInput = {
    create?: XOR<BusinessCreateWithoutDiscountCodeInput, BusinessUncheckedCreateWithoutDiscountCodeInput> | BusinessCreateWithoutDiscountCodeInput[] | BusinessUncheckedCreateWithoutDiscountCodeInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutDiscountCodeInput | BusinessCreateOrConnectWithoutDiscountCodeInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutDiscountCodeInput | BusinessUpsertWithWhereUniqueWithoutDiscountCodeInput[]
    createMany?: BusinessCreateManyDiscountCodeInputEnvelope
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutDiscountCodeInput | BusinessUpdateWithWhereUniqueWithoutDiscountCodeInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutDiscountCodeInput | BusinessUpdateManyWithWhereWithoutDiscountCodeInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutDiscountNestedInput = {
    create?: XOR<AppointmentCreateWithoutDiscountInput, AppointmentUncheckedCreateWithoutDiscountInput> | AppointmentCreateWithoutDiscountInput[] | AppointmentUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDiscountInput | AppointmentCreateOrConnectWithoutDiscountInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDiscountInput | AppointmentUpsertWithWhereUniqueWithoutDiscountInput[]
    createMany?: AppointmentCreateManyDiscountInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDiscountInput | AppointmentUpdateWithWhereUniqueWithoutDiscountInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDiscountInput | AppointmentUpdateManyWithWhereWithoutDiscountInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type SubscriptionDiscountLogUpdateManyWithoutDiscountNestedInput = {
    create?: XOR<SubscriptionDiscountLogCreateWithoutDiscountInput, SubscriptionDiscountLogUncheckedCreateWithoutDiscountInput> | SubscriptionDiscountLogCreateWithoutDiscountInput[] | SubscriptionDiscountLogUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: SubscriptionDiscountLogCreateOrConnectWithoutDiscountInput | SubscriptionDiscountLogCreateOrConnectWithoutDiscountInput[]
    upsert?: SubscriptionDiscountLogUpsertWithWhereUniqueWithoutDiscountInput | SubscriptionDiscountLogUpsertWithWhereUniqueWithoutDiscountInput[]
    createMany?: SubscriptionDiscountLogCreateManyDiscountInputEnvelope
    set?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    disconnect?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    delete?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    connect?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    update?: SubscriptionDiscountLogUpdateWithWhereUniqueWithoutDiscountInput | SubscriptionDiscountLogUpdateWithWhereUniqueWithoutDiscountInput[]
    updateMany?: SubscriptionDiscountLogUpdateManyWithWhereWithoutDiscountInput | SubscriptionDiscountLogUpdateManyWithWhereWithoutDiscountInput[]
    deleteMany?: SubscriptionDiscountLogScalarWhereInput | SubscriptionDiscountLogScalarWhereInput[]
  }

  export type BusinessUncheckedUpdateManyWithoutDiscountCodeNestedInput = {
    create?: XOR<BusinessCreateWithoutDiscountCodeInput, BusinessUncheckedCreateWithoutDiscountCodeInput> | BusinessCreateWithoutDiscountCodeInput[] | BusinessUncheckedCreateWithoutDiscountCodeInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutDiscountCodeInput | BusinessCreateOrConnectWithoutDiscountCodeInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutDiscountCodeInput | BusinessUpsertWithWhereUniqueWithoutDiscountCodeInput[]
    createMany?: BusinessCreateManyDiscountCodeInputEnvelope
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutDiscountCodeInput | BusinessUpdateWithWhereUniqueWithoutDiscountCodeInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutDiscountCodeInput | BusinessUpdateManyWithWhereWithoutDiscountCodeInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutDiscountNestedInput = {
    create?: XOR<AppointmentCreateWithoutDiscountInput, AppointmentUncheckedCreateWithoutDiscountInput> | AppointmentCreateWithoutDiscountInput[] | AppointmentUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDiscountInput | AppointmentCreateOrConnectWithoutDiscountInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDiscountInput | AppointmentUpsertWithWhereUniqueWithoutDiscountInput[]
    createMany?: AppointmentCreateManyDiscountInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDiscountInput | AppointmentUpdateWithWhereUniqueWithoutDiscountInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDiscountInput | AppointmentUpdateManyWithWhereWithoutDiscountInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type SubscriptionDiscountLogUncheckedUpdateManyWithoutDiscountNestedInput = {
    create?: XOR<SubscriptionDiscountLogCreateWithoutDiscountInput, SubscriptionDiscountLogUncheckedCreateWithoutDiscountInput> | SubscriptionDiscountLogCreateWithoutDiscountInput[] | SubscriptionDiscountLogUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: SubscriptionDiscountLogCreateOrConnectWithoutDiscountInput | SubscriptionDiscountLogCreateOrConnectWithoutDiscountInput[]
    upsert?: SubscriptionDiscountLogUpsertWithWhereUniqueWithoutDiscountInput | SubscriptionDiscountLogUpsertWithWhereUniqueWithoutDiscountInput[]
    createMany?: SubscriptionDiscountLogCreateManyDiscountInputEnvelope
    set?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    disconnect?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    delete?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    connect?: SubscriptionDiscountLogWhereUniqueInput | SubscriptionDiscountLogWhereUniqueInput[]
    update?: SubscriptionDiscountLogUpdateWithWhereUniqueWithoutDiscountInput | SubscriptionDiscountLogUpdateWithWhereUniqueWithoutDiscountInput[]
    updateMany?: SubscriptionDiscountLogUpdateManyWithWhereWithoutDiscountInput | SubscriptionDiscountLogUpdateManyWithWhereWithoutDiscountInput[]
    deleteMany?: SubscriptionDiscountLogScalarWhereInput | SubscriptionDiscountLogScalarWhereInput[]
  }

  export type SubscriberSubscriptionCreateNestedOneWithoutDiscountLogsInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutDiscountLogsInput, SubscriberSubscriptionUncheckedCreateWithoutDiscountLogsInput>
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutDiscountLogsInput
    connect?: SubscriberSubscriptionWhereUniqueInput
  }

  export type DiscountCreateNestedOneWithoutSubscriptionDiscountLogsInput = {
    create?: XOR<DiscountCreateWithoutSubscriptionDiscountLogsInput, DiscountUncheckedCreateWithoutSubscriptionDiscountLogsInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutSubscriptionDiscountLogsInput
    connect?: DiscountWhereUniqueInput
  }

  export type SubscriberSubscriptionUpdateOneRequiredWithoutDiscountLogsNestedInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutDiscountLogsInput, SubscriberSubscriptionUncheckedCreateWithoutDiscountLogsInput>
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutDiscountLogsInput
    upsert?: SubscriberSubscriptionUpsertWithoutDiscountLogsInput
    connect?: SubscriberSubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriberSubscriptionUpdateToOneWithWhereWithoutDiscountLogsInput, SubscriberSubscriptionUpdateWithoutDiscountLogsInput>, SubscriberSubscriptionUncheckedUpdateWithoutDiscountLogsInput>
  }

  export type DiscountUpdateOneRequiredWithoutSubscriptionDiscountLogsNestedInput = {
    create?: XOR<DiscountCreateWithoutSubscriptionDiscountLogsInput, DiscountUncheckedCreateWithoutSubscriptionDiscountLogsInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutSubscriptionDiscountLogsInput
    upsert?: DiscountUpsertWithoutSubscriptionDiscountLogsInput
    connect?: DiscountWhereUniqueInput
    update?: XOR<XOR<DiscountUpdateToOneWithWhereWithoutSubscriptionDiscountLogsInput, DiscountUpdateWithoutSubscriptionDiscountLogsInput>, DiscountUncheckedUpdateWithoutSubscriptionDiscountLogsInput>
  }

  export type FlowCreateNestedManyWithoutBusinessInput = {
    create?: XOR<FlowCreateWithoutBusinessInput, FlowUncheckedCreateWithoutBusinessInput> | FlowCreateWithoutBusinessInput[] | FlowUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: FlowCreateOrConnectWithoutBusinessInput | FlowCreateOrConnectWithoutBusinessInput[]
    createMany?: FlowCreateManyBusinessInputEnvelope
    connect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
  }

  export type WhatsAppNumberCreateNestedManyWithoutBusinessInput = {
    create?: XOR<WhatsAppNumberCreateWithoutBusinessInput, WhatsAppNumberUncheckedCreateWithoutBusinessInput> | WhatsAppNumberCreateWithoutBusinessInput[] | WhatsAppNumberUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: WhatsAppNumberCreateOrConnectWithoutBusinessInput | WhatsAppNumberCreateOrConnectWithoutBusinessInput[]
    createMany?: WhatsAppNumberCreateManyBusinessInputEnvelope
    connect?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutBusinessesInput = {
    create?: XOR<UserCreateWithoutBusinessesInput, UserUncheckedCreateWithoutBusinessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBusinessesInput
    connect?: UserWhereUniqueInput
  }

  export type DiscountCreateNestedOneWithoutBusinessesInput = {
    create?: XOR<DiscountCreateWithoutBusinessesInput, DiscountUncheckedCreateWithoutBusinessesInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutBusinessesInput
    connect?: DiscountWhereUniqueInput
  }

  export type BranchCreateNestedManyWithoutBusinessInput = {
    create?: XOR<BranchCreateWithoutBusinessInput, BranchUncheckedCreateWithoutBusinessInput> | BranchCreateWithoutBusinessInput[] | BranchUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutBusinessInput | BranchCreateOrConnectWithoutBusinessInput[]
    createMany?: BranchCreateManyBusinessInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutBusinessesInput = {
    create?: XOR<SubscriptionCreateWithoutBusinessesInput, SubscriptionUncheckedCreateWithoutBusinessesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutBusinessesInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type SubscriberSubscriptionCreateNestedManyWithoutBusinessInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutBusinessInput, SubscriberSubscriptionUncheckedCreateWithoutBusinessInput> | SubscriberSubscriptionCreateWithoutBusinessInput[] | SubscriberSubscriptionUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutBusinessInput | SubscriberSubscriptionCreateOrConnectWithoutBusinessInput[]
    createMany?: SubscriberSubscriptionCreateManyBusinessInputEnvelope
    connect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
  }

  export type ScheduleHourCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ScheduleHourCreateWithoutBusinessInput, ScheduleHourUncheckedCreateWithoutBusinessInput> | ScheduleHourCreateWithoutBusinessInput[] | ScheduleHourUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ScheduleHourCreateOrConnectWithoutBusinessInput | ScheduleHourCreateOrConnectWithoutBusinessInput[]
    createMany?: ScheduleHourCreateManyBusinessInputEnvelope
    connect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
  }

  export type FlowUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<FlowCreateWithoutBusinessInput, FlowUncheckedCreateWithoutBusinessInput> | FlowCreateWithoutBusinessInput[] | FlowUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: FlowCreateOrConnectWithoutBusinessInput | FlowCreateOrConnectWithoutBusinessInput[]
    createMany?: FlowCreateManyBusinessInputEnvelope
    connect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
  }

  export type WhatsAppNumberUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<WhatsAppNumberCreateWithoutBusinessInput, WhatsAppNumberUncheckedCreateWithoutBusinessInput> | WhatsAppNumberCreateWithoutBusinessInput[] | WhatsAppNumberUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: WhatsAppNumberCreateOrConnectWithoutBusinessInput | WhatsAppNumberCreateOrConnectWithoutBusinessInput[]
    createMany?: WhatsAppNumberCreateManyBusinessInputEnvelope
    connect?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<BranchCreateWithoutBusinessInput, BranchUncheckedCreateWithoutBusinessInput> | BranchCreateWithoutBusinessInput[] | BranchUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutBusinessInput | BranchCreateOrConnectWithoutBusinessInput[]
    createMany?: BranchCreateManyBusinessInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type SubscriberSubscriptionUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutBusinessInput, SubscriberSubscriptionUncheckedCreateWithoutBusinessInput> | SubscriberSubscriptionCreateWithoutBusinessInput[] | SubscriberSubscriptionUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutBusinessInput | SubscriberSubscriptionCreateOrConnectWithoutBusinessInput[]
    createMany?: SubscriberSubscriptionCreateManyBusinessInputEnvelope
    connect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
  }

  export type ScheduleHourUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ScheduleHourCreateWithoutBusinessInput, ScheduleHourUncheckedCreateWithoutBusinessInput> | ScheduleHourCreateWithoutBusinessInput[] | ScheduleHourUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ScheduleHourCreateOrConnectWithoutBusinessInput | ScheduleHourCreateOrConnectWithoutBusinessInput[]
    createMany?: ScheduleHourCreateManyBusinessInputEnvelope
    connect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
  }

  export type EnumBusinessTypeFieldUpdateOperationsInput = {
    set?: $Enums.BusinessType
  }

  export type NullableEnumSubscriptionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionType | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumSubscriptionValidityFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionValidity | null
  }

  export type EnumBusinessStatusFieldUpdateOperationsInput = {
    set?: $Enums.BusinessStatus
  }

  export type FlowUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<FlowCreateWithoutBusinessInput, FlowUncheckedCreateWithoutBusinessInput> | FlowCreateWithoutBusinessInput[] | FlowUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: FlowCreateOrConnectWithoutBusinessInput | FlowCreateOrConnectWithoutBusinessInput[]
    upsert?: FlowUpsertWithWhereUniqueWithoutBusinessInput | FlowUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: FlowCreateManyBusinessInputEnvelope
    set?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    disconnect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    delete?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    connect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    update?: FlowUpdateWithWhereUniqueWithoutBusinessInput | FlowUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: FlowUpdateManyWithWhereWithoutBusinessInput | FlowUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: FlowScalarWhereInput | FlowScalarWhereInput[]
  }

  export type WhatsAppNumberUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<WhatsAppNumberCreateWithoutBusinessInput, WhatsAppNumberUncheckedCreateWithoutBusinessInput> | WhatsAppNumberCreateWithoutBusinessInput[] | WhatsAppNumberUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: WhatsAppNumberCreateOrConnectWithoutBusinessInput | WhatsAppNumberCreateOrConnectWithoutBusinessInput[]
    upsert?: WhatsAppNumberUpsertWithWhereUniqueWithoutBusinessInput | WhatsAppNumberUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: WhatsAppNumberCreateManyBusinessInputEnvelope
    set?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    disconnect?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    delete?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    connect?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    update?: WhatsAppNumberUpdateWithWhereUniqueWithoutBusinessInput | WhatsAppNumberUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: WhatsAppNumberUpdateManyWithWhereWithoutBusinessInput | WhatsAppNumberUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: WhatsAppNumberScalarWhereInput | WhatsAppNumberScalarWhereInput[]
  }

  export type UserUpdateOneWithoutBusinessesNestedInput = {
    create?: XOR<UserCreateWithoutBusinessesInput, UserUncheckedCreateWithoutBusinessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBusinessesInput
    upsert?: UserUpsertWithoutBusinessesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBusinessesInput, UserUpdateWithoutBusinessesInput>, UserUncheckedUpdateWithoutBusinessesInput>
  }

  export type DiscountUpdateOneWithoutBusinessesNestedInput = {
    create?: XOR<DiscountCreateWithoutBusinessesInput, DiscountUncheckedCreateWithoutBusinessesInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutBusinessesInput
    upsert?: DiscountUpsertWithoutBusinessesInput
    disconnect?: DiscountWhereInput | boolean
    delete?: DiscountWhereInput | boolean
    connect?: DiscountWhereUniqueInput
    update?: XOR<XOR<DiscountUpdateToOneWithWhereWithoutBusinessesInput, DiscountUpdateWithoutBusinessesInput>, DiscountUncheckedUpdateWithoutBusinessesInput>
  }

  export type BranchUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<BranchCreateWithoutBusinessInput, BranchUncheckedCreateWithoutBusinessInput> | BranchCreateWithoutBusinessInput[] | BranchUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutBusinessInput | BranchCreateOrConnectWithoutBusinessInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutBusinessInput | BranchUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: BranchCreateManyBusinessInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutBusinessInput | BranchUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutBusinessInput | BranchUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutBusinessesNestedInput = {
    create?: XOR<SubscriptionCreateWithoutBusinessesInput, SubscriptionUncheckedCreateWithoutBusinessesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutBusinessesInput
    upsert?: SubscriptionUpsertWithoutBusinessesInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutBusinessesInput, SubscriptionUpdateWithoutBusinessesInput>, SubscriptionUncheckedUpdateWithoutBusinessesInput>
  }

  export type SubscriberSubscriptionUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutBusinessInput, SubscriberSubscriptionUncheckedCreateWithoutBusinessInput> | SubscriberSubscriptionCreateWithoutBusinessInput[] | SubscriberSubscriptionUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutBusinessInput | SubscriberSubscriptionCreateOrConnectWithoutBusinessInput[]
    upsert?: SubscriberSubscriptionUpsertWithWhereUniqueWithoutBusinessInput | SubscriberSubscriptionUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: SubscriberSubscriptionCreateManyBusinessInputEnvelope
    set?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    disconnect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    delete?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    connect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    update?: SubscriberSubscriptionUpdateWithWhereUniqueWithoutBusinessInput | SubscriberSubscriptionUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: SubscriberSubscriptionUpdateManyWithWhereWithoutBusinessInput | SubscriberSubscriptionUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: SubscriberSubscriptionScalarWhereInput | SubscriberSubscriptionScalarWhereInput[]
  }

  export type ScheduleHourUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ScheduleHourCreateWithoutBusinessInput, ScheduleHourUncheckedCreateWithoutBusinessInput> | ScheduleHourCreateWithoutBusinessInput[] | ScheduleHourUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ScheduleHourCreateOrConnectWithoutBusinessInput | ScheduleHourCreateOrConnectWithoutBusinessInput[]
    upsert?: ScheduleHourUpsertWithWhereUniqueWithoutBusinessInput | ScheduleHourUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ScheduleHourCreateManyBusinessInputEnvelope
    set?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    disconnect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    delete?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    connect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    update?: ScheduleHourUpdateWithWhereUniqueWithoutBusinessInput | ScheduleHourUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ScheduleHourUpdateManyWithWhereWithoutBusinessInput | ScheduleHourUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ScheduleHourScalarWhereInput | ScheduleHourScalarWhereInput[]
  }

  export type FlowUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<FlowCreateWithoutBusinessInput, FlowUncheckedCreateWithoutBusinessInput> | FlowCreateWithoutBusinessInput[] | FlowUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: FlowCreateOrConnectWithoutBusinessInput | FlowCreateOrConnectWithoutBusinessInput[]
    upsert?: FlowUpsertWithWhereUniqueWithoutBusinessInput | FlowUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: FlowCreateManyBusinessInputEnvelope
    set?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    disconnect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    delete?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    connect?: FlowWhereUniqueInput | FlowWhereUniqueInput[]
    update?: FlowUpdateWithWhereUniqueWithoutBusinessInput | FlowUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: FlowUpdateManyWithWhereWithoutBusinessInput | FlowUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: FlowScalarWhereInput | FlowScalarWhereInput[]
  }

  export type WhatsAppNumberUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<WhatsAppNumberCreateWithoutBusinessInput, WhatsAppNumberUncheckedCreateWithoutBusinessInput> | WhatsAppNumberCreateWithoutBusinessInput[] | WhatsAppNumberUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: WhatsAppNumberCreateOrConnectWithoutBusinessInput | WhatsAppNumberCreateOrConnectWithoutBusinessInput[]
    upsert?: WhatsAppNumberUpsertWithWhereUniqueWithoutBusinessInput | WhatsAppNumberUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: WhatsAppNumberCreateManyBusinessInputEnvelope
    set?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    disconnect?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    delete?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    connect?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    update?: WhatsAppNumberUpdateWithWhereUniqueWithoutBusinessInput | WhatsAppNumberUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: WhatsAppNumberUpdateManyWithWhereWithoutBusinessInput | WhatsAppNumberUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: WhatsAppNumberScalarWhereInput | WhatsAppNumberScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<BranchCreateWithoutBusinessInput, BranchUncheckedCreateWithoutBusinessInput> | BranchCreateWithoutBusinessInput[] | BranchUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutBusinessInput | BranchCreateOrConnectWithoutBusinessInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutBusinessInput | BranchUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: BranchCreateManyBusinessInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutBusinessInput | BranchUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutBusinessInput | BranchUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type SubscriberSubscriptionUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutBusinessInput, SubscriberSubscriptionUncheckedCreateWithoutBusinessInput> | SubscriberSubscriptionCreateWithoutBusinessInput[] | SubscriberSubscriptionUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutBusinessInput | SubscriberSubscriptionCreateOrConnectWithoutBusinessInput[]
    upsert?: SubscriberSubscriptionUpsertWithWhereUniqueWithoutBusinessInput | SubscriberSubscriptionUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: SubscriberSubscriptionCreateManyBusinessInputEnvelope
    set?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    disconnect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    delete?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    connect?: SubscriberSubscriptionWhereUniqueInput | SubscriberSubscriptionWhereUniqueInput[]
    update?: SubscriberSubscriptionUpdateWithWhereUniqueWithoutBusinessInput | SubscriberSubscriptionUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: SubscriberSubscriptionUpdateManyWithWhereWithoutBusinessInput | SubscriberSubscriptionUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: SubscriberSubscriptionScalarWhereInput | SubscriberSubscriptionScalarWhereInput[]
  }

  export type ScheduleHourUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ScheduleHourCreateWithoutBusinessInput, ScheduleHourUncheckedCreateWithoutBusinessInput> | ScheduleHourCreateWithoutBusinessInput[] | ScheduleHourUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ScheduleHourCreateOrConnectWithoutBusinessInput | ScheduleHourCreateOrConnectWithoutBusinessInput[]
    upsert?: ScheduleHourUpsertWithWhereUniqueWithoutBusinessInput | ScheduleHourUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ScheduleHourCreateManyBusinessInputEnvelope
    set?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    disconnect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    delete?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    connect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    update?: ScheduleHourUpdateWithWhereUniqueWithoutBusinessInput | ScheduleHourUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ScheduleHourUpdateManyWithWhereWithoutBusinessInput | ScheduleHourUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ScheduleHourScalarWhereInput | ScheduleHourScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOwnedBranchesInput = {
    create?: XOR<UserCreateWithoutOwnedBranchesInput, UserUncheckedCreateWithoutOwnedBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedBranchesInput
    connect?: UserWhereUniqueInput
  }

  export type BusinessCreateNestedOneWithoutBranchesInput = {
    create?: XOR<BusinessCreateWithoutBranchesInput, BusinessUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutBranchesInput
    connect?: BusinessWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ServiceBranchCreateNestedManyWithoutBranchInput = {
    create?: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput> | ServiceBranchCreateWithoutBranchInput[] | ServiceBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutBranchInput | ServiceBranchCreateOrConnectWithoutBranchInput[]
    createMany?: ServiceBranchCreateManyBranchInputEnvelope
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutBranchInput = {
    create?: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput> | AppointmentCreateWithoutBranchInput[] | AppointmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutBranchInput | AppointmentCreateOrConnectWithoutBranchInput[]
    createMany?: AppointmentCreateManyBranchInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type PromotionCreateNestedManyWithoutBranchesInput = {
    create?: XOR<PromotionCreateWithoutBranchesInput, PromotionUncheckedCreateWithoutBranchesInput> | PromotionCreateWithoutBranchesInput[] | PromotionUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutBranchesInput | PromotionCreateOrConnectWithoutBranchesInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type TabletAccountCreateNestedManyWithoutBranchInput = {
    create?: XOR<TabletAccountCreateWithoutBranchInput, TabletAccountUncheckedCreateWithoutBranchInput> | TabletAccountCreateWithoutBranchInput[] | TabletAccountUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TabletAccountCreateOrConnectWithoutBranchInput | TabletAccountCreateOrConnectWithoutBranchInput[]
    createMany?: TabletAccountCreateManyBranchInputEnvelope
    connect?: TabletAccountWhereUniqueInput | TabletAccountWhereUniqueInput[]
  }

  export type WhatsappAdCreateNestedManyWithoutBranchInput = {
    create?: XOR<WhatsappAdCreateWithoutBranchInput, WhatsappAdUncheckedCreateWithoutBranchInput> | WhatsappAdCreateWithoutBranchInput[] | WhatsappAdUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WhatsappAdCreateOrConnectWithoutBranchInput | WhatsappAdCreateOrConnectWithoutBranchInput[]
    createMany?: WhatsappAdCreateManyBranchInputEnvelope
    connect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
  }

  export type ScheduleHourCreateNestedManyWithoutBranchInput = {
    create?: XOR<ScheduleHourCreateWithoutBranchInput, ScheduleHourUncheckedCreateWithoutBranchInput> | ScheduleHourCreateWithoutBranchInput[] | ScheduleHourUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ScheduleHourCreateOrConnectWithoutBranchInput | ScheduleHourCreateOrConnectWithoutBranchInput[]
    createMany?: ScheduleHourCreateManyBranchInputEnvelope
    connect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ServiceBranchUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput> | ServiceBranchCreateWithoutBranchInput[] | ServiceBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutBranchInput | ServiceBranchCreateOrConnectWithoutBranchInput[]
    createMany?: ServiceBranchCreateManyBranchInputEnvelope
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput> | AppointmentCreateWithoutBranchInput[] | AppointmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutBranchInput | AppointmentCreateOrConnectWithoutBranchInput[]
    createMany?: AppointmentCreateManyBranchInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type PromotionUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<PromotionCreateWithoutBranchesInput, PromotionUncheckedCreateWithoutBranchesInput> | PromotionCreateWithoutBranchesInput[] | PromotionUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutBranchesInput | PromotionCreateOrConnectWithoutBranchesInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type TabletAccountUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<TabletAccountCreateWithoutBranchInput, TabletAccountUncheckedCreateWithoutBranchInput> | TabletAccountCreateWithoutBranchInput[] | TabletAccountUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TabletAccountCreateOrConnectWithoutBranchInput | TabletAccountCreateOrConnectWithoutBranchInput[]
    createMany?: TabletAccountCreateManyBranchInputEnvelope
    connect?: TabletAccountWhereUniqueInput | TabletAccountWhereUniqueInput[]
  }

  export type WhatsappAdUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<WhatsappAdCreateWithoutBranchInput, WhatsappAdUncheckedCreateWithoutBranchInput> | WhatsappAdCreateWithoutBranchInput[] | WhatsappAdUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WhatsappAdCreateOrConnectWithoutBranchInput | WhatsappAdCreateOrConnectWithoutBranchInput[]
    createMany?: WhatsappAdCreateManyBranchInputEnvelope
    connect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
  }

  export type ScheduleHourUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ScheduleHourCreateWithoutBranchInput, ScheduleHourUncheckedCreateWithoutBranchInput> | ScheduleHourCreateWithoutBranchInput[] | ScheduleHourUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ScheduleHourCreateOrConnectWithoutBranchInput | ScheduleHourCreateOrConnectWithoutBranchInput[]
    createMany?: ScheduleHourCreateManyBranchInputEnvelope
    connect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOwnedBranchesNestedInput = {
    create?: XOR<UserCreateWithoutOwnedBranchesInput, UserUncheckedCreateWithoutOwnedBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedBranchesInput
    upsert?: UserUpsertWithoutOwnedBranchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedBranchesInput, UserUpdateWithoutOwnedBranchesInput>, UserUncheckedUpdateWithoutOwnedBranchesInput>
  }

  export type BusinessUpdateOneWithoutBranchesNestedInput = {
    create?: XOR<BusinessCreateWithoutBranchesInput, BusinessUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutBranchesInput
    upsert?: BusinessUpsertWithoutBranchesInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutBranchesInput, BusinessUpdateWithoutBranchesInput>, BusinessUncheckedUpdateWithoutBranchesInput>
  }

  export type UserUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ServiceBranchUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput> | ServiceBranchCreateWithoutBranchInput[] | ServiceBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutBranchInput | ServiceBranchCreateOrConnectWithoutBranchInput[]
    upsert?: ServiceBranchUpsertWithWhereUniqueWithoutBranchInput | ServiceBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ServiceBranchCreateManyBranchInputEnvelope
    set?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    disconnect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    delete?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    update?: ServiceBranchUpdateWithWhereUniqueWithoutBranchInput | ServiceBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ServiceBranchUpdateManyWithWhereWithoutBranchInput | ServiceBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput> | AppointmentCreateWithoutBranchInput[] | AppointmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutBranchInput | AppointmentCreateOrConnectWithoutBranchInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutBranchInput | AppointmentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AppointmentCreateManyBranchInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutBranchInput | AppointmentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutBranchInput | AppointmentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type PromotionUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<PromotionCreateWithoutBranchesInput, PromotionUncheckedCreateWithoutBranchesInput> | PromotionCreateWithoutBranchesInput[] | PromotionUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutBranchesInput | PromotionCreateOrConnectWithoutBranchesInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutBranchesInput | PromotionUpsertWithWhereUniqueWithoutBranchesInput[]
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutBranchesInput | PromotionUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutBranchesInput | PromotionUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type TabletAccountUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TabletAccountCreateWithoutBranchInput, TabletAccountUncheckedCreateWithoutBranchInput> | TabletAccountCreateWithoutBranchInput[] | TabletAccountUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TabletAccountCreateOrConnectWithoutBranchInput | TabletAccountCreateOrConnectWithoutBranchInput[]
    upsert?: TabletAccountUpsertWithWhereUniqueWithoutBranchInput | TabletAccountUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TabletAccountCreateManyBranchInputEnvelope
    set?: TabletAccountWhereUniqueInput | TabletAccountWhereUniqueInput[]
    disconnect?: TabletAccountWhereUniqueInput | TabletAccountWhereUniqueInput[]
    delete?: TabletAccountWhereUniqueInput | TabletAccountWhereUniqueInput[]
    connect?: TabletAccountWhereUniqueInput | TabletAccountWhereUniqueInput[]
    update?: TabletAccountUpdateWithWhereUniqueWithoutBranchInput | TabletAccountUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TabletAccountUpdateManyWithWhereWithoutBranchInput | TabletAccountUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TabletAccountScalarWhereInput | TabletAccountScalarWhereInput[]
  }

  export type WhatsappAdUpdateManyWithoutBranchNestedInput = {
    create?: XOR<WhatsappAdCreateWithoutBranchInput, WhatsappAdUncheckedCreateWithoutBranchInput> | WhatsappAdCreateWithoutBranchInput[] | WhatsappAdUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WhatsappAdCreateOrConnectWithoutBranchInput | WhatsappAdCreateOrConnectWithoutBranchInput[]
    upsert?: WhatsappAdUpsertWithWhereUniqueWithoutBranchInput | WhatsappAdUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: WhatsappAdCreateManyBranchInputEnvelope
    set?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    disconnect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    delete?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    connect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    update?: WhatsappAdUpdateWithWhereUniqueWithoutBranchInput | WhatsappAdUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: WhatsappAdUpdateManyWithWhereWithoutBranchInput | WhatsappAdUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: WhatsappAdScalarWhereInput | WhatsappAdScalarWhereInput[]
  }

  export type ScheduleHourUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ScheduleHourCreateWithoutBranchInput, ScheduleHourUncheckedCreateWithoutBranchInput> | ScheduleHourCreateWithoutBranchInput[] | ScheduleHourUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ScheduleHourCreateOrConnectWithoutBranchInput | ScheduleHourCreateOrConnectWithoutBranchInput[]
    upsert?: ScheduleHourUpsertWithWhereUniqueWithoutBranchInput | ScheduleHourUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ScheduleHourCreateManyBranchInputEnvelope
    set?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    disconnect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    delete?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    connect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    update?: ScheduleHourUpdateWithWhereUniqueWithoutBranchInput | ScheduleHourUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ScheduleHourUpdateManyWithWhereWithoutBranchInput | ScheduleHourUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ScheduleHourScalarWhereInput | ScheduleHourScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput> | ServiceBranchCreateWithoutBranchInput[] | ServiceBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutBranchInput | ServiceBranchCreateOrConnectWithoutBranchInput[]
    upsert?: ServiceBranchUpsertWithWhereUniqueWithoutBranchInput | ServiceBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ServiceBranchCreateManyBranchInputEnvelope
    set?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    disconnect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    delete?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    update?: ServiceBranchUpdateWithWhereUniqueWithoutBranchInput | ServiceBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ServiceBranchUpdateManyWithWhereWithoutBranchInput | ServiceBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput> | AppointmentCreateWithoutBranchInput[] | AppointmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutBranchInput | AppointmentCreateOrConnectWithoutBranchInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutBranchInput | AppointmentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AppointmentCreateManyBranchInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutBranchInput | AppointmentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutBranchInput | AppointmentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type PromotionUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<PromotionCreateWithoutBranchesInput, PromotionUncheckedCreateWithoutBranchesInput> | PromotionCreateWithoutBranchesInput[] | PromotionUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutBranchesInput | PromotionCreateOrConnectWithoutBranchesInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutBranchesInput | PromotionUpsertWithWhereUniqueWithoutBranchesInput[]
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutBranchesInput | PromotionUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutBranchesInput | PromotionUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type TabletAccountUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TabletAccountCreateWithoutBranchInput, TabletAccountUncheckedCreateWithoutBranchInput> | TabletAccountCreateWithoutBranchInput[] | TabletAccountUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TabletAccountCreateOrConnectWithoutBranchInput | TabletAccountCreateOrConnectWithoutBranchInput[]
    upsert?: TabletAccountUpsertWithWhereUniqueWithoutBranchInput | TabletAccountUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TabletAccountCreateManyBranchInputEnvelope
    set?: TabletAccountWhereUniqueInput | TabletAccountWhereUniqueInput[]
    disconnect?: TabletAccountWhereUniqueInput | TabletAccountWhereUniqueInput[]
    delete?: TabletAccountWhereUniqueInput | TabletAccountWhereUniqueInput[]
    connect?: TabletAccountWhereUniqueInput | TabletAccountWhereUniqueInput[]
    update?: TabletAccountUpdateWithWhereUniqueWithoutBranchInput | TabletAccountUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TabletAccountUpdateManyWithWhereWithoutBranchInput | TabletAccountUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TabletAccountScalarWhereInput | TabletAccountScalarWhereInput[]
  }

  export type WhatsappAdUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<WhatsappAdCreateWithoutBranchInput, WhatsappAdUncheckedCreateWithoutBranchInput> | WhatsappAdCreateWithoutBranchInput[] | WhatsappAdUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WhatsappAdCreateOrConnectWithoutBranchInput | WhatsappAdCreateOrConnectWithoutBranchInput[]
    upsert?: WhatsappAdUpsertWithWhereUniqueWithoutBranchInput | WhatsappAdUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: WhatsappAdCreateManyBranchInputEnvelope
    set?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    disconnect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    delete?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    connect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    update?: WhatsappAdUpdateWithWhereUniqueWithoutBranchInput | WhatsappAdUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: WhatsappAdUpdateManyWithWhereWithoutBranchInput | WhatsappAdUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: WhatsappAdScalarWhereInput | WhatsappAdScalarWhereInput[]
  }

  export type ScheduleHourUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ScheduleHourCreateWithoutBranchInput, ScheduleHourUncheckedCreateWithoutBranchInput> | ScheduleHourCreateWithoutBranchInput[] | ScheduleHourUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ScheduleHourCreateOrConnectWithoutBranchInput | ScheduleHourCreateOrConnectWithoutBranchInput[]
    upsert?: ScheduleHourUpsertWithWhereUniqueWithoutBranchInput | ScheduleHourUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ScheduleHourCreateManyBranchInputEnvelope
    set?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    disconnect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    delete?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    connect?: ScheduleHourWhereUniqueInput | ScheduleHourWhereUniqueInput[]
    update?: ScheduleHourUpdateWithWhereUniqueWithoutBranchInput | ScheduleHourUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ScheduleHourUpdateManyWithWhereWithoutBranchInput | ScheduleHourUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ScheduleHourScalarWhereInput | ScheduleHourScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutScheduleHoursInput = {
    create?: XOR<UserCreateWithoutScheduleHoursInput, UserUncheckedCreateWithoutScheduleHoursInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduleHoursInput
    connect?: UserWhereUniqueInput
  }

  export type BusinessCreateNestedOneWithoutScheduleHoursInput = {
    create?: XOR<BusinessCreateWithoutScheduleHoursInput, BusinessUncheckedCreateWithoutScheduleHoursInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutScheduleHoursInput
    connect?: BusinessWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutScheduleHoursInput = {
    create?: XOR<BranchCreateWithoutScheduleHoursInput, BranchUncheckedCreateWithoutScheduleHoursInput>
    connectOrCreate?: BranchCreateOrConnectWithoutScheduleHoursInput
    connect?: BranchWhereUniqueInput
  }

  export type EnumScheduleOwnerTypeFieldUpdateOperationsInput = {
    set?: $Enums.ScheduleOwnerType
  }

  export type EnumWeekDayFieldUpdateOperationsInput = {
    set?: $Enums.WeekDay
  }

  export type EnumScheduleInheritanceModeFieldUpdateOperationsInput = {
    set?: $Enums.ScheduleInheritanceMode
  }

  export type UserUpdateOneWithoutScheduleHoursNestedInput = {
    create?: XOR<UserCreateWithoutScheduleHoursInput, UserUncheckedCreateWithoutScheduleHoursInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduleHoursInput
    upsert?: UserUpsertWithoutScheduleHoursInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScheduleHoursInput, UserUpdateWithoutScheduleHoursInput>, UserUncheckedUpdateWithoutScheduleHoursInput>
  }

  export type BusinessUpdateOneWithoutScheduleHoursNestedInput = {
    create?: XOR<BusinessCreateWithoutScheduleHoursInput, BusinessUncheckedCreateWithoutScheduleHoursInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutScheduleHoursInput
    upsert?: BusinessUpsertWithoutScheduleHoursInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutScheduleHoursInput, BusinessUpdateWithoutScheduleHoursInput>, BusinessUncheckedUpdateWithoutScheduleHoursInput>
  }

  export type BranchUpdateOneWithoutScheduleHoursNestedInput = {
    create?: XOR<BranchCreateWithoutScheduleHoursInput, BranchUncheckedCreateWithoutScheduleHoursInput>
    connectOrCreate?: BranchCreateOrConnectWithoutScheduleHoursInput
    upsert?: BranchUpsertWithoutScheduleHoursInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutScheduleHoursInput, BranchUpdateWithoutScheduleHoursInput>, BranchUncheckedUpdateWithoutScheduleHoursInput>
  }

  export type UserCreateNestedOneWithoutStatusLogsInput = {
    create?: XOR<UserCreateWithoutStatusLogsInput, UserUncheckedCreateWithoutStatusLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatusLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumStaffStatusFieldUpdateOperationsInput = {
    set?: $Enums.StaffStatus
  }

  export type UserUpdateOneRequiredWithoutStatusLogsNestedInput = {
    create?: XOR<UserCreateWithoutStatusLogsInput, UserUncheckedCreateWithoutStatusLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatusLogsInput
    upsert?: UserUpsertWithoutStatusLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStatusLogsInput, UserUpdateWithoutStatusLogsInput>, UserUncheckedUpdateWithoutStatusLogsInput>
  }

  export type UserCreateNestedOneWithoutAttendanceRecordsInput = {
    create?: XOR<UserCreateWithoutAttendanceRecordsInput, UserUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type UserUpdateOneRequiredWithoutAttendanceRecordsNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceRecordsInput, UserUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceRecordsInput
    upsert?: UserUpsertWithoutAttendanceRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceRecordsInput, UserUpdateWithoutAttendanceRecordsInput>, UserUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type UserCreateNestedOneWithoutVacationsInput = {
    create?: XOR<UserCreateWithoutVacationsInput, UserUncheckedCreateWithoutVacationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVacationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumVacationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VacationStatus
  }

  export type UserUpdateOneRequiredWithoutVacationsNestedInput = {
    create?: XOR<UserCreateWithoutVacationsInput, UserUncheckedCreateWithoutVacationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVacationsInput
    upsert?: UserUpsertWithoutVacationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVacationsInput, UserUpdateWithoutVacationsInput>, UserUncheckedUpdateWithoutVacationsInput>
  }

  export type UserOnServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<UserOnServiceCreateWithoutServiceInput, UserOnServiceUncheckedCreateWithoutServiceInput> | UserOnServiceCreateWithoutServiceInput[] | UserOnServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserOnServiceCreateOrConnectWithoutServiceInput | UserOnServiceCreateOrConnectWithoutServiceInput[]
    createMany?: UserOnServiceCreateManyServiceInputEnvelope
    connect?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
  }

  export type ServiceBranchCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput> | ServiceBranchCreateWithoutServiceInput[] | ServiceBranchUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutServiceInput | ServiceBranchCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceBranchCreateManyServiceInputEnvelope
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutServiceInput = {
    create?: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput> | AppointmentCreateWithoutServiceInput[] | AppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceInput | AppointmentCreateOrConnectWithoutServiceInput[]
    createMany?: AppointmentCreateManyServiceInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type WhatsappAdCreateNestedManyWithoutServiceInput = {
    create?: XOR<WhatsappAdCreateWithoutServiceInput, WhatsappAdUncheckedCreateWithoutServiceInput> | WhatsappAdCreateWithoutServiceInput[] | WhatsappAdUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: WhatsappAdCreateOrConnectWithoutServiceInput | WhatsappAdCreateOrConnectWithoutServiceInput[]
    createMany?: WhatsappAdCreateManyServiceInputEnvelope
    connect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
  }

  export type UserOnServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<UserOnServiceCreateWithoutServiceInput, UserOnServiceUncheckedCreateWithoutServiceInput> | UserOnServiceCreateWithoutServiceInput[] | UserOnServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserOnServiceCreateOrConnectWithoutServiceInput | UserOnServiceCreateOrConnectWithoutServiceInput[]
    createMany?: UserOnServiceCreateManyServiceInputEnvelope
    connect?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
  }

  export type ServiceBranchUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput> | ServiceBranchCreateWithoutServiceInput[] | ServiceBranchUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutServiceInput | ServiceBranchCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceBranchCreateManyServiceInputEnvelope
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput> | AppointmentCreateWithoutServiceInput[] | AppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceInput | AppointmentCreateOrConnectWithoutServiceInput[]
    createMany?: AppointmentCreateManyServiceInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type WhatsappAdUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<WhatsappAdCreateWithoutServiceInput, WhatsappAdUncheckedCreateWithoutServiceInput> | WhatsappAdCreateWithoutServiceInput[] | WhatsappAdUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: WhatsappAdCreateOrConnectWithoutServiceInput | WhatsappAdCreateOrConnectWithoutServiceInput[]
    createMany?: WhatsappAdCreateManyServiceInputEnvelope
    connect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
  }

  export type UserOnServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<UserOnServiceCreateWithoutServiceInput, UserOnServiceUncheckedCreateWithoutServiceInput> | UserOnServiceCreateWithoutServiceInput[] | UserOnServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserOnServiceCreateOrConnectWithoutServiceInput | UserOnServiceCreateOrConnectWithoutServiceInput[]
    upsert?: UserOnServiceUpsertWithWhereUniqueWithoutServiceInput | UserOnServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: UserOnServiceCreateManyServiceInputEnvelope
    set?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    disconnect?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    delete?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    connect?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    update?: UserOnServiceUpdateWithWhereUniqueWithoutServiceInput | UserOnServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: UserOnServiceUpdateManyWithWhereWithoutServiceInput | UserOnServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: UserOnServiceScalarWhereInput | UserOnServiceScalarWhereInput[]
  }

  export type ServiceBranchUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput> | ServiceBranchCreateWithoutServiceInput[] | ServiceBranchUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutServiceInput | ServiceBranchCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceBranchUpsertWithWhereUniqueWithoutServiceInput | ServiceBranchUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceBranchCreateManyServiceInputEnvelope
    set?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    disconnect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    delete?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    update?: ServiceBranchUpdateWithWhereUniqueWithoutServiceInput | ServiceBranchUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceBranchUpdateManyWithWhereWithoutServiceInput | ServiceBranchUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutServiceNestedInput = {
    create?: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput> | AppointmentCreateWithoutServiceInput[] | AppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceInput | AppointmentCreateOrConnectWithoutServiceInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutServiceInput | AppointmentUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: AppointmentCreateManyServiceInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutServiceInput | AppointmentUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutServiceInput | AppointmentUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type WhatsappAdUpdateManyWithoutServiceNestedInput = {
    create?: XOR<WhatsappAdCreateWithoutServiceInput, WhatsappAdUncheckedCreateWithoutServiceInput> | WhatsappAdCreateWithoutServiceInput[] | WhatsappAdUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: WhatsappAdCreateOrConnectWithoutServiceInput | WhatsappAdCreateOrConnectWithoutServiceInput[]
    upsert?: WhatsappAdUpsertWithWhereUniqueWithoutServiceInput | WhatsappAdUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: WhatsappAdCreateManyServiceInputEnvelope
    set?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    disconnect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    delete?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    connect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    update?: WhatsappAdUpdateWithWhereUniqueWithoutServiceInput | WhatsappAdUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: WhatsappAdUpdateManyWithWhereWithoutServiceInput | WhatsappAdUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: WhatsappAdScalarWhereInput | WhatsappAdScalarWhereInput[]
  }

  export type UserOnServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<UserOnServiceCreateWithoutServiceInput, UserOnServiceUncheckedCreateWithoutServiceInput> | UserOnServiceCreateWithoutServiceInput[] | UserOnServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserOnServiceCreateOrConnectWithoutServiceInput | UserOnServiceCreateOrConnectWithoutServiceInput[]
    upsert?: UserOnServiceUpsertWithWhereUniqueWithoutServiceInput | UserOnServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: UserOnServiceCreateManyServiceInputEnvelope
    set?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    disconnect?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    delete?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    connect?: UserOnServiceWhereUniqueInput | UserOnServiceWhereUniqueInput[]
    update?: UserOnServiceUpdateWithWhereUniqueWithoutServiceInput | UserOnServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: UserOnServiceUpdateManyWithWhereWithoutServiceInput | UserOnServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: UserOnServiceScalarWhereInput | UserOnServiceScalarWhereInput[]
  }

  export type ServiceBranchUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput> | ServiceBranchCreateWithoutServiceInput[] | ServiceBranchUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutServiceInput | ServiceBranchCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceBranchUpsertWithWhereUniqueWithoutServiceInput | ServiceBranchUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceBranchCreateManyServiceInputEnvelope
    set?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    disconnect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    delete?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    update?: ServiceBranchUpdateWithWhereUniqueWithoutServiceInput | ServiceBranchUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceBranchUpdateManyWithWhereWithoutServiceInput | ServiceBranchUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput> | AppointmentCreateWithoutServiceInput[] | AppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceInput | AppointmentCreateOrConnectWithoutServiceInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutServiceInput | AppointmentUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: AppointmentCreateManyServiceInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutServiceInput | AppointmentUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutServiceInput | AppointmentUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type WhatsappAdUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<WhatsappAdCreateWithoutServiceInput, WhatsappAdUncheckedCreateWithoutServiceInput> | WhatsappAdCreateWithoutServiceInput[] | WhatsappAdUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: WhatsappAdCreateOrConnectWithoutServiceInput | WhatsappAdCreateOrConnectWithoutServiceInput[]
    upsert?: WhatsappAdUpsertWithWhereUniqueWithoutServiceInput | WhatsappAdUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: WhatsappAdCreateManyServiceInputEnvelope
    set?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    disconnect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    delete?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    connect?: WhatsappAdWhereUniqueInput | WhatsappAdWhereUniqueInput[]
    update?: WhatsappAdUpdateWithWhereUniqueWithoutServiceInput | WhatsappAdUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: WhatsappAdUpdateManyWithWhereWithoutServiceInput | WhatsappAdUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: WhatsappAdScalarWhereInput | WhatsappAdScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutProvidersInput = {
    create?: XOR<ServiceCreateWithoutProvidersInput, ServiceUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutProvidersInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutServicesInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutProvidersNestedInput = {
    create?: XOR<ServiceCreateWithoutProvidersInput, ServiceUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutProvidersInput
    upsert?: ServiceUpsertWithoutProvidersInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutProvidersInput, ServiceUpdateWithoutProvidersInput>, ServiceUncheckedUpdateWithoutProvidersInput>
  }

  export type UserUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput
    upsert?: UserUpsertWithoutServicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServicesInput, UserUpdateWithoutServicesInput>, UserUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceCreateNestedOneWithoutBranchesInput = {
    create?: XOR<ServiceCreateWithoutBranchesInput, ServiceUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBranchesInput
    connect?: ServiceWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutServiceBranchesInput = {
    create?: XOR<BranchCreateWithoutServiceBranchesInput, BranchUncheckedCreateWithoutServiceBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutServiceBranchesInput
    connect?: BranchWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutBranchesNestedInput = {
    create?: XOR<ServiceCreateWithoutBranchesInput, ServiceUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBranchesInput
    upsert?: ServiceUpsertWithoutBranchesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBranchesInput, ServiceUpdateWithoutBranchesInput>, ServiceUncheckedUpdateWithoutBranchesInput>
  }

  export type BranchUpdateOneRequiredWithoutServiceBranchesNestedInput = {
    create?: XOR<BranchCreateWithoutServiceBranchesInput, BranchUncheckedCreateWithoutServiceBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutServiceBranchesInput
    upsert?: BranchUpsertWithoutServiceBranchesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutServiceBranchesInput, BranchUpdateWithoutServiceBranchesInput>, BranchUncheckedUpdateWithoutServiceBranchesInput>
  }

  export type PromotionCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PromotionCreateWithoutAppointmentsInput, PromotionUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutAppointmentsInput
    connect?: PromotionWhereUniqueInput
  }

  export type SubscriberSubscriptionCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutAppointmentsInput, SubscriberSubscriptionUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutAppointmentsInput
    connect?: SubscriberSubscriptionWhereUniqueInput
  }

  export type DiscountCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<DiscountCreateWithoutAppointmentsInput, DiscountUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutAppointmentsInput
    connect?: DiscountWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ServiceCreateWithoutAppointmentsInput, ServiceUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAppointmentsInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAppointmentsAsConsumerInput = {
    create?: XOR<UserCreateWithoutAppointmentsAsConsumerInput, UserUncheckedCreateWithoutAppointmentsAsConsumerInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsAsConsumerInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAppointmentsAsProviderInput = {
    create?: XOR<UserCreateWithoutAppointmentsAsProviderInput, UserUncheckedCreateWithoutAppointmentsAsProviderInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsAsProviderInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<BranchCreateWithoutAppointmentsInput, BranchUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAppointmentsInput
    connect?: BranchWhereUniqueInput
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentBookingType | null
  }

  export type PromotionUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<PromotionCreateWithoutAppointmentsInput, PromotionUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutAppointmentsInput
    upsert?: PromotionUpsertWithoutAppointmentsInput
    disconnect?: PromotionWhereInput | boolean
    delete?: PromotionWhereInput | boolean
    connect?: PromotionWhereUniqueInput
    update?: XOR<XOR<PromotionUpdateToOneWithWhereWithoutAppointmentsInput, PromotionUpdateWithoutAppointmentsInput>, PromotionUncheckedUpdateWithoutAppointmentsInput>
  }

  export type SubscriberSubscriptionUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<SubscriberSubscriptionCreateWithoutAppointmentsInput, SubscriberSubscriptionUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: SubscriberSubscriptionCreateOrConnectWithoutAppointmentsInput
    upsert?: SubscriberSubscriptionUpsertWithoutAppointmentsInput
    disconnect?: SubscriberSubscriptionWhereInput | boolean
    delete?: SubscriberSubscriptionWhereInput | boolean
    connect?: SubscriberSubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriberSubscriptionUpdateToOneWithWhereWithoutAppointmentsInput, SubscriberSubscriptionUpdateWithoutAppointmentsInput>, SubscriberSubscriptionUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DiscountUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<DiscountCreateWithoutAppointmentsInput, DiscountUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutAppointmentsInput
    upsert?: DiscountUpsertWithoutAppointmentsInput
    disconnect?: DiscountWhereInput | boolean
    delete?: DiscountWhereInput | boolean
    connect?: DiscountWhereUniqueInput
    update?: XOR<XOR<DiscountUpdateToOneWithWhereWithoutAppointmentsInput, DiscountUpdateWithoutAppointmentsInput>, DiscountUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ServiceUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<ServiceCreateWithoutAppointmentsInput, ServiceUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAppointmentsInput
    upsert?: ServiceUpsertWithoutAppointmentsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutAppointmentsInput, ServiceUpdateWithoutAppointmentsInput>, ServiceUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateOneRequiredWithoutAppointmentsAsConsumerNestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsAsConsumerInput, UserUncheckedCreateWithoutAppointmentsAsConsumerInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsAsConsumerInput
    upsert?: UserUpsertWithoutAppointmentsAsConsumerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsAsConsumerInput, UserUpdateWithoutAppointmentsAsConsumerInput>, UserUncheckedUpdateWithoutAppointmentsAsConsumerInput>
  }

  export type UserUpdateOneWithoutAppointmentsAsProviderNestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsAsProviderInput, UserUncheckedCreateWithoutAppointmentsAsProviderInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsAsProviderInput
    upsert?: UserUpsertWithoutAppointmentsAsProviderInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsAsProviderInput, UserUpdateWithoutAppointmentsAsProviderInput>, UserUncheckedUpdateWithoutAppointmentsAsProviderInput>
  }

  export type BranchUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<BranchCreateWithoutAppointmentsInput, BranchUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAppointmentsInput
    upsert?: BranchUpsertWithoutAppointmentsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAppointmentsInput, BranchUpdateWithoutAppointmentsInput>, BranchUncheckedUpdateWithoutAppointmentsInput>
  }

  export type BranchCreateNestedManyWithoutPromotionsInput = {
    create?: XOR<BranchCreateWithoutPromotionsInput, BranchUncheckedCreateWithoutPromotionsInput> | BranchCreateWithoutPromotionsInput[] | BranchUncheckedCreateWithoutPromotionsInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutPromotionsInput | BranchCreateOrConnectWithoutPromotionsInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutPromotionInput = {
    create?: XOR<AppointmentCreateWithoutPromotionInput, AppointmentUncheckedCreateWithoutPromotionInput> | AppointmentCreateWithoutPromotionInput[] | AppointmentUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPromotionInput | AppointmentCreateOrConnectWithoutPromotionInput[]
    createMany?: AppointmentCreateManyPromotionInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutPromotionsInput = {
    create?: XOR<BranchCreateWithoutPromotionsInput, BranchUncheckedCreateWithoutPromotionsInput> | BranchCreateWithoutPromotionsInput[] | BranchUncheckedCreateWithoutPromotionsInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutPromotionsInput | BranchCreateOrConnectWithoutPromotionsInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPromotionInput = {
    create?: XOR<AppointmentCreateWithoutPromotionInput, AppointmentUncheckedCreateWithoutPromotionInput> | AppointmentCreateWithoutPromotionInput[] | AppointmentUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPromotionInput | AppointmentCreateOrConnectWithoutPromotionInput[]
    createMany?: AppointmentCreateManyPromotionInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BranchUpdateManyWithoutPromotionsNestedInput = {
    create?: XOR<BranchCreateWithoutPromotionsInput, BranchUncheckedCreateWithoutPromotionsInput> | BranchCreateWithoutPromotionsInput[] | BranchUncheckedCreateWithoutPromotionsInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutPromotionsInput | BranchCreateOrConnectWithoutPromotionsInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutPromotionsInput | BranchUpsertWithWhereUniqueWithoutPromotionsInput[]
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutPromotionsInput | BranchUpdateWithWhereUniqueWithoutPromotionsInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutPromotionsInput | BranchUpdateManyWithWhereWithoutPromotionsInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<AppointmentCreateWithoutPromotionInput, AppointmentUncheckedCreateWithoutPromotionInput> | AppointmentCreateWithoutPromotionInput[] | AppointmentUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPromotionInput | AppointmentCreateOrConnectWithoutPromotionInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPromotionInput | AppointmentUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: AppointmentCreateManyPromotionInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPromotionInput | AppointmentUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPromotionInput | AppointmentUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutPromotionsNestedInput = {
    create?: XOR<BranchCreateWithoutPromotionsInput, BranchUncheckedCreateWithoutPromotionsInput> | BranchCreateWithoutPromotionsInput[] | BranchUncheckedCreateWithoutPromotionsInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutPromotionsInput | BranchCreateOrConnectWithoutPromotionsInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutPromotionsInput | BranchUpsertWithWhereUniqueWithoutPromotionsInput[]
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutPromotionsInput | BranchUpdateWithWhereUniqueWithoutPromotionsInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutPromotionsInput | BranchUpdateManyWithWhereWithoutPromotionsInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<AppointmentCreateWithoutPromotionInput, AppointmentUncheckedCreateWithoutPromotionInput> | AppointmentCreateWithoutPromotionInput[] | AppointmentUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPromotionInput | AppointmentCreateOrConnectWithoutPromotionInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPromotionInput | AppointmentUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: AppointmentCreateManyPromotionInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPromotionInput | AppointmentUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPromotionInput | AppointmentUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutTabletAccountsInput = {
    create?: XOR<BranchCreateWithoutTabletAccountsInput, BranchUncheckedCreateWithoutTabletAccountsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutTabletAccountsInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutTabletAccountsNestedInput = {
    create?: XOR<BranchCreateWithoutTabletAccountsInput, BranchUncheckedCreateWithoutTabletAccountsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutTabletAccountsInput
    upsert?: BranchUpsertWithoutTabletAccountsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutTabletAccountsInput, BranchUpdateWithoutTabletAccountsInput>, BranchUncheckedUpdateWithoutTabletAccountsInput>
  }

  export type BranchCreateNestedOneWithoutWhatsappAdsInput = {
    create?: XOR<BranchCreateWithoutWhatsappAdsInput, BranchUncheckedCreateWithoutWhatsappAdsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutWhatsappAdsInput
    connect?: BranchWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutWhatsappAdsInput = {
    create?: XOR<ServiceCreateWithoutWhatsappAdsInput, ServiceUncheckedCreateWithoutWhatsappAdsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutWhatsappAdsInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutAssignedWhatsappAdsInput = {
    create?: XOR<UserCreateWithoutAssignedWhatsappAdsInput, UserUncheckedCreateWithoutAssignedWhatsappAdsInput> | UserCreateWithoutAssignedWhatsappAdsInput[] | UserUncheckedCreateWithoutAssignedWhatsappAdsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedWhatsappAdsInput | UserCreateOrConnectWithoutAssignedWhatsappAdsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAssignedWhatsappAdsInput = {
    create?: XOR<UserCreateWithoutAssignedWhatsappAdsInput, UserUncheckedCreateWithoutAssignedWhatsappAdsInput> | UserCreateWithoutAssignedWhatsappAdsInput[] | UserUncheckedCreateWithoutAssignedWhatsappAdsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedWhatsappAdsInput | UserCreateOrConnectWithoutAssignedWhatsappAdsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EnumAdTargetTypeFieldUpdateOperationsInput = {
    set?: $Enums.AdTargetType
  }

  export type EnumAdStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdStatus
  }

  export type BranchUpdateOneRequiredWithoutWhatsappAdsNestedInput = {
    create?: XOR<BranchCreateWithoutWhatsappAdsInput, BranchUncheckedCreateWithoutWhatsappAdsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutWhatsappAdsInput
    upsert?: BranchUpsertWithoutWhatsappAdsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutWhatsappAdsInput, BranchUpdateWithoutWhatsappAdsInput>, BranchUncheckedUpdateWithoutWhatsappAdsInput>
  }

  export type ServiceUpdateOneWithoutWhatsappAdsNestedInput = {
    create?: XOR<ServiceCreateWithoutWhatsappAdsInput, ServiceUncheckedCreateWithoutWhatsappAdsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutWhatsappAdsInput
    upsert?: ServiceUpsertWithoutWhatsappAdsInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutWhatsappAdsInput, ServiceUpdateWithoutWhatsappAdsInput>, ServiceUncheckedUpdateWithoutWhatsappAdsInput>
  }

  export type UserUpdateManyWithoutAssignedWhatsappAdsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedWhatsappAdsInput, UserUncheckedCreateWithoutAssignedWhatsappAdsInput> | UserCreateWithoutAssignedWhatsappAdsInput[] | UserUncheckedCreateWithoutAssignedWhatsappAdsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedWhatsappAdsInput | UserCreateOrConnectWithoutAssignedWhatsappAdsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAssignedWhatsappAdsInput | UserUpsertWithWhereUniqueWithoutAssignedWhatsappAdsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAssignedWhatsappAdsInput | UserUpdateWithWhereUniqueWithoutAssignedWhatsappAdsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAssignedWhatsappAdsInput | UserUpdateManyWithWhereWithoutAssignedWhatsappAdsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAssignedWhatsappAdsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedWhatsappAdsInput, UserUncheckedCreateWithoutAssignedWhatsappAdsInput> | UserCreateWithoutAssignedWhatsappAdsInput[] | UserUncheckedCreateWithoutAssignedWhatsappAdsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedWhatsappAdsInput | UserCreateOrConnectWithoutAssignedWhatsappAdsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAssignedWhatsappAdsInput | UserUpsertWithWhereUniqueWithoutAssignedWhatsappAdsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAssignedWhatsappAdsInput | UserUpdateWithWhereUniqueWithoutAssignedWhatsappAdsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAssignedWhatsappAdsInput | UserUpdateManyWithWhereWithoutAssignedWhatsappAdsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BusinessCreateNestedOneWithoutWhatsappNumbersInput = {
    create?: XOR<BusinessCreateWithoutWhatsappNumbersInput, BusinessUncheckedCreateWithoutWhatsappNumbersInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutWhatsappNumbersInput
    connect?: BusinessWhereUniqueInput
  }

  export type FlowCreateNestedOneWithoutWhatsappNumbersInput = {
    create?: XOR<FlowCreateWithoutWhatsappNumbersInput, FlowUncheckedCreateWithoutWhatsappNumbersInput>
    connectOrCreate?: FlowCreateOrConnectWithoutWhatsappNumbersInput
    connect?: FlowWhereUniqueInput
  }

  export type BusinessUpdateOneRequiredWithoutWhatsappNumbersNestedInput = {
    create?: XOR<BusinessCreateWithoutWhatsappNumbersInput, BusinessUncheckedCreateWithoutWhatsappNumbersInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutWhatsappNumbersInput
    upsert?: BusinessUpsertWithoutWhatsappNumbersInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutWhatsappNumbersInput, BusinessUpdateWithoutWhatsappNumbersInput>, BusinessUncheckedUpdateWithoutWhatsappNumbersInput>
  }

  export type FlowUpdateOneWithoutWhatsappNumbersNestedInput = {
    create?: XOR<FlowCreateWithoutWhatsappNumbersInput, FlowUncheckedCreateWithoutWhatsappNumbersInput>
    connectOrCreate?: FlowCreateOrConnectWithoutWhatsappNumbersInput
    upsert?: FlowUpsertWithoutWhatsappNumbersInput
    disconnect?: FlowWhereInput | boolean
    delete?: FlowWhereInput | boolean
    connect?: FlowWhereUniqueInput
    update?: XOR<XOR<FlowUpdateToOneWithWhereWithoutWhatsappNumbersInput, FlowUpdateWithoutWhatsappNumbersInput>, FlowUncheckedUpdateWithoutWhatsappNumbersInput>
  }

  export type BusinessCreateNestedOneWithoutFlowsInput = {
    create?: XOR<BusinessCreateWithoutFlowsInput, BusinessUncheckedCreateWithoutFlowsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutFlowsInput
    connect?: BusinessWhereUniqueInput
  }

  export type StepCreateNestedManyWithoutFlowInput = {
    create?: XOR<StepCreateWithoutFlowInput, StepUncheckedCreateWithoutFlowInput> | StepCreateWithoutFlowInput[] | StepUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: StepCreateOrConnectWithoutFlowInput | StepCreateOrConnectWithoutFlowInput[]
    createMany?: StepCreateManyFlowInputEnvelope
    connect?: StepWhereUniqueInput | StepWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutFlowInput = {
    create?: XOR<SessionCreateWithoutFlowInput, SessionUncheckedCreateWithoutFlowInput> | SessionCreateWithoutFlowInput[] | SessionUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutFlowInput | SessionCreateOrConnectWithoutFlowInput[]
    createMany?: SessionCreateManyFlowInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type WhatsAppNumberCreateNestedManyWithoutDefaultFlowInput = {
    create?: XOR<WhatsAppNumberCreateWithoutDefaultFlowInput, WhatsAppNumberUncheckedCreateWithoutDefaultFlowInput> | WhatsAppNumberCreateWithoutDefaultFlowInput[] | WhatsAppNumberUncheckedCreateWithoutDefaultFlowInput[]
    connectOrCreate?: WhatsAppNumberCreateOrConnectWithoutDefaultFlowInput | WhatsAppNumberCreateOrConnectWithoutDefaultFlowInput[]
    createMany?: WhatsAppNumberCreateManyDefaultFlowInputEnvelope
    connect?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
  }

  export type StepUncheckedCreateNestedManyWithoutFlowInput = {
    create?: XOR<StepCreateWithoutFlowInput, StepUncheckedCreateWithoutFlowInput> | StepCreateWithoutFlowInput[] | StepUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: StepCreateOrConnectWithoutFlowInput | StepCreateOrConnectWithoutFlowInput[]
    createMany?: StepCreateManyFlowInputEnvelope
    connect?: StepWhereUniqueInput | StepWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutFlowInput = {
    create?: XOR<SessionCreateWithoutFlowInput, SessionUncheckedCreateWithoutFlowInput> | SessionCreateWithoutFlowInput[] | SessionUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutFlowInput | SessionCreateOrConnectWithoutFlowInput[]
    createMany?: SessionCreateManyFlowInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type WhatsAppNumberUncheckedCreateNestedManyWithoutDefaultFlowInput = {
    create?: XOR<WhatsAppNumberCreateWithoutDefaultFlowInput, WhatsAppNumberUncheckedCreateWithoutDefaultFlowInput> | WhatsAppNumberCreateWithoutDefaultFlowInput[] | WhatsAppNumberUncheckedCreateWithoutDefaultFlowInput[]
    connectOrCreate?: WhatsAppNumberCreateOrConnectWithoutDefaultFlowInput | WhatsAppNumberCreateOrConnectWithoutDefaultFlowInput[]
    createMany?: WhatsAppNumberCreateManyDefaultFlowInputEnvelope
    connect?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
  }

  export type BusinessUpdateOneWithoutFlowsNestedInput = {
    create?: XOR<BusinessCreateWithoutFlowsInput, BusinessUncheckedCreateWithoutFlowsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutFlowsInput
    upsert?: BusinessUpsertWithoutFlowsInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutFlowsInput, BusinessUpdateWithoutFlowsInput>, BusinessUncheckedUpdateWithoutFlowsInput>
  }

  export type StepUpdateManyWithoutFlowNestedInput = {
    create?: XOR<StepCreateWithoutFlowInput, StepUncheckedCreateWithoutFlowInput> | StepCreateWithoutFlowInput[] | StepUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: StepCreateOrConnectWithoutFlowInput | StepCreateOrConnectWithoutFlowInput[]
    upsert?: StepUpsertWithWhereUniqueWithoutFlowInput | StepUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: StepCreateManyFlowInputEnvelope
    set?: StepWhereUniqueInput | StepWhereUniqueInput[]
    disconnect?: StepWhereUniqueInput | StepWhereUniqueInput[]
    delete?: StepWhereUniqueInput | StepWhereUniqueInput[]
    connect?: StepWhereUniqueInput | StepWhereUniqueInput[]
    update?: StepUpdateWithWhereUniqueWithoutFlowInput | StepUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: StepUpdateManyWithWhereWithoutFlowInput | StepUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: StepScalarWhereInput | StepScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutFlowNestedInput = {
    create?: XOR<SessionCreateWithoutFlowInput, SessionUncheckedCreateWithoutFlowInput> | SessionCreateWithoutFlowInput[] | SessionUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutFlowInput | SessionCreateOrConnectWithoutFlowInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutFlowInput | SessionUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: SessionCreateManyFlowInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutFlowInput | SessionUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutFlowInput | SessionUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type WhatsAppNumberUpdateManyWithoutDefaultFlowNestedInput = {
    create?: XOR<WhatsAppNumberCreateWithoutDefaultFlowInput, WhatsAppNumberUncheckedCreateWithoutDefaultFlowInput> | WhatsAppNumberCreateWithoutDefaultFlowInput[] | WhatsAppNumberUncheckedCreateWithoutDefaultFlowInput[]
    connectOrCreate?: WhatsAppNumberCreateOrConnectWithoutDefaultFlowInput | WhatsAppNumberCreateOrConnectWithoutDefaultFlowInput[]
    upsert?: WhatsAppNumberUpsertWithWhereUniqueWithoutDefaultFlowInput | WhatsAppNumberUpsertWithWhereUniqueWithoutDefaultFlowInput[]
    createMany?: WhatsAppNumberCreateManyDefaultFlowInputEnvelope
    set?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    disconnect?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    delete?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    connect?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    update?: WhatsAppNumberUpdateWithWhereUniqueWithoutDefaultFlowInput | WhatsAppNumberUpdateWithWhereUniqueWithoutDefaultFlowInput[]
    updateMany?: WhatsAppNumberUpdateManyWithWhereWithoutDefaultFlowInput | WhatsAppNumberUpdateManyWithWhereWithoutDefaultFlowInput[]
    deleteMany?: WhatsAppNumberScalarWhereInput | WhatsAppNumberScalarWhereInput[]
  }

  export type StepUncheckedUpdateManyWithoutFlowNestedInput = {
    create?: XOR<StepCreateWithoutFlowInput, StepUncheckedCreateWithoutFlowInput> | StepCreateWithoutFlowInput[] | StepUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: StepCreateOrConnectWithoutFlowInput | StepCreateOrConnectWithoutFlowInput[]
    upsert?: StepUpsertWithWhereUniqueWithoutFlowInput | StepUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: StepCreateManyFlowInputEnvelope
    set?: StepWhereUniqueInput | StepWhereUniqueInput[]
    disconnect?: StepWhereUniqueInput | StepWhereUniqueInput[]
    delete?: StepWhereUniqueInput | StepWhereUniqueInput[]
    connect?: StepWhereUniqueInput | StepWhereUniqueInput[]
    update?: StepUpdateWithWhereUniqueWithoutFlowInput | StepUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: StepUpdateManyWithWhereWithoutFlowInput | StepUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: StepScalarWhereInput | StepScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutFlowNestedInput = {
    create?: XOR<SessionCreateWithoutFlowInput, SessionUncheckedCreateWithoutFlowInput> | SessionCreateWithoutFlowInput[] | SessionUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutFlowInput | SessionCreateOrConnectWithoutFlowInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutFlowInput | SessionUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: SessionCreateManyFlowInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutFlowInput | SessionUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutFlowInput | SessionUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type WhatsAppNumberUncheckedUpdateManyWithoutDefaultFlowNestedInput = {
    create?: XOR<WhatsAppNumberCreateWithoutDefaultFlowInput, WhatsAppNumberUncheckedCreateWithoutDefaultFlowInput> | WhatsAppNumberCreateWithoutDefaultFlowInput[] | WhatsAppNumberUncheckedCreateWithoutDefaultFlowInput[]
    connectOrCreate?: WhatsAppNumberCreateOrConnectWithoutDefaultFlowInput | WhatsAppNumberCreateOrConnectWithoutDefaultFlowInput[]
    upsert?: WhatsAppNumberUpsertWithWhereUniqueWithoutDefaultFlowInput | WhatsAppNumberUpsertWithWhereUniqueWithoutDefaultFlowInput[]
    createMany?: WhatsAppNumberCreateManyDefaultFlowInputEnvelope
    set?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    disconnect?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    delete?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    connect?: WhatsAppNumberWhereUniqueInput | WhatsAppNumberWhereUniqueInput[]
    update?: WhatsAppNumberUpdateWithWhereUniqueWithoutDefaultFlowInput | WhatsAppNumberUpdateWithWhereUniqueWithoutDefaultFlowInput[]
    updateMany?: WhatsAppNumberUpdateManyWithWhereWithoutDefaultFlowInput | WhatsAppNumberUpdateManyWithWhereWithoutDefaultFlowInput[]
    deleteMany?: WhatsAppNumberScalarWhereInput | WhatsAppNumberScalarWhereInput[]
  }

  export type FlowCreateNestedOneWithoutStepsInput = {
    create?: XOR<FlowCreateWithoutStepsInput, FlowUncheckedCreateWithoutStepsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutStepsInput
    connect?: FlowWhereUniqueInput
  }

  export type StepOptionCreateNestedManyWithoutStepInput = {
    create?: XOR<StepOptionCreateWithoutStepInput, StepOptionUncheckedCreateWithoutStepInput> | StepOptionCreateWithoutStepInput[] | StepOptionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: StepOptionCreateOrConnectWithoutStepInput | StepOptionCreateOrConnectWithoutStepInput[]
    createMany?: StepOptionCreateManyStepInputEnvelope
    connect?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutCurrentStepInput = {
    create?: XOR<SessionCreateWithoutCurrentStepInput, SessionUncheckedCreateWithoutCurrentStepInput> | SessionCreateWithoutCurrentStepInput[] | SessionUncheckedCreateWithoutCurrentStepInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCurrentStepInput | SessionCreateOrConnectWithoutCurrentStepInput[]
    createMany?: SessionCreateManyCurrentStepInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutStepInput = {
    create?: XOR<LogCreateWithoutStepInput, LogUncheckedCreateWithoutStepInput> | LogCreateWithoutStepInput[] | LogUncheckedCreateWithoutStepInput[]
    connectOrCreate?: LogCreateOrConnectWithoutStepInput | LogCreateOrConnectWithoutStepInput[]
    createMany?: LogCreateManyStepInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type StepOptionCreateNestedManyWithoutNextStepInput = {
    create?: XOR<StepOptionCreateWithoutNextStepInput, StepOptionUncheckedCreateWithoutNextStepInput> | StepOptionCreateWithoutNextStepInput[] | StepOptionUncheckedCreateWithoutNextStepInput[]
    connectOrCreate?: StepOptionCreateOrConnectWithoutNextStepInput | StepOptionCreateOrConnectWithoutNextStepInput[]
    createMany?: StepOptionCreateManyNextStepInputEnvelope
    connect?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
  }

  export type StepOptionUncheckedCreateNestedManyWithoutStepInput = {
    create?: XOR<StepOptionCreateWithoutStepInput, StepOptionUncheckedCreateWithoutStepInput> | StepOptionCreateWithoutStepInput[] | StepOptionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: StepOptionCreateOrConnectWithoutStepInput | StepOptionCreateOrConnectWithoutStepInput[]
    createMany?: StepOptionCreateManyStepInputEnvelope
    connect?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutCurrentStepInput = {
    create?: XOR<SessionCreateWithoutCurrentStepInput, SessionUncheckedCreateWithoutCurrentStepInput> | SessionCreateWithoutCurrentStepInput[] | SessionUncheckedCreateWithoutCurrentStepInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCurrentStepInput | SessionCreateOrConnectWithoutCurrentStepInput[]
    createMany?: SessionCreateManyCurrentStepInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutStepInput = {
    create?: XOR<LogCreateWithoutStepInput, LogUncheckedCreateWithoutStepInput> | LogCreateWithoutStepInput[] | LogUncheckedCreateWithoutStepInput[]
    connectOrCreate?: LogCreateOrConnectWithoutStepInput | LogCreateOrConnectWithoutStepInput[]
    createMany?: LogCreateManyStepInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type StepOptionUncheckedCreateNestedManyWithoutNextStepInput = {
    create?: XOR<StepOptionCreateWithoutNextStepInput, StepOptionUncheckedCreateWithoutNextStepInput> | StepOptionCreateWithoutNextStepInput[] | StepOptionUncheckedCreateWithoutNextStepInput[]
    connectOrCreate?: StepOptionCreateOrConnectWithoutNextStepInput | StepOptionCreateOrConnectWithoutNextStepInput[]
    createMany?: StepOptionCreateManyNextStepInputEnvelope
    connect?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
  }

  export type EnumStepTypeFieldUpdateOperationsInput = {
    set?: $Enums.StepType
  }

  export type EnumDynamicSourceFieldUpdateOperationsInput = {
    set?: $Enums.DynamicSource
  }

  export type FlowUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<FlowCreateWithoutStepsInput, FlowUncheckedCreateWithoutStepsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutStepsInput
    upsert?: FlowUpsertWithoutStepsInput
    connect?: FlowWhereUniqueInput
    update?: XOR<XOR<FlowUpdateToOneWithWhereWithoutStepsInput, FlowUpdateWithoutStepsInput>, FlowUncheckedUpdateWithoutStepsInput>
  }

  export type StepOptionUpdateManyWithoutStepNestedInput = {
    create?: XOR<StepOptionCreateWithoutStepInput, StepOptionUncheckedCreateWithoutStepInput> | StepOptionCreateWithoutStepInput[] | StepOptionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: StepOptionCreateOrConnectWithoutStepInput | StepOptionCreateOrConnectWithoutStepInput[]
    upsert?: StepOptionUpsertWithWhereUniqueWithoutStepInput | StepOptionUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: StepOptionCreateManyStepInputEnvelope
    set?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    disconnect?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    delete?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    connect?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    update?: StepOptionUpdateWithWhereUniqueWithoutStepInput | StepOptionUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: StepOptionUpdateManyWithWhereWithoutStepInput | StepOptionUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: StepOptionScalarWhereInput | StepOptionScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutCurrentStepNestedInput = {
    create?: XOR<SessionCreateWithoutCurrentStepInput, SessionUncheckedCreateWithoutCurrentStepInput> | SessionCreateWithoutCurrentStepInput[] | SessionUncheckedCreateWithoutCurrentStepInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCurrentStepInput | SessionCreateOrConnectWithoutCurrentStepInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutCurrentStepInput | SessionUpsertWithWhereUniqueWithoutCurrentStepInput[]
    createMany?: SessionCreateManyCurrentStepInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutCurrentStepInput | SessionUpdateWithWhereUniqueWithoutCurrentStepInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutCurrentStepInput | SessionUpdateManyWithWhereWithoutCurrentStepInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type LogUpdateManyWithoutStepNestedInput = {
    create?: XOR<LogCreateWithoutStepInput, LogUncheckedCreateWithoutStepInput> | LogCreateWithoutStepInput[] | LogUncheckedCreateWithoutStepInput[]
    connectOrCreate?: LogCreateOrConnectWithoutStepInput | LogCreateOrConnectWithoutStepInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutStepInput | LogUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: LogCreateManyStepInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutStepInput | LogUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: LogUpdateManyWithWhereWithoutStepInput | LogUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type StepOptionUpdateManyWithoutNextStepNestedInput = {
    create?: XOR<StepOptionCreateWithoutNextStepInput, StepOptionUncheckedCreateWithoutNextStepInput> | StepOptionCreateWithoutNextStepInput[] | StepOptionUncheckedCreateWithoutNextStepInput[]
    connectOrCreate?: StepOptionCreateOrConnectWithoutNextStepInput | StepOptionCreateOrConnectWithoutNextStepInput[]
    upsert?: StepOptionUpsertWithWhereUniqueWithoutNextStepInput | StepOptionUpsertWithWhereUniqueWithoutNextStepInput[]
    createMany?: StepOptionCreateManyNextStepInputEnvelope
    set?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    disconnect?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    delete?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    connect?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    update?: StepOptionUpdateWithWhereUniqueWithoutNextStepInput | StepOptionUpdateWithWhereUniqueWithoutNextStepInput[]
    updateMany?: StepOptionUpdateManyWithWhereWithoutNextStepInput | StepOptionUpdateManyWithWhereWithoutNextStepInput[]
    deleteMany?: StepOptionScalarWhereInput | StepOptionScalarWhereInput[]
  }

  export type StepOptionUncheckedUpdateManyWithoutStepNestedInput = {
    create?: XOR<StepOptionCreateWithoutStepInput, StepOptionUncheckedCreateWithoutStepInput> | StepOptionCreateWithoutStepInput[] | StepOptionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: StepOptionCreateOrConnectWithoutStepInput | StepOptionCreateOrConnectWithoutStepInput[]
    upsert?: StepOptionUpsertWithWhereUniqueWithoutStepInput | StepOptionUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: StepOptionCreateManyStepInputEnvelope
    set?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    disconnect?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    delete?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    connect?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    update?: StepOptionUpdateWithWhereUniqueWithoutStepInput | StepOptionUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: StepOptionUpdateManyWithWhereWithoutStepInput | StepOptionUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: StepOptionScalarWhereInput | StepOptionScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutCurrentStepNestedInput = {
    create?: XOR<SessionCreateWithoutCurrentStepInput, SessionUncheckedCreateWithoutCurrentStepInput> | SessionCreateWithoutCurrentStepInput[] | SessionUncheckedCreateWithoutCurrentStepInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCurrentStepInput | SessionCreateOrConnectWithoutCurrentStepInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutCurrentStepInput | SessionUpsertWithWhereUniqueWithoutCurrentStepInput[]
    createMany?: SessionCreateManyCurrentStepInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutCurrentStepInput | SessionUpdateWithWhereUniqueWithoutCurrentStepInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutCurrentStepInput | SessionUpdateManyWithWhereWithoutCurrentStepInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutStepNestedInput = {
    create?: XOR<LogCreateWithoutStepInput, LogUncheckedCreateWithoutStepInput> | LogCreateWithoutStepInput[] | LogUncheckedCreateWithoutStepInput[]
    connectOrCreate?: LogCreateOrConnectWithoutStepInput | LogCreateOrConnectWithoutStepInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutStepInput | LogUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: LogCreateManyStepInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutStepInput | LogUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: LogUpdateManyWithWhereWithoutStepInput | LogUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type StepOptionUncheckedUpdateManyWithoutNextStepNestedInput = {
    create?: XOR<StepOptionCreateWithoutNextStepInput, StepOptionUncheckedCreateWithoutNextStepInput> | StepOptionCreateWithoutNextStepInput[] | StepOptionUncheckedCreateWithoutNextStepInput[]
    connectOrCreate?: StepOptionCreateOrConnectWithoutNextStepInput | StepOptionCreateOrConnectWithoutNextStepInput[]
    upsert?: StepOptionUpsertWithWhereUniqueWithoutNextStepInput | StepOptionUpsertWithWhereUniqueWithoutNextStepInput[]
    createMany?: StepOptionCreateManyNextStepInputEnvelope
    set?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    disconnect?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    delete?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    connect?: StepOptionWhereUniqueInput | StepOptionWhereUniqueInput[]
    update?: StepOptionUpdateWithWhereUniqueWithoutNextStepInput | StepOptionUpdateWithWhereUniqueWithoutNextStepInput[]
    updateMany?: StepOptionUpdateManyWithWhereWithoutNextStepInput | StepOptionUpdateManyWithWhereWithoutNextStepInput[]
    deleteMany?: StepOptionScalarWhereInput | StepOptionScalarWhereInput[]
  }

  export type StepCreateNestedOneWithoutOptionsInput = {
    create?: XOR<StepCreateWithoutOptionsInput, StepUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: StepCreateOrConnectWithoutOptionsInput
    connect?: StepWhereUniqueInput
  }

  export type StepCreateNestedOneWithoutNextStepOptionsInput = {
    create?: XOR<StepCreateWithoutNextStepOptionsInput, StepUncheckedCreateWithoutNextStepOptionsInput>
    connectOrCreate?: StepCreateOrConnectWithoutNextStepOptionsInput
    connect?: StepWhereUniqueInput
  }

  export type StepUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<StepCreateWithoutOptionsInput, StepUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: StepCreateOrConnectWithoutOptionsInput
    upsert?: StepUpsertWithoutOptionsInput
    connect?: StepWhereUniqueInput
    update?: XOR<XOR<StepUpdateToOneWithWhereWithoutOptionsInput, StepUpdateWithoutOptionsInput>, StepUncheckedUpdateWithoutOptionsInput>
  }

  export type StepUpdateOneWithoutNextStepOptionsNestedInput = {
    create?: XOR<StepCreateWithoutNextStepOptionsInput, StepUncheckedCreateWithoutNextStepOptionsInput>
    connectOrCreate?: StepCreateOrConnectWithoutNextStepOptionsInput
    upsert?: StepUpsertWithoutNextStepOptionsInput
    disconnect?: StepWhereInput | boolean
    delete?: StepWhereInput | boolean
    connect?: StepWhereUniqueInput
    update?: XOR<XOR<StepUpdateToOneWithWhereWithoutNextStepOptionsInput, StepUpdateWithoutNextStepOptionsInput>, StepUncheckedUpdateWithoutNextStepOptionsInput>
  }

  export type FlowCreateNestedOneWithoutSessionsInput = {
    create?: XOR<FlowCreateWithoutSessionsInput, FlowUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutSessionsInput
    connect?: FlowWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type StepCreateNestedOneWithoutSessionsInput = {
    create?: XOR<StepCreateWithoutSessionsInput, StepUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: StepCreateOrConnectWithoutSessionsInput
    connect?: StepWhereUniqueInput
  }

  export type LogCreateNestedManyWithoutSessionInput = {
    create?: XOR<LogCreateWithoutSessionInput, LogUncheckedCreateWithoutSessionInput> | LogCreateWithoutSessionInput[] | LogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: LogCreateOrConnectWithoutSessionInput | LogCreateOrConnectWithoutSessionInput[]
    createMany?: LogCreateManySessionInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<LogCreateWithoutSessionInput, LogUncheckedCreateWithoutSessionInput> | LogCreateWithoutSessionInput[] | LogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: LogCreateOrConnectWithoutSessionInput | LogCreateOrConnectWithoutSessionInput[]
    createMany?: LogCreateManySessionInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type FlowUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<FlowCreateWithoutSessionsInput, FlowUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: FlowCreateOrConnectWithoutSessionsInput
    upsert?: FlowUpsertWithoutSessionsInput
    connect?: FlowWhereUniqueInput
    update?: XOR<XOR<FlowUpdateToOneWithWhereWithoutSessionsInput, FlowUpdateWithoutSessionsInput>, FlowUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type StepUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<StepCreateWithoutSessionsInput, StepUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: StepCreateOrConnectWithoutSessionsInput
    upsert?: StepUpsertWithoutSessionsInput
    disconnect?: StepWhereInput | boolean
    delete?: StepWhereInput | boolean
    connect?: StepWhereUniqueInput
    update?: XOR<XOR<StepUpdateToOneWithWhereWithoutSessionsInput, StepUpdateWithoutSessionsInput>, StepUncheckedUpdateWithoutSessionsInput>
  }

  export type LogUpdateManyWithoutSessionNestedInput = {
    create?: XOR<LogCreateWithoutSessionInput, LogUncheckedCreateWithoutSessionInput> | LogCreateWithoutSessionInput[] | LogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: LogCreateOrConnectWithoutSessionInput | LogCreateOrConnectWithoutSessionInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutSessionInput | LogUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: LogCreateManySessionInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutSessionInput | LogUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: LogUpdateManyWithWhereWithoutSessionInput | LogUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<LogCreateWithoutSessionInput, LogUncheckedCreateWithoutSessionInput> | LogCreateWithoutSessionInput[] | LogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: LogCreateOrConnectWithoutSessionInput | LogCreateOrConnectWithoutSessionInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutSessionInput | LogUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: LogCreateManySessionInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutSessionInput | LogUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: LogUpdateManyWithWhereWithoutSessionInput | LogUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type SessionCreateNestedOneWithoutLogsInput = {
    create?: XOR<SessionCreateWithoutLogsInput, SessionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutLogsInput
    connect?: SessionWhereUniqueInput
  }

  export type StepCreateNestedOneWithoutLogsInput = {
    create?: XOR<StepCreateWithoutLogsInput, StepUncheckedCreateWithoutLogsInput>
    connectOrCreate?: StepCreateOrConnectWithoutLogsInput
    connect?: StepWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<SessionCreateWithoutLogsInput, SessionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutLogsInput
    upsert?: SessionUpsertWithoutLogsInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutLogsInput, SessionUpdateWithoutLogsInput>, SessionUncheckedUpdateWithoutLogsInput>
  }

  export type StepUpdateOneWithoutLogsNestedInput = {
    create?: XOR<StepCreateWithoutLogsInput, StepUncheckedCreateWithoutLogsInput>
    connectOrCreate?: StepCreateOrConnectWithoutLogsInput
    upsert?: StepUpsertWithoutLogsInput
    disconnect?: StepWhereInput | boolean
    delete?: StepWhereInput | boolean
    connect?: StepWhereUniqueInput
    update?: XOR<XOR<StepUpdateToOneWithWhereWithoutLogsInput, StepUpdateWithoutLogsInput>, StepUncheckedUpdateWithoutLogsInput>
  }

  export type EnumContactStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContactStatus
  }

  export type EnumDemoStatusFieldUpdateOperationsInput = {
    set?: $Enums.DemoStatus
  }

  export type EnumAlertActionFieldUpdateOperationsInput = {
    set?: $Enums.AlertAction
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserRoleNullableFilter<$PrismaModel> | $Enums.UserRole | null
  }

  export type NestedEnumUserRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserRole | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumUserRoleNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeFilter<$PrismaModel> | $Enums.SubscriptionType
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionValidityFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionValidity | EnumSubscriptionValidityFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionValidityFilter<$PrismaModel> | $Enums.SubscriptionValidity
  }

  export type NestedEnumSubscriptionValidityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionValidity | EnumSubscriptionValidityFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionValidityWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionValidity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionValidityFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionValidityFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumDiscountGroupFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountGroup | EnumDiscountGroupFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountGroup[] | ListEnumDiscountGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountGroup[] | ListEnumDiscountGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountGroupFilter<$PrismaModel> | $Enums.DiscountGroup
  }

  export type NestedEnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type NestedEnumDiscountGroupWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountGroup | EnumDiscountGroupFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountGroup[] | ListEnumDiscountGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountGroup[] | ListEnumDiscountGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountGroupWithAggregatesFilter<$PrismaModel> | $Enums.DiscountGroup
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountGroupFilter<$PrismaModel>
    _max?: NestedEnumDiscountGroupFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBusinessTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessType | EnumBusinessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessTypeFilter<$PrismaModel> | $Enums.BusinessType
  }

  export type NestedEnumSubscriptionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionTypeNullableFilter<$PrismaModel> | $Enums.SubscriptionType | null
  }

  export type NestedEnumSubscriptionValidityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionValidity | EnumSubscriptionValidityFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionValidityNullableFilter<$PrismaModel> | $Enums.SubscriptionValidity | null
  }

  export type NestedEnumBusinessStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessStatus | EnumBusinessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessStatusFilter<$PrismaModel> | $Enums.BusinessStatus
  }

  export type NestedEnumBusinessTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessType | EnumBusinessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessTypeWithAggregatesFilter<$PrismaModel> | $Enums.BusinessType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBusinessTypeFilter<$PrismaModel>
    _max?: NestedEnumBusinessTypeFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTypeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionValidityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionValidity | EnumSubscriptionValidityFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionValidity[] | ListEnumSubscriptionValidityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionValidityNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionValidity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionValidityNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionValidityNullableFilter<$PrismaModel>
  }

  export type NestedEnumBusinessStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessStatus | EnumBusinessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessStatusWithAggregatesFilter<$PrismaModel> | $Enums.BusinessStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBusinessStatusFilter<$PrismaModel>
    _max?: NestedEnumBusinessStatusFilter<$PrismaModel>
  }

  export type NestedEnumScheduleOwnerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleOwnerType | EnumScheduleOwnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleOwnerType[] | ListEnumScheduleOwnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleOwnerType[] | ListEnumScheduleOwnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleOwnerTypeFilter<$PrismaModel> | $Enums.ScheduleOwnerType
  }

  export type NestedEnumWeekDayFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDay | EnumWeekDayFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel>
    not?: NestedEnumWeekDayFilter<$PrismaModel> | $Enums.WeekDay
  }

  export type NestedEnumScheduleInheritanceModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleInheritanceMode | EnumScheduleInheritanceModeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleInheritanceMode[] | ListEnumScheduleInheritanceModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleInheritanceMode[] | ListEnumScheduleInheritanceModeFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleInheritanceModeFilter<$PrismaModel> | $Enums.ScheduleInheritanceMode
  }

  export type NestedEnumScheduleOwnerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleOwnerType | EnumScheduleOwnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleOwnerType[] | ListEnumScheduleOwnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleOwnerType[] | ListEnumScheduleOwnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleOwnerTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleOwnerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleOwnerTypeFilter<$PrismaModel>
    _max?: NestedEnumScheduleOwnerTypeFilter<$PrismaModel>
  }

  export type NestedEnumWeekDayWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDay | EnumWeekDayFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeekDay[] | ListEnumWeekDayFieldRefInput<$PrismaModel>
    not?: NestedEnumWeekDayWithAggregatesFilter<$PrismaModel> | $Enums.WeekDay
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeekDayFilter<$PrismaModel>
    _max?: NestedEnumWeekDayFilter<$PrismaModel>
  }

  export type NestedEnumScheduleInheritanceModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleInheritanceMode | EnumScheduleInheritanceModeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleInheritanceMode[] | ListEnumScheduleInheritanceModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleInheritanceMode[] | ListEnumScheduleInheritanceModeFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleInheritanceModeWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleInheritanceMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleInheritanceModeFilter<$PrismaModel>
    _max?: NestedEnumScheduleInheritanceModeFilter<$PrismaModel>
  }

  export type NestedEnumStaffStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffStatus | EnumStaffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StaffStatus[] | ListEnumStaffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffStatus[] | ListEnumStaffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffStatusFilter<$PrismaModel> | $Enums.StaffStatus
  }

  export type NestedEnumStaffStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffStatus | EnumStaffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StaffStatus[] | ListEnumStaffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffStatus[] | ListEnumStaffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffStatusWithAggregatesFilter<$PrismaModel> | $Enums.StaffStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStaffStatusFilter<$PrismaModel>
    _max?: NestedEnumStaffStatusFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumVacationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VacationStatus | EnumVacationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VacationStatus[] | ListEnumVacationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VacationStatus[] | ListEnumVacationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVacationStatusFilter<$PrismaModel> | $Enums.VacationStatus
  }

  export type NestedEnumVacationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VacationStatus | EnumVacationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VacationStatus[] | ListEnumVacationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VacationStatus[] | ListEnumVacationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVacationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VacationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVacationStatusFilter<$PrismaModel>
    _max?: NestedEnumVacationStatusFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedEnumAppointmentBookingTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentBookingType | EnumAppointmentBookingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AppointmentBookingType[] | ListEnumAppointmentBookingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AppointmentBookingType[] | ListEnumAppointmentBookingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAppointmentBookingTypeNullableFilter<$PrismaModel> | $Enums.AppointmentBookingType | null
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentBookingTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentBookingType | EnumAppointmentBookingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AppointmentBookingType[] | ListEnumAppointmentBookingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AppointmentBookingType[] | ListEnumAppointmentBookingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAppointmentBookingTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentBookingType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAppointmentBookingTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumAppointmentBookingTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAdTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdTargetType | EnumAdTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdTargetType[] | ListEnumAdTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdTargetType[] | ListEnumAdTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdTargetTypeFilter<$PrismaModel> | $Enums.AdTargetType
  }

  export type NestedEnumAdStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdStatus | EnumAdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdStatusFilter<$PrismaModel> | $Enums.AdStatus
  }

  export type NestedEnumAdTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdTargetType | EnumAdTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdTargetType[] | ListEnumAdTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdTargetType[] | ListEnumAdTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdTargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumAdTargetTypeFilter<$PrismaModel>
  }

  export type NestedEnumAdStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdStatus | EnumAdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdStatusFilter<$PrismaModel>
    _max?: NestedEnumAdStatusFilter<$PrismaModel>
  }

  export type NestedEnumStepTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StepType | EnumStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStepTypeFilter<$PrismaModel> | $Enums.StepType
  }

  export type NestedEnumDynamicSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.DynamicSource | EnumDynamicSourceFieldRefInput<$PrismaModel>
    in?: $Enums.DynamicSource[] | ListEnumDynamicSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.DynamicSource[] | ListEnumDynamicSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumDynamicSourceFilter<$PrismaModel> | $Enums.DynamicSource
  }

  export type NestedEnumStepTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StepType | EnumStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStepTypeWithAggregatesFilter<$PrismaModel> | $Enums.StepType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStepTypeFilter<$PrismaModel>
    _max?: NestedEnumStepTypeFilter<$PrismaModel>
  }

  export type NestedEnumDynamicSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DynamicSource | EnumDynamicSourceFieldRefInput<$PrismaModel>
    in?: $Enums.DynamicSource[] | ListEnumDynamicSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.DynamicSource[] | ListEnumDynamicSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumDynamicSourceWithAggregatesFilter<$PrismaModel> | $Enums.DynamicSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDynamicSourceFilter<$PrismaModel>
    _max?: NestedEnumDynamicSourceFilter<$PrismaModel>
  }

  export type NestedEnumContactStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusFilter<$PrismaModel> | $Enums.ContactStatus
  }

  export type NestedEnumContactStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContactStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactStatusFilter<$PrismaModel>
    _max?: NestedEnumContactStatusFilter<$PrismaModel>
  }

  export type NestedEnumDemoStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DemoStatus | EnumDemoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DemoStatus[] | ListEnumDemoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DemoStatus[] | ListEnumDemoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDemoStatusFilter<$PrismaModel> | $Enums.DemoStatus
  }

  export type NestedEnumDemoStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DemoStatus | EnumDemoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DemoStatus[] | ListEnumDemoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DemoStatus[] | ListEnumDemoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDemoStatusWithAggregatesFilter<$PrismaModel> | $Enums.DemoStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDemoStatusFilter<$PrismaModel>
    _max?: NestedEnumDemoStatusFilter<$PrismaModel>
  }

  export type NestedEnumAlertActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertAction | EnumAlertActionFieldRefInput<$PrismaModel>
    in?: $Enums.AlertAction[] | ListEnumAlertActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertAction[] | ListEnumAlertActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertActionFilter<$PrismaModel> | $Enums.AlertAction
  }

  export type NestedEnumAlertActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertAction | EnumAlertActionFieldRefInput<$PrismaModel>
    in?: $Enums.AlertAction[] | ListEnumAlertActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertAction[] | ListEnumAlertActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertActionWithAggregatesFilter<$PrismaModel> | $Enums.AlertAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertActionFilter<$PrismaModel>
    _max?: NestedEnumAlertActionFilter<$PrismaModel>
  }

  export type UserCreateWithoutSubscriberMembersInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriberMembersInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriberMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriberMembersInput, UserUncheckedCreateWithoutSubscriberMembersInput>
  }

  export type UserCreateWithoutSubscriberInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriberInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriberInput, UserUncheckedCreateWithoutSubscriberInput>
  }

  export type UserCreateManySubscriberInputEnvelope = {
    data: UserCreateManySubscriberInput | UserCreateManySubscriberInput[]
    skipDuplicates?: boolean
  }

  export type BranchCreateWithoutUsersInput = {
    id?: string
    name: string
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber: UserCreateNestedOneWithoutOwnedBranchesInput
    business?: BusinessCreateNestedOneWithoutBranchesInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    promotions?: PromotionCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    subscriberId: string
    businessId?: string | null
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountUncheckedCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUsersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
  }

  export type UserOnServiceCreateWithoutProviderInput = {
    id?: string
    service: ServiceCreateNestedOneWithoutProvidersInput
  }

  export type UserOnServiceUncheckedCreateWithoutProviderInput = {
    id?: string
    serviceId: string
  }

  export type UserOnServiceCreateOrConnectWithoutProviderInput = {
    where: UserOnServiceWhereUniqueInput
    create: XOR<UserOnServiceCreateWithoutProviderInput, UserOnServiceUncheckedCreateWithoutProviderInput>
  }

  export type UserOnServiceCreateManyProviderInputEnvelope = {
    data: UserOnServiceCreateManyProviderInput | UserOnServiceCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutConsumerInput = {
    id?: string
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    promotion?: PromotionCreateNestedOneWithoutAppointmentsInput
    subscriberSubscription?: SubscriberSubscriptionCreateNestedOneWithoutAppointmentsInput
    discount?: DiscountCreateNestedOneWithoutAppointmentsInput
    service: ServiceCreateNestedOneWithoutAppointmentsInput
    serviceProvider?: UserCreateNestedOneWithoutAppointmentsAsProviderInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutConsumerInput = {
    id?: string
    serviceId: string
    branchId: string
    serviceProviderId?: string | null
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    discountId?: string | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    subscriberSubscriptionId?: string | null
    promotionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AppointmentCreateOrConnectWithoutConsumerInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutConsumerInput, AppointmentUncheckedCreateWithoutConsumerInput>
  }

  export type AppointmentCreateManyConsumerInputEnvelope = {
    data: AppointmentCreateManyConsumerInput | AppointmentCreateManyConsumerInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutServiceProviderInput = {
    id?: string
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    promotion?: PromotionCreateNestedOneWithoutAppointmentsInput
    subscriberSubscription?: SubscriberSubscriptionCreateNestedOneWithoutAppointmentsInput
    discount?: DiscountCreateNestedOneWithoutAppointmentsInput
    service: ServiceCreateNestedOneWithoutAppointmentsInput
    consumer: UserCreateNestedOneWithoutAppointmentsAsConsumerInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    serviceId: string
    consumerId: string
    branchId: string
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    discountId?: string | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    subscriberSubscriptionId?: string | null
    promotionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AppointmentCreateOrConnectWithoutServiceProviderInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput>
  }

  export type AppointmentCreateManyServiceProviderInputEnvelope = {
    data: AppointmentCreateManyServiceProviderInput | AppointmentCreateManyServiceProviderInput[]
    skipDuplicates?: boolean
  }

  export type BusinessCreateWithoutSubscriberInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowCreateNestedManyWithoutBusinessInput
    whatsappNumbers?: WhatsAppNumberCreateNestedManyWithoutBusinessInput
    discountCode?: DiscountCreateNestedOneWithoutBusinessesInput
    branches?: BranchCreateNestedManyWithoutBusinessInput
    subscription?: SubscriptionCreateNestedOneWithoutBusinessesInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutSubscriberInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    discountCodeId?: string | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowUncheckedCreateNestedManyWithoutBusinessInput
    whatsappNumbers?: WhatsAppNumberUncheckedCreateNestedManyWithoutBusinessInput
    branches?: BranchUncheckedCreateNestedManyWithoutBusinessInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutSubscriberInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutSubscriberInput, BusinessUncheckedCreateWithoutSubscriberInput>
  }

  export type BusinessCreateManySubscriberInputEnvelope = {
    data: BusinessCreateManySubscriberInput | BusinessCreateManySubscriberInput[]
    skipDuplicates?: boolean
  }

  export type BranchCreateWithoutSubscriberInput = {
    id?: string
    name: string
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    business?: BusinessCreateNestedOneWithoutBranchesInput
    users?: UserCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    promotions?: PromotionCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutSubscriberInput = {
    id?: string
    name: string
    businessId?: string | null
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountUncheckedCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutSubscriberInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSubscriberInput, BranchUncheckedCreateWithoutSubscriberInput>
  }

  export type BranchCreateManySubscriberInputEnvelope = {
    data: BranchCreateManySubscriberInput | BranchCreateManySubscriberInput[]
    skipDuplicates?: boolean
  }

  export type SubscriberSubscriptionCreateWithoutSubscriberInput = {
    id?: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    business?: BusinessCreateNestedOneWithoutSubscriberSubscriptionsInput
    subscription: SubscriptionCreateNestedOneWithoutSubscriberSubscriptionsInput
    appointments?: AppointmentCreateNestedManyWithoutSubscriberSubscriptionInput
    discountLogs?: SubscriptionDiscountLogCreateNestedManyWithoutSubscriberSubscriptionInput
  }

  export type SubscriberSubscriptionUncheckedCreateWithoutSubscriberInput = {
    id?: string
    subscriptionId: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    businessId?: string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSubscriberSubscriptionInput
    discountLogs?: SubscriptionDiscountLogUncheckedCreateNestedManyWithoutSubscriberSubscriptionInput
  }

  export type SubscriberSubscriptionCreateOrConnectWithoutSubscriberInput = {
    where: SubscriberSubscriptionWhereUniqueInput
    create: XOR<SubscriberSubscriptionCreateWithoutSubscriberInput, SubscriberSubscriptionUncheckedCreateWithoutSubscriberInput>
  }

  export type SubscriberSubscriptionCreateManySubscriberInputEnvelope = {
    data: SubscriberSubscriptionCreateManySubscriberInput | SubscriberSubscriptionCreateManySubscriberInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutSubscriberInput = {
    id?: string
    type: $Enums.SubscriptionType
    description: string
    price: number
    noOfBranches: number
    noOfAdmins: number
    noOfStaffManagers: number
    noOfServiceProviders: number
    noOfReceptionists: number
    whatsappBot: boolean
    manualReminder: boolean
    automatedReminder: boolean
    googleReviewLink: boolean
    promotions: boolean
    selfServiceTablet: boolean
    basicDashboard: boolean
    fullAccessDashboard: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriptionInput
    businesses?: BusinessCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutSubscriberInput = {
    id?: string
    type: $Enums.SubscriptionType
    description: string
    price: number
    noOfBranches: number
    noOfAdmins: number
    noOfStaffManagers: number
    noOfServiceProviders: number
    noOfReceptionists: number
    whatsappBot: boolean
    manualReminder: boolean
    automatedReminder: boolean
    googleReviewLink: boolean
    promotions: boolean
    selfServiceTablet: boolean
    basicDashboard: boolean
    fullAccessDashboard: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriptionInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutSubscriberInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutSubscriberInput, SubscriptionUncheckedCreateWithoutSubscriberInput>
  }

  export type WhatsappAdCreateWithoutAssignedCustomersInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    targetDate: Date | string
    customerType: $Enums.AdTargetType
    status?: $Enums.AdStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    branch: BranchCreateNestedOneWithoutWhatsappAdsInput
    service?: ServiceCreateNestedOneWithoutWhatsappAdsInput
  }

  export type WhatsappAdUncheckedCreateWithoutAssignedCustomersInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    targetDate: Date | string
    customerType: $Enums.AdTargetType
    branchId: string
    serviceId?: string | null
    status?: $Enums.AdStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type WhatsappAdCreateOrConnectWithoutAssignedCustomersInput = {
    where: WhatsappAdWhereUniqueInput
    create: XOR<WhatsappAdCreateWithoutAssignedCustomersInput, WhatsappAdUncheckedCreateWithoutAssignedCustomersInput>
  }

  export type ScheduleHourCreateWithoutStaffInput = {
    id?: string
    ownerType: $Enums.ScheduleOwnerType
    ownerId: string
    dayOfWeek: $Enums.WeekDay
    openTime: string
    closeTime: string
    isClosed?: boolean
    inheritanceMode?: $Enums.ScheduleInheritanceMode
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    business?: BusinessCreateNestedOneWithoutScheduleHoursInput
    branch?: BranchCreateNestedOneWithoutScheduleHoursInput
  }

  export type ScheduleHourUncheckedCreateWithoutStaffInput = {
    id?: string
    ownerType: $Enums.ScheduleOwnerType
    ownerId: string
    dayOfWeek: $Enums.WeekDay
    openTime: string
    closeTime: string
    isClosed?: boolean
    inheritanceMode?: $Enums.ScheduleInheritanceMode
    businessId?: string | null
    branchId?: string | null
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ScheduleHourCreateOrConnectWithoutStaffInput = {
    where: ScheduleHourWhereUniqueInput
    create: XOR<ScheduleHourCreateWithoutStaffInput, ScheduleHourUncheckedCreateWithoutStaffInput>
  }

  export type ScheduleHourCreateManyStaffInputEnvelope = {
    data: ScheduleHourCreateManyStaffInput | ScheduleHourCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    flow: FlowCreateNestedOneWithoutSessionsInput
    currentStep?: StepCreateNestedOneWithoutSessionsInput
    logs?: LogCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    flowId: string
    currentStepId?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    logs?: LogUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutStaffInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AttendanceUncheckedCreateWithoutStaffInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AttendanceCreateOrConnectWithoutStaffInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutStaffInput, AttendanceUncheckedCreateWithoutStaffInput>
  }

  export type AttendanceCreateManyStaffInputEnvelope = {
    data: AttendanceCreateManyStaffInput | AttendanceCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type VacationCreateWithoutStaffInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status: $Enums.VacationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type VacationUncheckedCreateWithoutStaffInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status: $Enums.VacationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type VacationCreateOrConnectWithoutStaffInput = {
    where: VacationWhereUniqueInput
    create: XOR<VacationCreateWithoutStaffInput, VacationUncheckedCreateWithoutStaffInput>
  }

  export type VacationCreateManyStaffInputEnvelope = {
    data: VacationCreateManyStaffInput | VacationCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutManagerInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutManagerInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutManagerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type UserCreateManyManagerInputEnvelope = {
    data: UserCreateManyManagerInput | UserCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutStaffMembersInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStaffMembersInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStaffMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffMembersInput, UserUncheckedCreateWithoutStaffMembersInput>
  }

  export type StaffStatusLogCreateWithoutUserInput = {
    id?: string
    status: $Enums.StaffStatus
    timestamp?: Date | string
  }

  export type StaffStatusLogUncheckedCreateWithoutUserInput = {
    id?: string
    status: $Enums.StaffStatus
    timestamp?: Date | string
  }

  export type StaffStatusLogCreateOrConnectWithoutUserInput = {
    where: StaffStatusLogWhereUniqueInput
    create: XOR<StaffStatusLogCreateWithoutUserInput, StaffStatusLogUncheckedCreateWithoutUserInput>
  }

  export type StaffStatusLogCreateManyUserInputEnvelope = {
    data: StaffStatusLogCreateManyUserInput | StaffStatusLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSubscriberMembersInput = {
    update: XOR<UserUpdateWithoutSubscriberMembersInput, UserUncheckedUpdateWithoutSubscriberMembersInput>
    create: XOR<UserCreateWithoutSubscriberMembersInput, UserUncheckedCreateWithoutSubscriberMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriberMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriberMembersInput, UserUncheckedUpdateWithoutSubscriberMembersInput>
  }

  export type UserUpdateWithoutSubscriberMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriberMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutSubscriberInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSubscriberInput, UserUncheckedUpdateWithoutSubscriberInput>
    create: XOR<UserCreateWithoutSubscriberInput, UserUncheckedCreateWithoutSubscriberInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSubscriberInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSubscriberInput, UserUncheckedUpdateWithoutSubscriberInput>
  }

  export type UserUpdateManyWithWhereWithoutSubscriberInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSubscriberInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    branchId?: StringNullableFilter<"User"> | string | null
    subscriberId?: StringNullableFilter<"User"> | string | null
    imageUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    availability?: JsonNullableFilter<"User">
    usesBranchSchedule?: BoolFilter<"User"> | boolean
    managerId?: StringNullableFilter<"User"> | string | null
    x?: StringNullableFilter<"User"> | string | null
    instagram?: StringNullableFilter<"User"> | string | null
    fb?: StringNullableFilter<"User"> | string | null
    whatsapp?: StringNullableFilter<"User"> | string | null
    language?: StringNullableFilter<"User"> | string | null
    isLoggedIn?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdBy?: StringNullableFilter<"User"> | string | null
    updatedBy?: StringNullableFilter<"User"> | string | null
    isDeleted?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedBy?: StringNullableFilter<"User"> | string | null
  }

  export type BranchUpsertWithoutUsersInput = {
    update: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUsersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type BranchUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneRequiredWithoutOwnedBranchesNestedInput
    business?: BusinessUpdateOneWithoutBranchesNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUncheckedUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUncheckedUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserOnServiceUpsertWithWhereUniqueWithoutProviderInput = {
    where: UserOnServiceWhereUniqueInput
    update: XOR<UserOnServiceUpdateWithoutProviderInput, UserOnServiceUncheckedUpdateWithoutProviderInput>
    create: XOR<UserOnServiceCreateWithoutProviderInput, UserOnServiceUncheckedCreateWithoutProviderInput>
  }

  export type UserOnServiceUpdateWithWhereUniqueWithoutProviderInput = {
    where: UserOnServiceWhereUniqueInput
    data: XOR<UserOnServiceUpdateWithoutProviderInput, UserOnServiceUncheckedUpdateWithoutProviderInput>
  }

  export type UserOnServiceUpdateManyWithWhereWithoutProviderInput = {
    where: UserOnServiceScalarWhereInput
    data: XOR<UserOnServiceUpdateManyMutationInput, UserOnServiceUncheckedUpdateManyWithoutProviderInput>
  }

  export type UserOnServiceScalarWhereInput = {
    AND?: UserOnServiceScalarWhereInput | UserOnServiceScalarWhereInput[]
    OR?: UserOnServiceScalarWhereInput[]
    NOT?: UserOnServiceScalarWhereInput | UserOnServiceScalarWhereInput[]
    id?: StringFilter<"UserOnService"> | string
    serviceId?: StringFilter<"UserOnService"> | string
    providerId?: StringFilter<"UserOnService"> | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutConsumerInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutConsumerInput, AppointmentUncheckedUpdateWithoutConsumerInput>
    create: XOR<AppointmentCreateWithoutConsumerInput, AppointmentUncheckedCreateWithoutConsumerInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutConsumerInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutConsumerInput, AppointmentUncheckedUpdateWithoutConsumerInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutConsumerInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutConsumerInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    serviceId?: StringFilter<"Appointment"> | string
    consumerId?: StringFilter<"Appointment"> | string
    branchId?: StringFilter<"Appointment"> | string
    serviceProviderId?: StringNullableFilter<"Appointment"> | string | null
    appointmentTime?: DateTimeFilter<"Appointment"> | Date | string
    appointmentDate?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    appointmentTimeSlot?: StringNullableFilter<"Appointment"> | string | null
    reminderMinutesBefore?: IntNullableFilter<"Appointment"> | number | null
    discountId?: StringNullableFilter<"Appointment"> | string | null
    note?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    bookingType?: EnumAppointmentBookingTypeNullableFilter<"Appointment"> | $Enums.AppointmentBookingType | null
    review?: StringNullableFilter<"Appointment"> | string | null
    rating?: IntNullableFilter<"Appointment"> | number | null
    isManual?: BoolFilter<"Appointment"> | boolean
    price?: IntNullableFilter<"Appointment"> | number | null
    subscriberSubscriptionId?: StringNullableFilter<"Appointment"> | string | null
    promotionId?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    createdBy?: StringNullableFilter<"Appointment"> | string | null
    updatedBy?: StringNullableFilter<"Appointment"> | string | null
    isDeleted?: BoolFilter<"Appointment"> | boolean
    deletedAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    deletedBy?: StringNullableFilter<"Appointment"> | string | null
  }

  export type AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutServiceProviderInput, AppointmentUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutServiceProviderInput, AppointmentUncheckedUpdateWithoutServiceProviderInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutServiceProviderInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type BusinessUpsertWithWhereUniqueWithoutSubscriberInput = {
    where: BusinessWhereUniqueInput
    update: XOR<BusinessUpdateWithoutSubscriberInput, BusinessUncheckedUpdateWithoutSubscriberInput>
    create: XOR<BusinessCreateWithoutSubscriberInput, BusinessUncheckedCreateWithoutSubscriberInput>
  }

  export type BusinessUpdateWithWhereUniqueWithoutSubscriberInput = {
    where: BusinessWhereUniqueInput
    data: XOR<BusinessUpdateWithoutSubscriberInput, BusinessUncheckedUpdateWithoutSubscriberInput>
  }

  export type BusinessUpdateManyWithWhereWithoutSubscriberInput = {
    where: BusinessScalarWhereInput
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyWithoutSubscriberInput>
  }

  export type BusinessScalarWhereInput = {
    AND?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
    OR?: BusinessScalarWhereInput[]
    NOT?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
    id?: StringFilter<"Business"> | string
    businessId?: IntFilter<"Business"> | number
    name?: StringFilter<"Business"> | string
    image?: StringNullableFilter<"Business"> | string | null
    websiteLink?: StringNullableFilter<"Business"> | string | null
    phoneNumber?: StringNullableFilter<"Business"> | string | null
    businessType?: EnumBusinessTypeFilter<"Business"> | $Enums.BusinessType
    subscriptionId?: StringNullableFilter<"Business"> | string | null
    subscriptionType?: EnumSubscriptionTypeNullableFilter<"Business"> | $Enums.SubscriptionType | null
    subscriptionPrice?: FloatNullableFilter<"Business"> | number | null
    subscriptionValidity?: EnumSubscriptionValidityNullableFilter<"Business"> | $Enums.SubscriptionValidity | null
    discountCodeId?: StringNullableFilter<"Business"> | string | null
    subscriberId?: StringNullableFilter<"Business"> | string | null
    status?: EnumBusinessStatusFilter<"Business"> | $Enums.BusinessStatus
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    createdBy?: StringNullableFilter<"Business"> | string | null
    updatedBy?: StringNullableFilter<"Business"> | string | null
    isDeleted?: BoolFilter<"Business"> | boolean
    deletedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    deletedBy?: StringNullableFilter<"Business"> | string | null
  }

  export type BranchUpsertWithWhereUniqueWithoutSubscriberInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutSubscriberInput, BranchUncheckedUpdateWithoutSubscriberInput>
    create: XOR<BranchCreateWithoutSubscriberInput, BranchUncheckedCreateWithoutSubscriberInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutSubscriberInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutSubscriberInput, BranchUncheckedUpdateWithoutSubscriberInput>
  }

  export type BranchUpdateManyWithWhereWithoutSubscriberInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutSubscriberInput>
  }

  export type BranchScalarWhereInput = {
    AND?: BranchScalarWhereInput | BranchScalarWhereInput[]
    OR?: BranchScalarWhereInput[]
    NOT?: BranchScalarWhereInput | BranchScalarWhereInput[]
    id?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    subscriberId?: StringFilter<"Branch"> | string
    businessId?: StringNullableFilter<"Branch"> | string | null
    location?: StringNullableFilter<"Branch"> | string | null
    phone?: StringNullableFilter<"Branch"> | string | null
    status?: BoolFilter<"Branch"> | boolean
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    createdBy?: StringNullableFilter<"Branch"> | string | null
    updatedBy?: StringNullableFilter<"Branch"> | string | null
    isDeleted?: BoolFilter<"Branch"> | boolean
    deletedAt?: DateTimeNullableFilter<"Branch"> | Date | string | null
    deletedBy?: StringNullableFilter<"Branch"> | string | null
  }

  export type SubscriberSubscriptionUpsertWithWhereUniqueWithoutSubscriberInput = {
    where: SubscriberSubscriptionWhereUniqueInput
    update: XOR<SubscriberSubscriptionUpdateWithoutSubscriberInput, SubscriberSubscriptionUncheckedUpdateWithoutSubscriberInput>
    create: XOR<SubscriberSubscriptionCreateWithoutSubscriberInput, SubscriberSubscriptionUncheckedCreateWithoutSubscriberInput>
  }

  export type SubscriberSubscriptionUpdateWithWhereUniqueWithoutSubscriberInput = {
    where: SubscriberSubscriptionWhereUniqueInput
    data: XOR<SubscriberSubscriptionUpdateWithoutSubscriberInput, SubscriberSubscriptionUncheckedUpdateWithoutSubscriberInput>
  }

  export type SubscriberSubscriptionUpdateManyWithWhereWithoutSubscriberInput = {
    where: SubscriberSubscriptionScalarWhereInput
    data: XOR<SubscriberSubscriptionUpdateManyMutationInput, SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberInput>
  }

  export type SubscriberSubscriptionScalarWhereInput = {
    AND?: SubscriberSubscriptionScalarWhereInput | SubscriberSubscriptionScalarWhereInput[]
    OR?: SubscriberSubscriptionScalarWhereInput[]
    NOT?: SubscriberSubscriptionScalarWhereInput | SubscriberSubscriptionScalarWhereInput[]
    id?: StringFilter<"SubscriberSubscription"> | string
    subscriberId?: StringFilter<"SubscriberSubscription"> | string
    subscriptionId?: StringFilter<"SubscriberSubscription"> | string
    type?: EnumSubscriptionTypeFilter<"SubscriberSubscription"> | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFilter<"SubscriberSubscription"> | $Enums.SubscriptionValidity
    price?: FloatFilter<"SubscriberSubscription"> | number
    features?: JsonFilter<"SubscriberSubscription">
    startDate?: DateTimeFilter<"SubscriberSubscription"> | Date | string
    businessId?: StringNullableFilter<"SubscriberSubscription"> | string | null
    endDate?: DateTimeNullableFilter<"SubscriberSubscription"> | Date | string | null
    isActive?: BoolFilter<"SubscriberSubscription"> | boolean
    createdAt?: DateTimeFilter<"SubscriberSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriberSubscription"> | Date | string
    createdBy?: StringNullableFilter<"SubscriberSubscription"> | string | null
    updatedBy?: StringNullableFilter<"SubscriberSubscription"> | string | null
    isDeleted?: BoolFilter<"SubscriberSubscription"> | boolean
    deletedAt?: DateTimeNullableFilter<"SubscriberSubscription"> | Date | string | null
    deletedBy?: StringNullableFilter<"SubscriberSubscription"> | string | null
  }

  export type SubscriptionUpsertWithoutSubscriberInput = {
    update: XOR<SubscriptionUpdateWithoutSubscriberInput, SubscriptionUncheckedUpdateWithoutSubscriberInput>
    create: XOR<SubscriptionCreateWithoutSubscriberInput, SubscriptionUncheckedCreateWithoutSubscriberInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutSubscriberInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutSubscriberInput, SubscriptionUncheckedUpdateWithoutSubscriberInput>
  }

  export type SubscriptionUpdateWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    noOfBranches?: IntFieldUpdateOperationsInput | number
    noOfAdmins?: IntFieldUpdateOperationsInput | number
    noOfStaffManagers?: IntFieldUpdateOperationsInput | number
    noOfServiceProviders?: IntFieldUpdateOperationsInput | number
    noOfReceptionists?: IntFieldUpdateOperationsInput | number
    whatsappBot?: BoolFieldUpdateOperationsInput | boolean
    manualReminder?: BoolFieldUpdateOperationsInput | boolean
    automatedReminder?: BoolFieldUpdateOperationsInput | boolean
    googleReviewLink?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    selfServiceTablet?: BoolFieldUpdateOperationsInput | boolean
    basicDashboard?: BoolFieldUpdateOperationsInput | boolean
    fullAccessDashboard?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriptionNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    noOfBranches?: IntFieldUpdateOperationsInput | number
    noOfAdmins?: IntFieldUpdateOperationsInput | number
    noOfStaffManagers?: IntFieldUpdateOperationsInput | number
    noOfServiceProviders?: IntFieldUpdateOperationsInput | number
    noOfReceptionists?: IntFieldUpdateOperationsInput | number
    whatsappBot?: BoolFieldUpdateOperationsInput | boolean
    manualReminder?: BoolFieldUpdateOperationsInput | boolean
    automatedReminder?: BoolFieldUpdateOperationsInput | boolean
    googleReviewLink?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    selfServiceTablet?: BoolFieldUpdateOperationsInput | boolean
    basicDashboard?: BoolFieldUpdateOperationsInput | boolean
    fullAccessDashboard?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriptionNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type WhatsappAdUpsertWithWhereUniqueWithoutAssignedCustomersInput = {
    where: WhatsappAdWhereUniqueInput
    update: XOR<WhatsappAdUpdateWithoutAssignedCustomersInput, WhatsappAdUncheckedUpdateWithoutAssignedCustomersInput>
    create: XOR<WhatsappAdCreateWithoutAssignedCustomersInput, WhatsappAdUncheckedCreateWithoutAssignedCustomersInput>
  }

  export type WhatsappAdUpdateWithWhereUniqueWithoutAssignedCustomersInput = {
    where: WhatsappAdWhereUniqueInput
    data: XOR<WhatsappAdUpdateWithoutAssignedCustomersInput, WhatsappAdUncheckedUpdateWithoutAssignedCustomersInput>
  }

  export type WhatsappAdUpdateManyWithWhereWithoutAssignedCustomersInput = {
    where: WhatsappAdScalarWhereInput
    data: XOR<WhatsappAdUpdateManyMutationInput, WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersInput>
  }

  export type WhatsappAdScalarWhereInput = {
    AND?: WhatsappAdScalarWhereInput | WhatsappAdScalarWhereInput[]
    OR?: WhatsappAdScalarWhereInput[]
    NOT?: WhatsappAdScalarWhereInput | WhatsappAdScalarWhereInput[]
    id?: StringFilter<"WhatsappAd"> | string
    name?: StringFilter<"WhatsappAd"> | string
    description?: StringNullableFilter<"WhatsappAd"> | string | null
    imageUrl?: StringNullableFilter<"WhatsappAd"> | string | null
    targetDate?: DateTimeFilter<"WhatsappAd"> | Date | string
    customerType?: EnumAdTargetTypeFilter<"WhatsappAd"> | $Enums.AdTargetType
    branchId?: StringFilter<"WhatsappAd"> | string
    serviceId?: StringNullableFilter<"WhatsappAd"> | string | null
    status?: EnumAdStatusFilter<"WhatsappAd"> | $Enums.AdStatus
    createdAt?: DateTimeFilter<"WhatsappAd"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappAd"> | Date | string
    createdBy?: StringNullableFilter<"WhatsappAd"> | string | null
    updatedBy?: StringNullableFilter<"WhatsappAd"> | string | null
    isDeleted?: BoolFilter<"WhatsappAd"> | boolean
    deletedAt?: DateTimeNullableFilter<"WhatsappAd"> | Date | string | null
    deletedBy?: StringNullableFilter<"WhatsappAd"> | string | null
  }

  export type ScheduleHourUpsertWithWhereUniqueWithoutStaffInput = {
    where: ScheduleHourWhereUniqueInput
    update: XOR<ScheduleHourUpdateWithoutStaffInput, ScheduleHourUncheckedUpdateWithoutStaffInput>
    create: XOR<ScheduleHourCreateWithoutStaffInput, ScheduleHourUncheckedCreateWithoutStaffInput>
  }

  export type ScheduleHourUpdateWithWhereUniqueWithoutStaffInput = {
    where: ScheduleHourWhereUniqueInput
    data: XOR<ScheduleHourUpdateWithoutStaffInput, ScheduleHourUncheckedUpdateWithoutStaffInput>
  }

  export type ScheduleHourUpdateManyWithWhereWithoutStaffInput = {
    where: ScheduleHourScalarWhereInput
    data: XOR<ScheduleHourUpdateManyMutationInput, ScheduleHourUncheckedUpdateManyWithoutStaffInput>
  }

  export type ScheduleHourScalarWhereInput = {
    AND?: ScheduleHourScalarWhereInput | ScheduleHourScalarWhereInput[]
    OR?: ScheduleHourScalarWhereInput[]
    NOT?: ScheduleHourScalarWhereInput | ScheduleHourScalarWhereInput[]
    id?: StringFilter<"ScheduleHour"> | string
    ownerType?: EnumScheduleOwnerTypeFilter<"ScheduleHour"> | $Enums.ScheduleOwnerType
    ownerId?: StringFilter<"ScheduleHour"> | string
    dayOfWeek?: EnumWeekDayFilter<"ScheduleHour"> | $Enums.WeekDay
    openTime?: StringFilter<"ScheduleHour"> | string
    closeTime?: StringFilter<"ScheduleHour"> | string
    isClosed?: BoolFilter<"ScheduleHour"> | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFilter<"ScheduleHour"> | $Enums.ScheduleInheritanceMode
    staffId?: StringNullableFilter<"ScheduleHour"> | string | null
    businessId?: StringNullableFilter<"ScheduleHour"> | string | null
    branchId?: StringNullableFilter<"ScheduleHour"> | string | null
    lastModifiedBy?: StringNullableFilter<"ScheduleHour"> | string | null
    createdAt?: DateTimeFilter<"ScheduleHour"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleHour"> | Date | string
    createdBy?: StringNullableFilter<"ScheduleHour"> | string | null
    updatedBy?: StringNullableFilter<"ScheduleHour"> | string | null
    isDeleted?: BoolFilter<"ScheduleHour"> | boolean
    deletedAt?: DateTimeNullableFilter<"ScheduleHour"> | Date | string | null
    deletedBy?: StringNullableFilter<"ScheduleHour"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    flowId?: StringFilter<"Session"> | string
    currentStepId?: StringNullableFilter<"Session"> | string | null
    isCompleted?: BoolFilter<"Session"> | boolean
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    createdBy?: StringFilter<"Session"> | string
    updatedBy?: StringNullableFilter<"Session"> | string | null
    DeletedBy?: StringNullableFilter<"Session"> | string | null
    DeletedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    isDeleted?: BoolFilter<"Session"> | boolean
  }

  export type AttendanceUpsertWithWhereUniqueWithoutStaffInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutStaffInput, AttendanceUncheckedUpdateWithoutStaffInput>
    create: XOR<AttendanceCreateWithoutStaffInput, AttendanceUncheckedCreateWithoutStaffInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutStaffInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutStaffInput, AttendanceUncheckedUpdateWithoutStaffInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutStaffInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutStaffInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    staffId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    notes?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    createdBy?: StringNullableFilter<"Attendance"> | string | null
    updatedBy?: StringNullableFilter<"Attendance"> | string | null
    isDeleted?: BoolFilter<"Attendance"> | boolean
    deletedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    deletedBy?: StringNullableFilter<"Attendance"> | string | null
  }

  export type VacationUpsertWithWhereUniqueWithoutStaffInput = {
    where: VacationWhereUniqueInput
    update: XOR<VacationUpdateWithoutStaffInput, VacationUncheckedUpdateWithoutStaffInput>
    create: XOR<VacationCreateWithoutStaffInput, VacationUncheckedCreateWithoutStaffInput>
  }

  export type VacationUpdateWithWhereUniqueWithoutStaffInput = {
    where: VacationWhereUniqueInput
    data: XOR<VacationUpdateWithoutStaffInput, VacationUncheckedUpdateWithoutStaffInput>
  }

  export type VacationUpdateManyWithWhereWithoutStaffInput = {
    where: VacationScalarWhereInput
    data: XOR<VacationUpdateManyMutationInput, VacationUncheckedUpdateManyWithoutStaffInput>
  }

  export type VacationScalarWhereInput = {
    AND?: VacationScalarWhereInput | VacationScalarWhereInput[]
    OR?: VacationScalarWhereInput[]
    NOT?: VacationScalarWhereInput | VacationScalarWhereInput[]
    id?: StringFilter<"Vacation"> | string
    staffId?: StringFilter<"Vacation"> | string
    startDate?: DateTimeFilter<"Vacation"> | Date | string
    endDate?: DateTimeFilter<"Vacation"> | Date | string
    reason?: StringNullableFilter<"Vacation"> | string | null
    status?: EnumVacationStatusFilter<"Vacation"> | $Enums.VacationStatus
    createdAt?: DateTimeFilter<"Vacation"> | Date | string
    updatedAt?: DateTimeFilter<"Vacation"> | Date | string
    createdBy?: StringNullableFilter<"Vacation"> | string | null
    updatedBy?: StringNullableFilter<"Vacation"> | string | null
    isDeleted?: BoolFilter<"Vacation"> | boolean
    deletedAt?: DateTimeNullableFilter<"Vacation"> | Date | string | null
    deletedBy?: StringNullableFilter<"Vacation"> | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutManagerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutManagerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
  }

  export type UserUpdateManyWithWhereWithoutManagerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutManagerInput>
  }

  export type UserUpsertWithoutStaffMembersInput = {
    update: XOR<UserUpdateWithoutStaffMembersInput, UserUncheckedUpdateWithoutStaffMembersInput>
    create: XOR<UserCreateWithoutStaffMembersInput, UserUncheckedCreateWithoutStaffMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffMembersInput, UserUncheckedUpdateWithoutStaffMembersInput>
  }

  export type UserUpdateWithoutStaffMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StaffStatusLogUpsertWithWhereUniqueWithoutUserInput = {
    where: StaffStatusLogWhereUniqueInput
    update: XOR<StaffStatusLogUpdateWithoutUserInput, StaffStatusLogUncheckedUpdateWithoutUserInput>
    create: XOR<StaffStatusLogCreateWithoutUserInput, StaffStatusLogUncheckedCreateWithoutUserInput>
  }

  export type StaffStatusLogUpdateWithWhereUniqueWithoutUserInput = {
    where: StaffStatusLogWhereUniqueInput
    data: XOR<StaffStatusLogUpdateWithoutUserInput, StaffStatusLogUncheckedUpdateWithoutUserInput>
  }

  export type StaffStatusLogUpdateManyWithWhereWithoutUserInput = {
    where: StaffStatusLogScalarWhereInput
    data: XOR<StaffStatusLogUpdateManyMutationInput, StaffStatusLogUncheckedUpdateManyWithoutUserInput>
  }

  export type StaffStatusLogScalarWhereInput = {
    AND?: StaffStatusLogScalarWhereInput | StaffStatusLogScalarWhereInput[]
    OR?: StaffStatusLogScalarWhereInput[]
    NOT?: StaffStatusLogScalarWhereInput | StaffStatusLogScalarWhereInput[]
    id?: StringFilter<"StaffStatusLog"> | string
    userId?: StringFilter<"StaffStatusLog"> | string
    status?: EnumStaffStatusFilter<"StaffStatusLog"> | $Enums.StaffStatus
    timestamp?: DateTimeFilter<"StaffStatusLog"> | Date | string
  }

  export type UserCreateWithoutSubscriptionInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriberSubscriptionCreateWithoutSubscriptionInput = {
    id?: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    business?: BusinessCreateNestedOneWithoutSubscriberSubscriptionsInput
    subscriber: UserCreateNestedOneWithoutSubscriberSubscriptionsInput
    appointments?: AppointmentCreateNestedManyWithoutSubscriberSubscriptionInput
    discountLogs?: SubscriptionDiscountLogCreateNestedManyWithoutSubscriberSubscriptionInput
  }

  export type SubscriberSubscriptionUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    subscriberId: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    businessId?: string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSubscriberSubscriptionInput
    discountLogs?: SubscriptionDiscountLogUncheckedCreateNestedManyWithoutSubscriberSubscriptionInput
  }

  export type SubscriberSubscriptionCreateOrConnectWithoutSubscriptionInput = {
    where: SubscriberSubscriptionWhereUniqueInput
    create: XOR<SubscriberSubscriptionCreateWithoutSubscriptionInput, SubscriberSubscriptionUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriberSubscriptionCreateManySubscriptionInputEnvelope = {
    data: SubscriberSubscriptionCreateManySubscriptionInput | SubscriberSubscriptionCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type BusinessCreateWithoutSubscriptionInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowCreateNestedManyWithoutBusinessInput
    whatsappNumbers?: WhatsAppNumberCreateNestedManyWithoutBusinessInput
    subscriber?: UserCreateNestedOneWithoutBusinessesInput
    discountCode?: DiscountCreateNestedOneWithoutBusinessesInput
    branches?: BranchCreateNestedManyWithoutBusinessInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    discountCodeId?: string | null
    subscriberId?: string | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowUncheckedCreateNestedManyWithoutBusinessInput
    whatsappNumbers?: WhatsAppNumberUncheckedCreateNestedManyWithoutBusinessInput
    branches?: BranchUncheckedCreateNestedManyWithoutBusinessInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutSubscriptionInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutSubscriptionInput, BusinessUncheckedCreateWithoutSubscriptionInput>
  }

  export type BusinessCreateManySubscriptionInputEnvelope = {
    data: BusinessCreateManySubscriptionInput | BusinessCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriberSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: SubscriberSubscriptionWhereUniqueInput
    update: XOR<SubscriberSubscriptionUpdateWithoutSubscriptionInput, SubscriberSubscriptionUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<SubscriberSubscriptionCreateWithoutSubscriptionInput, SubscriberSubscriptionUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriberSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: SubscriberSubscriptionWhereUniqueInput
    data: XOR<SubscriberSubscriptionUpdateWithoutSubscriptionInput, SubscriberSubscriptionUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriberSubscriptionUpdateManyWithWhereWithoutSubscriptionInput = {
    where: SubscriberSubscriptionScalarWhereInput
    data: XOR<SubscriberSubscriptionUpdateManyMutationInput, SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type BusinessUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: BusinessWhereUniqueInput
    update: XOR<BusinessUpdateWithoutSubscriptionInput, BusinessUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<BusinessCreateWithoutSubscriptionInput, BusinessUncheckedCreateWithoutSubscriptionInput>
  }

  export type BusinessUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: BusinessWhereUniqueInput
    data: XOR<BusinessUpdateWithoutSubscriptionInput, BusinessUncheckedUpdateWithoutSubscriptionInput>
  }

  export type BusinessUpdateManyWithWhereWithoutSubscriptionInput = {
    where: BusinessScalarWhereInput
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type BusinessCreateWithoutSubscriberSubscriptionsInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowCreateNestedManyWithoutBusinessInput
    whatsappNumbers?: WhatsAppNumberCreateNestedManyWithoutBusinessInput
    subscriber?: UserCreateNestedOneWithoutBusinessesInput
    discountCode?: DiscountCreateNestedOneWithoutBusinessesInput
    branches?: BranchCreateNestedManyWithoutBusinessInput
    subscription?: SubscriptionCreateNestedOneWithoutBusinessesInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutSubscriberSubscriptionsInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    discountCodeId?: string | null
    subscriberId?: string | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowUncheckedCreateNestedManyWithoutBusinessInput
    whatsappNumbers?: WhatsAppNumberUncheckedCreateNestedManyWithoutBusinessInput
    branches?: BranchUncheckedCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutSubscriberSubscriptionsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutSubscriberSubscriptionsInput, BusinessUncheckedCreateWithoutSubscriberSubscriptionsInput>
  }

  export type UserCreateWithoutSubscriberSubscriptionsInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriberSubscriptionsInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriberSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriberSubscriptionsInput, UserUncheckedCreateWithoutSubscriberSubscriptionsInput>
  }

  export type SubscriptionCreateWithoutSubscriberSubscriptionsInput = {
    id?: string
    type: $Enums.SubscriptionType
    description: string
    price: number
    noOfBranches: number
    noOfAdmins: number
    noOfStaffManagers: number
    noOfServiceProviders: number
    noOfReceptionists: number
    whatsappBot: boolean
    manualReminder: boolean
    automatedReminder: boolean
    googleReviewLink: boolean
    promotions: boolean
    selfServiceTablet: boolean
    basicDashboard: boolean
    fullAccessDashboard: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriptionInput
    businesses?: BusinessCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutSubscriberSubscriptionsInput = {
    id?: string
    type: $Enums.SubscriptionType
    description: string
    price: number
    noOfBranches: number
    noOfAdmins: number
    noOfStaffManagers: number
    noOfServiceProviders: number
    noOfReceptionists: number
    whatsappBot: boolean
    manualReminder: boolean
    automatedReminder: boolean
    googleReviewLink: boolean
    promotions: boolean
    selfServiceTablet: boolean
    basicDashboard: boolean
    fullAccessDashboard: boolean
    subscriberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutSubscriberSubscriptionsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutSubscriberSubscriptionsInput, SubscriptionUncheckedCreateWithoutSubscriberSubscriptionsInput>
  }

  export type AppointmentCreateWithoutSubscriberSubscriptionInput = {
    id?: string
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    promotion?: PromotionCreateNestedOneWithoutAppointmentsInput
    discount?: DiscountCreateNestedOneWithoutAppointmentsInput
    service: ServiceCreateNestedOneWithoutAppointmentsInput
    consumer: UserCreateNestedOneWithoutAppointmentsAsConsumerInput
    serviceProvider?: UserCreateNestedOneWithoutAppointmentsAsProviderInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutSubscriberSubscriptionInput = {
    id?: string
    serviceId: string
    consumerId: string
    branchId: string
    serviceProviderId?: string | null
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    discountId?: string | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    promotionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AppointmentCreateOrConnectWithoutSubscriberSubscriptionInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutSubscriberSubscriptionInput, AppointmentUncheckedCreateWithoutSubscriberSubscriptionInput>
  }

  export type AppointmentCreateManySubscriberSubscriptionInputEnvelope = {
    data: AppointmentCreateManySubscriberSubscriptionInput | AppointmentCreateManySubscriberSubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionDiscountLogCreateWithoutSubscriberSubscriptionInput = {
    id?: string
    discountCode: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountedAmount: number
    originalPrice: number
    finalPrice: number
    appliedAt?: Date | string
    createdBy?: string | null
    discount: DiscountCreateNestedOneWithoutSubscriptionDiscountLogsInput
  }

  export type SubscriptionDiscountLogUncheckedCreateWithoutSubscriberSubscriptionInput = {
    id?: string
    discountId: string
    discountCode: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountedAmount: number
    originalPrice: number
    finalPrice: number
    appliedAt?: Date | string
    createdBy?: string | null
  }

  export type SubscriptionDiscountLogCreateOrConnectWithoutSubscriberSubscriptionInput = {
    where: SubscriptionDiscountLogWhereUniqueInput
    create: XOR<SubscriptionDiscountLogCreateWithoutSubscriberSubscriptionInput, SubscriptionDiscountLogUncheckedCreateWithoutSubscriberSubscriptionInput>
  }

  export type SubscriptionDiscountLogCreateManySubscriberSubscriptionInputEnvelope = {
    data: SubscriptionDiscountLogCreateManySubscriberSubscriptionInput | SubscriptionDiscountLogCreateManySubscriberSubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithoutSubscriberSubscriptionsInput = {
    update: XOR<BusinessUpdateWithoutSubscriberSubscriptionsInput, BusinessUncheckedUpdateWithoutSubscriberSubscriptionsInput>
    create: XOR<BusinessCreateWithoutSubscriberSubscriptionsInput, BusinessUncheckedCreateWithoutSubscriberSubscriptionsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutSubscriberSubscriptionsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutSubscriberSubscriptionsInput, BusinessUncheckedUpdateWithoutSubscriberSubscriptionsInput>
  }

  export type BusinessUpdateWithoutSubscriberSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUpdateManyWithoutBusinessNestedInput
    whatsappNumbers?: WhatsAppNumberUpdateManyWithoutBusinessNestedInput
    subscriber?: UserUpdateOneWithoutBusinessesNestedInput
    discountCode?: DiscountUpdateOneWithoutBusinessesNestedInput
    branches?: BranchUpdateManyWithoutBusinessNestedInput
    subscription?: SubscriptionUpdateOneWithoutBusinessesNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutSubscriberSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    discountCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUncheckedUpdateManyWithoutBusinessNestedInput
    whatsappNumbers?: WhatsAppNumberUncheckedUpdateManyWithoutBusinessNestedInput
    branches?: BranchUncheckedUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type UserUpsertWithoutSubscriberSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriberSubscriptionsInput, UserUncheckedUpdateWithoutSubscriberSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriberSubscriptionsInput, UserUncheckedCreateWithoutSubscriberSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriberSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriberSubscriptionsInput, UserUncheckedUpdateWithoutSubscriberSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriberSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriberSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionUpsertWithoutSubscriberSubscriptionsInput = {
    update: XOR<SubscriptionUpdateWithoutSubscriberSubscriptionsInput, SubscriptionUncheckedUpdateWithoutSubscriberSubscriptionsInput>
    create: XOR<SubscriptionCreateWithoutSubscriberSubscriptionsInput, SubscriptionUncheckedCreateWithoutSubscriberSubscriptionsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutSubscriberSubscriptionsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutSubscriberSubscriptionsInput, SubscriptionUncheckedUpdateWithoutSubscriberSubscriptionsInput>
  }

  export type SubscriptionUpdateWithoutSubscriberSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    noOfBranches?: IntFieldUpdateOperationsInput | number
    noOfAdmins?: IntFieldUpdateOperationsInput | number
    noOfStaffManagers?: IntFieldUpdateOperationsInput | number
    noOfServiceProviders?: IntFieldUpdateOperationsInput | number
    noOfReceptionists?: IntFieldUpdateOperationsInput | number
    whatsappBot?: BoolFieldUpdateOperationsInput | boolean
    manualReminder?: BoolFieldUpdateOperationsInput | boolean
    automatedReminder?: BoolFieldUpdateOperationsInput | boolean
    googleReviewLink?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    selfServiceTablet?: BoolFieldUpdateOperationsInput | boolean
    basicDashboard?: BoolFieldUpdateOperationsInput | boolean
    fullAccessDashboard?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriptionNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutSubscriberSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    noOfBranches?: IntFieldUpdateOperationsInput | number
    noOfAdmins?: IntFieldUpdateOperationsInput | number
    noOfStaffManagers?: IntFieldUpdateOperationsInput | number
    noOfServiceProviders?: IntFieldUpdateOperationsInput | number
    noOfReceptionists?: IntFieldUpdateOperationsInput | number
    whatsappBot?: BoolFieldUpdateOperationsInput | boolean
    manualReminder?: BoolFieldUpdateOperationsInput | boolean
    automatedReminder?: BoolFieldUpdateOperationsInput | boolean
    googleReviewLink?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    selfServiceTablet?: BoolFieldUpdateOperationsInput | boolean
    basicDashboard?: BoolFieldUpdateOperationsInput | boolean
    fullAccessDashboard?: BoolFieldUpdateOperationsInput | boolean
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutSubscriberSubscriptionInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutSubscriberSubscriptionInput, AppointmentUncheckedUpdateWithoutSubscriberSubscriptionInput>
    create: XOR<AppointmentCreateWithoutSubscriberSubscriptionInput, AppointmentUncheckedCreateWithoutSubscriberSubscriptionInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutSubscriberSubscriptionInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutSubscriberSubscriptionInput, AppointmentUncheckedUpdateWithoutSubscriberSubscriptionInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutSubscriberSubscriptionInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutSubscriberSubscriptionInput>
  }

  export type SubscriptionDiscountLogUpsertWithWhereUniqueWithoutSubscriberSubscriptionInput = {
    where: SubscriptionDiscountLogWhereUniqueInput
    update: XOR<SubscriptionDiscountLogUpdateWithoutSubscriberSubscriptionInput, SubscriptionDiscountLogUncheckedUpdateWithoutSubscriberSubscriptionInput>
    create: XOR<SubscriptionDiscountLogCreateWithoutSubscriberSubscriptionInput, SubscriptionDiscountLogUncheckedCreateWithoutSubscriberSubscriptionInput>
  }

  export type SubscriptionDiscountLogUpdateWithWhereUniqueWithoutSubscriberSubscriptionInput = {
    where: SubscriptionDiscountLogWhereUniqueInput
    data: XOR<SubscriptionDiscountLogUpdateWithoutSubscriberSubscriptionInput, SubscriptionDiscountLogUncheckedUpdateWithoutSubscriberSubscriptionInput>
  }

  export type SubscriptionDiscountLogUpdateManyWithWhereWithoutSubscriberSubscriptionInput = {
    where: SubscriptionDiscountLogScalarWhereInput
    data: XOR<SubscriptionDiscountLogUpdateManyMutationInput, SubscriptionDiscountLogUncheckedUpdateManyWithoutSubscriberSubscriptionInput>
  }

  export type SubscriptionDiscountLogScalarWhereInput = {
    AND?: SubscriptionDiscountLogScalarWhereInput | SubscriptionDiscountLogScalarWhereInput[]
    OR?: SubscriptionDiscountLogScalarWhereInput[]
    NOT?: SubscriptionDiscountLogScalarWhereInput | SubscriptionDiscountLogScalarWhereInput[]
    id?: StringFilter<"SubscriptionDiscountLog"> | string
    subscriberSubscriptionId?: StringFilter<"SubscriptionDiscountLog"> | string
    discountId?: StringFilter<"SubscriptionDiscountLog"> | string
    discountCode?: StringFilter<"SubscriptionDiscountLog"> | string
    discountType?: EnumDiscountTypeFilter<"SubscriptionDiscountLog"> | $Enums.DiscountType
    discountValue?: FloatFilter<"SubscriptionDiscountLog"> | number
    discountedAmount?: FloatFilter<"SubscriptionDiscountLog"> | number
    originalPrice?: FloatFilter<"SubscriptionDiscountLog"> | number
    finalPrice?: FloatFilter<"SubscriptionDiscountLog"> | number
    appliedAt?: DateTimeFilter<"SubscriptionDiscountLog"> | Date | string
    createdBy?: StringNullableFilter<"SubscriptionDiscountLog"> | string | null
  }

  export type BusinessCreateWithoutDiscountCodeInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowCreateNestedManyWithoutBusinessInput
    whatsappNumbers?: WhatsAppNumberCreateNestedManyWithoutBusinessInput
    subscriber?: UserCreateNestedOneWithoutBusinessesInput
    branches?: BranchCreateNestedManyWithoutBusinessInput
    subscription?: SubscriptionCreateNestedOneWithoutBusinessesInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutDiscountCodeInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    subscriberId?: string | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowUncheckedCreateNestedManyWithoutBusinessInput
    whatsappNumbers?: WhatsAppNumberUncheckedCreateNestedManyWithoutBusinessInput
    branches?: BranchUncheckedCreateNestedManyWithoutBusinessInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutDiscountCodeInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutDiscountCodeInput, BusinessUncheckedCreateWithoutDiscountCodeInput>
  }

  export type BusinessCreateManyDiscountCodeInputEnvelope = {
    data: BusinessCreateManyDiscountCodeInput | BusinessCreateManyDiscountCodeInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutDiscountInput = {
    id?: string
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    promotion?: PromotionCreateNestedOneWithoutAppointmentsInput
    subscriberSubscription?: SubscriberSubscriptionCreateNestedOneWithoutAppointmentsInput
    service: ServiceCreateNestedOneWithoutAppointmentsInput
    consumer: UserCreateNestedOneWithoutAppointmentsAsConsumerInput
    serviceProvider?: UserCreateNestedOneWithoutAppointmentsAsProviderInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutDiscountInput = {
    id?: string
    serviceId: string
    consumerId: string
    branchId: string
    serviceProviderId?: string | null
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    subscriberSubscriptionId?: string | null
    promotionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AppointmentCreateOrConnectWithoutDiscountInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDiscountInput, AppointmentUncheckedCreateWithoutDiscountInput>
  }

  export type AppointmentCreateManyDiscountInputEnvelope = {
    data: AppointmentCreateManyDiscountInput | AppointmentCreateManyDiscountInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionDiscountLogCreateWithoutDiscountInput = {
    id?: string
    discountCode: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountedAmount: number
    originalPrice: number
    finalPrice: number
    appliedAt?: Date | string
    createdBy?: string | null
    subscriberSubscription: SubscriberSubscriptionCreateNestedOneWithoutDiscountLogsInput
  }

  export type SubscriptionDiscountLogUncheckedCreateWithoutDiscountInput = {
    id?: string
    subscriberSubscriptionId: string
    discountCode: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountedAmount: number
    originalPrice: number
    finalPrice: number
    appliedAt?: Date | string
    createdBy?: string | null
  }

  export type SubscriptionDiscountLogCreateOrConnectWithoutDiscountInput = {
    where: SubscriptionDiscountLogWhereUniqueInput
    create: XOR<SubscriptionDiscountLogCreateWithoutDiscountInput, SubscriptionDiscountLogUncheckedCreateWithoutDiscountInput>
  }

  export type SubscriptionDiscountLogCreateManyDiscountInputEnvelope = {
    data: SubscriptionDiscountLogCreateManyDiscountInput | SubscriptionDiscountLogCreateManyDiscountInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithWhereUniqueWithoutDiscountCodeInput = {
    where: BusinessWhereUniqueInput
    update: XOR<BusinessUpdateWithoutDiscountCodeInput, BusinessUncheckedUpdateWithoutDiscountCodeInput>
    create: XOR<BusinessCreateWithoutDiscountCodeInput, BusinessUncheckedCreateWithoutDiscountCodeInput>
  }

  export type BusinessUpdateWithWhereUniqueWithoutDiscountCodeInput = {
    where: BusinessWhereUniqueInput
    data: XOR<BusinessUpdateWithoutDiscountCodeInput, BusinessUncheckedUpdateWithoutDiscountCodeInput>
  }

  export type BusinessUpdateManyWithWhereWithoutDiscountCodeInput = {
    where: BusinessScalarWhereInput
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyWithoutDiscountCodeInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDiscountInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDiscountInput, AppointmentUncheckedUpdateWithoutDiscountInput>
    create: XOR<AppointmentCreateWithoutDiscountInput, AppointmentUncheckedCreateWithoutDiscountInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDiscountInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDiscountInput, AppointmentUncheckedUpdateWithoutDiscountInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDiscountInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDiscountInput>
  }

  export type SubscriptionDiscountLogUpsertWithWhereUniqueWithoutDiscountInput = {
    where: SubscriptionDiscountLogWhereUniqueInput
    update: XOR<SubscriptionDiscountLogUpdateWithoutDiscountInput, SubscriptionDiscountLogUncheckedUpdateWithoutDiscountInput>
    create: XOR<SubscriptionDiscountLogCreateWithoutDiscountInput, SubscriptionDiscountLogUncheckedCreateWithoutDiscountInput>
  }

  export type SubscriptionDiscountLogUpdateWithWhereUniqueWithoutDiscountInput = {
    where: SubscriptionDiscountLogWhereUniqueInput
    data: XOR<SubscriptionDiscountLogUpdateWithoutDiscountInput, SubscriptionDiscountLogUncheckedUpdateWithoutDiscountInput>
  }

  export type SubscriptionDiscountLogUpdateManyWithWhereWithoutDiscountInput = {
    where: SubscriptionDiscountLogScalarWhereInput
    data: XOR<SubscriptionDiscountLogUpdateManyMutationInput, SubscriptionDiscountLogUncheckedUpdateManyWithoutDiscountInput>
  }

  export type SubscriberSubscriptionCreateWithoutDiscountLogsInput = {
    id?: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    business?: BusinessCreateNestedOneWithoutSubscriberSubscriptionsInput
    subscriber: UserCreateNestedOneWithoutSubscriberSubscriptionsInput
    subscription: SubscriptionCreateNestedOneWithoutSubscriberSubscriptionsInput
    appointments?: AppointmentCreateNestedManyWithoutSubscriberSubscriptionInput
  }

  export type SubscriberSubscriptionUncheckedCreateWithoutDiscountLogsInput = {
    id?: string
    subscriberId: string
    subscriptionId: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    businessId?: string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSubscriberSubscriptionInput
  }

  export type SubscriberSubscriptionCreateOrConnectWithoutDiscountLogsInput = {
    where: SubscriberSubscriptionWhereUniqueInput
    create: XOR<SubscriberSubscriptionCreateWithoutDiscountLogsInput, SubscriberSubscriptionUncheckedCreateWithoutDiscountLogsInput>
  }

  export type DiscountCreateWithoutSubscriptionDiscountLogsInput = {
    id?: string
    code: string
    group: $Enums.DiscountGroup
    packageType: $Enums.SubscriptionType
    discountType: $Enums.DiscountType
    value: number
    usageLimit?: number | null
    usageCount?: number
    startDate: Date | string
    expiryDate: Date | string
    isManuallyExpired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    businesses?: BusinessCreateNestedManyWithoutDiscountCodeInput
    appointments?: AppointmentCreateNestedManyWithoutDiscountInput
  }

  export type DiscountUncheckedCreateWithoutSubscriptionDiscountLogsInput = {
    id?: string
    code: string
    group: $Enums.DiscountGroup
    packageType: $Enums.SubscriptionType
    discountType: $Enums.DiscountType
    value: number
    usageLimit?: number | null
    usageCount?: number
    startDate: Date | string
    expiryDate: Date | string
    isManuallyExpired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    businesses?: BusinessUncheckedCreateNestedManyWithoutDiscountCodeInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDiscountInput
  }

  export type DiscountCreateOrConnectWithoutSubscriptionDiscountLogsInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutSubscriptionDiscountLogsInput, DiscountUncheckedCreateWithoutSubscriptionDiscountLogsInput>
  }

  export type SubscriberSubscriptionUpsertWithoutDiscountLogsInput = {
    update: XOR<SubscriberSubscriptionUpdateWithoutDiscountLogsInput, SubscriberSubscriptionUncheckedUpdateWithoutDiscountLogsInput>
    create: XOR<SubscriberSubscriptionCreateWithoutDiscountLogsInput, SubscriberSubscriptionUncheckedCreateWithoutDiscountLogsInput>
    where?: SubscriberSubscriptionWhereInput
  }

  export type SubscriberSubscriptionUpdateToOneWithWhereWithoutDiscountLogsInput = {
    where?: SubscriberSubscriptionWhereInput
    data: XOR<SubscriberSubscriptionUpdateWithoutDiscountLogsInput, SubscriberSubscriptionUncheckedUpdateWithoutDiscountLogsInput>
  }

  export type SubscriberSubscriptionUpdateWithoutDiscountLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessUpdateOneWithoutSubscriberSubscriptionsNestedInput
    subscriber?: UserUpdateOneRequiredWithoutSubscriberSubscriptionsNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutSubscriberSubscriptionsNestedInput
    appointments?: AppointmentUpdateManyWithoutSubscriberSubscriptionNestedInput
  }

  export type SubscriberSubscriptionUncheckedUpdateWithoutDiscountLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutSubscriberSubscriptionNestedInput
  }

  export type DiscountUpsertWithoutSubscriptionDiscountLogsInput = {
    update: XOR<DiscountUpdateWithoutSubscriptionDiscountLogsInput, DiscountUncheckedUpdateWithoutSubscriptionDiscountLogsInput>
    create: XOR<DiscountCreateWithoutSubscriptionDiscountLogsInput, DiscountUncheckedCreateWithoutSubscriptionDiscountLogsInput>
    where?: DiscountWhereInput
  }

  export type DiscountUpdateToOneWithWhereWithoutSubscriptionDiscountLogsInput = {
    where?: DiscountWhereInput
    data: XOR<DiscountUpdateWithoutSubscriptionDiscountLogsInput, DiscountUncheckedUpdateWithoutSubscriptionDiscountLogsInput>
  }

  export type DiscountUpdateWithoutSubscriptionDiscountLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    group?: EnumDiscountGroupFieldUpdateOperationsInput | $Enums.DiscountGroup
    packageType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isManuallyExpired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    businesses?: BusinessUpdateManyWithoutDiscountCodeNestedInput
    appointments?: AppointmentUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountUncheckedUpdateWithoutSubscriptionDiscountLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    group?: EnumDiscountGroupFieldUpdateOperationsInput | $Enums.DiscountGroup
    packageType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isManuallyExpired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    businesses?: BusinessUncheckedUpdateManyWithoutDiscountCodeNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDiscountNestedInput
  }

  export type FlowCreateWithoutBusinessInput = {
    id?: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    steps?: StepCreateNestedManyWithoutFlowInput
    sessions?: SessionCreateNestedManyWithoutFlowInput
    whatsappNumbers?: WhatsAppNumberCreateNestedManyWithoutDefaultFlowInput
  }

  export type FlowUncheckedCreateWithoutBusinessInput = {
    id?: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    steps?: StepUncheckedCreateNestedManyWithoutFlowInput
    sessions?: SessionUncheckedCreateNestedManyWithoutFlowInput
    whatsappNumbers?: WhatsAppNumberUncheckedCreateNestedManyWithoutDefaultFlowInput
  }

  export type FlowCreateOrConnectWithoutBusinessInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutBusinessInput, FlowUncheckedCreateWithoutBusinessInput>
  }

  export type FlowCreateManyBusinessInputEnvelope = {
    data: FlowCreateManyBusinessInput | FlowCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppNumberCreateWithoutBusinessInput = {
    id?: string
    phoneNumber: string
    phoneNumberId?: string | null
    wabaId?: string | null
    accessToken?: string | null
    isVerified?: boolean
    otp?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    defaultFlow?: FlowCreateNestedOneWithoutWhatsappNumbersInput
  }

  export type WhatsAppNumberUncheckedCreateWithoutBusinessInput = {
    id?: string
    phoneNumber: string
    phoneNumberId?: string | null
    wabaId?: string | null
    accessToken?: string | null
    isVerified?: boolean
    defaultFlowId?: string | null
    otp?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type WhatsAppNumberCreateOrConnectWithoutBusinessInput = {
    where: WhatsAppNumberWhereUniqueInput
    create: XOR<WhatsAppNumberCreateWithoutBusinessInput, WhatsAppNumberUncheckedCreateWithoutBusinessInput>
  }

  export type WhatsAppNumberCreateManyBusinessInputEnvelope = {
    data: WhatsAppNumberCreateManyBusinessInput | WhatsAppNumberCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBusinessesInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBusinessesInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBusinessesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBusinessesInput, UserUncheckedCreateWithoutBusinessesInput>
  }

  export type DiscountCreateWithoutBusinessesInput = {
    id?: string
    code: string
    group: $Enums.DiscountGroup
    packageType: $Enums.SubscriptionType
    discountType: $Enums.DiscountType
    value: number
    usageLimit?: number | null
    usageCount?: number
    startDate: Date | string
    expiryDate: Date | string
    isManuallyExpired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    appointments?: AppointmentCreateNestedManyWithoutDiscountInput
    subscriptionDiscountLogs?: SubscriptionDiscountLogCreateNestedManyWithoutDiscountInput
  }

  export type DiscountUncheckedCreateWithoutBusinessesInput = {
    id?: string
    code: string
    group: $Enums.DiscountGroup
    packageType: $Enums.SubscriptionType
    discountType: $Enums.DiscountType
    value: number
    usageLimit?: number | null
    usageCount?: number
    startDate: Date | string
    expiryDate: Date | string
    isManuallyExpired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDiscountInput
    subscriptionDiscountLogs?: SubscriptionDiscountLogUncheckedCreateNestedManyWithoutDiscountInput
  }

  export type DiscountCreateOrConnectWithoutBusinessesInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutBusinessesInput, DiscountUncheckedCreateWithoutBusinessesInput>
  }

  export type BranchCreateWithoutBusinessInput = {
    id?: string
    name: string
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber: UserCreateNestedOneWithoutOwnedBranchesInput
    users?: UserCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    promotions?: PromotionCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutBusinessInput = {
    id?: string
    name: string
    subscriberId: string
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountUncheckedCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutBusinessInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutBusinessInput, BranchUncheckedCreateWithoutBusinessInput>
  }

  export type BranchCreateManyBusinessInputEnvelope = {
    data: BranchCreateManyBusinessInput | BranchCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutBusinessesInput = {
    id?: string
    type: $Enums.SubscriptionType
    description: string
    price: number
    noOfBranches: number
    noOfAdmins: number
    noOfStaffManagers: number
    noOfServiceProviders: number
    noOfReceptionists: number
    whatsappBot: boolean
    manualReminder: boolean
    automatedReminder: boolean
    googleReviewLink: boolean
    promotions: boolean
    selfServiceTablet: boolean
    basicDashboard: boolean
    fullAccessDashboard: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriptionInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutBusinessesInput = {
    id?: string
    type: $Enums.SubscriptionType
    description: string
    price: number
    noOfBranches: number
    noOfAdmins: number
    noOfStaffManagers: number
    noOfServiceProviders: number
    noOfReceptionists: number
    whatsappBot: boolean
    manualReminder: boolean
    automatedReminder: boolean
    googleReviewLink: boolean
    promotions: boolean
    selfServiceTablet: boolean
    basicDashboard: boolean
    fullAccessDashboard: boolean
    subscriberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutBusinessesInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutBusinessesInput, SubscriptionUncheckedCreateWithoutBusinessesInput>
  }

  export type SubscriberSubscriptionCreateWithoutBusinessInput = {
    id?: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber: UserCreateNestedOneWithoutSubscriberSubscriptionsInput
    subscription: SubscriptionCreateNestedOneWithoutSubscriberSubscriptionsInput
    appointments?: AppointmentCreateNestedManyWithoutSubscriberSubscriptionInput
    discountLogs?: SubscriptionDiscountLogCreateNestedManyWithoutSubscriberSubscriptionInput
  }

  export type SubscriberSubscriptionUncheckedCreateWithoutBusinessInput = {
    id?: string
    subscriberId: string
    subscriptionId: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSubscriberSubscriptionInput
    discountLogs?: SubscriptionDiscountLogUncheckedCreateNestedManyWithoutSubscriberSubscriptionInput
  }

  export type SubscriberSubscriptionCreateOrConnectWithoutBusinessInput = {
    where: SubscriberSubscriptionWhereUniqueInput
    create: XOR<SubscriberSubscriptionCreateWithoutBusinessInput, SubscriberSubscriptionUncheckedCreateWithoutBusinessInput>
  }

  export type SubscriberSubscriptionCreateManyBusinessInputEnvelope = {
    data: SubscriberSubscriptionCreateManyBusinessInput | SubscriberSubscriptionCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleHourCreateWithoutBusinessInput = {
    id?: string
    ownerType: $Enums.ScheduleOwnerType
    ownerId: string
    dayOfWeek: $Enums.WeekDay
    openTime: string
    closeTime: string
    isClosed?: boolean
    inheritanceMode?: $Enums.ScheduleInheritanceMode
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    staff?: UserCreateNestedOneWithoutScheduleHoursInput
    branch?: BranchCreateNestedOneWithoutScheduleHoursInput
  }

  export type ScheduleHourUncheckedCreateWithoutBusinessInput = {
    id?: string
    ownerType: $Enums.ScheduleOwnerType
    ownerId: string
    dayOfWeek: $Enums.WeekDay
    openTime: string
    closeTime: string
    isClosed?: boolean
    inheritanceMode?: $Enums.ScheduleInheritanceMode
    staffId?: string | null
    branchId?: string | null
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ScheduleHourCreateOrConnectWithoutBusinessInput = {
    where: ScheduleHourWhereUniqueInput
    create: XOR<ScheduleHourCreateWithoutBusinessInput, ScheduleHourUncheckedCreateWithoutBusinessInput>
  }

  export type ScheduleHourCreateManyBusinessInputEnvelope = {
    data: ScheduleHourCreateManyBusinessInput | ScheduleHourCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type FlowUpsertWithWhereUniqueWithoutBusinessInput = {
    where: FlowWhereUniqueInput
    update: XOR<FlowUpdateWithoutBusinessInput, FlowUncheckedUpdateWithoutBusinessInput>
    create: XOR<FlowCreateWithoutBusinessInput, FlowUncheckedCreateWithoutBusinessInput>
  }

  export type FlowUpdateWithWhereUniqueWithoutBusinessInput = {
    where: FlowWhereUniqueInput
    data: XOR<FlowUpdateWithoutBusinessInput, FlowUncheckedUpdateWithoutBusinessInput>
  }

  export type FlowUpdateManyWithWhereWithoutBusinessInput = {
    where: FlowScalarWhereInput
    data: XOR<FlowUpdateManyMutationInput, FlowUncheckedUpdateManyWithoutBusinessInput>
  }

  export type FlowScalarWhereInput = {
    AND?: FlowScalarWhereInput | FlowScalarWhereInput[]
    OR?: FlowScalarWhereInput[]
    NOT?: FlowScalarWhereInput | FlowScalarWhereInput[]
    id?: StringFilter<"Flow"> | string
    name?: StringFilter<"Flow"> | string
    isActive?: BoolFilter<"Flow"> | boolean
    businessId?: StringNullableFilter<"Flow"> | string | null
    createdAt?: DateTimeFilter<"Flow"> | Date | string
    updatedAt?: DateTimeFilter<"Flow"> | Date | string
    createdBy?: StringFilter<"Flow"> | string
    updatedBy?: StringNullableFilter<"Flow"> | string | null
    DeletedBy?: StringNullableFilter<"Flow"> | string | null
    DeletedAt?: DateTimeNullableFilter<"Flow"> | Date | string | null
    isDeleted?: BoolFilter<"Flow"> | boolean
  }

  export type WhatsAppNumberUpsertWithWhereUniqueWithoutBusinessInput = {
    where: WhatsAppNumberWhereUniqueInput
    update: XOR<WhatsAppNumberUpdateWithoutBusinessInput, WhatsAppNumberUncheckedUpdateWithoutBusinessInput>
    create: XOR<WhatsAppNumberCreateWithoutBusinessInput, WhatsAppNumberUncheckedCreateWithoutBusinessInput>
  }

  export type WhatsAppNumberUpdateWithWhereUniqueWithoutBusinessInput = {
    where: WhatsAppNumberWhereUniqueInput
    data: XOR<WhatsAppNumberUpdateWithoutBusinessInput, WhatsAppNumberUncheckedUpdateWithoutBusinessInput>
  }

  export type WhatsAppNumberUpdateManyWithWhereWithoutBusinessInput = {
    where: WhatsAppNumberScalarWhereInput
    data: XOR<WhatsAppNumberUpdateManyMutationInput, WhatsAppNumberUncheckedUpdateManyWithoutBusinessInput>
  }

  export type WhatsAppNumberScalarWhereInput = {
    AND?: WhatsAppNumberScalarWhereInput | WhatsAppNumberScalarWhereInput[]
    OR?: WhatsAppNumberScalarWhereInput[]
    NOT?: WhatsAppNumberScalarWhereInput | WhatsAppNumberScalarWhereInput[]
    id?: StringFilter<"WhatsAppNumber"> | string
    businessId?: StringFilter<"WhatsAppNumber"> | string
    phoneNumber?: StringFilter<"WhatsAppNumber"> | string
    phoneNumberId?: StringNullableFilter<"WhatsAppNumber"> | string | null
    wabaId?: StringNullableFilter<"WhatsAppNumber"> | string | null
    accessToken?: StringNullableFilter<"WhatsAppNumber"> | string | null
    isVerified?: BoolFilter<"WhatsAppNumber"> | boolean
    defaultFlowId?: StringNullableFilter<"WhatsAppNumber"> | string | null
    otp?: IntNullableFilter<"WhatsAppNumber"> | number | null
    createdAt?: DateTimeFilter<"WhatsAppNumber"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppNumber"> | Date | string
    isDeleted?: BoolFilter<"WhatsAppNumber"> | boolean
  }

  export type UserUpsertWithoutBusinessesInput = {
    update: XOR<UserUpdateWithoutBusinessesInput, UserUncheckedUpdateWithoutBusinessesInput>
    create: XOR<UserCreateWithoutBusinessesInput, UserUncheckedCreateWithoutBusinessesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBusinessesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBusinessesInput, UserUncheckedUpdateWithoutBusinessesInput>
  }

  export type UserUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DiscountUpsertWithoutBusinessesInput = {
    update: XOR<DiscountUpdateWithoutBusinessesInput, DiscountUncheckedUpdateWithoutBusinessesInput>
    create: XOR<DiscountCreateWithoutBusinessesInput, DiscountUncheckedCreateWithoutBusinessesInput>
    where?: DiscountWhereInput
  }

  export type DiscountUpdateToOneWithWhereWithoutBusinessesInput = {
    where?: DiscountWhereInput
    data: XOR<DiscountUpdateWithoutBusinessesInput, DiscountUncheckedUpdateWithoutBusinessesInput>
  }

  export type DiscountUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    group?: EnumDiscountGroupFieldUpdateOperationsInput | $Enums.DiscountGroup
    packageType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isManuallyExpired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUpdateManyWithoutDiscountNestedInput
    subscriptionDiscountLogs?: SubscriptionDiscountLogUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountUncheckedUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    group?: EnumDiscountGroupFieldUpdateOperationsInput | $Enums.DiscountGroup
    packageType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isManuallyExpired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutDiscountNestedInput
    subscriptionDiscountLogs?: SubscriptionDiscountLogUncheckedUpdateManyWithoutDiscountNestedInput
  }

  export type BranchUpsertWithWhereUniqueWithoutBusinessInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutBusinessInput, BranchUncheckedUpdateWithoutBusinessInput>
    create: XOR<BranchCreateWithoutBusinessInput, BranchUncheckedCreateWithoutBusinessInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutBusinessInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutBusinessInput, BranchUncheckedUpdateWithoutBusinessInput>
  }

  export type BranchUpdateManyWithWhereWithoutBusinessInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutBusinessInput>
  }

  export type SubscriptionUpsertWithoutBusinessesInput = {
    update: XOR<SubscriptionUpdateWithoutBusinessesInput, SubscriptionUncheckedUpdateWithoutBusinessesInput>
    create: XOR<SubscriptionCreateWithoutBusinessesInput, SubscriptionUncheckedCreateWithoutBusinessesInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutBusinessesInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutBusinessesInput, SubscriptionUncheckedUpdateWithoutBusinessesInput>
  }

  export type SubscriptionUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    noOfBranches?: IntFieldUpdateOperationsInput | number
    noOfAdmins?: IntFieldUpdateOperationsInput | number
    noOfStaffManagers?: IntFieldUpdateOperationsInput | number
    noOfServiceProviders?: IntFieldUpdateOperationsInput | number
    noOfReceptionists?: IntFieldUpdateOperationsInput | number
    whatsappBot?: BoolFieldUpdateOperationsInput | boolean
    manualReminder?: BoolFieldUpdateOperationsInput | boolean
    automatedReminder?: BoolFieldUpdateOperationsInput | boolean
    googleReviewLink?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    selfServiceTablet?: BoolFieldUpdateOperationsInput | boolean
    basicDashboard?: BoolFieldUpdateOperationsInput | boolean
    fullAccessDashboard?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriptionNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    noOfBranches?: IntFieldUpdateOperationsInput | number
    noOfAdmins?: IntFieldUpdateOperationsInput | number
    noOfStaffManagers?: IntFieldUpdateOperationsInput | number
    noOfServiceProviders?: IntFieldUpdateOperationsInput | number
    noOfReceptionists?: IntFieldUpdateOperationsInput | number
    whatsappBot?: BoolFieldUpdateOperationsInput | boolean
    manualReminder?: BoolFieldUpdateOperationsInput | boolean
    automatedReminder?: BoolFieldUpdateOperationsInput | boolean
    googleReviewLink?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    selfServiceTablet?: BoolFieldUpdateOperationsInput | boolean
    basicDashboard?: BoolFieldUpdateOperationsInput | boolean
    fullAccessDashboard?: BoolFieldUpdateOperationsInput | boolean
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriberSubscriptionUpsertWithWhereUniqueWithoutBusinessInput = {
    where: SubscriberSubscriptionWhereUniqueInput
    update: XOR<SubscriberSubscriptionUpdateWithoutBusinessInput, SubscriberSubscriptionUncheckedUpdateWithoutBusinessInput>
    create: XOR<SubscriberSubscriptionCreateWithoutBusinessInput, SubscriberSubscriptionUncheckedCreateWithoutBusinessInput>
  }

  export type SubscriberSubscriptionUpdateWithWhereUniqueWithoutBusinessInput = {
    where: SubscriberSubscriptionWhereUniqueInput
    data: XOR<SubscriberSubscriptionUpdateWithoutBusinessInput, SubscriberSubscriptionUncheckedUpdateWithoutBusinessInput>
  }

  export type SubscriberSubscriptionUpdateManyWithWhereWithoutBusinessInput = {
    where: SubscriberSubscriptionScalarWhereInput
    data: XOR<SubscriberSubscriptionUpdateManyMutationInput, SubscriberSubscriptionUncheckedUpdateManyWithoutBusinessInput>
  }

  export type ScheduleHourUpsertWithWhereUniqueWithoutBusinessInput = {
    where: ScheduleHourWhereUniqueInput
    update: XOR<ScheduleHourUpdateWithoutBusinessInput, ScheduleHourUncheckedUpdateWithoutBusinessInput>
    create: XOR<ScheduleHourCreateWithoutBusinessInput, ScheduleHourUncheckedCreateWithoutBusinessInput>
  }

  export type ScheduleHourUpdateWithWhereUniqueWithoutBusinessInput = {
    where: ScheduleHourWhereUniqueInput
    data: XOR<ScheduleHourUpdateWithoutBusinessInput, ScheduleHourUncheckedUpdateWithoutBusinessInput>
  }

  export type ScheduleHourUpdateManyWithWhereWithoutBusinessInput = {
    where: ScheduleHourScalarWhereInput
    data: XOR<ScheduleHourUpdateManyMutationInput, ScheduleHourUncheckedUpdateManyWithoutBusinessInput>
  }

  export type UserCreateWithoutOwnedBranchesInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedBranchesInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedBranchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedBranchesInput, UserUncheckedCreateWithoutOwnedBranchesInput>
  }

  export type BusinessCreateWithoutBranchesInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowCreateNestedManyWithoutBusinessInput
    whatsappNumbers?: WhatsAppNumberCreateNestedManyWithoutBusinessInput
    subscriber?: UserCreateNestedOneWithoutBusinessesInput
    discountCode?: DiscountCreateNestedOneWithoutBusinessesInput
    subscription?: SubscriptionCreateNestedOneWithoutBusinessesInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutBranchesInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    discountCodeId?: string | null
    subscriberId?: string | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowUncheckedCreateNestedManyWithoutBusinessInput
    whatsappNumbers?: WhatsAppNumberUncheckedCreateNestedManyWithoutBusinessInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutBranchesInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutBranchesInput, BusinessUncheckedCreateWithoutBranchesInput>
  }

  export type UserCreateWithoutBranchInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBranchInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBranchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserCreateManyBranchInputEnvelope = {
    data: UserCreateManyBranchInput | UserCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ServiceBranchCreateWithoutBranchInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    service: ServiceCreateNestedOneWithoutBranchesInput
  }

  export type ServiceBranchUncheckedCreateWithoutBranchInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ServiceBranchCreateOrConnectWithoutBranchInput = {
    where: ServiceBranchWhereUniqueInput
    create: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput>
  }

  export type ServiceBranchCreateManyBranchInputEnvelope = {
    data: ServiceBranchCreateManyBranchInput | ServiceBranchCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutBranchInput = {
    id?: string
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    promotion?: PromotionCreateNestedOneWithoutAppointmentsInput
    subscriberSubscription?: SubscriberSubscriptionCreateNestedOneWithoutAppointmentsInput
    discount?: DiscountCreateNestedOneWithoutAppointmentsInput
    service: ServiceCreateNestedOneWithoutAppointmentsInput
    consumer: UserCreateNestedOneWithoutAppointmentsAsConsumerInput
    serviceProvider?: UserCreateNestedOneWithoutAppointmentsAsProviderInput
  }

  export type AppointmentUncheckedCreateWithoutBranchInput = {
    id?: string
    serviceId: string
    consumerId: string
    serviceProviderId?: string | null
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    discountId?: string | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    subscriberSubscriptionId?: string | null
    promotionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AppointmentCreateOrConnectWithoutBranchInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput>
  }

  export type AppointmentCreateManyBranchInputEnvelope = {
    data: AppointmentCreateManyBranchInput | AppointmentCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type PromotionCreateWithoutBranchesInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: number
    limit?: number | null
    status?: boolean
    startDate: Date | string
    expiryDate: Date | string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    appointments?: AppointmentCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateWithoutBranchesInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: number
    limit?: number | null
    status?: boolean
    startDate: Date | string
    expiryDate: Date | string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionCreateOrConnectWithoutBranchesInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutBranchesInput, PromotionUncheckedCreateWithoutBranchesInput>
  }

  export type TabletAccountCreateWithoutBranchInput = {
    id?: string
    username: string
    password: string
    loginLink?: string | null
    loginToken: string
    isActive?: boolean
    isLoggedIn?: boolean
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TabletAccountUncheckedCreateWithoutBranchInput = {
    id?: string
    username: string
    password: string
    loginLink?: string | null
    loginToken: string
    isActive?: boolean
    isLoggedIn?: boolean
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TabletAccountCreateOrConnectWithoutBranchInput = {
    where: TabletAccountWhereUniqueInput
    create: XOR<TabletAccountCreateWithoutBranchInput, TabletAccountUncheckedCreateWithoutBranchInput>
  }

  export type TabletAccountCreateManyBranchInputEnvelope = {
    data: TabletAccountCreateManyBranchInput | TabletAccountCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type WhatsappAdCreateWithoutBranchInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    targetDate: Date | string
    customerType: $Enums.AdTargetType
    status?: $Enums.AdStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    service?: ServiceCreateNestedOneWithoutWhatsappAdsInput
    assignedCustomers?: UserCreateNestedManyWithoutAssignedWhatsappAdsInput
  }

  export type WhatsappAdUncheckedCreateWithoutBranchInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    targetDate: Date | string
    customerType: $Enums.AdTargetType
    serviceId?: string | null
    status?: $Enums.AdStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    assignedCustomers?: UserUncheckedCreateNestedManyWithoutAssignedWhatsappAdsInput
  }

  export type WhatsappAdCreateOrConnectWithoutBranchInput = {
    where: WhatsappAdWhereUniqueInput
    create: XOR<WhatsappAdCreateWithoutBranchInput, WhatsappAdUncheckedCreateWithoutBranchInput>
  }

  export type WhatsappAdCreateManyBranchInputEnvelope = {
    data: WhatsappAdCreateManyBranchInput | WhatsappAdCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleHourCreateWithoutBranchInput = {
    id?: string
    ownerType: $Enums.ScheduleOwnerType
    ownerId: string
    dayOfWeek: $Enums.WeekDay
    openTime: string
    closeTime: string
    isClosed?: boolean
    inheritanceMode?: $Enums.ScheduleInheritanceMode
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    staff?: UserCreateNestedOneWithoutScheduleHoursInput
    business?: BusinessCreateNestedOneWithoutScheduleHoursInput
  }

  export type ScheduleHourUncheckedCreateWithoutBranchInput = {
    id?: string
    ownerType: $Enums.ScheduleOwnerType
    ownerId: string
    dayOfWeek: $Enums.WeekDay
    openTime: string
    closeTime: string
    isClosed?: boolean
    inheritanceMode?: $Enums.ScheduleInheritanceMode
    staffId?: string | null
    businessId?: string | null
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ScheduleHourCreateOrConnectWithoutBranchInput = {
    where: ScheduleHourWhereUniqueInput
    create: XOR<ScheduleHourCreateWithoutBranchInput, ScheduleHourUncheckedCreateWithoutBranchInput>
  }

  export type ScheduleHourCreateManyBranchInputEnvelope = {
    data: ScheduleHourCreateManyBranchInput | ScheduleHourCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedBranchesInput = {
    update: XOR<UserUpdateWithoutOwnedBranchesInput, UserUncheckedUpdateWithoutOwnedBranchesInput>
    create: XOR<UserCreateWithoutOwnedBranchesInput, UserUncheckedCreateWithoutOwnedBranchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedBranchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedBranchesInput, UserUncheckedUpdateWithoutOwnedBranchesInput>
  }

  export type UserUpdateWithoutOwnedBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BusinessUpsertWithoutBranchesInput = {
    update: XOR<BusinessUpdateWithoutBranchesInput, BusinessUncheckedUpdateWithoutBranchesInput>
    create: XOR<BusinessCreateWithoutBranchesInput, BusinessUncheckedCreateWithoutBranchesInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutBranchesInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutBranchesInput, BusinessUncheckedUpdateWithoutBranchesInput>
  }

  export type BusinessUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUpdateManyWithoutBusinessNestedInput
    whatsappNumbers?: WhatsAppNumberUpdateManyWithoutBusinessNestedInput
    subscriber?: UserUpdateOneWithoutBusinessesNestedInput
    discountCode?: DiscountUpdateOneWithoutBusinessesNestedInput
    subscription?: SubscriptionUpdateOneWithoutBusinessesNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    discountCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUncheckedUpdateManyWithoutBusinessNestedInput
    whatsappNumbers?: WhatsAppNumberUncheckedUpdateManyWithoutBusinessNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
  }

  export type UserUpdateManyWithWhereWithoutBranchInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBranchInput>
  }

  export type ServiceBranchUpsertWithWhereUniqueWithoutBranchInput = {
    where: ServiceBranchWhereUniqueInput
    update: XOR<ServiceBranchUpdateWithoutBranchInput, ServiceBranchUncheckedUpdateWithoutBranchInput>
    create: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput>
  }

  export type ServiceBranchUpdateWithWhereUniqueWithoutBranchInput = {
    where: ServiceBranchWhereUniqueInput
    data: XOR<ServiceBranchUpdateWithoutBranchInput, ServiceBranchUncheckedUpdateWithoutBranchInput>
  }

  export type ServiceBranchUpdateManyWithWhereWithoutBranchInput = {
    where: ServiceBranchScalarWhereInput
    data: XOR<ServiceBranchUpdateManyMutationInput, ServiceBranchUncheckedUpdateManyWithoutBranchInput>
  }

  export type ServiceBranchScalarWhereInput = {
    AND?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
    OR?: ServiceBranchScalarWhereInput[]
    NOT?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
    id?: StringFilter<"ServiceBranch"> | string
    serviceId?: StringFilter<"ServiceBranch"> | string
    branchId?: StringFilter<"ServiceBranch"> | string
    createdAt?: DateTimeFilter<"ServiceBranch"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceBranch"> | Date | string
    createdBy?: StringNullableFilter<"ServiceBranch"> | string | null
    updatedBy?: StringNullableFilter<"ServiceBranch"> | string | null
    isDeleted?: BoolFilter<"ServiceBranch"> | boolean
    deletedAt?: DateTimeNullableFilter<"ServiceBranch"> | Date | string | null
    deletedBy?: StringNullableFilter<"ServiceBranch"> | string | null
  }

  export type AppointmentUpsertWithWhereUniqueWithoutBranchInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutBranchInput, AppointmentUncheckedUpdateWithoutBranchInput>
    create: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutBranchInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutBranchInput, AppointmentUncheckedUpdateWithoutBranchInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutBranchInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutBranchInput>
  }

  export type PromotionUpsertWithWhereUniqueWithoutBranchesInput = {
    where: PromotionWhereUniqueInput
    update: XOR<PromotionUpdateWithoutBranchesInput, PromotionUncheckedUpdateWithoutBranchesInput>
    create: XOR<PromotionCreateWithoutBranchesInput, PromotionUncheckedCreateWithoutBranchesInput>
  }

  export type PromotionUpdateWithWhereUniqueWithoutBranchesInput = {
    where: PromotionWhereUniqueInput
    data: XOR<PromotionUpdateWithoutBranchesInput, PromotionUncheckedUpdateWithoutBranchesInput>
  }

  export type PromotionUpdateManyWithWhereWithoutBranchesInput = {
    where: PromotionScalarWhereInput
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyWithoutBranchesInput>
  }

  export type PromotionScalarWhereInput = {
    AND?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
    OR?: PromotionScalarWhereInput[]
    NOT?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
    id?: StringFilter<"Promotion"> | string
    name?: StringFilter<"Promotion"> | string
    type?: EnumDiscountTypeFilter<"Promotion"> | $Enums.DiscountType
    value?: FloatFilter<"Promotion"> | number
    limit?: IntNullableFilter<"Promotion"> | number | null
    status?: BoolFilter<"Promotion"> | boolean
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    expiryDate?: DateTimeFilter<"Promotion"> | Date | string
    imageUrl?: StringNullableFilter<"Promotion"> | string | null
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    createdBy?: StringNullableFilter<"Promotion"> | string | null
    updatedBy?: StringNullableFilter<"Promotion"> | string | null
    isDeleted?: BoolFilter<"Promotion"> | boolean
    deletedAt?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    deletedBy?: StringNullableFilter<"Promotion"> | string | null
  }

  export type TabletAccountUpsertWithWhereUniqueWithoutBranchInput = {
    where: TabletAccountWhereUniqueInput
    update: XOR<TabletAccountUpdateWithoutBranchInput, TabletAccountUncheckedUpdateWithoutBranchInput>
    create: XOR<TabletAccountCreateWithoutBranchInput, TabletAccountUncheckedCreateWithoutBranchInput>
  }

  export type TabletAccountUpdateWithWhereUniqueWithoutBranchInput = {
    where: TabletAccountWhereUniqueInput
    data: XOR<TabletAccountUpdateWithoutBranchInput, TabletAccountUncheckedUpdateWithoutBranchInput>
  }

  export type TabletAccountUpdateManyWithWhereWithoutBranchInput = {
    where: TabletAccountScalarWhereInput
    data: XOR<TabletAccountUpdateManyMutationInput, TabletAccountUncheckedUpdateManyWithoutBranchInput>
  }

  export type TabletAccountScalarWhereInput = {
    AND?: TabletAccountScalarWhereInput | TabletAccountScalarWhereInput[]
    OR?: TabletAccountScalarWhereInput[]
    NOT?: TabletAccountScalarWhereInput | TabletAccountScalarWhereInput[]
    id?: StringFilter<"TabletAccount"> | string
    username?: StringFilter<"TabletAccount"> | string
    password?: StringFilter<"TabletAccount"> | string
    branchId?: StringFilter<"TabletAccount"> | string
    loginLink?: StringNullableFilter<"TabletAccount"> | string | null
    loginToken?: StringFilter<"TabletAccount"> | string
    isActive?: BoolFilter<"TabletAccount"> | boolean
    isLoggedIn?: BoolFilter<"TabletAccount"> | boolean
    lastActivityAt?: DateTimeNullableFilter<"TabletAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"TabletAccount"> | Date | string
    updatedAt?: DateTimeFilter<"TabletAccount"> | Date | string
    createdBy?: StringNullableFilter<"TabletAccount"> | string | null
    updatedBy?: StringNullableFilter<"TabletAccount"> | string | null
    isDeleted?: BoolFilter<"TabletAccount"> | boolean
    deletedAt?: DateTimeNullableFilter<"TabletAccount"> | Date | string | null
    deletedBy?: StringNullableFilter<"TabletAccount"> | string | null
  }

  export type WhatsappAdUpsertWithWhereUniqueWithoutBranchInput = {
    where: WhatsappAdWhereUniqueInput
    update: XOR<WhatsappAdUpdateWithoutBranchInput, WhatsappAdUncheckedUpdateWithoutBranchInput>
    create: XOR<WhatsappAdCreateWithoutBranchInput, WhatsappAdUncheckedCreateWithoutBranchInput>
  }

  export type WhatsappAdUpdateWithWhereUniqueWithoutBranchInput = {
    where: WhatsappAdWhereUniqueInput
    data: XOR<WhatsappAdUpdateWithoutBranchInput, WhatsappAdUncheckedUpdateWithoutBranchInput>
  }

  export type WhatsappAdUpdateManyWithWhereWithoutBranchInput = {
    where: WhatsappAdScalarWhereInput
    data: XOR<WhatsappAdUpdateManyMutationInput, WhatsappAdUncheckedUpdateManyWithoutBranchInput>
  }

  export type ScheduleHourUpsertWithWhereUniqueWithoutBranchInput = {
    where: ScheduleHourWhereUniqueInput
    update: XOR<ScheduleHourUpdateWithoutBranchInput, ScheduleHourUncheckedUpdateWithoutBranchInput>
    create: XOR<ScheduleHourCreateWithoutBranchInput, ScheduleHourUncheckedCreateWithoutBranchInput>
  }

  export type ScheduleHourUpdateWithWhereUniqueWithoutBranchInput = {
    where: ScheduleHourWhereUniqueInput
    data: XOR<ScheduleHourUpdateWithoutBranchInput, ScheduleHourUncheckedUpdateWithoutBranchInput>
  }

  export type ScheduleHourUpdateManyWithWhereWithoutBranchInput = {
    where: ScheduleHourScalarWhereInput
    data: XOR<ScheduleHourUpdateManyMutationInput, ScheduleHourUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserCreateWithoutScheduleHoursInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutScheduleHoursInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutScheduleHoursInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScheduleHoursInput, UserUncheckedCreateWithoutScheduleHoursInput>
  }

  export type BusinessCreateWithoutScheduleHoursInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowCreateNestedManyWithoutBusinessInput
    whatsappNumbers?: WhatsAppNumberCreateNestedManyWithoutBusinessInput
    subscriber?: UserCreateNestedOneWithoutBusinessesInput
    discountCode?: DiscountCreateNestedOneWithoutBusinessesInput
    branches?: BranchCreateNestedManyWithoutBusinessInput
    subscription?: SubscriptionCreateNestedOneWithoutBusinessesInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutScheduleHoursInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    discountCodeId?: string | null
    subscriberId?: string | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowUncheckedCreateNestedManyWithoutBusinessInput
    whatsappNumbers?: WhatsAppNumberUncheckedCreateNestedManyWithoutBusinessInput
    branches?: BranchUncheckedCreateNestedManyWithoutBusinessInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutScheduleHoursInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutScheduleHoursInput, BusinessUncheckedCreateWithoutScheduleHoursInput>
  }

  export type BranchCreateWithoutScheduleHoursInput = {
    id?: string
    name: string
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber: UserCreateNestedOneWithoutOwnedBranchesInput
    business?: BusinessCreateNestedOneWithoutBranchesInput
    users?: UserCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    promotions?: PromotionCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutScheduleHoursInput = {
    id?: string
    name: string
    subscriberId: string
    businessId?: string | null
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountUncheckedCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutScheduleHoursInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutScheduleHoursInput, BranchUncheckedCreateWithoutScheduleHoursInput>
  }

  export type UserUpsertWithoutScheduleHoursInput = {
    update: XOR<UserUpdateWithoutScheduleHoursInput, UserUncheckedUpdateWithoutScheduleHoursInput>
    create: XOR<UserCreateWithoutScheduleHoursInput, UserUncheckedCreateWithoutScheduleHoursInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScheduleHoursInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScheduleHoursInput, UserUncheckedUpdateWithoutScheduleHoursInput>
  }

  export type UserUpdateWithoutScheduleHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutScheduleHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BusinessUpsertWithoutScheduleHoursInput = {
    update: XOR<BusinessUpdateWithoutScheduleHoursInput, BusinessUncheckedUpdateWithoutScheduleHoursInput>
    create: XOR<BusinessCreateWithoutScheduleHoursInput, BusinessUncheckedCreateWithoutScheduleHoursInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutScheduleHoursInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutScheduleHoursInput, BusinessUncheckedUpdateWithoutScheduleHoursInput>
  }

  export type BusinessUpdateWithoutScheduleHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUpdateManyWithoutBusinessNestedInput
    whatsappNumbers?: WhatsAppNumberUpdateManyWithoutBusinessNestedInput
    subscriber?: UserUpdateOneWithoutBusinessesNestedInput
    discountCode?: DiscountUpdateOneWithoutBusinessesNestedInput
    branches?: BranchUpdateManyWithoutBusinessNestedInput
    subscription?: SubscriptionUpdateOneWithoutBusinessesNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutScheduleHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    discountCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUncheckedUpdateManyWithoutBusinessNestedInput
    whatsappNumbers?: WhatsAppNumberUncheckedUpdateManyWithoutBusinessNestedInput
    branches?: BranchUncheckedUpdateManyWithoutBusinessNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BranchUpsertWithoutScheduleHoursInput = {
    update: XOR<BranchUpdateWithoutScheduleHoursInput, BranchUncheckedUpdateWithoutScheduleHoursInput>
    create: XOR<BranchCreateWithoutScheduleHoursInput, BranchUncheckedCreateWithoutScheduleHoursInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutScheduleHoursInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutScheduleHoursInput, BranchUncheckedUpdateWithoutScheduleHoursInput>
  }

  export type BranchUpdateWithoutScheduleHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneRequiredWithoutOwnedBranchesNestedInput
    business?: BusinessUpdateOneWithoutBranchesNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutScheduleHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUncheckedUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserCreateWithoutStatusLogsInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
  }

  export type UserUncheckedCreateWithoutStatusLogsInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutStatusLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStatusLogsInput, UserUncheckedCreateWithoutStatusLogsInput>
  }

  export type UserUpsertWithoutStatusLogsInput = {
    update: XOR<UserUpdateWithoutStatusLogsInput, UserUncheckedUpdateWithoutStatusLogsInput>
    create: XOR<UserCreateWithoutStatusLogsInput, UserUncheckedCreateWithoutStatusLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStatusLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStatusLogsInput, UserUncheckedUpdateWithoutStatusLogsInput>
  }

  export type UserUpdateWithoutStatusLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutStatusLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type UserCreateWithoutAttendanceRecordsInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttendanceRecordsInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttendanceRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceRecordsInput, UserUncheckedCreateWithoutAttendanceRecordsInput>
  }

  export type UserUpsertWithoutAttendanceRecordsInput = {
    update: XOR<UserUpdateWithoutAttendanceRecordsInput, UserUncheckedUpdateWithoutAttendanceRecordsInput>
    create: XOR<UserCreateWithoutAttendanceRecordsInput, UserUncheckedCreateWithoutAttendanceRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceRecordsInput, UserUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type UserUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutVacationsInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVacationsInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVacationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVacationsInput, UserUncheckedCreateWithoutVacationsInput>
  }

  export type UserUpsertWithoutVacationsInput = {
    update: XOR<UserUpdateWithoutVacationsInput, UserUncheckedUpdateWithoutVacationsInput>
    create: XOR<UserCreateWithoutVacationsInput, UserUncheckedCreateWithoutVacationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVacationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVacationsInput, UserUncheckedUpdateWithoutVacationsInput>
  }

  export type UserUpdateWithoutVacationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVacationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserOnServiceCreateWithoutServiceInput = {
    id?: string
    provider: UserCreateNestedOneWithoutServicesInput
  }

  export type UserOnServiceUncheckedCreateWithoutServiceInput = {
    id?: string
    providerId: string
  }

  export type UserOnServiceCreateOrConnectWithoutServiceInput = {
    where: UserOnServiceWhereUniqueInput
    create: XOR<UserOnServiceCreateWithoutServiceInput, UserOnServiceUncheckedCreateWithoutServiceInput>
  }

  export type UserOnServiceCreateManyServiceInputEnvelope = {
    data: UserOnServiceCreateManyServiceInput | UserOnServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceBranchCreateWithoutServiceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    branch: BranchCreateNestedOneWithoutServiceBranchesInput
  }

  export type ServiceBranchUncheckedCreateWithoutServiceInput = {
    id?: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ServiceBranchCreateOrConnectWithoutServiceInput = {
    where: ServiceBranchWhereUniqueInput
    create: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput>
  }

  export type ServiceBranchCreateManyServiceInputEnvelope = {
    data: ServiceBranchCreateManyServiceInput | ServiceBranchCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutServiceInput = {
    id?: string
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    promotion?: PromotionCreateNestedOneWithoutAppointmentsInput
    subscriberSubscription?: SubscriberSubscriptionCreateNestedOneWithoutAppointmentsInput
    discount?: DiscountCreateNestedOneWithoutAppointmentsInput
    consumer: UserCreateNestedOneWithoutAppointmentsAsConsumerInput
    serviceProvider?: UserCreateNestedOneWithoutAppointmentsAsProviderInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutServiceInput = {
    id?: string
    consumerId: string
    branchId: string
    serviceProviderId?: string | null
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    discountId?: string | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    subscriberSubscriptionId?: string | null
    promotionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AppointmentCreateOrConnectWithoutServiceInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput>
  }

  export type AppointmentCreateManyServiceInputEnvelope = {
    data: AppointmentCreateManyServiceInput | AppointmentCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type WhatsappAdCreateWithoutServiceInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    targetDate: Date | string
    customerType: $Enums.AdTargetType
    status?: $Enums.AdStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    branch: BranchCreateNestedOneWithoutWhatsappAdsInput
    assignedCustomers?: UserCreateNestedManyWithoutAssignedWhatsappAdsInput
  }

  export type WhatsappAdUncheckedCreateWithoutServiceInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    targetDate: Date | string
    customerType: $Enums.AdTargetType
    branchId: string
    status?: $Enums.AdStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    assignedCustomers?: UserUncheckedCreateNestedManyWithoutAssignedWhatsappAdsInput
  }

  export type WhatsappAdCreateOrConnectWithoutServiceInput = {
    where: WhatsappAdWhereUniqueInput
    create: XOR<WhatsappAdCreateWithoutServiceInput, WhatsappAdUncheckedCreateWithoutServiceInput>
  }

  export type WhatsappAdCreateManyServiceInputEnvelope = {
    data: WhatsappAdCreateManyServiceInput | WhatsappAdCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type UserOnServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: UserOnServiceWhereUniqueInput
    update: XOR<UserOnServiceUpdateWithoutServiceInput, UserOnServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<UserOnServiceCreateWithoutServiceInput, UserOnServiceUncheckedCreateWithoutServiceInput>
  }

  export type UserOnServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: UserOnServiceWhereUniqueInput
    data: XOR<UserOnServiceUpdateWithoutServiceInput, UserOnServiceUncheckedUpdateWithoutServiceInput>
  }

  export type UserOnServiceUpdateManyWithWhereWithoutServiceInput = {
    where: UserOnServiceScalarWhereInput
    data: XOR<UserOnServiceUpdateManyMutationInput, UserOnServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceBranchUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceBranchWhereUniqueInput
    update: XOR<ServiceBranchUpdateWithoutServiceInput, ServiceBranchUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput>
  }

  export type ServiceBranchUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceBranchWhereUniqueInput
    data: XOR<ServiceBranchUpdateWithoutServiceInput, ServiceBranchUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceBranchUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceBranchScalarWhereInput
    data: XOR<ServiceBranchUpdateManyMutationInput, ServiceBranchUncheckedUpdateManyWithoutServiceInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutServiceInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutServiceInput, AppointmentUncheckedUpdateWithoutServiceInput>
    create: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutServiceInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutServiceInput, AppointmentUncheckedUpdateWithoutServiceInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutServiceInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutServiceInput>
  }

  export type WhatsappAdUpsertWithWhereUniqueWithoutServiceInput = {
    where: WhatsappAdWhereUniqueInput
    update: XOR<WhatsappAdUpdateWithoutServiceInput, WhatsappAdUncheckedUpdateWithoutServiceInput>
    create: XOR<WhatsappAdCreateWithoutServiceInput, WhatsappAdUncheckedCreateWithoutServiceInput>
  }

  export type WhatsappAdUpdateWithWhereUniqueWithoutServiceInput = {
    where: WhatsappAdWhereUniqueInput
    data: XOR<WhatsappAdUpdateWithoutServiceInput, WhatsappAdUncheckedUpdateWithoutServiceInput>
  }

  export type WhatsappAdUpdateManyWithWhereWithoutServiceInput = {
    where: WhatsappAdScalarWhereInput
    data: XOR<WhatsappAdUpdateManyMutationInput, WhatsappAdUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceCreateWithoutProvidersInput = {
    id?: string
    name: string
    providerId?: string | null
    duration: number
    price: number
    bufferTime: number
    status?: boolean
    frequency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    branches?: ServiceBranchCreateNestedManyWithoutServiceInput
    appointments?: AppointmentCreateNestedManyWithoutServiceInput
    whatsappAds?: WhatsappAdCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutProvidersInput = {
    id?: string
    name: string
    providerId?: string | null
    duration: number
    price: number
    bufferTime: number
    status?: boolean
    frequency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    branches?: ServiceBranchUncheckedCreateNestedManyWithoutServiceInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutServiceInput
    whatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutProvidersInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutProvidersInput, ServiceUncheckedCreateWithoutProvidersInput>
  }

  export type UserCreateWithoutServicesInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServicesInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
  }

  export type ServiceUpsertWithoutProvidersInput = {
    update: XOR<ServiceUpdateWithoutProvidersInput, ServiceUncheckedUpdateWithoutProvidersInput>
    create: XOR<ServiceCreateWithoutProvidersInput, ServiceUncheckedCreateWithoutProvidersInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutProvidersInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutProvidersInput, ServiceUncheckedUpdateWithoutProvidersInput>
  }

  export type ServiceUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    bufferTime?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branches?: ServiceBranchUpdateManyWithoutServiceNestedInput
    appointments?: AppointmentUpdateManyWithoutServiceNestedInput
    whatsappAds?: WhatsappAdUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    bufferTime?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branches?: ServiceBranchUncheckedUpdateManyWithoutServiceNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutServiceNestedInput
    whatsappAds?: WhatsappAdUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserUpsertWithoutServicesInput = {
    update: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>
  }

  export type UserUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceCreateWithoutBranchesInput = {
    id?: string
    name: string
    providerId?: string | null
    duration: number
    price: number
    bufferTime: number
    status?: boolean
    frequency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    providers?: UserOnServiceCreateNestedManyWithoutServiceInput
    appointments?: AppointmentCreateNestedManyWithoutServiceInput
    whatsappAds?: WhatsappAdCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutBranchesInput = {
    id?: string
    name: string
    providerId?: string | null
    duration: number
    price: number
    bufferTime: number
    status?: boolean
    frequency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    providers?: UserOnServiceUncheckedCreateNestedManyWithoutServiceInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutServiceInput
    whatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutBranchesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBranchesInput, ServiceUncheckedCreateWithoutBranchesInput>
  }

  export type BranchCreateWithoutServiceBranchesInput = {
    id?: string
    name: string
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber: UserCreateNestedOneWithoutOwnedBranchesInput
    business?: BusinessCreateNestedOneWithoutBranchesInput
    users?: UserCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    promotions?: PromotionCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutServiceBranchesInput = {
    id?: string
    name: string
    subscriberId: string
    businessId?: string | null
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountUncheckedCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutServiceBranchesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutServiceBranchesInput, BranchUncheckedCreateWithoutServiceBranchesInput>
  }

  export type ServiceUpsertWithoutBranchesInput = {
    update: XOR<ServiceUpdateWithoutBranchesInput, ServiceUncheckedUpdateWithoutBranchesInput>
    create: XOR<ServiceCreateWithoutBranchesInput, ServiceUncheckedCreateWithoutBranchesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBranchesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBranchesInput, ServiceUncheckedUpdateWithoutBranchesInput>
  }

  export type ServiceUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    bufferTime?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: UserOnServiceUpdateManyWithoutServiceNestedInput
    appointments?: AppointmentUpdateManyWithoutServiceNestedInput
    whatsappAds?: WhatsappAdUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    bufferTime?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: UserOnServiceUncheckedUpdateManyWithoutServiceNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutServiceNestedInput
    whatsappAds?: WhatsappAdUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type BranchUpsertWithoutServiceBranchesInput = {
    update: XOR<BranchUpdateWithoutServiceBranchesInput, BranchUncheckedUpdateWithoutServiceBranchesInput>
    create: XOR<BranchCreateWithoutServiceBranchesInput, BranchUncheckedCreateWithoutServiceBranchesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutServiceBranchesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutServiceBranchesInput, BranchUncheckedUpdateWithoutServiceBranchesInput>
  }

  export type BranchUpdateWithoutServiceBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneRequiredWithoutOwnedBranchesNestedInput
    business?: BusinessUpdateOneWithoutBranchesNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutServiceBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUncheckedUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUncheckedUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type PromotionCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: number
    limit?: number | null
    status?: boolean
    startDate: Date | string
    expiryDate: Date | string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    branches?: BranchCreateNestedManyWithoutPromotionsInput
  }

  export type PromotionUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: number
    limit?: number | null
    status?: boolean
    startDate: Date | string
    expiryDate: Date | string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    branches?: BranchUncheckedCreateNestedManyWithoutPromotionsInput
  }

  export type PromotionCreateOrConnectWithoutAppointmentsInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutAppointmentsInput, PromotionUncheckedCreateWithoutAppointmentsInput>
  }

  export type SubscriberSubscriptionCreateWithoutAppointmentsInput = {
    id?: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    business?: BusinessCreateNestedOneWithoutSubscriberSubscriptionsInput
    subscriber: UserCreateNestedOneWithoutSubscriberSubscriptionsInput
    subscription: SubscriptionCreateNestedOneWithoutSubscriberSubscriptionsInput
    discountLogs?: SubscriptionDiscountLogCreateNestedManyWithoutSubscriberSubscriptionInput
  }

  export type SubscriberSubscriptionUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    subscriberId: string
    subscriptionId: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    businessId?: string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    discountLogs?: SubscriptionDiscountLogUncheckedCreateNestedManyWithoutSubscriberSubscriptionInput
  }

  export type SubscriberSubscriptionCreateOrConnectWithoutAppointmentsInput = {
    where: SubscriberSubscriptionWhereUniqueInput
    create: XOR<SubscriberSubscriptionCreateWithoutAppointmentsInput, SubscriberSubscriptionUncheckedCreateWithoutAppointmentsInput>
  }

  export type DiscountCreateWithoutAppointmentsInput = {
    id?: string
    code: string
    group: $Enums.DiscountGroup
    packageType: $Enums.SubscriptionType
    discountType: $Enums.DiscountType
    value: number
    usageLimit?: number | null
    usageCount?: number
    startDate: Date | string
    expiryDate: Date | string
    isManuallyExpired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    businesses?: BusinessCreateNestedManyWithoutDiscountCodeInput
    subscriptionDiscountLogs?: SubscriptionDiscountLogCreateNestedManyWithoutDiscountInput
  }

  export type DiscountUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    code: string
    group: $Enums.DiscountGroup
    packageType: $Enums.SubscriptionType
    discountType: $Enums.DiscountType
    value: number
    usageLimit?: number | null
    usageCount?: number
    startDate: Date | string
    expiryDate: Date | string
    isManuallyExpired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    businesses?: BusinessUncheckedCreateNestedManyWithoutDiscountCodeInput
    subscriptionDiscountLogs?: SubscriptionDiscountLogUncheckedCreateNestedManyWithoutDiscountInput
  }

  export type DiscountCreateOrConnectWithoutAppointmentsInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutAppointmentsInput, DiscountUncheckedCreateWithoutAppointmentsInput>
  }

  export type ServiceCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    providerId?: string | null
    duration: number
    price: number
    bufferTime: number
    status?: boolean
    frequency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    providers?: UserOnServiceCreateNestedManyWithoutServiceInput
    branches?: ServiceBranchCreateNestedManyWithoutServiceInput
    whatsappAds?: WhatsappAdCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    providerId?: string | null
    duration: number
    price: number
    bufferTime: number
    status?: boolean
    frequency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    providers?: UserOnServiceUncheckedCreateNestedManyWithoutServiceInput
    branches?: ServiceBranchUncheckedCreateNestedManyWithoutServiceInput
    whatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutAppointmentsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutAppointmentsInput, ServiceUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserCreateWithoutAppointmentsAsConsumerInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAppointmentsAsConsumerInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAppointmentsAsConsumerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsAsConsumerInput, UserUncheckedCreateWithoutAppointmentsAsConsumerInput>
  }

  export type UserCreateWithoutAppointmentsAsProviderInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAppointmentsAsProviderInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAppointmentsAsProviderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsAsProviderInput, UserUncheckedCreateWithoutAppointmentsAsProviderInput>
  }

  export type BranchCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber: UserCreateNestedOneWithoutOwnedBranchesInput
    business?: BusinessCreateNestedOneWithoutBranchesInput
    users?: UserCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    promotions?: PromotionCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    subscriberId: string
    businessId?: string | null
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountUncheckedCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutAppointmentsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAppointmentsInput, BranchUncheckedCreateWithoutAppointmentsInput>
  }

  export type PromotionUpsertWithoutAppointmentsInput = {
    update: XOR<PromotionUpdateWithoutAppointmentsInput, PromotionUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PromotionCreateWithoutAppointmentsInput, PromotionUncheckedCreateWithoutAppointmentsInput>
    where?: PromotionWhereInput
  }

  export type PromotionUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PromotionWhereInput
    data: XOR<PromotionUpdateWithoutAppointmentsInput, PromotionUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PromotionUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branches?: BranchUpdateManyWithoutPromotionsNestedInput
  }

  export type PromotionUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branches?: BranchUncheckedUpdateManyWithoutPromotionsNestedInput
  }

  export type SubscriberSubscriptionUpsertWithoutAppointmentsInput = {
    update: XOR<SubscriberSubscriptionUpdateWithoutAppointmentsInput, SubscriberSubscriptionUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<SubscriberSubscriptionCreateWithoutAppointmentsInput, SubscriberSubscriptionUncheckedCreateWithoutAppointmentsInput>
    where?: SubscriberSubscriptionWhereInput
  }

  export type SubscriberSubscriptionUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: SubscriberSubscriptionWhereInput
    data: XOR<SubscriberSubscriptionUpdateWithoutAppointmentsInput, SubscriberSubscriptionUncheckedUpdateWithoutAppointmentsInput>
  }

  export type SubscriberSubscriptionUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessUpdateOneWithoutSubscriberSubscriptionsNestedInput
    subscriber?: UserUpdateOneRequiredWithoutSubscriberSubscriptionsNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutSubscriberSubscriptionsNestedInput
    discountLogs?: SubscriptionDiscountLogUpdateManyWithoutSubscriberSubscriptionNestedInput
  }

  export type SubscriberSubscriptionUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    discountLogs?: SubscriptionDiscountLogUncheckedUpdateManyWithoutSubscriberSubscriptionNestedInput
  }

  export type DiscountUpsertWithoutAppointmentsInput = {
    update: XOR<DiscountUpdateWithoutAppointmentsInput, DiscountUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<DiscountCreateWithoutAppointmentsInput, DiscountUncheckedCreateWithoutAppointmentsInput>
    where?: DiscountWhereInput
  }

  export type DiscountUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: DiscountWhereInput
    data: XOR<DiscountUpdateWithoutAppointmentsInput, DiscountUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DiscountUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    group?: EnumDiscountGroupFieldUpdateOperationsInput | $Enums.DiscountGroup
    packageType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isManuallyExpired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    businesses?: BusinessUpdateManyWithoutDiscountCodeNestedInput
    subscriptionDiscountLogs?: SubscriptionDiscountLogUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    group?: EnumDiscountGroupFieldUpdateOperationsInput | $Enums.DiscountGroup
    packageType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isManuallyExpired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    businesses?: BusinessUncheckedUpdateManyWithoutDiscountCodeNestedInput
    subscriptionDiscountLogs?: SubscriptionDiscountLogUncheckedUpdateManyWithoutDiscountNestedInput
  }

  export type ServiceUpsertWithoutAppointmentsInput = {
    update: XOR<ServiceUpdateWithoutAppointmentsInput, ServiceUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ServiceCreateWithoutAppointmentsInput, ServiceUncheckedCreateWithoutAppointmentsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutAppointmentsInput, ServiceUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ServiceUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    bufferTime?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: UserOnServiceUpdateManyWithoutServiceNestedInput
    branches?: ServiceBranchUpdateManyWithoutServiceNestedInput
    whatsappAds?: WhatsappAdUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    bufferTime?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: UserOnServiceUncheckedUpdateManyWithoutServiceNestedInput
    branches?: ServiceBranchUncheckedUpdateManyWithoutServiceNestedInput
    whatsappAds?: WhatsappAdUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserUpsertWithoutAppointmentsAsConsumerInput = {
    update: XOR<UserUpdateWithoutAppointmentsAsConsumerInput, UserUncheckedUpdateWithoutAppointmentsAsConsumerInput>
    create: XOR<UserCreateWithoutAppointmentsAsConsumerInput, UserUncheckedCreateWithoutAppointmentsAsConsumerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsAsConsumerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsAsConsumerInput, UserUncheckedUpdateWithoutAppointmentsAsConsumerInput>
  }

  export type UserUpdateWithoutAppointmentsAsConsumerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsAsConsumerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutAppointmentsAsProviderInput = {
    update: XOR<UserUpdateWithoutAppointmentsAsProviderInput, UserUncheckedUpdateWithoutAppointmentsAsProviderInput>
    create: XOR<UserCreateWithoutAppointmentsAsProviderInput, UserUncheckedCreateWithoutAppointmentsAsProviderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsAsProviderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsAsProviderInput, UserUncheckedUpdateWithoutAppointmentsAsProviderInput>
  }

  export type UserUpdateWithoutAppointmentsAsProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsAsProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BranchUpsertWithoutAppointmentsInput = {
    update: XOR<BranchUpdateWithoutAppointmentsInput, BranchUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<BranchCreateWithoutAppointmentsInput, BranchUncheckedCreateWithoutAppointmentsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAppointmentsInput, BranchUncheckedUpdateWithoutAppointmentsInput>
  }

  export type BranchUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneRequiredWithoutOwnedBranchesNestedInput
    business?: BusinessUpdateOneWithoutBranchesNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUncheckedUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUncheckedUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutPromotionsInput = {
    id?: string
    name: string
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber: UserCreateNestedOneWithoutOwnedBranchesInput
    business?: BusinessCreateNestedOneWithoutBranchesInput
    users?: UserCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    tabletAccounts?: TabletAccountCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutPromotionsInput = {
    id?: string
    name: string
    subscriberId: string
    businessId?: string | null
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    tabletAccounts?: TabletAccountUncheckedCreateNestedManyWithoutBranchInput
    whatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutPromotionsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutPromotionsInput, BranchUncheckedCreateWithoutPromotionsInput>
  }

  export type AppointmentCreateWithoutPromotionInput = {
    id?: string
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberSubscription?: SubscriberSubscriptionCreateNestedOneWithoutAppointmentsInput
    discount?: DiscountCreateNestedOneWithoutAppointmentsInput
    service: ServiceCreateNestedOneWithoutAppointmentsInput
    consumer: UserCreateNestedOneWithoutAppointmentsAsConsumerInput
    serviceProvider?: UserCreateNestedOneWithoutAppointmentsAsProviderInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutPromotionInput = {
    id?: string
    serviceId: string
    consumerId: string
    branchId: string
    serviceProviderId?: string | null
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    discountId?: string | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    subscriberSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AppointmentCreateOrConnectWithoutPromotionInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPromotionInput, AppointmentUncheckedCreateWithoutPromotionInput>
  }

  export type AppointmentCreateManyPromotionInputEnvelope = {
    data: AppointmentCreateManyPromotionInput | AppointmentCreateManyPromotionInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithWhereUniqueWithoutPromotionsInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutPromotionsInput, BranchUncheckedUpdateWithoutPromotionsInput>
    create: XOR<BranchCreateWithoutPromotionsInput, BranchUncheckedCreateWithoutPromotionsInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutPromotionsInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutPromotionsInput, BranchUncheckedUpdateWithoutPromotionsInput>
  }

  export type BranchUpdateManyWithWhereWithoutPromotionsInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutPromotionsInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPromotionInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPromotionInput, AppointmentUncheckedUpdateWithoutPromotionInput>
    create: XOR<AppointmentCreateWithoutPromotionInput, AppointmentUncheckedCreateWithoutPromotionInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPromotionInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPromotionInput, AppointmentUncheckedUpdateWithoutPromotionInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPromotionInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPromotionInput>
  }

  export type BranchCreateWithoutTabletAccountsInput = {
    id?: string
    name: string
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber: UserCreateNestedOneWithoutOwnedBranchesInput
    business?: BusinessCreateNestedOneWithoutBranchesInput
    users?: UserCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    promotions?: PromotionCreateNestedManyWithoutBranchesInput
    whatsappAds?: WhatsappAdCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutTabletAccountsInput = {
    id?: string
    name: string
    subscriberId: string
    businessId?: string | null
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutBranchesInput
    whatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutTabletAccountsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutTabletAccountsInput, BranchUncheckedCreateWithoutTabletAccountsInput>
  }

  export type BranchUpsertWithoutTabletAccountsInput = {
    update: XOR<BranchUpdateWithoutTabletAccountsInput, BranchUncheckedUpdateWithoutTabletAccountsInput>
    create: XOR<BranchCreateWithoutTabletAccountsInput, BranchUncheckedCreateWithoutTabletAccountsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutTabletAccountsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutTabletAccountsInput, BranchUncheckedUpdateWithoutTabletAccountsInput>
  }

  export type BranchUpdateWithoutTabletAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneRequiredWithoutOwnedBranchesNestedInput
    business?: BusinessUpdateOneWithoutBranchesNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUpdateManyWithoutBranchesNestedInput
    whatsappAds?: WhatsappAdUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutTabletAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutBranchesNestedInput
    whatsappAds?: WhatsappAdUncheckedUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutWhatsappAdsInput = {
    id?: string
    name: string
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber: UserCreateNestedOneWithoutOwnedBranchesInput
    business?: BusinessCreateNestedOneWithoutBranchesInput
    users?: UserCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    promotions?: PromotionCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutWhatsappAdsInput = {
    id?: string
    name: string
    subscriberId: string
    businessId?: string | null
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutBranchesInput
    tabletAccounts?: TabletAccountUncheckedCreateNestedManyWithoutBranchInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutWhatsappAdsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutWhatsappAdsInput, BranchUncheckedCreateWithoutWhatsappAdsInput>
  }

  export type ServiceCreateWithoutWhatsappAdsInput = {
    id?: string
    name: string
    providerId?: string | null
    duration: number
    price: number
    bufferTime: number
    status?: boolean
    frequency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    providers?: UserOnServiceCreateNestedManyWithoutServiceInput
    branches?: ServiceBranchCreateNestedManyWithoutServiceInput
    appointments?: AppointmentCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutWhatsappAdsInput = {
    id?: string
    name: string
    providerId?: string | null
    duration: number
    price: number
    bufferTime: number
    status?: boolean
    frequency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    providers?: UserOnServiceUncheckedCreateNestedManyWithoutServiceInput
    branches?: ServiceBranchUncheckedCreateNestedManyWithoutServiceInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutWhatsappAdsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutWhatsappAdsInput, ServiceUncheckedCreateWithoutWhatsappAdsInput>
  }

  export type UserCreateWithoutAssignedWhatsappAdsInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedWhatsappAdsInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedWhatsappAdsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedWhatsappAdsInput, UserUncheckedCreateWithoutAssignedWhatsappAdsInput>
  }

  export type BranchUpsertWithoutWhatsappAdsInput = {
    update: XOR<BranchUpdateWithoutWhatsappAdsInput, BranchUncheckedUpdateWithoutWhatsappAdsInput>
    create: XOR<BranchCreateWithoutWhatsappAdsInput, BranchUncheckedCreateWithoutWhatsappAdsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutWhatsappAdsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutWhatsappAdsInput, BranchUncheckedUpdateWithoutWhatsappAdsInput>
  }

  export type BranchUpdateWithoutWhatsappAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneRequiredWithoutOwnedBranchesNestedInput
    business?: BusinessUpdateOneWithoutBranchesNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutWhatsappAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUncheckedUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ServiceUpsertWithoutWhatsappAdsInput = {
    update: XOR<ServiceUpdateWithoutWhatsappAdsInput, ServiceUncheckedUpdateWithoutWhatsappAdsInput>
    create: XOR<ServiceCreateWithoutWhatsappAdsInput, ServiceUncheckedCreateWithoutWhatsappAdsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutWhatsappAdsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutWhatsappAdsInput, ServiceUncheckedUpdateWithoutWhatsappAdsInput>
  }

  export type ServiceUpdateWithoutWhatsappAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    bufferTime?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: UserOnServiceUpdateManyWithoutServiceNestedInput
    branches?: ServiceBranchUpdateManyWithoutServiceNestedInput
    appointments?: AppointmentUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutWhatsappAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    bufferTime?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: UserOnServiceUncheckedUpdateManyWithoutServiceNestedInput
    branches?: ServiceBranchUncheckedUpdateManyWithoutServiceNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutAssignedWhatsappAdsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAssignedWhatsappAdsInput, UserUncheckedUpdateWithoutAssignedWhatsappAdsInput>
    create: XOR<UserCreateWithoutAssignedWhatsappAdsInput, UserUncheckedCreateWithoutAssignedWhatsappAdsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAssignedWhatsappAdsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAssignedWhatsappAdsInput, UserUncheckedUpdateWithoutAssignedWhatsappAdsInput>
  }

  export type UserUpdateManyWithWhereWithoutAssignedWhatsappAdsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAssignedWhatsappAdsInput>
  }

  export type BusinessCreateWithoutWhatsappNumbersInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowCreateNestedManyWithoutBusinessInput
    subscriber?: UserCreateNestedOneWithoutBusinessesInput
    discountCode?: DiscountCreateNestedOneWithoutBusinessesInput
    branches?: BranchCreateNestedManyWithoutBusinessInput
    subscription?: SubscriptionCreateNestedOneWithoutBusinessesInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutWhatsappNumbersInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    discountCodeId?: string | null
    subscriberId?: string | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    flows?: FlowUncheckedCreateNestedManyWithoutBusinessInput
    branches?: BranchUncheckedCreateNestedManyWithoutBusinessInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutWhatsappNumbersInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutWhatsappNumbersInput, BusinessUncheckedCreateWithoutWhatsappNumbersInput>
  }

  export type FlowCreateWithoutWhatsappNumbersInput = {
    id?: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    business?: BusinessCreateNestedOneWithoutFlowsInput
    steps?: StepCreateNestedManyWithoutFlowInput
    sessions?: SessionCreateNestedManyWithoutFlowInput
  }

  export type FlowUncheckedCreateWithoutWhatsappNumbersInput = {
    id?: string
    name: string
    isActive?: boolean
    businessId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    steps?: StepUncheckedCreateNestedManyWithoutFlowInput
    sessions?: SessionUncheckedCreateNestedManyWithoutFlowInput
  }

  export type FlowCreateOrConnectWithoutWhatsappNumbersInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutWhatsappNumbersInput, FlowUncheckedCreateWithoutWhatsappNumbersInput>
  }

  export type BusinessUpsertWithoutWhatsappNumbersInput = {
    update: XOR<BusinessUpdateWithoutWhatsappNumbersInput, BusinessUncheckedUpdateWithoutWhatsappNumbersInput>
    create: XOR<BusinessCreateWithoutWhatsappNumbersInput, BusinessUncheckedCreateWithoutWhatsappNumbersInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutWhatsappNumbersInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutWhatsappNumbersInput, BusinessUncheckedUpdateWithoutWhatsappNumbersInput>
  }

  export type BusinessUpdateWithoutWhatsappNumbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUpdateManyWithoutBusinessNestedInput
    subscriber?: UserUpdateOneWithoutBusinessesNestedInput
    discountCode?: DiscountUpdateOneWithoutBusinessesNestedInput
    branches?: BranchUpdateManyWithoutBusinessNestedInput
    subscription?: SubscriptionUpdateOneWithoutBusinessesNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutWhatsappNumbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    discountCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUncheckedUpdateManyWithoutBusinessNestedInput
    branches?: BranchUncheckedUpdateManyWithoutBusinessNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type FlowUpsertWithoutWhatsappNumbersInput = {
    update: XOR<FlowUpdateWithoutWhatsappNumbersInput, FlowUncheckedUpdateWithoutWhatsappNumbersInput>
    create: XOR<FlowCreateWithoutWhatsappNumbersInput, FlowUncheckedCreateWithoutWhatsappNumbersInput>
    where?: FlowWhereInput
  }

  export type FlowUpdateToOneWithWhereWithoutWhatsappNumbersInput = {
    where?: FlowWhereInput
    data: XOR<FlowUpdateWithoutWhatsappNumbersInput, FlowUncheckedUpdateWithoutWhatsappNumbersInput>
  }

  export type FlowUpdateWithoutWhatsappNumbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    business?: BusinessUpdateOneWithoutFlowsNestedInput
    steps?: StepUpdateManyWithoutFlowNestedInput
    sessions?: SessionUpdateManyWithoutFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutWhatsappNumbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    steps?: StepUncheckedUpdateManyWithoutFlowNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type BusinessCreateWithoutFlowsInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    whatsappNumbers?: WhatsAppNumberCreateNestedManyWithoutBusinessInput
    subscriber?: UserCreateNestedOneWithoutBusinessesInput
    discountCode?: DiscountCreateNestedOneWithoutBusinessesInput
    branches?: BranchCreateNestedManyWithoutBusinessInput
    subscription?: SubscriptionCreateNestedOneWithoutBusinessesInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutFlowsInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    discountCodeId?: string | null
    subscriberId?: string | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    whatsappNumbers?: WhatsAppNumberUncheckedCreateNestedManyWithoutBusinessInput
    branches?: BranchUncheckedCreateNestedManyWithoutBusinessInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutBusinessInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutFlowsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutFlowsInput, BusinessUncheckedCreateWithoutFlowsInput>
  }

  export type StepCreateWithoutFlowInput = {
    id?: string
    order: number
    type: $Enums.StepType
    message?: string | null
    dynamicSource?: $Enums.DynamicSource
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    options?: StepOptionCreateNestedManyWithoutStepInput
    sessions?: SessionCreateNestedManyWithoutCurrentStepInput
    logs?: LogCreateNestedManyWithoutStepInput
    nextStepOptions?: StepOptionCreateNestedManyWithoutNextStepInput
  }

  export type StepUncheckedCreateWithoutFlowInput = {
    id?: string
    order: number
    type: $Enums.StepType
    message?: string | null
    dynamicSource?: $Enums.DynamicSource
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    options?: StepOptionUncheckedCreateNestedManyWithoutStepInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCurrentStepInput
    logs?: LogUncheckedCreateNestedManyWithoutStepInput
    nextStepOptions?: StepOptionUncheckedCreateNestedManyWithoutNextStepInput
  }

  export type StepCreateOrConnectWithoutFlowInput = {
    where: StepWhereUniqueInput
    create: XOR<StepCreateWithoutFlowInput, StepUncheckedCreateWithoutFlowInput>
  }

  export type StepCreateManyFlowInputEnvelope = {
    data: StepCreateManyFlowInput | StepCreateManyFlowInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutFlowInput = {
    id?: string
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    user: UserCreateNestedOneWithoutSessionsInput
    currentStep?: StepCreateNestedOneWithoutSessionsInput
    logs?: LogCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutFlowInput = {
    id?: string
    userId: string
    currentStepId?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    logs?: LogUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutFlowInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutFlowInput, SessionUncheckedCreateWithoutFlowInput>
  }

  export type SessionCreateManyFlowInputEnvelope = {
    data: SessionCreateManyFlowInput | SessionCreateManyFlowInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppNumberCreateWithoutDefaultFlowInput = {
    id?: string
    phoneNumber: string
    phoneNumberId?: string | null
    wabaId?: string | null
    accessToken?: string | null
    isVerified?: boolean
    otp?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    business: BusinessCreateNestedOneWithoutWhatsappNumbersInput
  }

  export type WhatsAppNumberUncheckedCreateWithoutDefaultFlowInput = {
    id?: string
    businessId: string
    phoneNumber: string
    phoneNumberId?: string | null
    wabaId?: string | null
    accessToken?: string | null
    isVerified?: boolean
    otp?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type WhatsAppNumberCreateOrConnectWithoutDefaultFlowInput = {
    where: WhatsAppNumberWhereUniqueInput
    create: XOR<WhatsAppNumberCreateWithoutDefaultFlowInput, WhatsAppNumberUncheckedCreateWithoutDefaultFlowInput>
  }

  export type WhatsAppNumberCreateManyDefaultFlowInputEnvelope = {
    data: WhatsAppNumberCreateManyDefaultFlowInput | WhatsAppNumberCreateManyDefaultFlowInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithoutFlowsInput = {
    update: XOR<BusinessUpdateWithoutFlowsInput, BusinessUncheckedUpdateWithoutFlowsInput>
    create: XOR<BusinessCreateWithoutFlowsInput, BusinessUncheckedCreateWithoutFlowsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutFlowsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutFlowsInput, BusinessUncheckedUpdateWithoutFlowsInput>
  }

  export type BusinessUpdateWithoutFlowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumbers?: WhatsAppNumberUpdateManyWithoutBusinessNestedInput
    subscriber?: UserUpdateOneWithoutBusinessesNestedInput
    discountCode?: DiscountUpdateOneWithoutBusinessesNestedInput
    branches?: BranchUpdateManyWithoutBusinessNestedInput
    subscription?: SubscriptionUpdateOneWithoutBusinessesNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutFlowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    discountCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumbers?: WhatsAppNumberUncheckedUpdateManyWithoutBusinessNestedInput
    branches?: BranchUncheckedUpdateManyWithoutBusinessNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type StepUpsertWithWhereUniqueWithoutFlowInput = {
    where: StepWhereUniqueInput
    update: XOR<StepUpdateWithoutFlowInput, StepUncheckedUpdateWithoutFlowInput>
    create: XOR<StepCreateWithoutFlowInput, StepUncheckedCreateWithoutFlowInput>
  }

  export type StepUpdateWithWhereUniqueWithoutFlowInput = {
    where: StepWhereUniqueInput
    data: XOR<StepUpdateWithoutFlowInput, StepUncheckedUpdateWithoutFlowInput>
  }

  export type StepUpdateManyWithWhereWithoutFlowInput = {
    where: StepScalarWhereInput
    data: XOR<StepUpdateManyMutationInput, StepUncheckedUpdateManyWithoutFlowInput>
  }

  export type StepScalarWhereInput = {
    AND?: StepScalarWhereInput | StepScalarWhereInput[]
    OR?: StepScalarWhereInput[]
    NOT?: StepScalarWhereInput | StepScalarWhereInput[]
    id?: StringFilter<"Step"> | string
    flowId?: StringFilter<"Step"> | string
    order?: IntFilter<"Step"> | number
    type?: EnumStepTypeFilter<"Step"> | $Enums.StepType
    message?: StringNullableFilter<"Step"> | string | null
    dynamicSource?: EnumDynamicSourceFilter<"Step"> | $Enums.DynamicSource
    createdAt?: DateTimeFilter<"Step"> | Date | string
    updatedAt?: DateTimeFilter<"Step"> | Date | string
    createdBy?: StringFilter<"Step"> | string
    updatedBy?: StringNullableFilter<"Step"> | string | null
    DeletedBy?: StringNullableFilter<"Step"> | string | null
    DeletedAt?: DateTimeNullableFilter<"Step"> | Date | string | null
    isDeleted?: BoolFilter<"Step"> | boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutFlowInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutFlowInput, SessionUncheckedUpdateWithoutFlowInput>
    create: XOR<SessionCreateWithoutFlowInput, SessionUncheckedCreateWithoutFlowInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutFlowInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutFlowInput, SessionUncheckedUpdateWithoutFlowInput>
  }

  export type SessionUpdateManyWithWhereWithoutFlowInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutFlowInput>
  }

  export type WhatsAppNumberUpsertWithWhereUniqueWithoutDefaultFlowInput = {
    where: WhatsAppNumberWhereUniqueInput
    update: XOR<WhatsAppNumberUpdateWithoutDefaultFlowInput, WhatsAppNumberUncheckedUpdateWithoutDefaultFlowInput>
    create: XOR<WhatsAppNumberCreateWithoutDefaultFlowInput, WhatsAppNumberUncheckedCreateWithoutDefaultFlowInput>
  }

  export type WhatsAppNumberUpdateWithWhereUniqueWithoutDefaultFlowInput = {
    where: WhatsAppNumberWhereUniqueInput
    data: XOR<WhatsAppNumberUpdateWithoutDefaultFlowInput, WhatsAppNumberUncheckedUpdateWithoutDefaultFlowInput>
  }

  export type WhatsAppNumberUpdateManyWithWhereWithoutDefaultFlowInput = {
    where: WhatsAppNumberScalarWhereInput
    data: XOR<WhatsAppNumberUpdateManyMutationInput, WhatsAppNumberUncheckedUpdateManyWithoutDefaultFlowInput>
  }

  export type FlowCreateWithoutStepsInput = {
    id?: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    business?: BusinessCreateNestedOneWithoutFlowsInput
    sessions?: SessionCreateNestedManyWithoutFlowInput
    whatsappNumbers?: WhatsAppNumberCreateNestedManyWithoutDefaultFlowInput
  }

  export type FlowUncheckedCreateWithoutStepsInput = {
    id?: string
    name: string
    isActive?: boolean
    businessId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    sessions?: SessionUncheckedCreateNestedManyWithoutFlowInput
    whatsappNumbers?: WhatsAppNumberUncheckedCreateNestedManyWithoutDefaultFlowInput
  }

  export type FlowCreateOrConnectWithoutStepsInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutStepsInput, FlowUncheckedCreateWithoutStepsInput>
  }

  export type StepOptionCreateWithoutStepInput = {
    id?: string
    label: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    nextStep?: StepCreateNestedOneWithoutNextStepOptionsInput
  }

  export type StepOptionUncheckedCreateWithoutStepInput = {
    id?: string
    label: string
    value: string
    nextStepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type StepOptionCreateOrConnectWithoutStepInput = {
    where: StepOptionWhereUniqueInput
    create: XOR<StepOptionCreateWithoutStepInput, StepOptionUncheckedCreateWithoutStepInput>
  }

  export type StepOptionCreateManyStepInputEnvelope = {
    data: StepOptionCreateManyStepInput | StepOptionCreateManyStepInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutCurrentStepInput = {
    id?: string
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    flow: FlowCreateNestedOneWithoutSessionsInput
    user: UserCreateNestedOneWithoutSessionsInput
    logs?: LogCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutCurrentStepInput = {
    id?: string
    userId: string
    flowId: string
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    logs?: LogUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutCurrentStepInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutCurrentStepInput, SessionUncheckedCreateWithoutCurrentStepInput>
  }

  export type SessionCreateManyCurrentStepInputEnvelope = {
    data: SessionCreateManyCurrentStepInput | SessionCreateManyCurrentStepInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutStepInput = {
    id?: string
    message: string
    direction: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    session: SessionCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateWithoutStepInput = {
    id?: string
    sessionId: string
    message: string
    direction: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type LogCreateOrConnectWithoutStepInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutStepInput, LogUncheckedCreateWithoutStepInput>
  }

  export type LogCreateManyStepInputEnvelope = {
    data: LogCreateManyStepInput | LogCreateManyStepInput[]
    skipDuplicates?: boolean
  }

  export type StepOptionCreateWithoutNextStepInput = {
    id?: string
    label: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    step: StepCreateNestedOneWithoutOptionsInput
  }

  export type StepOptionUncheckedCreateWithoutNextStepInput = {
    id?: string
    stepId: string
    label: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type StepOptionCreateOrConnectWithoutNextStepInput = {
    where: StepOptionWhereUniqueInput
    create: XOR<StepOptionCreateWithoutNextStepInput, StepOptionUncheckedCreateWithoutNextStepInput>
  }

  export type StepOptionCreateManyNextStepInputEnvelope = {
    data: StepOptionCreateManyNextStepInput | StepOptionCreateManyNextStepInput[]
    skipDuplicates?: boolean
  }

  export type FlowUpsertWithoutStepsInput = {
    update: XOR<FlowUpdateWithoutStepsInput, FlowUncheckedUpdateWithoutStepsInput>
    create: XOR<FlowCreateWithoutStepsInput, FlowUncheckedCreateWithoutStepsInput>
    where?: FlowWhereInput
  }

  export type FlowUpdateToOneWithWhereWithoutStepsInput = {
    where?: FlowWhereInput
    data: XOR<FlowUpdateWithoutStepsInput, FlowUncheckedUpdateWithoutStepsInput>
  }

  export type FlowUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    business?: BusinessUpdateOneWithoutFlowsNestedInput
    sessions?: SessionUpdateManyWithoutFlowNestedInput
    whatsappNumbers?: WhatsAppNumberUpdateManyWithoutDefaultFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    sessions?: SessionUncheckedUpdateManyWithoutFlowNestedInput
    whatsappNumbers?: WhatsAppNumberUncheckedUpdateManyWithoutDefaultFlowNestedInput
  }

  export type StepOptionUpsertWithWhereUniqueWithoutStepInput = {
    where: StepOptionWhereUniqueInput
    update: XOR<StepOptionUpdateWithoutStepInput, StepOptionUncheckedUpdateWithoutStepInput>
    create: XOR<StepOptionCreateWithoutStepInput, StepOptionUncheckedCreateWithoutStepInput>
  }

  export type StepOptionUpdateWithWhereUniqueWithoutStepInput = {
    where: StepOptionWhereUniqueInput
    data: XOR<StepOptionUpdateWithoutStepInput, StepOptionUncheckedUpdateWithoutStepInput>
  }

  export type StepOptionUpdateManyWithWhereWithoutStepInput = {
    where: StepOptionScalarWhereInput
    data: XOR<StepOptionUpdateManyMutationInput, StepOptionUncheckedUpdateManyWithoutStepInput>
  }

  export type StepOptionScalarWhereInput = {
    AND?: StepOptionScalarWhereInput | StepOptionScalarWhereInput[]
    OR?: StepOptionScalarWhereInput[]
    NOT?: StepOptionScalarWhereInput | StepOptionScalarWhereInput[]
    id?: StringFilter<"StepOption"> | string
    stepId?: StringFilter<"StepOption"> | string
    label?: StringFilter<"StepOption"> | string
    value?: StringFilter<"StepOption"> | string
    nextStepId?: StringNullableFilter<"StepOption"> | string | null
    createdAt?: DateTimeFilter<"StepOption"> | Date | string
    updatedAt?: DateTimeFilter<"StepOption"> | Date | string
    createdBy?: StringFilter<"StepOption"> | string
    updatedBy?: StringNullableFilter<"StepOption"> | string | null
    DeletedBy?: StringNullableFilter<"StepOption"> | string | null
    DeletedAt?: DateTimeNullableFilter<"StepOption"> | Date | string | null
    isDeleted?: BoolFilter<"StepOption"> | boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutCurrentStepInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutCurrentStepInput, SessionUncheckedUpdateWithoutCurrentStepInput>
    create: XOR<SessionCreateWithoutCurrentStepInput, SessionUncheckedCreateWithoutCurrentStepInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutCurrentStepInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutCurrentStepInput, SessionUncheckedUpdateWithoutCurrentStepInput>
  }

  export type SessionUpdateManyWithWhereWithoutCurrentStepInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutCurrentStepInput>
  }

  export type LogUpsertWithWhereUniqueWithoutStepInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutStepInput, LogUncheckedUpdateWithoutStepInput>
    create: XOR<LogCreateWithoutStepInput, LogUncheckedCreateWithoutStepInput>
  }

  export type LogUpdateWithWhereUniqueWithoutStepInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutStepInput, LogUncheckedUpdateWithoutStepInput>
  }

  export type LogUpdateManyWithWhereWithoutStepInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutStepInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: StringFilter<"Log"> | string
    sessionId?: StringFilter<"Log"> | string
    stepId?: StringNullableFilter<"Log"> | string | null
    message?: StringFilter<"Log"> | string
    direction?: StringFilter<"Log"> | string
    createdAt?: DateTimeFilter<"Log"> | Date | string
    updatedAt?: DateTimeFilter<"Log"> | Date | string
    createdBy?: StringNullableFilter<"Log"> | string | null
    updatedBy?: StringNullableFilter<"Log"> | string | null
    isDeleted?: BoolFilter<"Log"> | boolean
    deletedAt?: DateTimeNullableFilter<"Log"> | Date | string | null
    deletedBy?: StringNullableFilter<"Log"> | string | null
  }

  export type StepOptionUpsertWithWhereUniqueWithoutNextStepInput = {
    where: StepOptionWhereUniqueInput
    update: XOR<StepOptionUpdateWithoutNextStepInput, StepOptionUncheckedUpdateWithoutNextStepInput>
    create: XOR<StepOptionCreateWithoutNextStepInput, StepOptionUncheckedCreateWithoutNextStepInput>
  }

  export type StepOptionUpdateWithWhereUniqueWithoutNextStepInput = {
    where: StepOptionWhereUniqueInput
    data: XOR<StepOptionUpdateWithoutNextStepInput, StepOptionUncheckedUpdateWithoutNextStepInput>
  }

  export type StepOptionUpdateManyWithWhereWithoutNextStepInput = {
    where: StepOptionScalarWhereInput
    data: XOR<StepOptionUpdateManyMutationInput, StepOptionUncheckedUpdateManyWithoutNextStepInput>
  }

  export type StepCreateWithoutOptionsInput = {
    id?: string
    order: number
    type: $Enums.StepType
    message?: string | null
    dynamicSource?: $Enums.DynamicSource
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    flow: FlowCreateNestedOneWithoutStepsInput
    sessions?: SessionCreateNestedManyWithoutCurrentStepInput
    logs?: LogCreateNestedManyWithoutStepInput
    nextStepOptions?: StepOptionCreateNestedManyWithoutNextStepInput
  }

  export type StepUncheckedCreateWithoutOptionsInput = {
    id?: string
    flowId: string
    order: number
    type: $Enums.StepType
    message?: string | null
    dynamicSource?: $Enums.DynamicSource
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    sessions?: SessionUncheckedCreateNestedManyWithoutCurrentStepInput
    logs?: LogUncheckedCreateNestedManyWithoutStepInput
    nextStepOptions?: StepOptionUncheckedCreateNestedManyWithoutNextStepInput
  }

  export type StepCreateOrConnectWithoutOptionsInput = {
    where: StepWhereUniqueInput
    create: XOR<StepCreateWithoutOptionsInput, StepUncheckedCreateWithoutOptionsInput>
  }

  export type StepCreateWithoutNextStepOptionsInput = {
    id?: string
    order: number
    type: $Enums.StepType
    message?: string | null
    dynamicSource?: $Enums.DynamicSource
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    flow: FlowCreateNestedOneWithoutStepsInput
    options?: StepOptionCreateNestedManyWithoutStepInput
    sessions?: SessionCreateNestedManyWithoutCurrentStepInput
    logs?: LogCreateNestedManyWithoutStepInput
  }

  export type StepUncheckedCreateWithoutNextStepOptionsInput = {
    id?: string
    flowId: string
    order: number
    type: $Enums.StepType
    message?: string | null
    dynamicSource?: $Enums.DynamicSource
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    options?: StepOptionUncheckedCreateNestedManyWithoutStepInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCurrentStepInput
    logs?: LogUncheckedCreateNestedManyWithoutStepInput
  }

  export type StepCreateOrConnectWithoutNextStepOptionsInput = {
    where: StepWhereUniqueInput
    create: XOR<StepCreateWithoutNextStepOptionsInput, StepUncheckedCreateWithoutNextStepOptionsInput>
  }

  export type StepUpsertWithoutOptionsInput = {
    update: XOR<StepUpdateWithoutOptionsInput, StepUncheckedUpdateWithoutOptionsInput>
    create: XOR<StepCreateWithoutOptionsInput, StepUncheckedCreateWithoutOptionsInput>
    where?: StepWhereInput
  }

  export type StepUpdateToOneWithWhereWithoutOptionsInput = {
    where?: StepWhereInput
    data: XOR<StepUpdateWithoutOptionsInput, StepUncheckedUpdateWithoutOptionsInput>
  }

  export type StepUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    flow?: FlowUpdateOneRequiredWithoutStepsNestedInput
    sessions?: SessionUpdateManyWithoutCurrentStepNestedInput
    logs?: LogUpdateManyWithoutStepNestedInput
    nextStepOptions?: StepOptionUpdateManyWithoutNextStepNestedInput
  }

  export type StepUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    sessions?: SessionUncheckedUpdateManyWithoutCurrentStepNestedInput
    logs?: LogUncheckedUpdateManyWithoutStepNestedInput
    nextStepOptions?: StepOptionUncheckedUpdateManyWithoutNextStepNestedInput
  }

  export type StepUpsertWithoutNextStepOptionsInput = {
    update: XOR<StepUpdateWithoutNextStepOptionsInput, StepUncheckedUpdateWithoutNextStepOptionsInput>
    create: XOR<StepCreateWithoutNextStepOptionsInput, StepUncheckedCreateWithoutNextStepOptionsInput>
    where?: StepWhereInput
  }

  export type StepUpdateToOneWithWhereWithoutNextStepOptionsInput = {
    where?: StepWhereInput
    data: XOR<StepUpdateWithoutNextStepOptionsInput, StepUncheckedUpdateWithoutNextStepOptionsInput>
  }

  export type StepUpdateWithoutNextStepOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    flow?: FlowUpdateOneRequiredWithoutStepsNestedInput
    options?: StepOptionUpdateManyWithoutStepNestedInput
    sessions?: SessionUpdateManyWithoutCurrentStepNestedInput
    logs?: LogUpdateManyWithoutStepNestedInput
  }

  export type StepUncheckedUpdateWithoutNextStepOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    options?: StepOptionUncheckedUpdateManyWithoutStepNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCurrentStepNestedInput
    logs?: LogUncheckedUpdateManyWithoutStepNestedInput
  }

  export type FlowCreateWithoutSessionsInput = {
    id?: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    business?: BusinessCreateNestedOneWithoutFlowsInput
    steps?: StepCreateNestedManyWithoutFlowInput
    whatsappNumbers?: WhatsAppNumberCreateNestedManyWithoutDefaultFlowInput
  }

  export type FlowUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    isActive?: boolean
    businessId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    steps?: StepUncheckedCreateNestedManyWithoutFlowInput
    whatsappNumbers?: WhatsAppNumberUncheckedCreateNestedManyWithoutDefaultFlowInput
  }

  export type FlowCreateOrConnectWithoutSessionsInput = {
    where: FlowWhereUniqueInput
    create: XOR<FlowCreateWithoutSessionsInput, FlowUncheckedCreateWithoutSessionsInput>
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriber?: UserCreateNestedOneWithoutSubscriberMembersInput
    subscriberMembers?: UserCreateNestedManyWithoutSubscriberInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    services?: UserOnServiceCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourCreateNestedManyWithoutStaffInput
    attendanceRecords?: AttendanceCreateNestedManyWithoutStaffInput
    vacations?: VacationCreateNestedManyWithoutStaffInput
    staffMembers?: UserCreateNestedManyWithoutManagerInput
    manager?: UserCreateNestedOneWithoutStaffMembersInput
    statusLogs?: StaffStatusLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    subscriberMembers?: UserUncheckedCreateNestedManyWithoutSubscriberInput
    services?: UserOnServiceUncheckedCreateNestedManyWithoutProviderInput
    appointmentsAsConsumer?: AppointmentUncheckedCreateNestedManyWithoutConsumerInput
    appointmentsAsProvider?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriberInput
    ownedBranches?: BranchUncheckedCreateNestedManyWithoutSubscriberInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutSubscriberInput
    assignedWhatsappAds?: WhatsappAdUncheckedCreateNestedManyWithoutAssignedCustomersInput
    scheduleHours?: ScheduleHourUncheckedCreateNestedManyWithoutStaffInput
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutStaffInput
    vacations?: VacationUncheckedCreateNestedManyWithoutStaffInput
    staffMembers?: UserUncheckedCreateNestedManyWithoutManagerInput
    statusLogs?: StaffStatusLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type StepCreateWithoutSessionsInput = {
    id?: string
    order: number
    type: $Enums.StepType
    message?: string | null
    dynamicSource?: $Enums.DynamicSource
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    flow: FlowCreateNestedOneWithoutStepsInput
    options?: StepOptionCreateNestedManyWithoutStepInput
    logs?: LogCreateNestedManyWithoutStepInput
    nextStepOptions?: StepOptionCreateNestedManyWithoutNextStepInput
  }

  export type StepUncheckedCreateWithoutSessionsInput = {
    id?: string
    flowId: string
    order: number
    type: $Enums.StepType
    message?: string | null
    dynamicSource?: $Enums.DynamicSource
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    options?: StepOptionUncheckedCreateNestedManyWithoutStepInput
    logs?: LogUncheckedCreateNestedManyWithoutStepInput
    nextStepOptions?: StepOptionUncheckedCreateNestedManyWithoutNextStepInput
  }

  export type StepCreateOrConnectWithoutSessionsInput = {
    where: StepWhereUniqueInput
    create: XOR<StepCreateWithoutSessionsInput, StepUncheckedCreateWithoutSessionsInput>
  }

  export type LogCreateWithoutSessionInput = {
    id?: string
    message: string
    direction: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    step?: StepCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateWithoutSessionInput = {
    id?: string
    stepId?: string | null
    message: string
    direction: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type LogCreateOrConnectWithoutSessionInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutSessionInput, LogUncheckedCreateWithoutSessionInput>
  }

  export type LogCreateManySessionInputEnvelope = {
    data: LogCreateManySessionInput | LogCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type FlowUpsertWithoutSessionsInput = {
    update: XOR<FlowUpdateWithoutSessionsInput, FlowUncheckedUpdateWithoutSessionsInput>
    create: XOR<FlowCreateWithoutSessionsInput, FlowUncheckedCreateWithoutSessionsInput>
    where?: FlowWhereInput
  }

  export type FlowUpdateToOneWithWhereWithoutSessionsInput = {
    where?: FlowWhereInput
    data: XOR<FlowUpdateWithoutSessionsInput, FlowUncheckedUpdateWithoutSessionsInput>
  }

  export type FlowUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    business?: BusinessUpdateOneWithoutFlowsNestedInput
    steps?: StepUpdateManyWithoutFlowNestedInput
    whatsappNumbers?: WhatsAppNumberUpdateManyWithoutDefaultFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    steps?: StepUncheckedUpdateManyWithoutFlowNestedInput
    whatsappNumbers?: WhatsAppNumberUncheckedUpdateManyWithoutDefaultFlowNestedInput
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StepUpsertWithoutSessionsInput = {
    update: XOR<StepUpdateWithoutSessionsInput, StepUncheckedUpdateWithoutSessionsInput>
    create: XOR<StepCreateWithoutSessionsInput, StepUncheckedCreateWithoutSessionsInput>
    where?: StepWhereInput
  }

  export type StepUpdateToOneWithWhereWithoutSessionsInput = {
    where?: StepWhereInput
    data: XOR<StepUpdateWithoutSessionsInput, StepUncheckedUpdateWithoutSessionsInput>
  }

  export type StepUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    flow?: FlowUpdateOneRequiredWithoutStepsNestedInput
    options?: StepOptionUpdateManyWithoutStepNestedInput
    logs?: LogUpdateManyWithoutStepNestedInput
    nextStepOptions?: StepOptionUpdateManyWithoutNextStepNestedInput
  }

  export type StepUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    options?: StepOptionUncheckedUpdateManyWithoutStepNestedInput
    logs?: LogUncheckedUpdateManyWithoutStepNestedInput
    nextStepOptions?: StepOptionUncheckedUpdateManyWithoutNextStepNestedInput
  }

  export type LogUpsertWithWhereUniqueWithoutSessionInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutSessionInput, LogUncheckedUpdateWithoutSessionInput>
    create: XOR<LogCreateWithoutSessionInput, LogUncheckedCreateWithoutSessionInput>
  }

  export type LogUpdateWithWhereUniqueWithoutSessionInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutSessionInput, LogUncheckedUpdateWithoutSessionInput>
  }

  export type LogUpdateManyWithWhereWithoutSessionInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionCreateWithoutLogsInput = {
    id?: string
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    flow: FlowCreateNestedOneWithoutSessionsInput
    user: UserCreateNestedOneWithoutSessionsInput
    currentStep?: StepCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutLogsInput = {
    id?: string
    userId: string
    flowId: string
    currentStepId?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type SessionCreateOrConnectWithoutLogsInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutLogsInput, SessionUncheckedCreateWithoutLogsInput>
  }

  export type StepCreateWithoutLogsInput = {
    id?: string
    order: number
    type: $Enums.StepType
    message?: string | null
    dynamicSource?: $Enums.DynamicSource
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    flow: FlowCreateNestedOneWithoutStepsInput
    options?: StepOptionCreateNestedManyWithoutStepInput
    sessions?: SessionCreateNestedManyWithoutCurrentStepInput
    nextStepOptions?: StepOptionCreateNestedManyWithoutNextStepInput
  }

  export type StepUncheckedCreateWithoutLogsInput = {
    id?: string
    flowId: string
    order: number
    type: $Enums.StepType
    message?: string | null
    dynamicSource?: $Enums.DynamicSource
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
    options?: StepOptionUncheckedCreateNestedManyWithoutStepInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCurrentStepInput
    nextStepOptions?: StepOptionUncheckedCreateNestedManyWithoutNextStepInput
  }

  export type StepCreateOrConnectWithoutLogsInput = {
    where: StepWhereUniqueInput
    create: XOR<StepCreateWithoutLogsInput, StepUncheckedCreateWithoutLogsInput>
  }

  export type SessionUpsertWithoutLogsInput = {
    update: XOR<SessionUpdateWithoutLogsInput, SessionUncheckedUpdateWithoutLogsInput>
    create: XOR<SessionCreateWithoutLogsInput, SessionUncheckedCreateWithoutLogsInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutLogsInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutLogsInput, SessionUncheckedUpdateWithoutLogsInput>
  }

  export type SessionUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    flow?: FlowUpdateOneRequiredWithoutSessionsNestedInput
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    currentStep?: StepUpdateOneWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StepUpsertWithoutLogsInput = {
    update: XOR<StepUpdateWithoutLogsInput, StepUncheckedUpdateWithoutLogsInput>
    create: XOR<StepCreateWithoutLogsInput, StepUncheckedCreateWithoutLogsInput>
    where?: StepWhereInput
  }

  export type StepUpdateToOneWithWhereWithoutLogsInput = {
    where?: StepWhereInput
    data: XOR<StepUpdateWithoutLogsInput, StepUncheckedUpdateWithoutLogsInput>
  }

  export type StepUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    flow?: FlowUpdateOneRequiredWithoutStepsNestedInput
    options?: StepOptionUpdateManyWithoutStepNestedInput
    sessions?: SessionUpdateManyWithoutCurrentStepNestedInput
    nextStepOptions?: StepOptionUpdateManyWithoutNextStepNestedInput
  }

  export type StepUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    options?: StepOptionUncheckedUpdateManyWithoutStepNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCurrentStepNestedInput
    nextStepOptions?: StepOptionUncheckedUpdateManyWithoutNextStepNestedInput
  }

  export type UserCreateManySubscriberInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type UserOnServiceCreateManyProviderInput = {
    id?: string
    serviceId: string
  }

  export type AppointmentCreateManyConsumerInput = {
    id?: string
    serviceId: string
    branchId: string
    serviceProviderId?: string | null
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    discountId?: string | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    subscriberSubscriptionId?: string | null
    promotionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AppointmentCreateManyServiceProviderInput = {
    id?: string
    serviceId: string
    consumerId: string
    branchId: string
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    discountId?: string | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    subscriberSubscriptionId?: string | null
    promotionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type BusinessCreateManySubscriberInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    discountCodeId?: string | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type BranchCreateManySubscriberInput = {
    id?: string
    name: string
    businessId?: string | null
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type SubscriberSubscriptionCreateManySubscriberInput = {
    id?: string
    subscriptionId: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    businessId?: string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ScheduleHourCreateManyStaffInput = {
    id?: string
    ownerType: $Enums.ScheduleOwnerType
    ownerId: string
    dayOfWeek: $Enums.WeekDay
    openTime: string
    closeTime: string
    isClosed?: boolean
    inheritanceMode?: $Enums.ScheduleInheritanceMode
    businessId?: string | null
    branchId?: string | null
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    flowId: string
    currentStepId?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type AttendanceCreateManyStaffInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type VacationCreateManyStaffInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status: $Enums.VacationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type UserCreateManyManagerInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    branchId?: string | null
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type StaffStatusLogCreateManyUserInput = {
    id?: string
    status: $Enums.StaffStatus
    timestamp?: Date | string
  }

  export type UserUpdateWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserOnServiceUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: ServiceUpdateOneRequiredWithoutProvidersNestedInput
  }

  export type UserOnServiceUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type UserOnServiceUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentUpdateWithoutConsumerInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotion?: PromotionUpdateOneWithoutAppointmentsNestedInput
    subscriberSubscription?: SubscriberSubscriptionUpdateOneWithoutAppointmentsNestedInput
    discount?: DiscountUpdateOneWithoutAppointmentsNestedInput
    service?: ServiceUpdateOneRequiredWithoutAppointmentsNestedInput
    serviceProvider?: UserUpdateOneWithoutAppointmentsAsProviderNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutConsumerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    subscriberSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutConsumerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    subscriberSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotion?: PromotionUpdateOneWithoutAppointmentsNestedInput
    subscriberSubscription?: SubscriberSubscriptionUpdateOneWithoutAppointmentsNestedInput
    discount?: DiscountUpdateOneWithoutAppointmentsNestedInput
    service?: ServiceUpdateOneRequiredWithoutAppointmentsNestedInput
    consumer?: UserUpdateOneRequiredWithoutAppointmentsAsConsumerNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    consumerId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    subscriberSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    consumerId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    subscriberSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessUpdateWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUpdateManyWithoutBusinessNestedInput
    whatsappNumbers?: WhatsAppNumberUpdateManyWithoutBusinessNestedInput
    discountCode?: DiscountUpdateOneWithoutBusinessesNestedInput
    branches?: BranchUpdateManyWithoutBusinessNestedInput
    subscription?: SubscriptionUpdateOneWithoutBusinessesNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    discountCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUncheckedUpdateManyWithoutBusinessNestedInput
    whatsappNumbers?: WhatsAppNumberUncheckedUpdateManyWithoutBusinessNestedInput
    branches?: BranchUncheckedUpdateManyWithoutBusinessNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateManyWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    discountCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BranchUpdateWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessUpdateOneWithoutBranchesNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUncheckedUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUncheckedUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriberSubscriptionUpdateWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessUpdateOneWithoutSubscriberSubscriptionsNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutSubscriberSubscriptionsNestedInput
    appointments?: AppointmentUpdateManyWithoutSubscriberSubscriptionNestedInput
    discountLogs?: SubscriptionDiscountLogUpdateManyWithoutSubscriberSubscriptionNestedInput
  }

  export type SubscriberSubscriptionUncheckedUpdateWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutSubscriberSubscriptionNestedInput
    discountLogs?: SubscriptionDiscountLogUncheckedUpdateManyWithoutSubscriberSubscriptionNestedInput
  }

  export type SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsappAdUpdateWithoutAssignedCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerType?: EnumAdTargetTypeFieldUpdateOperationsInput | $Enums.AdTargetType
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneRequiredWithoutWhatsappAdsNestedInput
    service?: ServiceUpdateOneWithoutWhatsappAdsNestedInput
  }

  export type WhatsappAdUncheckedUpdateWithoutAssignedCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerType?: EnumAdTargetTypeFieldUpdateOperationsInput | $Enums.AdTargetType
    branchId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerType?: EnumAdTargetTypeFieldUpdateOperationsInput | $Enums.AdTargetType
    branchId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleHourUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumScheduleOwnerTypeFieldUpdateOperationsInput | $Enums.ScheduleOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFieldUpdateOperationsInput | $Enums.ScheduleInheritanceMode
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessUpdateOneWithoutScheduleHoursNestedInput
    branch?: BranchUpdateOneWithoutScheduleHoursNestedInput
  }

  export type ScheduleHourUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumScheduleOwnerTypeFieldUpdateOperationsInput | $Enums.ScheduleOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFieldUpdateOperationsInput | $Enums.ScheduleInheritanceMode
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleHourUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumScheduleOwnerTypeFieldUpdateOperationsInput | $Enums.ScheduleOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFieldUpdateOperationsInput | $Enums.ScheduleInheritanceMode
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    flow?: FlowUpdateOneRequiredWithoutSessionsNestedInput
    currentStep?: StepUpdateOneWithoutSessionsNestedInput
    logs?: LogUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    logs?: LogUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttendanceUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VacationUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVacationStatusFieldUpdateOperationsInput | $Enums.VacationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VacationUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVacationStatusFieldUpdateOperationsInput | $Enums.VacationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VacationUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVacationStatusFieldUpdateOperationsInput | $Enums.VacationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StaffStatusLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStaffStatusFieldUpdateOperationsInput | $Enums.StaffStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffStatusLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStaffStatusFieldUpdateOperationsInput | $Enums.StaffStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffStatusLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStaffStatusFieldUpdateOperationsInput | $Enums.StaffStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriberSubscriptionCreateManySubscriptionInput = {
    id?: string
    subscriberId: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    businessId?: string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type BusinessCreateManySubscriptionInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    discountCodeId?: string | null
    subscriberId?: string | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type SubscriberSubscriptionUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessUpdateOneWithoutSubscriberSubscriptionsNestedInput
    subscriber?: UserUpdateOneRequiredWithoutSubscriberSubscriptionsNestedInput
    appointments?: AppointmentUpdateManyWithoutSubscriberSubscriptionNestedInput
    discountLogs?: SubscriptionDiscountLogUpdateManyWithoutSubscriberSubscriptionNestedInput
  }

  export type SubscriberSubscriptionUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutSubscriberSubscriptionNestedInput
    discountLogs?: SubscriptionDiscountLogUncheckedUpdateManyWithoutSubscriberSubscriptionNestedInput
  }

  export type SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUpdateManyWithoutBusinessNestedInput
    whatsappNumbers?: WhatsAppNumberUpdateManyWithoutBusinessNestedInput
    subscriber?: UserUpdateOneWithoutBusinessesNestedInput
    discountCode?: DiscountUpdateOneWithoutBusinessesNestedInput
    branches?: BranchUpdateManyWithoutBusinessNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    discountCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUncheckedUpdateManyWithoutBusinessNestedInput
    whatsappNumbers?: WhatsAppNumberUncheckedUpdateManyWithoutBusinessNestedInput
    branches?: BranchUncheckedUpdateManyWithoutBusinessNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    discountCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentCreateManySubscriberSubscriptionInput = {
    id?: string
    serviceId: string
    consumerId: string
    branchId: string
    serviceProviderId?: string | null
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    discountId?: string | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    promotionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type SubscriptionDiscountLogCreateManySubscriberSubscriptionInput = {
    id?: string
    discountId: string
    discountCode: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountedAmount: number
    originalPrice: number
    finalPrice: number
    appliedAt?: Date | string
    createdBy?: string | null
  }

  export type AppointmentUpdateWithoutSubscriberSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotion?: PromotionUpdateOneWithoutAppointmentsNestedInput
    discount?: DiscountUpdateOneWithoutAppointmentsNestedInput
    service?: ServiceUpdateOneRequiredWithoutAppointmentsNestedInput
    consumer?: UserUpdateOneRequiredWithoutAppointmentsAsConsumerNestedInput
    serviceProvider?: UserUpdateOneWithoutAppointmentsAsProviderNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutSubscriberSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    consumerId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutSubscriberSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    consumerId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionDiscountLogUpdateWithoutSubscriberSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountedAmount?: FloatFieldUpdateOperationsInput | number
    originalPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: DiscountUpdateOneRequiredWithoutSubscriptionDiscountLogsNestedInput
  }

  export type SubscriptionDiscountLogUncheckedUpdateWithoutSubscriberSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountId?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountedAmount?: FloatFieldUpdateOperationsInput | number
    originalPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionDiscountLogUncheckedUpdateManyWithoutSubscriberSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountId?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountedAmount?: FloatFieldUpdateOperationsInput | number
    originalPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessCreateManyDiscountCodeInput = {
    id?: string
    businessId: number
    name: string
    image?: string | null
    websiteLink?: string | null
    phoneNumber?: string | null
    businessType: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionType?: $Enums.SubscriptionType | null
    subscriptionPrice?: number | null
    subscriptionValidity?: $Enums.SubscriptionValidity | null
    subscriberId?: string | null
    status?: $Enums.BusinessStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AppointmentCreateManyDiscountInput = {
    id?: string
    serviceId: string
    consumerId: string
    branchId: string
    serviceProviderId?: string | null
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    subscriberSubscriptionId?: string | null
    promotionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type SubscriptionDiscountLogCreateManyDiscountInput = {
    id?: string
    subscriberSubscriptionId: string
    discountCode: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountedAmount: number
    originalPrice: number
    finalPrice: number
    appliedAt?: Date | string
    createdBy?: string | null
  }

  export type BusinessUpdateWithoutDiscountCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUpdateManyWithoutBusinessNestedInput
    whatsappNumbers?: WhatsAppNumberUpdateManyWithoutBusinessNestedInput
    subscriber?: UserUpdateOneWithoutBusinessesNestedInput
    branches?: BranchUpdateManyWithoutBusinessNestedInput
    subscription?: SubscriptionUpdateOneWithoutBusinessesNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutDiscountCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flows?: FlowUncheckedUpdateManyWithoutBusinessNestedInput
    whatsappNumbers?: WhatsAppNumberUncheckedUpdateManyWithoutBusinessNestedInput
    branches?: BranchUncheckedUpdateManyWithoutBusinessNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateManyWithoutDiscountCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: NullableEnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType | null
    subscriptionPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionValidity?: NullableEnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUpdateWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotion?: PromotionUpdateOneWithoutAppointmentsNestedInput
    subscriberSubscription?: SubscriberSubscriptionUpdateOneWithoutAppointmentsNestedInput
    service?: ServiceUpdateOneRequiredWithoutAppointmentsNestedInput
    consumer?: UserUpdateOneRequiredWithoutAppointmentsAsConsumerNestedInput
    serviceProvider?: UserUpdateOneWithoutAppointmentsAsProviderNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    consumerId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    subscriberSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    consumerId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    subscriberSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionDiscountLogUpdateWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountedAmount?: FloatFieldUpdateOperationsInput | number
    originalPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberSubscription?: SubscriberSubscriptionUpdateOneRequiredWithoutDiscountLogsNestedInput
  }

  export type SubscriptionDiscountLogUncheckedUpdateWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberSubscriptionId?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountedAmount?: FloatFieldUpdateOperationsInput | number
    originalPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionDiscountLogUncheckedUpdateManyWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberSubscriptionId?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountedAmount?: FloatFieldUpdateOperationsInput | number
    originalPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlowCreateManyBusinessInput = {
    id?: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type WhatsAppNumberCreateManyBusinessInput = {
    id?: string
    phoneNumber: string
    phoneNumberId?: string | null
    wabaId?: string | null
    accessToken?: string | null
    isVerified?: boolean
    defaultFlowId?: string | null
    otp?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type BranchCreateManyBusinessInput = {
    id?: string
    name: string
    subscriberId: string
    location?: string | null
    phone?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type SubscriberSubscriptionCreateManyBusinessInput = {
    id?: string
    subscriberId: string
    subscriptionId: string
    type: $Enums.SubscriptionType
    validity: $Enums.SubscriptionValidity
    price: number
    features: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ScheduleHourCreateManyBusinessInput = {
    id?: string
    ownerType: $Enums.ScheduleOwnerType
    ownerId: string
    dayOfWeek: $Enums.WeekDay
    openTime: string
    closeTime: string
    isClosed?: boolean
    inheritanceMode?: $Enums.ScheduleInheritanceMode
    staffId?: string | null
    branchId?: string | null
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type FlowUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    steps?: StepUpdateManyWithoutFlowNestedInput
    sessions?: SessionUpdateManyWithoutFlowNestedInput
    whatsappNumbers?: WhatsAppNumberUpdateManyWithoutDefaultFlowNestedInput
  }

  export type FlowUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    steps?: StepUncheckedUpdateManyWithoutFlowNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutFlowNestedInput
    whatsappNumbers?: WhatsAppNumberUncheckedUpdateManyWithoutDefaultFlowNestedInput
  }

  export type FlowUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WhatsAppNumberUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: NullableStringFieldUpdateOperationsInput | string | null
    wabaId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    defaultFlow?: FlowUpdateOneWithoutWhatsappNumbersNestedInput
  }

  export type WhatsAppNumberUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: NullableStringFieldUpdateOperationsInput | string | null
    wabaId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    defaultFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WhatsAppNumberUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: NullableStringFieldUpdateOperationsInput | string | null
    wabaId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    defaultFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BranchUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneRequiredWithoutOwnedBranchesNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutBranchesNestedInput
    tabletAccounts?: TabletAccountUncheckedUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUncheckedUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriberSubscriptionUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneRequiredWithoutSubscriberSubscriptionsNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutSubscriberSubscriptionsNestedInput
    appointments?: AppointmentUpdateManyWithoutSubscriberSubscriptionNestedInput
    discountLogs?: SubscriptionDiscountLogUpdateManyWithoutSubscriberSubscriptionNestedInput
  }

  export type SubscriberSubscriptionUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutSubscriberSubscriptionNestedInput
    discountLogs?: SubscriptionDiscountLogUncheckedUpdateManyWithoutSubscriberSubscriptionNestedInput
  }

  export type SubscriberSubscriptionUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    validity?: EnumSubscriptionValidityFieldUpdateOperationsInput | $Enums.SubscriptionValidity
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleHourUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumScheduleOwnerTypeFieldUpdateOperationsInput | $Enums.ScheduleOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFieldUpdateOperationsInput | $Enums.ScheduleInheritanceMode
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: UserUpdateOneWithoutScheduleHoursNestedInput
    branch?: BranchUpdateOneWithoutScheduleHoursNestedInput
  }

  export type ScheduleHourUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumScheduleOwnerTypeFieldUpdateOperationsInput | $Enums.ScheduleOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFieldUpdateOperationsInput | $Enums.ScheduleInheritanceMode
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleHourUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumScheduleOwnerTypeFieldUpdateOperationsInput | $Enums.ScheduleOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFieldUpdateOperationsInput | $Enums.ScheduleInheritanceMode
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyBranchInput = {
    id?: string
    firstName?: string
    lastName?: string
    email: string
    password: string
    phone?: string
    role?: $Enums.UserRole
    subscriberId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: boolean
    managerId?: string | null
    x?: string | null
    instagram?: string | null
    fb?: string | null
    whatsapp?: string | null
    language?: string | null
    isLoggedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ServiceBranchCreateManyBranchInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AppointmentCreateManyBranchInput = {
    id?: string
    serviceId: string
    consumerId: string
    serviceProviderId?: string | null
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    discountId?: string | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    subscriberSubscriptionId?: string | null
    promotionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TabletAccountCreateManyBranchInput = {
    id?: string
    username: string
    password: string
    loginLink?: string | null
    loginToken: string
    isActive?: boolean
    isLoggedIn?: boolean
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type WhatsappAdCreateManyBranchInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    targetDate: Date | string
    customerType: $Enums.AdTargetType
    serviceId?: string | null
    status?: $Enums.AdStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ScheduleHourCreateManyBranchInput = {
    id?: string
    ownerType: $Enums.ScheduleOwnerType
    ownerId: string
    dayOfWeek: $Enums.WeekDay
    openTime: string
    closeTime: string
    isClosed?: boolean
    inheritanceMode?: $Enums.ScheduleInheritanceMode
    staffId?: string | null
    businessId?: string | null
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type UserUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    assignedWhatsappAds?: WhatsappAdUncheckedUpdateManyWithoutAssignedCustomersNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceBranchUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceUpdateOneRequiredWithoutBranchesNestedInput
  }

  export type ServiceBranchUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceBranchUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotion?: PromotionUpdateOneWithoutAppointmentsNestedInput
    subscriberSubscription?: SubscriberSubscriptionUpdateOneWithoutAppointmentsNestedInput
    discount?: DiscountUpdateOneWithoutAppointmentsNestedInput
    service?: ServiceUpdateOneRequiredWithoutAppointmentsNestedInput
    consumer?: UserUpdateOneRequiredWithoutAppointmentsAsConsumerNestedInput
    serviceProvider?: UserUpdateOneWithoutAppointmentsAsProviderNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    consumerId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    subscriberSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    consumerId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    subscriberSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateManyWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: FloatFieldUpdateOperationsInput | number
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TabletAccountUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    loginLink?: NullableStringFieldUpdateOperationsInput | string | null
    loginToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TabletAccountUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    loginLink?: NullableStringFieldUpdateOperationsInput | string | null
    loginToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TabletAccountUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    loginLink?: NullableStringFieldUpdateOperationsInput | string | null
    loginToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsappAdUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerType?: EnumAdTargetTypeFieldUpdateOperationsInput | $Enums.AdTargetType
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceUpdateOneWithoutWhatsappAdsNestedInput
    assignedCustomers?: UserUpdateManyWithoutAssignedWhatsappAdsNestedInput
  }

  export type WhatsappAdUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerType?: EnumAdTargetTypeFieldUpdateOperationsInput | $Enums.AdTargetType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedCustomers?: UserUncheckedUpdateManyWithoutAssignedWhatsappAdsNestedInput
  }

  export type WhatsappAdUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerType?: EnumAdTargetTypeFieldUpdateOperationsInput | $Enums.AdTargetType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleHourUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumScheduleOwnerTypeFieldUpdateOperationsInput | $Enums.ScheduleOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFieldUpdateOperationsInput | $Enums.ScheduleInheritanceMode
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: UserUpdateOneWithoutScheduleHoursNestedInput
    business?: BusinessUpdateOneWithoutScheduleHoursNestedInput
  }

  export type ScheduleHourUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumScheduleOwnerTypeFieldUpdateOperationsInput | $Enums.ScheduleOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFieldUpdateOperationsInput | $Enums.ScheduleInheritanceMode
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleHourUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumScheduleOwnerTypeFieldUpdateOperationsInput | $Enums.ScheduleOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDayFieldUpdateOperationsInput | $Enums.WeekDay
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    inheritanceMode?: EnumScheduleInheritanceModeFieldUpdateOperationsInput | $Enums.ScheduleInheritanceMode
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserOnServiceCreateManyServiceInput = {
    id?: string
    providerId: string
  }

  export type ServiceBranchCreateManyServiceInput = {
    id?: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type AppointmentCreateManyServiceInput = {
    id?: string
    consumerId: string
    branchId: string
    serviceProviderId?: string | null
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    discountId?: string | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    subscriberSubscriptionId?: string | null
    promotionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type WhatsappAdCreateManyServiceInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    targetDate: Date | string
    customerType: $Enums.AdTargetType
    branchId: string
    status?: $Enums.AdStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type UserOnServiceUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: UserUpdateOneRequiredWithoutServicesNestedInput
  }

  export type UserOnServiceUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type UserOnServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceBranchUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneRequiredWithoutServiceBranchesNestedInput
  }

  export type ServiceBranchUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceBranchUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotion?: PromotionUpdateOneWithoutAppointmentsNestedInput
    subscriberSubscription?: SubscriberSubscriptionUpdateOneWithoutAppointmentsNestedInput
    discount?: DiscountUpdateOneWithoutAppointmentsNestedInput
    consumer?: UserUpdateOneRequiredWithoutAppointmentsAsConsumerNestedInput
    serviceProvider?: UserUpdateOneWithoutAppointmentsAsProviderNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    consumerId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    subscriberSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    consumerId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    subscriberSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsappAdUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerType?: EnumAdTargetTypeFieldUpdateOperationsInput | $Enums.AdTargetType
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneRequiredWithoutWhatsappAdsNestedInput
    assignedCustomers?: UserUpdateManyWithoutAssignedWhatsappAdsNestedInput
  }

  export type WhatsappAdUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerType?: EnumAdTargetTypeFieldUpdateOperationsInput | $Enums.AdTargetType
    branchId?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedCustomers?: UserUncheckedUpdateManyWithoutAssignedWhatsappAdsNestedInput
  }

  export type WhatsappAdUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerType?: EnumAdTargetTypeFieldUpdateOperationsInput | $Enums.AdTargetType
    branchId?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentCreateManyPromotionInput = {
    id?: string
    serviceId: string
    consumerId: string
    branchId: string
    serviceProviderId?: string | null
    appointmentTime: Date | string
    appointmentDate?: Date | string | null
    appointmentTimeSlot?: string | null
    reminderMinutesBefore?: number | null
    discountId?: string | null
    note?: string | null
    status?: $Enums.AppointmentStatus
    bookingType?: $Enums.AppointmentBookingType | null
    review?: string | null
    rating?: number | null
    isManual?: boolean
    price?: number | null
    subscriberSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type BranchUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneRequiredWithoutOwnedBranchesNestedInput
    business?: BusinessUpdateOneWithoutBranchesNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    tabletAccounts?: TabletAccountUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    tabletAccounts?: TabletAccountUncheckedUpdateManyWithoutBranchNestedInput
    whatsappAds?: WhatsappAdUncheckedUpdateManyWithoutBranchNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUpdateWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberSubscription?: SubscriberSubscriptionUpdateOneWithoutAppointmentsNestedInput
    discount?: DiscountUpdateOneWithoutAppointmentsNestedInput
    service?: ServiceUpdateOneRequiredWithoutAppointmentsNestedInput
    consumer?: UserUpdateOneRequiredWithoutAppointmentsAsConsumerNestedInput
    serviceProvider?: UserUpdateOneWithoutAppointmentsAsProviderNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    consumerId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    subscriberSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    consumerId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    reminderMinutesBefore?: NullableIntFieldUpdateOperationsInput | number | null
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    bookingType?: NullableEnumAppointmentBookingTypeFieldUpdateOperationsInput | $Enums.AppointmentBookingType | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isManual?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    subscriberSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutAssignedWhatsappAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriber?: UserUpdateOneWithoutSubscriberMembersNestedInput
    subscriberMembers?: UserUpdateManyWithoutSubscriberNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    services?: UserOnServiceUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUpdateOneWithoutSubscriberNestedInput
    scheduleHours?: ScheduleHourUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUpdateManyWithoutStaffNestedInput
    vacations?: VacationUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUpdateManyWithoutManagerNestedInput
    manager?: UserUpdateOneWithoutStaffMembersNestedInput
    statusLogs?: StaffStatusLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedWhatsappAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberMembers?: UserUncheckedUpdateManyWithoutSubscriberNestedInput
    services?: UserOnServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointmentsAsConsumer?: AppointmentUncheckedUpdateManyWithoutConsumerNestedInput
    appointmentsAsProvider?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriberNestedInput
    ownedBranches?: BranchUncheckedUpdateManyWithoutSubscriberNestedInput
    subscriberSubscriptions?: SubscriberSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutSubscriberNestedInput
    scheduleHours?: ScheduleHourUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutStaffNestedInput
    vacations?: VacationUncheckedUpdateManyWithoutStaffNestedInput
    staffMembers?: UserUncheckedUpdateManyWithoutManagerNestedInput
    statusLogs?: StaffStatusLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAssignedWhatsappAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    availability?: NullableJsonNullValueInput | InputJsonValue
    usesBranchSchedule?: BoolFieldUpdateOperationsInput | boolean
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    fb?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StepCreateManyFlowInput = {
    id?: string
    order: number
    type: $Enums.StepType
    message?: string | null
    dynamicSource?: $Enums.DynamicSource
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type SessionCreateManyFlowInput = {
    id?: string
    userId: string
    currentStepId?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type WhatsAppNumberCreateManyDefaultFlowInput = {
    id?: string
    businessId: string
    phoneNumber: string
    phoneNumberId?: string | null
    wabaId?: string | null
    accessToken?: string | null
    isVerified?: boolean
    otp?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type StepUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    options?: StepOptionUpdateManyWithoutStepNestedInput
    sessions?: SessionUpdateManyWithoutCurrentStepNestedInput
    logs?: LogUpdateManyWithoutStepNestedInput
    nextStepOptions?: StepOptionUpdateManyWithoutNextStepNestedInput
  }

  export type StepUncheckedUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    options?: StepOptionUncheckedUpdateManyWithoutStepNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCurrentStepNestedInput
    logs?: LogUncheckedUpdateManyWithoutStepNestedInput
    nextStepOptions?: StepOptionUncheckedUpdateManyWithoutNextStepNestedInput
  }

  export type StepUncheckedUpdateManyWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    dynamicSource?: EnumDynamicSourceFieldUpdateOperationsInput | $Enums.DynamicSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    currentStep?: StepUpdateOneWithoutSessionsNestedInput
    logs?: LogUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    logs?: LogUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateManyWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WhatsAppNumberUpdateWithoutDefaultFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: NullableStringFieldUpdateOperationsInput | string | null
    wabaId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    business?: BusinessUpdateOneRequiredWithoutWhatsappNumbersNestedInput
  }

  export type WhatsAppNumberUncheckedUpdateWithoutDefaultFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: NullableStringFieldUpdateOperationsInput | string | null
    wabaId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WhatsAppNumberUncheckedUpdateManyWithoutDefaultFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: NullableStringFieldUpdateOperationsInput | string | null
    wabaId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StepOptionCreateManyStepInput = {
    id?: string
    label: string
    value: string
    nextStepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type SessionCreateManyCurrentStepInput = {
    id?: string
    userId: string
    flowId: string
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type LogCreateManyStepInput = {
    id?: string
    sessionId: string
    message: string
    direction: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type StepOptionCreateManyNextStepInput = {
    id?: string
    stepId: string
    label: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    DeletedBy?: string | null
    DeletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type StepOptionUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    nextStep?: StepUpdateOneWithoutNextStepOptionsNestedInput
  }

  export type StepOptionUncheckedUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    nextStepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StepOptionUncheckedUpdateManyWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    nextStepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUpdateWithoutCurrentStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    flow?: FlowUpdateOneRequiredWithoutSessionsNestedInput
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    logs?: LogUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutCurrentStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    logs?: LogUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateManyWithoutCurrentStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LogUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StepOptionUpdateWithoutNextStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    step?: StepUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type StepOptionUncheckedUpdateWithoutNextStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StepOptionUncheckedUpdateManyWithoutNextStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LogCreateManySessionInput = {
    id?: string
    stepId?: string | null
    message: string
    direction: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type LogUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    step?: StepUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}