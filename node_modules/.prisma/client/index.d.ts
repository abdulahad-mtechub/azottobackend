
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "User"
  objects: {
    wallet: AztoWalletPayload<ExtArgs> | null
    auditLogs: AuditLogPayload<ExtArgs>[]
    aiQuotas: AIQuotaPayload<ExtArgs>[]
    aiDecisions: AIDecisionPayload<ExtArgs>[]
    chainTxs: BlockchainTransactionPayload<ExtArgs>[]
    alerts: AlertPayload<ExtArgs>[]
    documents: DocumentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string | null
    email: string | null
    password: string | null
    role: UserRole
    walletAddress: string | null
    signature: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model User
 * 
 */
export type User = runtime.Types.DefaultSelection<UserPayload>
export type AztoWalletPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "AztoWallet"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    balance: Prisma.Decimal
    userId: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
  }, ExtArgs["result"]["aztoWallet"]>
  composites: {}
}

/**
 * Model AztoWallet
 * 
 */
export type AztoWallet = runtime.Types.DefaultSelection<AztoWalletPayload>
export type VinPassportPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "VinPassport"
  objects: {
    invoices: InvoicePayload<ExtArgs>[]
    gasSettlements: GasSettlementPayload<ExtArgs>[]
    auditLogs: AuditLogPayload<ExtArgs>[]
    onChainProofs: OnChainProofPayload<ExtArgs>[]
    documents: DocumentPayload<ExtArgs>[]
    conditionMatrices: ConditionMatrixPayload<ExtArgs>[]
    mechanicalHealths: MechanicalHealthPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    vin: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
  }, ExtArgs["result"]["vinPassport"]>
  composites: {}
}

/**
 * Model VinPassport
 * 
 */
export type VinPassport = runtime.Types.DefaultSelection<VinPassportPayload>
export type GasSettlementPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "GasSettlement"
  objects: {
    vinPassport: VinPassportPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    amount: Prisma.Decimal
    vinPassportId: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
  }, ExtArgs["result"]["gasSettlement"]>
  composites: {}
}

/**
 * Model GasSettlement
 * 
 */
export type GasSettlement = runtime.Types.DefaultSelection<GasSettlementPayload>
export type InvoicePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Invoice"
  objects: {
    vinPassport: VinPassportPayload<ExtArgs> | null
    documents: DocumentPayload<ExtArgs>[]
    parts: NormalizedPartPayload<ExtArgs>[]
    auditLogs: AuditLogPayload<ExtArgs>[]
    onChainProofs: OnChainProofPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    number: string
    status: TxStatus
    vinPassportId: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
  }, ExtArgs["result"]["invoice"]>
  composites: {}
}

/**
 * Model Invoice
 * 
 */
export type Invoice = runtime.Types.DefaultSelection<InvoicePayload>
export type NormalizedPartPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "NormalizedPart"
  objects: {
    invoice: InvoicePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    price: Prisma.Decimal
    invoiceId: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
  }, ExtArgs["result"]["normalizedPart"]>
  composites: {}
}

/**
 * Model NormalizedPart
 * 
 */
export type NormalizedPart = runtime.Types.DefaultSelection<NormalizedPartPayload>
export type AIDecisionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "AIDecision"
  objects: {
    user: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    entityType: EntityType
    entityId: string
    model: string
    promptHash: string
    responseHash: string
    decision: string
    confidence: number | null
    metadata: Prisma.JsonValue | null
    userId: string | null
    createdAt: Date
  }, ExtArgs["result"]["aIDecision"]>
  composites: {}
}

/**
 * Model AIDecision
 * 
 */
export type AIDecision = runtime.Types.DefaultSelection<AIDecisionPayload>
export type AIQuotaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "AIQuota"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    invoicesProcessed: number
    rejectedCount: number
    periodStart: Date
    periodEnd: Date
  }, ExtArgs["result"]["aIQuota"]>
  composites: {}
}

/**
 * Model AIQuota
 * 
 */
export type AIQuota = runtime.Types.DefaultSelection<AIQuotaPayload>
export type ConditionMatrixPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ConditionMatrix"
  objects: {
    vinPassport: VinPassportPayload<ExtArgs> | null
    auditLogs: AuditLogPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    vinPassportId: string | null
    version: string
    rulesHash: string
    effectiveFrom: Date
    isActive: boolean
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }, ExtArgs["result"]["conditionMatrix"]>
  composites: {}
}

/**
 * Model ConditionMatrix
 * 
 */
export type ConditionMatrix = runtime.Types.DefaultSelection<ConditionMatrixPayload>
export type SystemStatePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "SystemState"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    key: string
    value: string
    updatedAt: Date
    updatedBy: string | null
  }, ExtArgs["result"]["systemState"]>
  composites: {}
}

/**
 * Model SystemState
 * 
 */
export type SystemState = runtime.Types.DefaultSelection<SystemStatePayload>
export type BlockchainTransactionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "BlockchainTransaction"
  objects: {
    user: UserPayload<ExtArgs> | null
    auditLogs: AuditLogPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    chain: string
    contract: string
    txHash: string
    blockNumber: bigint | null
    eventName: string | null
    status: TxStatus
    entityType: EntityType
    entityId: string
    payload: Prisma.JsonValue
    confirmations: number
    userId: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["blockchainTransaction"]>
  composites: {}
}

/**
 * Model BlockchainTransaction
 * 
 */
export type BlockchainTransaction = runtime.Types.DefaultSelection<BlockchainTransactionPayload>
export type OnChainProofPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OnChainProof"
  objects: {
    invoice: InvoicePayload<ExtArgs> | null
    vinPassport: VinPassportPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    entityType: EntityType
    entityId: string
    hash: string
    algorithm: string
    chain: string
    contract: string
    txHash: string
    invoiceId: string | null
    vinPassportId: string | null
    createdAt: Date
  }, ExtArgs["result"]["onChainProof"]>
  composites: {}
}

/**
 * Model OnChainProof
 * 
 */
export type OnChainProof = runtime.Types.DefaultSelection<OnChainProofPayload>
export type ChainCursorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ChainCursor"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    chain: string
    contract: string
    lastBlock: bigint
    updatedAt: Date
  }, ExtArgs["result"]["chainCursor"]>
  composites: {}
}

/**
 * Model ChainCursor
 * 
 */
export type ChainCursor = runtime.Types.DefaultSelection<ChainCursorPayload>
export type DocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Document"
  objects: {
    vinPassport: VinPassportPayload<ExtArgs> | null
    invoice: InvoicePayload<ExtArgs> | null
    uploadedBy: UserPayload<ExtArgs> | null
    auditLogs: AuditLogPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state: FileState
    checksum: string
    vinPassportId: string | null
    invoiceId: string | null
    uploadedById: string | null
    createdAt: Date
    updatedAt: Date | null
    deletedAt: Date | null
    isDeleted: boolean
    deletedBy: string | null
  }, ExtArgs["result"]["document"]>
  composites: {}
}

/**
 * Model Document
 * 
 */
export type Document = runtime.Types.DefaultSelection<DocumentPayload>
export type MechanicalHealthPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "MechanicalHealth"
  objects: {
    vinPassport: VinPassportPayload<ExtArgs>
    auditLogs: AuditLogPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    vinPassportId: string
    partsMaintained: Prisma.JsonValue | null
    lastUpdate: Date | null
    greenLight: boolean
    createdAt: Date
    updatedAt: Date | null
    deletedAt: Date | null
    isDeleted: boolean
  }, ExtArgs["result"]["mechanicalHealth"]>
  composites: {}
}

/**
 * Model MechanicalHealth
 * 
 */
export type MechanicalHealth = runtime.Types.DefaultSelection<MechanicalHealthPayload>
export type AuditLogPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "AuditLog"
  objects: {
    user: UserPayload<ExtArgs> | null
    invoice: InvoicePayload<ExtArgs> | null
    vinPassport: VinPassportPayload<ExtArgs> | null
    chainTx: BlockchainTransactionPayload<ExtArgs> | null
    document: DocumentPayload<ExtArgs> | null
    conditionMatrix: ConditionMatrixPayload<ExtArgs> | null
    mechanicalHealth: MechanicalHealthPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue: Prisma.JsonValue | null
    newValue: Prisma.JsonValue | null
    userId: string | null
    invoiceId: string | null
    vinPassportId: string | null
    chainTxId: string | null
    documentId: string | null
    conditionMatrixId: string | null
    mechanicalHealthId: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
  }, ExtArgs["result"]["auditLog"]>
  composites: {}
}

/**
 * Model AuditLog
 * 
 */
export type AuditLog = runtime.Types.DefaultSelection<AuditLogPayload>
export type AlertPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Alert"
  objects: {
    user: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    userName: string
    userRole: UserRole
    action: AlertAction
    activity: string
    businessId: string | null
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
    userId: string | null
  }, ExtArgs["result"]["alert"]>
  composites: {}
}

/**
 * Model Alert
 * 
 */
export type Alert = runtime.Types.DefaultSelection<AlertPayload>

/**
 * Enums
 */

export const UserRole: {
  ADMIN: 'ADMIN',
  DEALER: 'DEALER',
  SELLER: 'SELLER',
  CUSTOMER: 'CUSTOMER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const TxStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  CONFIRMED: 'CONFIRMED',
  FAILED: 'FAILED'
};

export type TxStatus = (typeof TxStatus)[keyof typeof TxStatus]


export const EntityType: {
  USER: 'USER',
  WALLET: 'WALLET',
  VIN_PASSPORT: 'VIN_PASSPORT',
  INVOICE: 'INVOICE',
  PART: 'PART',
  GAS_SETTLEMENT: 'GAS_SETTLEMENT',
  BLOCKCHAIN_TX: 'BLOCKCHAIN_TX',
  ONCHAIN_PROOF: 'ONCHAIN_PROOF',
  DOCUMENT: 'DOCUMENT'
};

export type EntityType = (typeof EntityType)[keyof typeof EntityType]


export const FileType: {
  INVOICE: 'INVOICE',
  IMAGE: 'IMAGE',
  PDF: 'PDF',
  OTHER: 'OTHER'
};

export type FileType = (typeof FileType)[keyof typeof FileType]


export const FileState: {
  UPLOADED: 'UPLOADED',
  PROCESSING: 'PROCESSING',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED'
};

export type FileState = (typeof FileState)[keyof typeof FileState]


export const AuditAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  RESTORE: 'RESTORE'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const AlertAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  EXPORT: 'EXPORT',
  IMPORT: 'IMPORT',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  EDIT: 'EDIT',
  REQUEST: 'REQUEST',
  CHANGE_STATUS: 'CHANGE_STATUS',
  CONTACTED: 'CONTACTED',
  RENEW: 'RENEW',
  MAINTENANCE_MODE: 'MAINTENANCE_MODE'
};

export type AlertAction = (typeof AlertAction)[keyof typeof AlertAction]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.aztoWallet`: Exposes CRUD operations for the **AztoWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AztoWallets
    * const aztoWallets = await prisma.aztoWallet.findMany()
    * ```
    */
  get aztoWallet(): Prisma.AztoWalletDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.vinPassport`: Exposes CRUD operations for the **VinPassport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VinPassports
    * const vinPassports = await prisma.vinPassport.findMany()
    * ```
    */
  get vinPassport(): Prisma.VinPassportDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.gasSettlement`: Exposes CRUD operations for the **GasSettlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GasSettlements
    * const gasSettlements = await prisma.gasSettlement.findMany()
    * ```
    */
  get gasSettlement(): Prisma.GasSettlementDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.normalizedPart`: Exposes CRUD operations for the **NormalizedPart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NormalizedParts
    * const normalizedParts = await prisma.normalizedPart.findMany()
    * ```
    */
  get normalizedPart(): Prisma.NormalizedPartDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.aIDecision`: Exposes CRUD operations for the **AIDecision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIDecisions
    * const aIDecisions = await prisma.aIDecision.findMany()
    * ```
    */
  get aIDecision(): Prisma.AIDecisionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.aIQuota`: Exposes CRUD operations for the **AIQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIQuotas
    * const aIQuotas = await prisma.aIQuota.findMany()
    * ```
    */
  get aIQuota(): Prisma.AIQuotaDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.conditionMatrix`: Exposes CRUD operations for the **ConditionMatrix** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConditionMatrices
    * const conditionMatrices = await prisma.conditionMatrix.findMany()
    * ```
    */
  get conditionMatrix(): Prisma.ConditionMatrixDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.systemState`: Exposes CRUD operations for the **SystemState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemStates
    * const systemStates = await prisma.systemState.findMany()
    * ```
    */
  get systemState(): Prisma.SystemStateDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.blockchainTransaction`: Exposes CRUD operations for the **BlockchainTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockchainTransactions
    * const blockchainTransactions = await prisma.blockchainTransaction.findMany()
    * ```
    */
  get blockchainTransaction(): Prisma.BlockchainTransactionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.onChainProof`: Exposes CRUD operations for the **OnChainProof** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OnChainProofs
    * const onChainProofs = await prisma.onChainProof.findMany()
    * ```
    */
  get onChainProof(): Prisma.OnChainProofDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.chainCursor`: Exposes CRUD operations for the **ChainCursor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChainCursors
    * const chainCursors = await prisma.chainCursor.findMany()
    * ```
    */
  get chainCursor(): Prisma.ChainCursorDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.mechanicalHealth`: Exposes CRUD operations for the **MechanicalHealth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MechanicalHealths
    * const mechanicalHealths = await prisma.mechanicalHealth.findMany()
    * ```
    */
  get mechanicalHealth(): Prisma.MechanicalHealthDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    AztoWallet: 'AztoWallet',
    VinPassport: 'VinPassport',
    GasSettlement: 'GasSettlement',
    Invoice: 'Invoice',
    NormalizedPart: 'NormalizedPart',
    AIDecision: 'AIDecision',
    AIQuota: 'AIQuota',
    ConditionMatrix: 'ConditionMatrix',
    SystemState: 'SystemState',
    BlockchainTransaction: 'BlockchainTransaction',
    OnChainProof: 'OnChainProof',
    ChainCursor: 'ChainCursor',
    Document: 'Document',
    MechanicalHealth: 'MechanicalHealth',
    AuditLog: 'AuditLog',
    Alert: 'Alert'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'aztoWallet' | 'vinPassport' | 'gasSettlement' | 'invoice' | 'normalizedPart' | 'aIDecision' | 'aIQuota' | 'conditionMatrix' | 'systemState' | 'blockchainTransaction' | 'onChainProof' | 'chainCursor' | 'document' | 'mechanicalHealth' | 'auditLog' | 'alert'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: UserPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AztoWallet: {
        payload: AztoWalletPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AztoWalletFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AztoWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AztoWalletFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AztoWalletPayload>
          }
          findFirst: {
            args: Prisma.AztoWalletFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AztoWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AztoWalletFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AztoWalletPayload>
          }
          findMany: {
            args: Prisma.AztoWalletFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AztoWalletPayload>[]
          }
          create: {
            args: Prisma.AztoWalletCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AztoWalletPayload>
          }
          createMany: {
            args: Prisma.AztoWalletCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AztoWalletDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AztoWalletPayload>
          }
          update: {
            args: Prisma.AztoWalletUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AztoWalletPayload>
          }
          deleteMany: {
            args: Prisma.AztoWalletDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AztoWalletUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AztoWalletUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AztoWalletPayload>
          }
          aggregate: {
            args: Prisma.AztoWalletAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAztoWallet>
          }
          groupBy: {
            args: Prisma.AztoWalletGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AztoWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.AztoWalletCountArgs<ExtArgs>,
            result: $Utils.Optional<AztoWalletCountAggregateOutputType> | number
          }
        }
      }
      VinPassport: {
        payload: VinPassportPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.VinPassportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VinPassportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VinPassportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VinPassportPayload>
          }
          findFirst: {
            args: Prisma.VinPassportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VinPassportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VinPassportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VinPassportPayload>
          }
          findMany: {
            args: Prisma.VinPassportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VinPassportPayload>[]
          }
          create: {
            args: Prisma.VinPassportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VinPassportPayload>
          }
          createMany: {
            args: Prisma.VinPassportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VinPassportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VinPassportPayload>
          }
          update: {
            args: Prisma.VinPassportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VinPassportPayload>
          }
          deleteMany: {
            args: Prisma.VinPassportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VinPassportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VinPassportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VinPassportPayload>
          }
          aggregate: {
            args: Prisma.VinPassportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVinPassport>
          }
          groupBy: {
            args: Prisma.VinPassportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VinPassportGroupByOutputType>[]
          }
          count: {
            args: Prisma.VinPassportCountArgs<ExtArgs>,
            result: $Utils.Optional<VinPassportCountAggregateOutputType> | number
          }
        }
      }
      GasSettlement: {
        payload: GasSettlementPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.GasSettlementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GasSettlementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GasSettlementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GasSettlementPayload>
          }
          findFirst: {
            args: Prisma.GasSettlementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GasSettlementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GasSettlementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GasSettlementPayload>
          }
          findMany: {
            args: Prisma.GasSettlementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GasSettlementPayload>[]
          }
          create: {
            args: Prisma.GasSettlementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GasSettlementPayload>
          }
          createMany: {
            args: Prisma.GasSettlementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GasSettlementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GasSettlementPayload>
          }
          update: {
            args: Prisma.GasSettlementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GasSettlementPayload>
          }
          deleteMany: {
            args: Prisma.GasSettlementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GasSettlementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GasSettlementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GasSettlementPayload>
          }
          aggregate: {
            args: Prisma.GasSettlementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGasSettlement>
          }
          groupBy: {
            args: Prisma.GasSettlementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GasSettlementGroupByOutputType>[]
          }
          count: {
            args: Prisma.GasSettlementCountArgs<ExtArgs>,
            result: $Utils.Optional<GasSettlementCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: InvoicePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>,
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      NormalizedPart: {
        payload: NormalizedPartPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.NormalizedPartFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NormalizedPartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NormalizedPartFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NormalizedPartPayload>
          }
          findFirst: {
            args: Prisma.NormalizedPartFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NormalizedPartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NormalizedPartFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NormalizedPartPayload>
          }
          findMany: {
            args: Prisma.NormalizedPartFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NormalizedPartPayload>[]
          }
          create: {
            args: Prisma.NormalizedPartCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NormalizedPartPayload>
          }
          createMany: {
            args: Prisma.NormalizedPartCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NormalizedPartDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NormalizedPartPayload>
          }
          update: {
            args: Prisma.NormalizedPartUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NormalizedPartPayload>
          }
          deleteMany: {
            args: Prisma.NormalizedPartDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NormalizedPartUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NormalizedPartUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NormalizedPartPayload>
          }
          aggregate: {
            args: Prisma.NormalizedPartAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNormalizedPart>
          }
          groupBy: {
            args: Prisma.NormalizedPartGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NormalizedPartGroupByOutputType>[]
          }
          count: {
            args: Prisma.NormalizedPartCountArgs<ExtArgs>,
            result: $Utils.Optional<NormalizedPartCountAggregateOutputType> | number
          }
        }
      }
      AIDecision: {
        payload: AIDecisionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AIDecisionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIDecisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIDecisionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIDecisionPayload>
          }
          findFirst: {
            args: Prisma.AIDecisionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIDecisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIDecisionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIDecisionPayload>
          }
          findMany: {
            args: Prisma.AIDecisionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIDecisionPayload>[]
          }
          create: {
            args: Prisma.AIDecisionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIDecisionPayload>
          }
          createMany: {
            args: Prisma.AIDecisionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AIDecisionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIDecisionPayload>
          }
          update: {
            args: Prisma.AIDecisionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIDecisionPayload>
          }
          deleteMany: {
            args: Prisma.AIDecisionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AIDecisionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AIDecisionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIDecisionPayload>
          }
          aggregate: {
            args: Prisma.AIDecisionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAIDecision>
          }
          groupBy: {
            args: Prisma.AIDecisionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AIDecisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIDecisionCountArgs<ExtArgs>,
            result: $Utils.Optional<AIDecisionCountAggregateOutputType> | number
          }
        }
      }
      AIQuota: {
        payload: AIQuotaPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AIQuotaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIQuotaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIQuotaPayload>
          }
          findFirst: {
            args: Prisma.AIQuotaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIQuotaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIQuotaPayload>
          }
          findMany: {
            args: Prisma.AIQuotaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIQuotaPayload>[]
          }
          create: {
            args: Prisma.AIQuotaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIQuotaPayload>
          }
          createMany: {
            args: Prisma.AIQuotaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AIQuotaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIQuotaPayload>
          }
          update: {
            args: Prisma.AIQuotaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIQuotaPayload>
          }
          deleteMany: {
            args: Prisma.AIQuotaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AIQuotaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AIQuotaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIQuotaPayload>
          }
          aggregate: {
            args: Prisma.AIQuotaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAIQuota>
          }
          groupBy: {
            args: Prisma.AIQuotaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AIQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIQuotaCountArgs<ExtArgs>,
            result: $Utils.Optional<AIQuotaCountAggregateOutputType> | number
          }
        }
      }
      ConditionMatrix: {
        payload: ConditionMatrixPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ConditionMatrixFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConditionMatrixPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConditionMatrixFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConditionMatrixPayload>
          }
          findFirst: {
            args: Prisma.ConditionMatrixFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConditionMatrixPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConditionMatrixFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConditionMatrixPayload>
          }
          findMany: {
            args: Prisma.ConditionMatrixFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConditionMatrixPayload>[]
          }
          create: {
            args: Prisma.ConditionMatrixCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConditionMatrixPayload>
          }
          createMany: {
            args: Prisma.ConditionMatrixCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConditionMatrixDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConditionMatrixPayload>
          }
          update: {
            args: Prisma.ConditionMatrixUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConditionMatrixPayload>
          }
          deleteMany: {
            args: Prisma.ConditionMatrixDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConditionMatrixUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConditionMatrixUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConditionMatrixPayload>
          }
          aggregate: {
            args: Prisma.ConditionMatrixAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConditionMatrix>
          }
          groupBy: {
            args: Prisma.ConditionMatrixGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConditionMatrixGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConditionMatrixCountArgs<ExtArgs>,
            result: $Utils.Optional<ConditionMatrixCountAggregateOutputType> | number
          }
        }
      }
      SystemState: {
        payload: SystemStatePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.SystemStateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SystemStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemStateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SystemStatePayload>
          }
          findFirst: {
            args: Prisma.SystemStateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SystemStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemStateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SystemStatePayload>
          }
          findMany: {
            args: Prisma.SystemStateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SystemStatePayload>[]
          }
          create: {
            args: Prisma.SystemStateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SystemStatePayload>
          }
          createMany: {
            args: Prisma.SystemStateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SystemStateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SystemStatePayload>
          }
          update: {
            args: Prisma.SystemStateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SystemStatePayload>
          }
          deleteMany: {
            args: Prisma.SystemStateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SystemStateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SystemStateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SystemStatePayload>
          }
          aggregate: {
            args: Prisma.SystemStateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSystemState>
          }
          groupBy: {
            args: Prisma.SystemStateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SystemStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemStateCountArgs<ExtArgs>,
            result: $Utils.Optional<SystemStateCountAggregateOutputType> | number
          }
        }
      }
      BlockchainTransaction: {
        payload: BlockchainTransactionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BlockchainTransactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockchainTransactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainTransactionPayload>
          }
          findFirst: {
            args: Prisma.BlockchainTransactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockchainTransactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainTransactionPayload>
          }
          findMany: {
            args: Prisma.BlockchainTransactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainTransactionPayload>[]
          }
          create: {
            args: Prisma.BlockchainTransactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainTransactionPayload>
          }
          createMany: {
            args: Prisma.BlockchainTransactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BlockchainTransactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainTransactionPayload>
          }
          update: {
            args: Prisma.BlockchainTransactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainTransactionPayload>
          }
          deleteMany: {
            args: Prisma.BlockchainTransactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BlockchainTransactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BlockchainTransactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainTransactionPayload>
          }
          aggregate: {
            args: Prisma.BlockchainTransactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBlockchainTransaction>
          }
          groupBy: {
            args: Prisma.BlockchainTransactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BlockchainTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockchainTransactionCountArgs<ExtArgs>,
            result: $Utils.Optional<BlockchainTransactionCountAggregateOutputType> | number
          }
        }
      }
      OnChainProof: {
        payload: OnChainProofPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.OnChainProofFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OnChainProofPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OnChainProofFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OnChainProofPayload>
          }
          findFirst: {
            args: Prisma.OnChainProofFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OnChainProofPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OnChainProofFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OnChainProofPayload>
          }
          findMany: {
            args: Prisma.OnChainProofFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OnChainProofPayload>[]
          }
          create: {
            args: Prisma.OnChainProofCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OnChainProofPayload>
          }
          createMany: {
            args: Prisma.OnChainProofCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OnChainProofDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OnChainProofPayload>
          }
          update: {
            args: Prisma.OnChainProofUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OnChainProofPayload>
          }
          deleteMany: {
            args: Prisma.OnChainProofDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OnChainProofUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OnChainProofUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OnChainProofPayload>
          }
          aggregate: {
            args: Prisma.OnChainProofAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOnChainProof>
          }
          groupBy: {
            args: Prisma.OnChainProofGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OnChainProofGroupByOutputType>[]
          }
          count: {
            args: Prisma.OnChainProofCountArgs<ExtArgs>,
            result: $Utils.Optional<OnChainProofCountAggregateOutputType> | number
          }
        }
      }
      ChainCursor: {
        payload: ChainCursorPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ChainCursorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ChainCursorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChainCursorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ChainCursorPayload>
          }
          findFirst: {
            args: Prisma.ChainCursorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ChainCursorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChainCursorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ChainCursorPayload>
          }
          findMany: {
            args: Prisma.ChainCursorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ChainCursorPayload>[]
          }
          create: {
            args: Prisma.ChainCursorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ChainCursorPayload>
          }
          createMany: {
            args: Prisma.ChainCursorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ChainCursorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ChainCursorPayload>
          }
          update: {
            args: Prisma.ChainCursorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ChainCursorPayload>
          }
          deleteMany: {
            args: Prisma.ChainCursorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ChainCursorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ChainCursorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ChainCursorPayload>
          }
          aggregate: {
            args: Prisma.ChainCursorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChainCursor>
          }
          groupBy: {
            args: Prisma.ChainCursorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChainCursorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChainCursorCountArgs<ExtArgs>,
            result: $Utils.Optional<ChainCursorCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: DocumentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      MechanicalHealth: {
        payload: MechanicalHealthPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.MechanicalHealthFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MechanicalHealthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MechanicalHealthFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MechanicalHealthPayload>
          }
          findFirst: {
            args: Prisma.MechanicalHealthFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MechanicalHealthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MechanicalHealthFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MechanicalHealthPayload>
          }
          findMany: {
            args: Prisma.MechanicalHealthFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MechanicalHealthPayload>[]
          }
          create: {
            args: Prisma.MechanicalHealthCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MechanicalHealthPayload>
          }
          createMany: {
            args: Prisma.MechanicalHealthCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MechanicalHealthDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MechanicalHealthPayload>
          }
          update: {
            args: Prisma.MechanicalHealthUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MechanicalHealthPayload>
          }
          deleteMany: {
            args: Prisma.MechanicalHealthDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MechanicalHealthUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MechanicalHealthUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MechanicalHealthPayload>
          }
          aggregate: {
            args: Prisma.MechanicalHealthAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMechanicalHealth>
          }
          groupBy: {
            args: Prisma.MechanicalHealthGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MechanicalHealthGroupByOutputType>[]
          }
          count: {
            args: Prisma.MechanicalHealthCountArgs<ExtArgs>,
            result: $Utils.Optional<MechanicalHealthCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: AuditLogPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>,
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: AlertPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>,
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    auditLogs: number
    aiQuotas: number
    aiDecisions: number
    chainTxs: number
    alerts: number
    documents: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    aiQuotas?: boolean | UserCountOutputTypeCountAiQuotasArgs
    aiDecisions?: boolean | UserCountOutputTypeCountAiDecisionsArgs
    chainTxs?: boolean | UserCountOutputTypeCountChainTxsArgs
    alerts?: boolean | UserCountOutputTypeCountAlertsArgs
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiQuotasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AIQuotaWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiDecisionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AIDecisionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChainTxsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BlockchainTransactionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }



  /**
   * Count Type VinPassportCountOutputType
   */


  export type VinPassportCountOutputType = {
    invoices: number
    gasSettlements: number
    auditLogs: number
    onChainProofs: number
    documents: number
    conditionMatrices: number
    mechanicalHealths: number
  }

  export type VinPassportCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invoices?: boolean | VinPassportCountOutputTypeCountInvoicesArgs
    gasSettlements?: boolean | VinPassportCountOutputTypeCountGasSettlementsArgs
    auditLogs?: boolean | VinPassportCountOutputTypeCountAuditLogsArgs
    onChainProofs?: boolean | VinPassportCountOutputTypeCountOnChainProofsArgs
    documents?: boolean | VinPassportCountOutputTypeCountDocumentsArgs
    conditionMatrices?: boolean | VinPassportCountOutputTypeCountConditionMatricesArgs
    mechanicalHealths?: boolean | VinPassportCountOutputTypeCountMechanicalHealthsArgs
  }

  // Custom InputTypes

  /**
   * VinPassportCountOutputType without action
   */
  export type VinPassportCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VinPassportCountOutputType
     */
    select?: VinPassportCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * VinPassportCountOutputType without action
   */
  export type VinPassportCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * VinPassportCountOutputType without action
   */
  export type VinPassportCountOutputTypeCountGasSettlementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GasSettlementWhereInput
  }


  /**
   * VinPassportCountOutputType without action
   */
  export type VinPassportCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * VinPassportCountOutputType without action
   */
  export type VinPassportCountOutputTypeCountOnChainProofsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OnChainProofWhereInput
  }


  /**
   * VinPassportCountOutputType without action
   */
  export type VinPassportCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * VinPassportCountOutputType without action
   */
  export type VinPassportCountOutputTypeCountConditionMatricesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConditionMatrixWhereInput
  }


  /**
   * VinPassportCountOutputType without action
   */
  export type VinPassportCountOutputTypeCountMechanicalHealthsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MechanicalHealthWhereInput
  }



  /**
   * Count Type InvoiceCountOutputType
   */


  export type InvoiceCountOutputType = {
    documents: number
    parts: number
    auditLogs: number
    onChainProofs: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    documents?: boolean | InvoiceCountOutputTypeCountDocumentsArgs
    parts?: boolean | InvoiceCountOutputTypeCountPartsArgs
    auditLogs?: boolean | InvoiceCountOutputTypeCountAuditLogsArgs
    onChainProofs?: boolean | InvoiceCountOutputTypeCountOnChainProofsArgs
  }

  // Custom InputTypes

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPartsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NormalizedPartWhereInput
  }


  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountOnChainProofsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OnChainProofWhereInput
  }



  /**
   * Count Type ConditionMatrixCountOutputType
   */


  export type ConditionMatrixCountOutputType = {
    auditLogs: number
  }

  export type ConditionMatrixCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | ConditionMatrixCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes

  /**
   * ConditionMatrixCountOutputType without action
   */
  export type ConditionMatrixCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionMatrixCountOutputType
     */
    select?: ConditionMatrixCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ConditionMatrixCountOutputType without action
   */
  export type ConditionMatrixCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }



  /**
   * Count Type BlockchainTransactionCountOutputType
   */


  export type BlockchainTransactionCountOutputType = {
    auditLogs: number
  }

  export type BlockchainTransactionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | BlockchainTransactionCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes

  /**
   * BlockchainTransactionCountOutputType without action
   */
  export type BlockchainTransactionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransactionCountOutputType
     */
    select?: BlockchainTransactionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BlockchainTransactionCountOutputType without action
   */
  export type BlockchainTransactionCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }



  /**
   * Count Type DocumentCountOutputType
   */


  export type DocumentCountOutputType = {
    auditLogs: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | DocumentCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }



  /**
   * Count Type MechanicalHealthCountOutputType
   */


  export type MechanicalHealthCountOutputType = {
    auditLogs: number
  }

  export type MechanicalHealthCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | MechanicalHealthCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes

  /**
   * MechanicalHealthCountOutputType without action
   */
  export type MechanicalHealthCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicalHealthCountOutputType
     */
    select?: MechanicalHealthCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MechanicalHealthCountOutputType without action
   */
  export type MechanicalHealthCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: UserRole | null
    walletAddress: string | null
    signature: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: UserRole | null
    walletAddress: string | null
    signature: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    walletAddress: number
    signature: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    isDeleted: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    walletAddress?: true
    signature?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    walletAddress?: true
    signature?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    walletAddress?: true
    signature?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    password: string | null
    role: UserRole
    walletAddress: string | null
    signature: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    walletAddress?: boolean
    signature?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
    wallet?: boolean | AztoWalletArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    aiQuotas?: boolean | User$aiQuotasArgs<ExtArgs>
    aiDecisions?: boolean | User$aiDecisionsArgs<ExtArgs>
    chainTxs?: boolean | User$chainTxsArgs<ExtArgs>
    alerts?: boolean | User$alertsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    walletAddress?: boolean
    signature?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    wallet?: boolean | AztoWalletArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    aiQuotas?: boolean | User$aiQuotasArgs<ExtArgs>
    aiDecisions?: boolean | User$aiDecisionsArgs<ExtArgs>
    chainTxs?: boolean | User$chainTxsArgs<ExtArgs>
    alerts?: boolean | User$alertsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type UserGetPayload<S extends boolean | null | undefined | UserArgs> = $Types.GetResult<UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    wallet<T extends AztoWalletArgs<ExtArgs> = {}>(args?: Subset<T, AztoWalletArgs<ExtArgs>>): Prisma__AztoWalletClient<$Types.GetResult<AztoWalletPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findMany', never>| Null>;

    aiQuotas<T extends User$aiQuotasArgs<ExtArgs> = {}>(args?: Subset<T, User$aiQuotasArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AIQuotaPayload<ExtArgs>, T, 'findMany', never>| Null>;

    aiDecisions<T extends User$aiDecisionsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiDecisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AIDecisionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    chainTxs<T extends User$chainTxsArgs<ExtArgs> = {}>(args?: Subset<T, User$chainTxsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BlockchainTransactionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    alerts<T extends User$alertsArgs<ExtArgs> = {}>(args?: Subset<T, User$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findMany', never>| Null>;

    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuditLogScalarFieldEnum>
  }


  /**
   * User.aiQuotas
   */
  export type User$aiQuotasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQuota
     */
    select?: AIQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIQuotaInclude<ExtArgs> | null
    where?: AIQuotaWhereInput
    orderBy?: Enumerable<AIQuotaOrderByWithRelationInput>
    cursor?: AIQuotaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AIQuotaScalarFieldEnum>
  }


  /**
   * User.aiDecisions
   */
  export type User$aiDecisionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIDecisionInclude<ExtArgs> | null
    where?: AIDecisionWhereInput
    orderBy?: Enumerable<AIDecisionOrderByWithRelationInput>
    cursor?: AIDecisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AIDecisionScalarFieldEnum>
  }


  /**
   * User.chainTxs
   */
  export type User$chainTxsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    where?: BlockchainTransactionWhereInput
    orderBy?: Enumerable<BlockchainTransactionOrderByWithRelationInput>
    cursor?: BlockchainTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BlockchainTransactionScalarFieldEnum>
  }


  /**
   * User.alerts
   */
  export type User$alertsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AlertScalarFieldEnum>
  }


  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model AztoWallet
   */


  export type AggregateAztoWallet = {
    _count: AztoWalletCountAggregateOutputType | null
    _avg: AztoWalletAvgAggregateOutputType | null
    _sum: AztoWalletSumAggregateOutputType | null
    _min: AztoWalletMinAggregateOutputType | null
    _max: AztoWalletMaxAggregateOutputType | null
  }

  export type AztoWalletAvgAggregateOutputType = {
    balance: Decimal | null
  }

  export type AztoWalletSumAggregateOutputType = {
    balance: Decimal | null
  }

  export type AztoWalletMinAggregateOutputType = {
    id: string | null
    balance: Decimal | null
    userId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
  }

  export type AztoWalletMaxAggregateOutputType = {
    id: string | null
    balance: Decimal | null
    userId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
  }

  export type AztoWalletCountAggregateOutputType = {
    id: number
    balance: number
    userId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    isDeleted: number
    _all: number
  }


  export type AztoWalletAvgAggregateInputType = {
    balance?: true
  }

  export type AztoWalletSumAggregateInputType = {
    balance?: true
  }

  export type AztoWalletMinAggregateInputType = {
    id?: true
    balance?: true
    userId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type AztoWalletMaxAggregateInputType = {
    id?: true
    balance?: true
    userId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type AztoWalletCountAggregateInputType = {
    id?: true
    balance?: true
    userId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
    _all?: true
  }

  export type AztoWalletAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AztoWallet to aggregate.
     */
    where?: AztoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AztoWallets to fetch.
     */
    orderBy?: Enumerable<AztoWalletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AztoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AztoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AztoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AztoWallets
    **/
    _count?: true | AztoWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AztoWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AztoWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AztoWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AztoWalletMaxAggregateInputType
  }

  export type GetAztoWalletAggregateType<T extends AztoWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateAztoWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAztoWallet[P]>
      : GetScalarType<T[P], AggregateAztoWallet[P]>
  }




  export type AztoWalletGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AztoWalletWhereInput
    orderBy?: Enumerable<AztoWalletOrderByWithAggregationInput>
    by: AztoWalletScalarFieldEnum[]
    having?: AztoWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AztoWalletCountAggregateInputType | true
    _avg?: AztoWalletAvgAggregateInputType
    _sum?: AztoWalletSumAggregateInputType
    _min?: AztoWalletMinAggregateInputType
    _max?: AztoWalletMaxAggregateInputType
  }


  export type AztoWalletGroupByOutputType = {
    id: string
    balance: Decimal
    userId: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
    _count: AztoWalletCountAggregateOutputType | null
    _avg: AztoWalletAvgAggregateOutputType | null
    _sum: AztoWalletSumAggregateOutputType | null
    _min: AztoWalletMinAggregateOutputType | null
    _max: AztoWalletMaxAggregateOutputType | null
  }

  type GetAztoWalletGroupByPayload<T extends AztoWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AztoWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AztoWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AztoWalletGroupByOutputType[P]>
            : GetScalarType<T[P], AztoWalletGroupByOutputType[P]>
        }
      >
    >


  export type AztoWalletSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    userId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["aztoWallet"]>

  export type AztoWalletSelectScalar = {
    id?: boolean
    balance?: boolean
    userId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
  }

  export type AztoWalletInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type AztoWalletGetPayload<S extends boolean | null | undefined | AztoWalletArgs> = $Types.GetResult<AztoWalletPayload, S>

  type AztoWalletCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AztoWalletFindManyArgs, 'select' | 'include'> & {
      select?: AztoWalletCountAggregateInputType | true
    }

  export interface AztoWalletDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AztoWallet'], meta: { name: 'AztoWallet' } }
    /**
     * Find zero or one AztoWallet that matches the filter.
     * @param {AztoWalletFindUniqueArgs} args - Arguments to find a AztoWallet
     * @example
     * // Get one AztoWallet
     * const aztoWallet = await prisma.aztoWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AztoWalletFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AztoWalletFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AztoWallet'> extends True ? Prisma__AztoWalletClient<$Types.GetResult<AztoWalletPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AztoWalletClient<$Types.GetResult<AztoWalletPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one AztoWallet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AztoWalletFindUniqueOrThrowArgs} args - Arguments to find a AztoWallet
     * @example
     * // Get one AztoWallet
     * const aztoWallet = await prisma.aztoWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AztoWalletFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AztoWalletFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AztoWalletClient<$Types.GetResult<AztoWalletPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first AztoWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AztoWalletFindFirstArgs} args - Arguments to find a AztoWallet
     * @example
     * // Get one AztoWallet
     * const aztoWallet = await prisma.aztoWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AztoWalletFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AztoWalletFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AztoWallet'> extends True ? Prisma__AztoWalletClient<$Types.GetResult<AztoWalletPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AztoWalletClient<$Types.GetResult<AztoWalletPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first AztoWallet that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AztoWalletFindFirstOrThrowArgs} args - Arguments to find a AztoWallet
     * @example
     * // Get one AztoWallet
     * const aztoWallet = await prisma.aztoWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AztoWalletFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AztoWalletFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AztoWalletClient<$Types.GetResult<AztoWalletPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more AztoWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AztoWalletFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AztoWallets
     * const aztoWallets = await prisma.aztoWallet.findMany()
     * 
     * // Get first 10 AztoWallets
     * const aztoWallets = await prisma.aztoWallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aztoWalletWithIdOnly = await prisma.aztoWallet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AztoWalletFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AztoWalletFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AztoWalletPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a AztoWallet.
     * @param {AztoWalletCreateArgs} args - Arguments to create a AztoWallet.
     * @example
     * // Create one AztoWallet
     * const AztoWallet = await prisma.aztoWallet.create({
     *   data: {
     *     // ... data to create a AztoWallet
     *   }
     * })
     * 
    **/
    create<T extends AztoWalletCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AztoWalletCreateArgs<ExtArgs>>
    ): Prisma__AztoWalletClient<$Types.GetResult<AztoWalletPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many AztoWallets.
     *     @param {AztoWalletCreateManyArgs} args - Arguments to create many AztoWallets.
     *     @example
     *     // Create many AztoWallets
     *     const aztoWallet = await prisma.aztoWallet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AztoWalletCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AztoWalletCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AztoWallet.
     * @param {AztoWalletDeleteArgs} args - Arguments to delete one AztoWallet.
     * @example
     * // Delete one AztoWallet
     * const AztoWallet = await prisma.aztoWallet.delete({
     *   where: {
     *     // ... filter to delete one AztoWallet
     *   }
     * })
     * 
    **/
    delete<T extends AztoWalletDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AztoWalletDeleteArgs<ExtArgs>>
    ): Prisma__AztoWalletClient<$Types.GetResult<AztoWalletPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one AztoWallet.
     * @param {AztoWalletUpdateArgs} args - Arguments to update one AztoWallet.
     * @example
     * // Update one AztoWallet
     * const aztoWallet = await prisma.aztoWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AztoWalletUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AztoWalletUpdateArgs<ExtArgs>>
    ): Prisma__AztoWalletClient<$Types.GetResult<AztoWalletPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more AztoWallets.
     * @param {AztoWalletDeleteManyArgs} args - Arguments to filter AztoWallets to delete.
     * @example
     * // Delete a few AztoWallets
     * const { count } = await prisma.aztoWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AztoWalletDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AztoWalletDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AztoWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AztoWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AztoWallets
     * const aztoWallet = await prisma.aztoWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AztoWalletUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AztoWalletUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AztoWallet.
     * @param {AztoWalletUpsertArgs} args - Arguments to update or create a AztoWallet.
     * @example
     * // Update or create a AztoWallet
     * const aztoWallet = await prisma.aztoWallet.upsert({
     *   create: {
     *     // ... data to create a AztoWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AztoWallet we want to update
     *   }
     * })
    **/
    upsert<T extends AztoWalletUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AztoWalletUpsertArgs<ExtArgs>>
    ): Prisma__AztoWalletClient<$Types.GetResult<AztoWalletPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of AztoWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AztoWalletCountArgs} args - Arguments to filter AztoWallets to count.
     * @example
     * // Count the number of AztoWallets
     * const count = await prisma.aztoWallet.count({
     *   where: {
     *     // ... the filter for the AztoWallets we want to count
     *   }
     * })
    **/
    count<T extends AztoWalletCountArgs>(
      args?: Subset<T, AztoWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AztoWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AztoWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AztoWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AztoWalletAggregateArgs>(args: Subset<T, AztoWalletAggregateArgs>): Prisma.PrismaPromise<GetAztoWalletAggregateType<T>>

    /**
     * Group by AztoWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AztoWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AztoWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AztoWalletGroupByArgs['orderBy'] }
        : { orderBy?: AztoWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AztoWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAztoWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AztoWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AztoWalletClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AztoWallet base type for findUnique actions
   */
  export type AztoWalletFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AztoWallet
     */
    select?: AztoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AztoWalletInclude<ExtArgs> | null
    /**
     * Filter, which AztoWallet to fetch.
     */
    where: AztoWalletWhereUniqueInput
  }

  /**
   * AztoWallet findUnique
   */
  export interface AztoWalletFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AztoWalletFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AztoWallet findUniqueOrThrow
   */
  export type AztoWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AztoWallet
     */
    select?: AztoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AztoWalletInclude<ExtArgs> | null
    /**
     * Filter, which AztoWallet to fetch.
     */
    where: AztoWalletWhereUniqueInput
  }


  /**
   * AztoWallet base type for findFirst actions
   */
  export type AztoWalletFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AztoWallet
     */
    select?: AztoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AztoWalletInclude<ExtArgs> | null
    /**
     * Filter, which AztoWallet to fetch.
     */
    where?: AztoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AztoWallets to fetch.
     */
    orderBy?: Enumerable<AztoWalletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AztoWallets.
     */
    cursor?: AztoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AztoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AztoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AztoWallets.
     */
    distinct?: Enumerable<AztoWalletScalarFieldEnum>
  }

  /**
   * AztoWallet findFirst
   */
  export interface AztoWalletFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AztoWalletFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AztoWallet findFirstOrThrow
   */
  export type AztoWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AztoWallet
     */
    select?: AztoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AztoWalletInclude<ExtArgs> | null
    /**
     * Filter, which AztoWallet to fetch.
     */
    where?: AztoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AztoWallets to fetch.
     */
    orderBy?: Enumerable<AztoWalletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AztoWallets.
     */
    cursor?: AztoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AztoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AztoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AztoWallets.
     */
    distinct?: Enumerable<AztoWalletScalarFieldEnum>
  }


  /**
   * AztoWallet findMany
   */
  export type AztoWalletFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AztoWallet
     */
    select?: AztoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AztoWalletInclude<ExtArgs> | null
    /**
     * Filter, which AztoWallets to fetch.
     */
    where?: AztoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AztoWallets to fetch.
     */
    orderBy?: Enumerable<AztoWalletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AztoWallets.
     */
    cursor?: AztoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AztoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AztoWallets.
     */
    skip?: number
    distinct?: Enumerable<AztoWalletScalarFieldEnum>
  }


  /**
   * AztoWallet create
   */
  export type AztoWalletCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AztoWallet
     */
    select?: AztoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AztoWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a AztoWallet.
     */
    data: XOR<AztoWalletCreateInput, AztoWalletUncheckedCreateInput>
  }


  /**
   * AztoWallet createMany
   */
  export type AztoWalletCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AztoWallets.
     */
    data: Enumerable<AztoWalletCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AztoWallet update
   */
  export type AztoWalletUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AztoWallet
     */
    select?: AztoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AztoWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a AztoWallet.
     */
    data: XOR<AztoWalletUpdateInput, AztoWalletUncheckedUpdateInput>
    /**
     * Choose, which AztoWallet to update.
     */
    where: AztoWalletWhereUniqueInput
  }


  /**
   * AztoWallet updateMany
   */
  export type AztoWalletUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AztoWallets.
     */
    data: XOR<AztoWalletUpdateManyMutationInput, AztoWalletUncheckedUpdateManyInput>
    /**
     * Filter which AztoWallets to update
     */
    where?: AztoWalletWhereInput
  }


  /**
   * AztoWallet upsert
   */
  export type AztoWalletUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AztoWallet
     */
    select?: AztoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AztoWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the AztoWallet to update in case it exists.
     */
    where: AztoWalletWhereUniqueInput
    /**
     * In case the AztoWallet found by the `where` argument doesn't exist, create a new AztoWallet with this data.
     */
    create: XOR<AztoWalletCreateInput, AztoWalletUncheckedCreateInput>
    /**
     * In case the AztoWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AztoWalletUpdateInput, AztoWalletUncheckedUpdateInput>
  }


  /**
   * AztoWallet delete
   */
  export type AztoWalletDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AztoWallet
     */
    select?: AztoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AztoWalletInclude<ExtArgs> | null
    /**
     * Filter which AztoWallet to delete.
     */
    where: AztoWalletWhereUniqueInput
  }


  /**
   * AztoWallet deleteMany
   */
  export type AztoWalletDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AztoWallets to delete
     */
    where?: AztoWalletWhereInput
  }


  /**
   * AztoWallet without action
   */
  export type AztoWalletArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AztoWallet
     */
    select?: AztoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AztoWalletInclude<ExtArgs> | null
  }



  /**
   * Model VinPassport
   */


  export type AggregateVinPassport = {
    _count: VinPassportCountAggregateOutputType | null
    _min: VinPassportMinAggregateOutputType | null
    _max: VinPassportMaxAggregateOutputType | null
  }

  export type VinPassportMinAggregateOutputType = {
    id: string | null
    vin: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
  }

  export type VinPassportMaxAggregateOutputType = {
    id: string | null
    vin: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
  }

  export type VinPassportCountAggregateOutputType = {
    id: number
    vin: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    isDeleted: number
    _all: number
  }


  export type VinPassportMinAggregateInputType = {
    id?: true
    vin?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type VinPassportMaxAggregateInputType = {
    id?: true
    vin?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type VinPassportCountAggregateInputType = {
    id?: true
    vin?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
    _all?: true
  }

  export type VinPassportAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which VinPassport to aggregate.
     */
    where?: VinPassportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VinPassports to fetch.
     */
    orderBy?: Enumerable<VinPassportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VinPassportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VinPassports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VinPassports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VinPassports
    **/
    _count?: true | VinPassportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VinPassportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VinPassportMaxAggregateInputType
  }

  export type GetVinPassportAggregateType<T extends VinPassportAggregateArgs> = {
        [P in keyof T & keyof AggregateVinPassport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVinPassport[P]>
      : GetScalarType<T[P], AggregateVinPassport[P]>
  }




  export type VinPassportGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: VinPassportWhereInput
    orderBy?: Enumerable<VinPassportOrderByWithAggregationInput>
    by: VinPassportScalarFieldEnum[]
    having?: VinPassportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VinPassportCountAggregateInputType | true
    _min?: VinPassportMinAggregateInputType
    _max?: VinPassportMaxAggregateInputType
  }


  export type VinPassportGroupByOutputType = {
    id: string
    vin: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
    _count: VinPassportCountAggregateOutputType | null
    _min: VinPassportMinAggregateOutputType | null
    _max: VinPassportMaxAggregateOutputType | null
  }

  type GetVinPassportGroupByPayload<T extends VinPassportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VinPassportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VinPassportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VinPassportGroupByOutputType[P]>
            : GetScalarType<T[P], VinPassportGroupByOutputType[P]>
        }
      >
    >


  export type VinPassportSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vin?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
    invoices?: boolean | VinPassport$invoicesArgs<ExtArgs>
    gasSettlements?: boolean | VinPassport$gasSettlementsArgs<ExtArgs>
    auditLogs?: boolean | VinPassport$auditLogsArgs<ExtArgs>
    onChainProofs?: boolean | VinPassport$onChainProofsArgs<ExtArgs>
    documents?: boolean | VinPassport$documentsArgs<ExtArgs>
    conditionMatrices?: boolean | VinPassport$conditionMatricesArgs<ExtArgs>
    mechanicalHealths?: boolean | VinPassport$mechanicalHealthsArgs<ExtArgs>
    _count?: boolean | VinPassportCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["vinPassport"]>

  export type VinPassportSelectScalar = {
    id?: boolean
    vin?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
  }

  export type VinPassportInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invoices?: boolean | VinPassport$invoicesArgs<ExtArgs>
    gasSettlements?: boolean | VinPassport$gasSettlementsArgs<ExtArgs>
    auditLogs?: boolean | VinPassport$auditLogsArgs<ExtArgs>
    onChainProofs?: boolean | VinPassport$onChainProofsArgs<ExtArgs>
    documents?: boolean | VinPassport$documentsArgs<ExtArgs>
    conditionMatrices?: boolean | VinPassport$conditionMatricesArgs<ExtArgs>
    mechanicalHealths?: boolean | VinPassport$mechanicalHealthsArgs<ExtArgs>
    _count?: boolean | VinPassportCountOutputTypeArgs<ExtArgs>
  }


  type VinPassportGetPayload<S extends boolean | null | undefined | VinPassportArgs> = $Types.GetResult<VinPassportPayload, S>

  type VinPassportCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<VinPassportFindManyArgs, 'select' | 'include'> & {
      select?: VinPassportCountAggregateInputType | true
    }

  export interface VinPassportDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VinPassport'], meta: { name: 'VinPassport' } }
    /**
     * Find zero or one VinPassport that matches the filter.
     * @param {VinPassportFindUniqueArgs} args - Arguments to find a VinPassport
     * @example
     * // Get one VinPassport
     * const vinPassport = await prisma.vinPassport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VinPassportFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VinPassportFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VinPassport'> extends True ? Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one VinPassport that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VinPassportFindUniqueOrThrowArgs} args - Arguments to find a VinPassport
     * @example
     * // Get one VinPassport
     * const vinPassport = await prisma.vinPassport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VinPassportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VinPassportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first VinPassport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VinPassportFindFirstArgs} args - Arguments to find a VinPassport
     * @example
     * // Get one VinPassport
     * const vinPassport = await prisma.vinPassport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VinPassportFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VinPassportFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VinPassport'> extends True ? Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first VinPassport that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VinPassportFindFirstOrThrowArgs} args - Arguments to find a VinPassport
     * @example
     * // Get one VinPassport
     * const vinPassport = await prisma.vinPassport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VinPassportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VinPassportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more VinPassports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VinPassportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VinPassports
     * const vinPassports = await prisma.vinPassport.findMany()
     * 
     * // Get first 10 VinPassports
     * const vinPassports = await prisma.vinPassport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vinPassportWithIdOnly = await prisma.vinPassport.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VinPassportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VinPassportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a VinPassport.
     * @param {VinPassportCreateArgs} args - Arguments to create a VinPassport.
     * @example
     * // Create one VinPassport
     * const VinPassport = await prisma.vinPassport.create({
     *   data: {
     *     // ... data to create a VinPassport
     *   }
     * })
     * 
    **/
    create<T extends VinPassportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VinPassportCreateArgs<ExtArgs>>
    ): Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many VinPassports.
     *     @param {VinPassportCreateManyArgs} args - Arguments to create many VinPassports.
     *     @example
     *     // Create many VinPassports
     *     const vinPassport = await prisma.vinPassport.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VinPassportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VinPassportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VinPassport.
     * @param {VinPassportDeleteArgs} args - Arguments to delete one VinPassport.
     * @example
     * // Delete one VinPassport
     * const VinPassport = await prisma.vinPassport.delete({
     *   where: {
     *     // ... filter to delete one VinPassport
     *   }
     * })
     * 
    **/
    delete<T extends VinPassportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VinPassportDeleteArgs<ExtArgs>>
    ): Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one VinPassport.
     * @param {VinPassportUpdateArgs} args - Arguments to update one VinPassport.
     * @example
     * // Update one VinPassport
     * const vinPassport = await prisma.vinPassport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VinPassportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VinPassportUpdateArgs<ExtArgs>>
    ): Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more VinPassports.
     * @param {VinPassportDeleteManyArgs} args - Arguments to filter VinPassports to delete.
     * @example
     * // Delete a few VinPassports
     * const { count } = await prisma.vinPassport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VinPassportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VinPassportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VinPassports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VinPassportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VinPassports
     * const vinPassport = await prisma.vinPassport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VinPassportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VinPassportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VinPassport.
     * @param {VinPassportUpsertArgs} args - Arguments to update or create a VinPassport.
     * @example
     * // Update or create a VinPassport
     * const vinPassport = await prisma.vinPassport.upsert({
     *   create: {
     *     // ... data to create a VinPassport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VinPassport we want to update
     *   }
     * })
    **/
    upsert<T extends VinPassportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VinPassportUpsertArgs<ExtArgs>>
    ): Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of VinPassports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VinPassportCountArgs} args - Arguments to filter VinPassports to count.
     * @example
     * // Count the number of VinPassports
     * const count = await prisma.vinPassport.count({
     *   where: {
     *     // ... the filter for the VinPassports we want to count
     *   }
     * })
    **/
    count<T extends VinPassportCountArgs>(
      args?: Subset<T, VinPassportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VinPassportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VinPassport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VinPassportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VinPassportAggregateArgs>(args: Subset<T, VinPassportAggregateArgs>): Prisma.PrismaPromise<GetVinPassportAggregateType<T>>

    /**
     * Group by VinPassport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VinPassportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VinPassportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VinPassportGroupByArgs['orderBy'] }
        : { orderBy?: VinPassportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VinPassportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVinPassportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for VinPassport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VinPassportClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    invoices<T extends VinPassport$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, VinPassport$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findMany', never>| Null>;

    gasSettlements<T extends VinPassport$gasSettlementsArgs<ExtArgs> = {}>(args?: Subset<T, VinPassport$gasSettlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<GasSettlementPayload<ExtArgs>, T, 'findMany', never>| Null>;

    auditLogs<T extends VinPassport$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, VinPassport$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findMany', never>| Null>;

    onChainProofs<T extends VinPassport$onChainProofsArgs<ExtArgs> = {}>(args?: Subset<T, VinPassport$onChainProofsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OnChainProofPayload<ExtArgs>, T, 'findMany', never>| Null>;

    documents<T extends VinPassport$documentsArgs<ExtArgs> = {}>(args?: Subset<T, VinPassport$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    conditionMatrices<T extends VinPassport$conditionMatricesArgs<ExtArgs> = {}>(args?: Subset<T, VinPassport$conditionMatricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ConditionMatrixPayload<ExtArgs>, T, 'findMany', never>| Null>;

    mechanicalHealths<T extends VinPassport$mechanicalHealthsArgs<ExtArgs> = {}>(args?: Subset<T, VinPassport$mechanicalHealthsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MechanicalHealthPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * VinPassport base type for findUnique actions
   */
  export type VinPassportFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VinPassport
     */
    select?: VinPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VinPassportInclude<ExtArgs> | null
    /**
     * Filter, which VinPassport to fetch.
     */
    where: VinPassportWhereUniqueInput
  }

  /**
   * VinPassport findUnique
   */
  export interface VinPassportFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends VinPassportFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VinPassport findUniqueOrThrow
   */
  export type VinPassportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VinPassport
     */
    select?: VinPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VinPassportInclude<ExtArgs> | null
    /**
     * Filter, which VinPassport to fetch.
     */
    where: VinPassportWhereUniqueInput
  }


  /**
   * VinPassport base type for findFirst actions
   */
  export type VinPassportFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VinPassport
     */
    select?: VinPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VinPassportInclude<ExtArgs> | null
    /**
     * Filter, which VinPassport to fetch.
     */
    where?: VinPassportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VinPassports to fetch.
     */
    orderBy?: Enumerable<VinPassportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VinPassports.
     */
    cursor?: VinPassportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VinPassports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VinPassports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VinPassports.
     */
    distinct?: Enumerable<VinPassportScalarFieldEnum>
  }

  /**
   * VinPassport findFirst
   */
  export interface VinPassportFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends VinPassportFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VinPassport findFirstOrThrow
   */
  export type VinPassportFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VinPassport
     */
    select?: VinPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VinPassportInclude<ExtArgs> | null
    /**
     * Filter, which VinPassport to fetch.
     */
    where?: VinPassportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VinPassports to fetch.
     */
    orderBy?: Enumerable<VinPassportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VinPassports.
     */
    cursor?: VinPassportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VinPassports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VinPassports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VinPassports.
     */
    distinct?: Enumerable<VinPassportScalarFieldEnum>
  }


  /**
   * VinPassport findMany
   */
  export type VinPassportFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VinPassport
     */
    select?: VinPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VinPassportInclude<ExtArgs> | null
    /**
     * Filter, which VinPassports to fetch.
     */
    where?: VinPassportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VinPassports to fetch.
     */
    orderBy?: Enumerable<VinPassportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VinPassports.
     */
    cursor?: VinPassportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VinPassports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VinPassports.
     */
    skip?: number
    distinct?: Enumerable<VinPassportScalarFieldEnum>
  }


  /**
   * VinPassport create
   */
  export type VinPassportCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VinPassport
     */
    select?: VinPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VinPassportInclude<ExtArgs> | null
    /**
     * The data needed to create a VinPassport.
     */
    data: XOR<VinPassportCreateInput, VinPassportUncheckedCreateInput>
  }


  /**
   * VinPassport createMany
   */
  export type VinPassportCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VinPassports.
     */
    data: Enumerable<VinPassportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VinPassport update
   */
  export type VinPassportUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VinPassport
     */
    select?: VinPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VinPassportInclude<ExtArgs> | null
    /**
     * The data needed to update a VinPassport.
     */
    data: XOR<VinPassportUpdateInput, VinPassportUncheckedUpdateInput>
    /**
     * Choose, which VinPassport to update.
     */
    where: VinPassportWhereUniqueInput
  }


  /**
   * VinPassport updateMany
   */
  export type VinPassportUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VinPassports.
     */
    data: XOR<VinPassportUpdateManyMutationInput, VinPassportUncheckedUpdateManyInput>
    /**
     * Filter which VinPassports to update
     */
    where?: VinPassportWhereInput
  }


  /**
   * VinPassport upsert
   */
  export type VinPassportUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VinPassport
     */
    select?: VinPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VinPassportInclude<ExtArgs> | null
    /**
     * The filter to search for the VinPassport to update in case it exists.
     */
    where: VinPassportWhereUniqueInput
    /**
     * In case the VinPassport found by the `where` argument doesn't exist, create a new VinPassport with this data.
     */
    create: XOR<VinPassportCreateInput, VinPassportUncheckedCreateInput>
    /**
     * In case the VinPassport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VinPassportUpdateInput, VinPassportUncheckedUpdateInput>
  }


  /**
   * VinPassport delete
   */
  export type VinPassportDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VinPassport
     */
    select?: VinPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VinPassportInclude<ExtArgs> | null
    /**
     * Filter which VinPassport to delete.
     */
    where: VinPassportWhereUniqueInput
  }


  /**
   * VinPassport deleteMany
   */
  export type VinPassportDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which VinPassports to delete
     */
    where?: VinPassportWhereInput
  }


  /**
   * VinPassport.invoices
   */
  export type VinPassport$invoicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * VinPassport.gasSettlements
   */
  export type VinPassport$gasSettlementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GasSettlement
     */
    select?: GasSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GasSettlementInclude<ExtArgs> | null
    where?: GasSettlementWhereInput
    orderBy?: Enumerable<GasSettlementOrderByWithRelationInput>
    cursor?: GasSettlementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GasSettlementScalarFieldEnum>
  }


  /**
   * VinPassport.auditLogs
   */
  export type VinPassport$auditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuditLogScalarFieldEnum>
  }


  /**
   * VinPassport.onChainProofs
   */
  export type VinPassport$onChainProofsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnChainProof
     */
    select?: OnChainProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OnChainProofInclude<ExtArgs> | null
    where?: OnChainProofWhereInput
    orderBy?: Enumerable<OnChainProofOrderByWithRelationInput>
    cursor?: OnChainProofWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OnChainProofScalarFieldEnum>
  }


  /**
   * VinPassport.documents
   */
  export type VinPassport$documentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * VinPassport.conditionMatrices
   */
  export type VinPassport$conditionMatricesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionMatrix
     */
    select?: ConditionMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionMatrixInclude<ExtArgs> | null
    where?: ConditionMatrixWhereInput
    orderBy?: Enumerable<ConditionMatrixOrderByWithRelationInput>
    cursor?: ConditionMatrixWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ConditionMatrixScalarFieldEnum>
  }


  /**
   * VinPassport.mechanicalHealths
   */
  export type VinPassport$mechanicalHealthsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicalHealth
     */
    select?: MechanicalHealthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MechanicalHealthInclude<ExtArgs> | null
    where?: MechanicalHealthWhereInput
    orderBy?: Enumerable<MechanicalHealthOrderByWithRelationInput>
    cursor?: MechanicalHealthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MechanicalHealthScalarFieldEnum>
  }


  /**
   * VinPassport without action
   */
  export type VinPassportArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VinPassport
     */
    select?: VinPassportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VinPassportInclude<ExtArgs> | null
  }



  /**
   * Model GasSettlement
   */


  export type AggregateGasSettlement = {
    _count: GasSettlementCountAggregateOutputType | null
    _avg: GasSettlementAvgAggregateOutputType | null
    _sum: GasSettlementSumAggregateOutputType | null
    _min: GasSettlementMinAggregateOutputType | null
    _max: GasSettlementMaxAggregateOutputType | null
  }

  export type GasSettlementAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type GasSettlementSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type GasSettlementMinAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    vinPassportId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
  }

  export type GasSettlementMaxAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    vinPassportId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
  }

  export type GasSettlementCountAggregateOutputType = {
    id: number
    amount: number
    vinPassportId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    isDeleted: number
    _all: number
  }


  export type GasSettlementAvgAggregateInputType = {
    amount?: true
  }

  export type GasSettlementSumAggregateInputType = {
    amount?: true
  }

  export type GasSettlementMinAggregateInputType = {
    id?: true
    amount?: true
    vinPassportId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type GasSettlementMaxAggregateInputType = {
    id?: true
    amount?: true
    vinPassportId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type GasSettlementCountAggregateInputType = {
    id?: true
    amount?: true
    vinPassportId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
    _all?: true
  }

  export type GasSettlementAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which GasSettlement to aggregate.
     */
    where?: GasSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GasSettlements to fetch.
     */
    orderBy?: Enumerable<GasSettlementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GasSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GasSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GasSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GasSettlements
    **/
    _count?: true | GasSettlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GasSettlementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GasSettlementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GasSettlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GasSettlementMaxAggregateInputType
  }

  export type GetGasSettlementAggregateType<T extends GasSettlementAggregateArgs> = {
        [P in keyof T & keyof AggregateGasSettlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGasSettlement[P]>
      : GetScalarType<T[P], AggregateGasSettlement[P]>
  }




  export type GasSettlementGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GasSettlementWhereInput
    orderBy?: Enumerable<GasSettlementOrderByWithAggregationInput>
    by: GasSettlementScalarFieldEnum[]
    having?: GasSettlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GasSettlementCountAggregateInputType | true
    _avg?: GasSettlementAvgAggregateInputType
    _sum?: GasSettlementSumAggregateInputType
    _min?: GasSettlementMinAggregateInputType
    _max?: GasSettlementMaxAggregateInputType
  }


  export type GasSettlementGroupByOutputType = {
    id: string
    amount: Decimal
    vinPassportId: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
    _count: GasSettlementCountAggregateOutputType | null
    _avg: GasSettlementAvgAggregateOutputType | null
    _sum: GasSettlementSumAggregateOutputType | null
    _min: GasSettlementMinAggregateOutputType | null
    _max: GasSettlementMaxAggregateOutputType | null
  }

  type GetGasSettlementGroupByPayload<T extends GasSettlementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GasSettlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GasSettlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GasSettlementGroupByOutputType[P]>
            : GetScalarType<T[P], GasSettlementGroupByOutputType[P]>
        }
      >
    >


  export type GasSettlementSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    vinPassportId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
    vinPassport?: boolean | VinPassportArgs<ExtArgs>
  }, ExtArgs["result"]["gasSettlement"]>

  export type GasSettlementSelectScalar = {
    id?: boolean
    amount?: boolean
    vinPassportId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
  }

  export type GasSettlementInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    vinPassport?: boolean | VinPassportArgs<ExtArgs>
  }


  type GasSettlementGetPayload<S extends boolean | null | undefined | GasSettlementArgs> = $Types.GetResult<GasSettlementPayload, S>

  type GasSettlementCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<GasSettlementFindManyArgs, 'select' | 'include'> & {
      select?: GasSettlementCountAggregateInputType | true
    }

  export interface GasSettlementDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GasSettlement'], meta: { name: 'GasSettlement' } }
    /**
     * Find zero or one GasSettlement that matches the filter.
     * @param {GasSettlementFindUniqueArgs} args - Arguments to find a GasSettlement
     * @example
     * // Get one GasSettlement
     * const gasSettlement = await prisma.gasSettlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GasSettlementFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GasSettlementFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GasSettlement'> extends True ? Prisma__GasSettlementClient<$Types.GetResult<GasSettlementPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__GasSettlementClient<$Types.GetResult<GasSettlementPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one GasSettlement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GasSettlementFindUniqueOrThrowArgs} args - Arguments to find a GasSettlement
     * @example
     * // Get one GasSettlement
     * const gasSettlement = await prisma.gasSettlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GasSettlementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GasSettlementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GasSettlementClient<$Types.GetResult<GasSettlementPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first GasSettlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GasSettlementFindFirstArgs} args - Arguments to find a GasSettlement
     * @example
     * // Get one GasSettlement
     * const gasSettlement = await prisma.gasSettlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GasSettlementFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GasSettlementFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GasSettlement'> extends True ? Prisma__GasSettlementClient<$Types.GetResult<GasSettlementPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__GasSettlementClient<$Types.GetResult<GasSettlementPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first GasSettlement that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GasSettlementFindFirstOrThrowArgs} args - Arguments to find a GasSettlement
     * @example
     * // Get one GasSettlement
     * const gasSettlement = await prisma.gasSettlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GasSettlementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GasSettlementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GasSettlementClient<$Types.GetResult<GasSettlementPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more GasSettlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GasSettlementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GasSettlements
     * const gasSettlements = await prisma.gasSettlement.findMany()
     * 
     * // Get first 10 GasSettlements
     * const gasSettlements = await prisma.gasSettlement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gasSettlementWithIdOnly = await prisma.gasSettlement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GasSettlementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GasSettlementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<GasSettlementPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a GasSettlement.
     * @param {GasSettlementCreateArgs} args - Arguments to create a GasSettlement.
     * @example
     * // Create one GasSettlement
     * const GasSettlement = await prisma.gasSettlement.create({
     *   data: {
     *     // ... data to create a GasSettlement
     *   }
     * })
     * 
    **/
    create<T extends GasSettlementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GasSettlementCreateArgs<ExtArgs>>
    ): Prisma__GasSettlementClient<$Types.GetResult<GasSettlementPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many GasSettlements.
     *     @param {GasSettlementCreateManyArgs} args - Arguments to create many GasSettlements.
     *     @example
     *     // Create many GasSettlements
     *     const gasSettlement = await prisma.gasSettlement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GasSettlementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GasSettlementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GasSettlement.
     * @param {GasSettlementDeleteArgs} args - Arguments to delete one GasSettlement.
     * @example
     * // Delete one GasSettlement
     * const GasSettlement = await prisma.gasSettlement.delete({
     *   where: {
     *     // ... filter to delete one GasSettlement
     *   }
     * })
     * 
    **/
    delete<T extends GasSettlementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GasSettlementDeleteArgs<ExtArgs>>
    ): Prisma__GasSettlementClient<$Types.GetResult<GasSettlementPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one GasSettlement.
     * @param {GasSettlementUpdateArgs} args - Arguments to update one GasSettlement.
     * @example
     * // Update one GasSettlement
     * const gasSettlement = await prisma.gasSettlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GasSettlementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GasSettlementUpdateArgs<ExtArgs>>
    ): Prisma__GasSettlementClient<$Types.GetResult<GasSettlementPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more GasSettlements.
     * @param {GasSettlementDeleteManyArgs} args - Arguments to filter GasSettlements to delete.
     * @example
     * // Delete a few GasSettlements
     * const { count } = await prisma.gasSettlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GasSettlementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GasSettlementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GasSettlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GasSettlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GasSettlements
     * const gasSettlement = await prisma.gasSettlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GasSettlementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GasSettlementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GasSettlement.
     * @param {GasSettlementUpsertArgs} args - Arguments to update or create a GasSettlement.
     * @example
     * // Update or create a GasSettlement
     * const gasSettlement = await prisma.gasSettlement.upsert({
     *   create: {
     *     // ... data to create a GasSettlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GasSettlement we want to update
     *   }
     * })
    **/
    upsert<T extends GasSettlementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GasSettlementUpsertArgs<ExtArgs>>
    ): Prisma__GasSettlementClient<$Types.GetResult<GasSettlementPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of GasSettlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GasSettlementCountArgs} args - Arguments to filter GasSettlements to count.
     * @example
     * // Count the number of GasSettlements
     * const count = await prisma.gasSettlement.count({
     *   where: {
     *     // ... the filter for the GasSettlements we want to count
     *   }
     * })
    **/
    count<T extends GasSettlementCountArgs>(
      args?: Subset<T, GasSettlementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GasSettlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GasSettlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GasSettlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GasSettlementAggregateArgs>(args: Subset<T, GasSettlementAggregateArgs>): Prisma.PrismaPromise<GetGasSettlementAggregateType<T>>

    /**
     * Group by GasSettlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GasSettlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GasSettlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GasSettlementGroupByArgs['orderBy'] }
        : { orderBy?: GasSettlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GasSettlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGasSettlementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for GasSettlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GasSettlementClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    vinPassport<T extends VinPassportArgs<ExtArgs> = {}>(args?: Subset<T, VinPassportArgs<ExtArgs>>): Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * GasSettlement base type for findUnique actions
   */
  export type GasSettlementFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GasSettlement
     */
    select?: GasSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GasSettlementInclude<ExtArgs> | null
    /**
     * Filter, which GasSettlement to fetch.
     */
    where: GasSettlementWhereUniqueInput
  }

  /**
   * GasSettlement findUnique
   */
  export interface GasSettlementFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends GasSettlementFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GasSettlement findUniqueOrThrow
   */
  export type GasSettlementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GasSettlement
     */
    select?: GasSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GasSettlementInclude<ExtArgs> | null
    /**
     * Filter, which GasSettlement to fetch.
     */
    where: GasSettlementWhereUniqueInput
  }


  /**
   * GasSettlement base type for findFirst actions
   */
  export type GasSettlementFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GasSettlement
     */
    select?: GasSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GasSettlementInclude<ExtArgs> | null
    /**
     * Filter, which GasSettlement to fetch.
     */
    where?: GasSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GasSettlements to fetch.
     */
    orderBy?: Enumerable<GasSettlementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GasSettlements.
     */
    cursor?: GasSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GasSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GasSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GasSettlements.
     */
    distinct?: Enumerable<GasSettlementScalarFieldEnum>
  }

  /**
   * GasSettlement findFirst
   */
  export interface GasSettlementFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends GasSettlementFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GasSettlement findFirstOrThrow
   */
  export type GasSettlementFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GasSettlement
     */
    select?: GasSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GasSettlementInclude<ExtArgs> | null
    /**
     * Filter, which GasSettlement to fetch.
     */
    where?: GasSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GasSettlements to fetch.
     */
    orderBy?: Enumerable<GasSettlementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GasSettlements.
     */
    cursor?: GasSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GasSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GasSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GasSettlements.
     */
    distinct?: Enumerable<GasSettlementScalarFieldEnum>
  }


  /**
   * GasSettlement findMany
   */
  export type GasSettlementFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GasSettlement
     */
    select?: GasSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GasSettlementInclude<ExtArgs> | null
    /**
     * Filter, which GasSettlements to fetch.
     */
    where?: GasSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GasSettlements to fetch.
     */
    orderBy?: Enumerable<GasSettlementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GasSettlements.
     */
    cursor?: GasSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GasSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GasSettlements.
     */
    skip?: number
    distinct?: Enumerable<GasSettlementScalarFieldEnum>
  }


  /**
   * GasSettlement create
   */
  export type GasSettlementCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GasSettlement
     */
    select?: GasSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GasSettlementInclude<ExtArgs> | null
    /**
     * The data needed to create a GasSettlement.
     */
    data: XOR<GasSettlementCreateInput, GasSettlementUncheckedCreateInput>
  }


  /**
   * GasSettlement createMany
   */
  export type GasSettlementCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GasSettlements.
     */
    data: Enumerable<GasSettlementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GasSettlement update
   */
  export type GasSettlementUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GasSettlement
     */
    select?: GasSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GasSettlementInclude<ExtArgs> | null
    /**
     * The data needed to update a GasSettlement.
     */
    data: XOR<GasSettlementUpdateInput, GasSettlementUncheckedUpdateInput>
    /**
     * Choose, which GasSettlement to update.
     */
    where: GasSettlementWhereUniqueInput
  }


  /**
   * GasSettlement updateMany
   */
  export type GasSettlementUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GasSettlements.
     */
    data: XOR<GasSettlementUpdateManyMutationInput, GasSettlementUncheckedUpdateManyInput>
    /**
     * Filter which GasSettlements to update
     */
    where?: GasSettlementWhereInput
  }


  /**
   * GasSettlement upsert
   */
  export type GasSettlementUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GasSettlement
     */
    select?: GasSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GasSettlementInclude<ExtArgs> | null
    /**
     * The filter to search for the GasSettlement to update in case it exists.
     */
    where: GasSettlementWhereUniqueInput
    /**
     * In case the GasSettlement found by the `where` argument doesn't exist, create a new GasSettlement with this data.
     */
    create: XOR<GasSettlementCreateInput, GasSettlementUncheckedCreateInput>
    /**
     * In case the GasSettlement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GasSettlementUpdateInput, GasSettlementUncheckedUpdateInput>
  }


  /**
   * GasSettlement delete
   */
  export type GasSettlementDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GasSettlement
     */
    select?: GasSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GasSettlementInclude<ExtArgs> | null
    /**
     * Filter which GasSettlement to delete.
     */
    where: GasSettlementWhereUniqueInput
  }


  /**
   * GasSettlement deleteMany
   */
  export type GasSettlementDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which GasSettlements to delete
     */
    where?: GasSettlementWhereInput
  }


  /**
   * GasSettlement without action
   */
  export type GasSettlementArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GasSettlement
     */
    select?: GasSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GasSettlementInclude<ExtArgs> | null
  }



  /**
   * Model Invoice
   */


  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    number: string | null
    status: TxStatus | null
    vinPassportId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    number: string | null
    status: TxStatus | null
    vinPassportId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    number: number
    status: number
    vinPassportId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    isDeleted: number
    _all: number
  }


  export type InvoiceMinAggregateInputType = {
    id?: true
    number?: true
    status?: true
    vinPassportId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    number?: true
    status?: true
    vinPassportId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    number?: true
    status?: true
    vinPassportId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: Enumerable<InvoiceOrderByWithAggregationInput>
    by: InvoiceScalarFieldEnum[]
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }


  export type InvoiceGroupByOutputType = {
    id: string
    number: string
    status: TxStatus
    vinPassportId: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
    _count: InvoiceCountAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    status?: boolean
    vinPassportId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
    vinPassport?: boolean | VinPassportArgs<ExtArgs>
    documents?: boolean | Invoice$documentsArgs<ExtArgs>
    parts?: boolean | Invoice$partsArgs<ExtArgs>
    auditLogs?: boolean | Invoice$auditLogsArgs<ExtArgs>
    onChainProofs?: boolean | Invoice$onChainProofsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    number?: boolean
    status?: boolean
    vinPassportId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    vinPassport?: boolean | VinPassportArgs<ExtArgs>
    documents?: boolean | Invoice$documentsArgs<ExtArgs>
    parts?: boolean | Invoice$partsArgs<ExtArgs>
    auditLogs?: boolean | Invoice$auditLogsArgs<ExtArgs>
    onChainProofs?: boolean | Invoice$onChainProofsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeArgs<ExtArgs>
  }


  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceArgs> = $Types.GetResult<InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvoiceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Invoice'> extends True ? Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvoiceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Invoice'> extends True ? Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvoiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
    **/
    create<T extends InvoiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Invoices.
     *     @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     *     @example
     *     // Create many Invoices
     *     const invoice = await prisma.invoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvoiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
    **/
    delete<T extends InvoiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvoiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvoiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvoiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
    **/
    upsert<T extends InvoiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    vinPassport<T extends VinPassportArgs<ExtArgs> = {}>(args?: Subset<T, VinPassportArgs<ExtArgs>>): Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    documents<T extends Invoice$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    parts<T extends Invoice$partsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$partsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<NormalizedPartPayload<ExtArgs>, T, 'findMany', never>| Null>;

    auditLogs<T extends Invoice$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findMany', never>| Null>;

    onChainProofs<T extends Invoice$onChainProofsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$onChainProofsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OnChainProofPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Invoice base type for findUnique actions
   */
  export type InvoiceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUnique
   */
  export interface InvoiceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InvoiceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice base type for findFirst actions
   */
  export type InvoiceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }

  /**
   * Invoice findFirst
   */
  export interface InvoiceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InvoiceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }


  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: Enumerable<InvoiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }


  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }


  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }


  /**
   * Invoice.documents
   */
  export type Invoice$documentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Invoice.parts
   */
  export type Invoice$partsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedPart
     */
    select?: NormalizedPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NormalizedPartInclude<ExtArgs> | null
    where?: NormalizedPartWhereInput
    orderBy?: Enumerable<NormalizedPartOrderByWithRelationInput>
    cursor?: NormalizedPartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NormalizedPartScalarFieldEnum>
  }


  /**
   * Invoice.auditLogs
   */
  export type Invoice$auditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuditLogScalarFieldEnum>
  }


  /**
   * Invoice.onChainProofs
   */
  export type Invoice$onChainProofsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnChainProof
     */
    select?: OnChainProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OnChainProofInclude<ExtArgs> | null
    where?: OnChainProofWhereInput
    orderBy?: Enumerable<OnChainProofOrderByWithRelationInput>
    cursor?: OnChainProofWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OnChainProofScalarFieldEnum>
  }


  /**
   * Invoice without action
   */
  export type InvoiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
  }



  /**
   * Model NormalizedPart
   */


  export type AggregateNormalizedPart = {
    _count: NormalizedPartCountAggregateOutputType | null
    _avg: NormalizedPartAvgAggregateOutputType | null
    _sum: NormalizedPartSumAggregateOutputType | null
    _min: NormalizedPartMinAggregateOutputType | null
    _max: NormalizedPartMaxAggregateOutputType | null
  }

  export type NormalizedPartAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type NormalizedPartSumAggregateOutputType = {
    price: Decimal | null
  }

  export type NormalizedPartMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: Decimal | null
    invoiceId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
  }

  export type NormalizedPartMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: Decimal | null
    invoiceId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
  }

  export type NormalizedPartCountAggregateOutputType = {
    id: number
    name: number
    price: number
    invoiceId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    isDeleted: number
    _all: number
  }


  export type NormalizedPartAvgAggregateInputType = {
    price?: true
  }

  export type NormalizedPartSumAggregateInputType = {
    price?: true
  }

  export type NormalizedPartMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    invoiceId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type NormalizedPartMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    invoiceId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type NormalizedPartCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    invoiceId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
    _all?: true
  }

  export type NormalizedPartAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which NormalizedPart to aggregate.
     */
    where?: NormalizedPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NormalizedParts to fetch.
     */
    orderBy?: Enumerable<NormalizedPartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NormalizedPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NormalizedParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NormalizedParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NormalizedParts
    **/
    _count?: true | NormalizedPartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NormalizedPartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NormalizedPartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NormalizedPartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NormalizedPartMaxAggregateInputType
  }

  export type GetNormalizedPartAggregateType<T extends NormalizedPartAggregateArgs> = {
        [P in keyof T & keyof AggregateNormalizedPart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNormalizedPart[P]>
      : GetScalarType<T[P], AggregateNormalizedPart[P]>
  }




  export type NormalizedPartGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NormalizedPartWhereInput
    orderBy?: Enumerable<NormalizedPartOrderByWithAggregationInput>
    by: NormalizedPartScalarFieldEnum[]
    having?: NormalizedPartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NormalizedPartCountAggregateInputType | true
    _avg?: NormalizedPartAvgAggregateInputType
    _sum?: NormalizedPartSumAggregateInputType
    _min?: NormalizedPartMinAggregateInputType
    _max?: NormalizedPartMaxAggregateInputType
  }


  export type NormalizedPartGroupByOutputType = {
    id: string
    name: string
    price: Decimal
    invoiceId: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
    _count: NormalizedPartCountAggregateOutputType | null
    _avg: NormalizedPartAvgAggregateOutputType | null
    _sum: NormalizedPartSumAggregateOutputType | null
    _min: NormalizedPartMinAggregateOutputType | null
    _max: NormalizedPartMaxAggregateOutputType | null
  }

  type GetNormalizedPartGroupByPayload<T extends NormalizedPartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NormalizedPartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NormalizedPartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NormalizedPartGroupByOutputType[P]>
            : GetScalarType<T[P], NormalizedPartGroupByOutputType[P]>
        }
      >
    >


  export type NormalizedPartSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    invoiceId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
    invoice?: boolean | InvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["normalizedPart"]>

  export type NormalizedPartSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    invoiceId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
  }

  export type NormalizedPartInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceArgs<ExtArgs>
  }


  type NormalizedPartGetPayload<S extends boolean | null | undefined | NormalizedPartArgs> = $Types.GetResult<NormalizedPartPayload, S>

  type NormalizedPartCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<NormalizedPartFindManyArgs, 'select' | 'include'> & {
      select?: NormalizedPartCountAggregateInputType | true
    }

  export interface NormalizedPartDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NormalizedPart'], meta: { name: 'NormalizedPart' } }
    /**
     * Find zero or one NormalizedPart that matches the filter.
     * @param {NormalizedPartFindUniqueArgs} args - Arguments to find a NormalizedPart
     * @example
     * // Get one NormalizedPart
     * const normalizedPart = await prisma.normalizedPart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NormalizedPartFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NormalizedPartFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NormalizedPart'> extends True ? Prisma__NormalizedPartClient<$Types.GetResult<NormalizedPartPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__NormalizedPartClient<$Types.GetResult<NormalizedPartPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one NormalizedPart that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NormalizedPartFindUniqueOrThrowArgs} args - Arguments to find a NormalizedPart
     * @example
     * // Get one NormalizedPart
     * const normalizedPart = await prisma.normalizedPart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NormalizedPartFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NormalizedPartFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NormalizedPartClient<$Types.GetResult<NormalizedPartPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first NormalizedPart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalizedPartFindFirstArgs} args - Arguments to find a NormalizedPart
     * @example
     * // Get one NormalizedPart
     * const normalizedPart = await prisma.normalizedPart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NormalizedPartFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NormalizedPartFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NormalizedPart'> extends True ? Prisma__NormalizedPartClient<$Types.GetResult<NormalizedPartPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__NormalizedPartClient<$Types.GetResult<NormalizedPartPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first NormalizedPart that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalizedPartFindFirstOrThrowArgs} args - Arguments to find a NormalizedPart
     * @example
     * // Get one NormalizedPart
     * const normalizedPart = await prisma.normalizedPart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NormalizedPartFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NormalizedPartFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NormalizedPartClient<$Types.GetResult<NormalizedPartPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more NormalizedParts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalizedPartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NormalizedParts
     * const normalizedParts = await prisma.normalizedPart.findMany()
     * 
     * // Get first 10 NormalizedParts
     * const normalizedParts = await prisma.normalizedPart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const normalizedPartWithIdOnly = await prisma.normalizedPart.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NormalizedPartFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NormalizedPartFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<NormalizedPartPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a NormalizedPart.
     * @param {NormalizedPartCreateArgs} args - Arguments to create a NormalizedPart.
     * @example
     * // Create one NormalizedPart
     * const NormalizedPart = await prisma.normalizedPart.create({
     *   data: {
     *     // ... data to create a NormalizedPart
     *   }
     * })
     * 
    **/
    create<T extends NormalizedPartCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NormalizedPartCreateArgs<ExtArgs>>
    ): Prisma__NormalizedPartClient<$Types.GetResult<NormalizedPartPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many NormalizedParts.
     *     @param {NormalizedPartCreateManyArgs} args - Arguments to create many NormalizedParts.
     *     @example
     *     // Create many NormalizedParts
     *     const normalizedPart = await prisma.normalizedPart.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NormalizedPartCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NormalizedPartCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NormalizedPart.
     * @param {NormalizedPartDeleteArgs} args - Arguments to delete one NormalizedPart.
     * @example
     * // Delete one NormalizedPart
     * const NormalizedPart = await prisma.normalizedPart.delete({
     *   where: {
     *     // ... filter to delete one NormalizedPart
     *   }
     * })
     * 
    **/
    delete<T extends NormalizedPartDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NormalizedPartDeleteArgs<ExtArgs>>
    ): Prisma__NormalizedPartClient<$Types.GetResult<NormalizedPartPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one NormalizedPart.
     * @param {NormalizedPartUpdateArgs} args - Arguments to update one NormalizedPart.
     * @example
     * // Update one NormalizedPart
     * const normalizedPart = await prisma.normalizedPart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NormalizedPartUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NormalizedPartUpdateArgs<ExtArgs>>
    ): Prisma__NormalizedPartClient<$Types.GetResult<NormalizedPartPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more NormalizedParts.
     * @param {NormalizedPartDeleteManyArgs} args - Arguments to filter NormalizedParts to delete.
     * @example
     * // Delete a few NormalizedParts
     * const { count } = await prisma.normalizedPart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NormalizedPartDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NormalizedPartDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NormalizedParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalizedPartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NormalizedParts
     * const normalizedPart = await prisma.normalizedPart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NormalizedPartUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NormalizedPartUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NormalizedPart.
     * @param {NormalizedPartUpsertArgs} args - Arguments to update or create a NormalizedPart.
     * @example
     * // Update or create a NormalizedPart
     * const normalizedPart = await prisma.normalizedPart.upsert({
     *   create: {
     *     // ... data to create a NormalizedPart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NormalizedPart we want to update
     *   }
     * })
    **/
    upsert<T extends NormalizedPartUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NormalizedPartUpsertArgs<ExtArgs>>
    ): Prisma__NormalizedPartClient<$Types.GetResult<NormalizedPartPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of NormalizedParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalizedPartCountArgs} args - Arguments to filter NormalizedParts to count.
     * @example
     * // Count the number of NormalizedParts
     * const count = await prisma.normalizedPart.count({
     *   where: {
     *     // ... the filter for the NormalizedParts we want to count
     *   }
     * })
    **/
    count<T extends NormalizedPartCountArgs>(
      args?: Subset<T, NormalizedPartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NormalizedPartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NormalizedPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalizedPartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NormalizedPartAggregateArgs>(args: Subset<T, NormalizedPartAggregateArgs>): Prisma.PrismaPromise<GetNormalizedPartAggregateType<T>>

    /**
     * Group by NormalizedPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalizedPartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NormalizedPartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NormalizedPartGroupByArgs['orderBy'] }
        : { orderBy?: NormalizedPartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NormalizedPartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNormalizedPartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for NormalizedPart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NormalizedPartClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    invoice<T extends InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * NormalizedPart base type for findUnique actions
   */
  export type NormalizedPartFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedPart
     */
    select?: NormalizedPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NormalizedPartInclude<ExtArgs> | null
    /**
     * Filter, which NormalizedPart to fetch.
     */
    where: NormalizedPartWhereUniqueInput
  }

  /**
   * NormalizedPart findUnique
   */
  export interface NormalizedPartFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NormalizedPartFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NormalizedPart findUniqueOrThrow
   */
  export type NormalizedPartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedPart
     */
    select?: NormalizedPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NormalizedPartInclude<ExtArgs> | null
    /**
     * Filter, which NormalizedPart to fetch.
     */
    where: NormalizedPartWhereUniqueInput
  }


  /**
   * NormalizedPart base type for findFirst actions
   */
  export type NormalizedPartFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedPart
     */
    select?: NormalizedPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NormalizedPartInclude<ExtArgs> | null
    /**
     * Filter, which NormalizedPart to fetch.
     */
    where?: NormalizedPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NormalizedParts to fetch.
     */
    orderBy?: Enumerable<NormalizedPartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NormalizedParts.
     */
    cursor?: NormalizedPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NormalizedParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NormalizedParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NormalizedParts.
     */
    distinct?: Enumerable<NormalizedPartScalarFieldEnum>
  }

  /**
   * NormalizedPart findFirst
   */
  export interface NormalizedPartFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NormalizedPartFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NormalizedPart findFirstOrThrow
   */
  export type NormalizedPartFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedPart
     */
    select?: NormalizedPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NormalizedPartInclude<ExtArgs> | null
    /**
     * Filter, which NormalizedPart to fetch.
     */
    where?: NormalizedPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NormalizedParts to fetch.
     */
    orderBy?: Enumerable<NormalizedPartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NormalizedParts.
     */
    cursor?: NormalizedPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NormalizedParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NormalizedParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NormalizedParts.
     */
    distinct?: Enumerable<NormalizedPartScalarFieldEnum>
  }


  /**
   * NormalizedPart findMany
   */
  export type NormalizedPartFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedPart
     */
    select?: NormalizedPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NormalizedPartInclude<ExtArgs> | null
    /**
     * Filter, which NormalizedParts to fetch.
     */
    where?: NormalizedPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NormalizedParts to fetch.
     */
    orderBy?: Enumerable<NormalizedPartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NormalizedParts.
     */
    cursor?: NormalizedPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NormalizedParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NormalizedParts.
     */
    skip?: number
    distinct?: Enumerable<NormalizedPartScalarFieldEnum>
  }


  /**
   * NormalizedPart create
   */
  export type NormalizedPartCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedPart
     */
    select?: NormalizedPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NormalizedPartInclude<ExtArgs> | null
    /**
     * The data needed to create a NormalizedPart.
     */
    data: XOR<NormalizedPartCreateInput, NormalizedPartUncheckedCreateInput>
  }


  /**
   * NormalizedPart createMany
   */
  export type NormalizedPartCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NormalizedParts.
     */
    data: Enumerable<NormalizedPartCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NormalizedPart update
   */
  export type NormalizedPartUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedPart
     */
    select?: NormalizedPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NormalizedPartInclude<ExtArgs> | null
    /**
     * The data needed to update a NormalizedPart.
     */
    data: XOR<NormalizedPartUpdateInput, NormalizedPartUncheckedUpdateInput>
    /**
     * Choose, which NormalizedPart to update.
     */
    where: NormalizedPartWhereUniqueInput
  }


  /**
   * NormalizedPart updateMany
   */
  export type NormalizedPartUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NormalizedParts.
     */
    data: XOR<NormalizedPartUpdateManyMutationInput, NormalizedPartUncheckedUpdateManyInput>
    /**
     * Filter which NormalizedParts to update
     */
    where?: NormalizedPartWhereInput
  }


  /**
   * NormalizedPart upsert
   */
  export type NormalizedPartUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedPart
     */
    select?: NormalizedPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NormalizedPartInclude<ExtArgs> | null
    /**
     * The filter to search for the NormalizedPart to update in case it exists.
     */
    where: NormalizedPartWhereUniqueInput
    /**
     * In case the NormalizedPart found by the `where` argument doesn't exist, create a new NormalizedPart with this data.
     */
    create: XOR<NormalizedPartCreateInput, NormalizedPartUncheckedCreateInput>
    /**
     * In case the NormalizedPart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NormalizedPartUpdateInput, NormalizedPartUncheckedUpdateInput>
  }


  /**
   * NormalizedPart delete
   */
  export type NormalizedPartDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedPart
     */
    select?: NormalizedPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NormalizedPartInclude<ExtArgs> | null
    /**
     * Filter which NormalizedPart to delete.
     */
    where: NormalizedPartWhereUniqueInput
  }


  /**
   * NormalizedPart deleteMany
   */
  export type NormalizedPartDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which NormalizedParts to delete
     */
    where?: NormalizedPartWhereInput
  }


  /**
   * NormalizedPart without action
   */
  export type NormalizedPartArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedPart
     */
    select?: NormalizedPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NormalizedPartInclude<ExtArgs> | null
  }



  /**
   * Model AIDecision
   */


  export type AggregateAIDecision = {
    _count: AIDecisionCountAggregateOutputType | null
    _avg: AIDecisionAvgAggregateOutputType | null
    _sum: AIDecisionSumAggregateOutputType | null
    _min: AIDecisionMinAggregateOutputType | null
    _max: AIDecisionMaxAggregateOutputType | null
  }

  export type AIDecisionAvgAggregateOutputType = {
    confidence: number | null
  }

  export type AIDecisionSumAggregateOutputType = {
    confidence: number | null
  }

  export type AIDecisionMinAggregateOutputType = {
    id: string | null
    entityType: EntityType | null
    entityId: string | null
    model: string | null
    promptHash: string | null
    responseHash: string | null
    decision: string | null
    confidence: number | null
    userId: string | null
    createdAt: Date | null
  }

  export type AIDecisionMaxAggregateOutputType = {
    id: string | null
    entityType: EntityType | null
    entityId: string | null
    model: string | null
    promptHash: string | null
    responseHash: string | null
    decision: string | null
    confidence: number | null
    userId: string | null
    createdAt: Date | null
  }

  export type AIDecisionCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    model: number
    promptHash: number
    responseHash: number
    decision: number
    confidence: number
    metadata: number
    userId: number
    createdAt: number
    _all: number
  }


  export type AIDecisionAvgAggregateInputType = {
    confidence?: true
  }

  export type AIDecisionSumAggregateInputType = {
    confidence?: true
  }

  export type AIDecisionMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    model?: true
    promptHash?: true
    responseHash?: true
    decision?: true
    confidence?: true
    userId?: true
    createdAt?: true
  }

  export type AIDecisionMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    model?: true
    promptHash?: true
    responseHash?: true
    decision?: true
    confidence?: true
    userId?: true
    createdAt?: true
  }

  export type AIDecisionCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    model?: true
    promptHash?: true
    responseHash?: true
    decision?: true
    confidence?: true
    metadata?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type AIDecisionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIDecision to aggregate.
     */
    where?: AIDecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDecisions to fetch.
     */
    orderBy?: Enumerable<AIDecisionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIDecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDecisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDecisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIDecisions
    **/
    _count?: true | AIDecisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIDecisionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIDecisionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIDecisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIDecisionMaxAggregateInputType
  }

  export type GetAIDecisionAggregateType<T extends AIDecisionAggregateArgs> = {
        [P in keyof T & keyof AggregateAIDecision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIDecision[P]>
      : GetScalarType<T[P], AggregateAIDecision[P]>
  }




  export type AIDecisionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AIDecisionWhereInput
    orderBy?: Enumerable<AIDecisionOrderByWithAggregationInput>
    by: AIDecisionScalarFieldEnum[]
    having?: AIDecisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIDecisionCountAggregateInputType | true
    _avg?: AIDecisionAvgAggregateInputType
    _sum?: AIDecisionSumAggregateInputType
    _min?: AIDecisionMinAggregateInputType
    _max?: AIDecisionMaxAggregateInputType
  }


  export type AIDecisionGroupByOutputType = {
    id: string
    entityType: EntityType
    entityId: string
    model: string
    promptHash: string
    responseHash: string
    decision: string
    confidence: number | null
    metadata: JsonValue | null
    userId: string | null
    createdAt: Date
    _count: AIDecisionCountAggregateOutputType | null
    _avg: AIDecisionAvgAggregateOutputType | null
    _sum: AIDecisionSumAggregateOutputType | null
    _min: AIDecisionMinAggregateOutputType | null
    _max: AIDecisionMaxAggregateOutputType | null
  }

  type GetAIDecisionGroupByPayload<T extends AIDecisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AIDecisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIDecisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIDecisionGroupByOutputType[P]>
            : GetScalarType<T[P], AIDecisionGroupByOutputType[P]>
        }
      >
    >


  export type AIDecisionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    model?: boolean
    promptHash?: boolean
    responseHash?: boolean
    decision?: boolean
    confidence?: boolean
    metadata?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["aIDecision"]>

  export type AIDecisionSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    model?: boolean
    promptHash?: boolean
    responseHash?: boolean
    decision?: boolean
    confidence?: boolean
    metadata?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type AIDecisionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type AIDecisionGetPayload<S extends boolean | null | undefined | AIDecisionArgs> = $Types.GetResult<AIDecisionPayload, S>

  type AIDecisionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AIDecisionFindManyArgs, 'select' | 'include'> & {
      select?: AIDecisionCountAggregateInputType | true
    }

  export interface AIDecisionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIDecision'], meta: { name: 'AIDecision' } }
    /**
     * Find zero or one AIDecision that matches the filter.
     * @param {AIDecisionFindUniqueArgs} args - Arguments to find a AIDecision
     * @example
     * // Get one AIDecision
     * const aIDecision = await prisma.aIDecision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AIDecisionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AIDecisionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AIDecision'> extends True ? Prisma__AIDecisionClient<$Types.GetResult<AIDecisionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AIDecisionClient<$Types.GetResult<AIDecisionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one AIDecision that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AIDecisionFindUniqueOrThrowArgs} args - Arguments to find a AIDecision
     * @example
     * // Get one AIDecision
     * const aIDecision = await prisma.aIDecision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AIDecisionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AIDecisionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AIDecisionClient<$Types.GetResult<AIDecisionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first AIDecision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDecisionFindFirstArgs} args - Arguments to find a AIDecision
     * @example
     * // Get one AIDecision
     * const aIDecision = await prisma.aIDecision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AIDecisionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AIDecisionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AIDecision'> extends True ? Prisma__AIDecisionClient<$Types.GetResult<AIDecisionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AIDecisionClient<$Types.GetResult<AIDecisionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first AIDecision that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDecisionFindFirstOrThrowArgs} args - Arguments to find a AIDecision
     * @example
     * // Get one AIDecision
     * const aIDecision = await prisma.aIDecision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AIDecisionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AIDecisionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AIDecisionClient<$Types.GetResult<AIDecisionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more AIDecisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDecisionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIDecisions
     * const aIDecisions = await prisma.aIDecision.findMany()
     * 
     * // Get first 10 AIDecisions
     * const aIDecisions = await prisma.aIDecision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIDecisionWithIdOnly = await prisma.aIDecision.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AIDecisionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AIDecisionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AIDecisionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a AIDecision.
     * @param {AIDecisionCreateArgs} args - Arguments to create a AIDecision.
     * @example
     * // Create one AIDecision
     * const AIDecision = await prisma.aIDecision.create({
     *   data: {
     *     // ... data to create a AIDecision
     *   }
     * })
     * 
    **/
    create<T extends AIDecisionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AIDecisionCreateArgs<ExtArgs>>
    ): Prisma__AIDecisionClient<$Types.GetResult<AIDecisionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many AIDecisions.
     *     @param {AIDecisionCreateManyArgs} args - Arguments to create many AIDecisions.
     *     @example
     *     // Create many AIDecisions
     *     const aIDecision = await prisma.aIDecision.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AIDecisionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AIDecisionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AIDecision.
     * @param {AIDecisionDeleteArgs} args - Arguments to delete one AIDecision.
     * @example
     * // Delete one AIDecision
     * const AIDecision = await prisma.aIDecision.delete({
     *   where: {
     *     // ... filter to delete one AIDecision
     *   }
     * })
     * 
    **/
    delete<T extends AIDecisionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AIDecisionDeleteArgs<ExtArgs>>
    ): Prisma__AIDecisionClient<$Types.GetResult<AIDecisionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one AIDecision.
     * @param {AIDecisionUpdateArgs} args - Arguments to update one AIDecision.
     * @example
     * // Update one AIDecision
     * const aIDecision = await prisma.aIDecision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AIDecisionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AIDecisionUpdateArgs<ExtArgs>>
    ): Prisma__AIDecisionClient<$Types.GetResult<AIDecisionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more AIDecisions.
     * @param {AIDecisionDeleteManyArgs} args - Arguments to filter AIDecisions to delete.
     * @example
     * // Delete a few AIDecisions
     * const { count } = await prisma.aIDecision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AIDecisionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AIDecisionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIDecisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDecisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIDecisions
     * const aIDecision = await prisma.aIDecision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AIDecisionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AIDecisionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIDecision.
     * @param {AIDecisionUpsertArgs} args - Arguments to update or create a AIDecision.
     * @example
     * // Update or create a AIDecision
     * const aIDecision = await prisma.aIDecision.upsert({
     *   create: {
     *     // ... data to create a AIDecision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIDecision we want to update
     *   }
     * })
    **/
    upsert<T extends AIDecisionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AIDecisionUpsertArgs<ExtArgs>>
    ): Prisma__AIDecisionClient<$Types.GetResult<AIDecisionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of AIDecisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDecisionCountArgs} args - Arguments to filter AIDecisions to count.
     * @example
     * // Count the number of AIDecisions
     * const count = await prisma.aIDecision.count({
     *   where: {
     *     // ... the filter for the AIDecisions we want to count
     *   }
     * })
    **/
    count<T extends AIDecisionCountArgs>(
      args?: Subset<T, AIDecisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIDecisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIDecision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDecisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIDecisionAggregateArgs>(args: Subset<T, AIDecisionAggregateArgs>): Prisma.PrismaPromise<GetAIDecisionAggregateType<T>>

    /**
     * Group by AIDecision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDecisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIDecisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIDecisionGroupByArgs['orderBy'] }
        : { orderBy?: AIDecisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIDecisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIDecisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AIDecision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AIDecisionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AIDecision base type for findUnique actions
   */
  export type AIDecisionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * Filter, which AIDecision to fetch.
     */
    where: AIDecisionWhereUniqueInput
  }

  /**
   * AIDecision findUnique
   */
  export interface AIDecisionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AIDecisionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AIDecision findUniqueOrThrow
   */
  export type AIDecisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * Filter, which AIDecision to fetch.
     */
    where: AIDecisionWhereUniqueInput
  }


  /**
   * AIDecision base type for findFirst actions
   */
  export type AIDecisionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * Filter, which AIDecision to fetch.
     */
    where?: AIDecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDecisions to fetch.
     */
    orderBy?: Enumerable<AIDecisionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIDecisions.
     */
    cursor?: AIDecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDecisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDecisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIDecisions.
     */
    distinct?: Enumerable<AIDecisionScalarFieldEnum>
  }

  /**
   * AIDecision findFirst
   */
  export interface AIDecisionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AIDecisionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AIDecision findFirstOrThrow
   */
  export type AIDecisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * Filter, which AIDecision to fetch.
     */
    where?: AIDecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDecisions to fetch.
     */
    orderBy?: Enumerable<AIDecisionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIDecisions.
     */
    cursor?: AIDecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDecisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDecisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIDecisions.
     */
    distinct?: Enumerable<AIDecisionScalarFieldEnum>
  }


  /**
   * AIDecision findMany
   */
  export type AIDecisionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * Filter, which AIDecisions to fetch.
     */
    where?: AIDecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDecisions to fetch.
     */
    orderBy?: Enumerable<AIDecisionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIDecisions.
     */
    cursor?: AIDecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDecisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDecisions.
     */
    skip?: number
    distinct?: Enumerable<AIDecisionScalarFieldEnum>
  }


  /**
   * AIDecision create
   */
  export type AIDecisionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * The data needed to create a AIDecision.
     */
    data: XOR<AIDecisionCreateInput, AIDecisionUncheckedCreateInput>
  }


  /**
   * AIDecision createMany
   */
  export type AIDecisionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIDecisions.
     */
    data: Enumerable<AIDecisionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AIDecision update
   */
  export type AIDecisionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * The data needed to update a AIDecision.
     */
    data: XOR<AIDecisionUpdateInput, AIDecisionUncheckedUpdateInput>
    /**
     * Choose, which AIDecision to update.
     */
    where: AIDecisionWhereUniqueInput
  }


  /**
   * AIDecision updateMany
   */
  export type AIDecisionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIDecisions.
     */
    data: XOR<AIDecisionUpdateManyMutationInput, AIDecisionUncheckedUpdateManyInput>
    /**
     * Filter which AIDecisions to update
     */
    where?: AIDecisionWhereInput
  }


  /**
   * AIDecision upsert
   */
  export type AIDecisionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * The filter to search for the AIDecision to update in case it exists.
     */
    where: AIDecisionWhereUniqueInput
    /**
     * In case the AIDecision found by the `where` argument doesn't exist, create a new AIDecision with this data.
     */
    create: XOR<AIDecisionCreateInput, AIDecisionUncheckedCreateInput>
    /**
     * In case the AIDecision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIDecisionUpdateInput, AIDecisionUncheckedUpdateInput>
  }


  /**
   * AIDecision delete
   */
  export type AIDecisionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * Filter which AIDecision to delete.
     */
    where: AIDecisionWhereUniqueInput
  }


  /**
   * AIDecision deleteMany
   */
  export type AIDecisionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIDecisions to delete
     */
    where?: AIDecisionWhereInput
  }


  /**
   * AIDecision without action
   */
  export type AIDecisionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIDecisionInclude<ExtArgs> | null
  }



  /**
   * Model AIQuota
   */


  export type AggregateAIQuota = {
    _count: AIQuotaCountAggregateOutputType | null
    _avg: AIQuotaAvgAggregateOutputType | null
    _sum: AIQuotaSumAggregateOutputType | null
    _min: AIQuotaMinAggregateOutputType | null
    _max: AIQuotaMaxAggregateOutputType | null
  }

  export type AIQuotaAvgAggregateOutputType = {
    invoicesProcessed: number | null
    rejectedCount: number | null
  }

  export type AIQuotaSumAggregateOutputType = {
    invoicesProcessed: number | null
    rejectedCount: number | null
  }

  export type AIQuotaMinAggregateOutputType = {
    id: string | null
    userId: string | null
    invoicesProcessed: number | null
    rejectedCount: number | null
    periodStart: Date | null
    periodEnd: Date | null
  }

  export type AIQuotaMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    invoicesProcessed: number | null
    rejectedCount: number | null
    periodStart: Date | null
    periodEnd: Date | null
  }

  export type AIQuotaCountAggregateOutputType = {
    id: number
    userId: number
    invoicesProcessed: number
    rejectedCount: number
    periodStart: number
    periodEnd: number
    _all: number
  }


  export type AIQuotaAvgAggregateInputType = {
    invoicesProcessed?: true
    rejectedCount?: true
  }

  export type AIQuotaSumAggregateInputType = {
    invoicesProcessed?: true
    rejectedCount?: true
  }

  export type AIQuotaMinAggregateInputType = {
    id?: true
    userId?: true
    invoicesProcessed?: true
    rejectedCount?: true
    periodStart?: true
    periodEnd?: true
  }

  export type AIQuotaMaxAggregateInputType = {
    id?: true
    userId?: true
    invoicesProcessed?: true
    rejectedCount?: true
    periodStart?: true
    periodEnd?: true
  }

  export type AIQuotaCountAggregateInputType = {
    id?: true
    userId?: true
    invoicesProcessed?: true
    rejectedCount?: true
    periodStart?: true
    periodEnd?: true
    _all?: true
  }

  export type AIQuotaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIQuota to aggregate.
     */
    where?: AIQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIQuotas to fetch.
     */
    orderBy?: Enumerable<AIQuotaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIQuotas
    **/
    _count?: true | AIQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIQuotaMaxAggregateInputType
  }

  export type GetAIQuotaAggregateType<T extends AIQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateAIQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIQuota[P]>
      : GetScalarType<T[P], AggregateAIQuota[P]>
  }




  export type AIQuotaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AIQuotaWhereInput
    orderBy?: Enumerable<AIQuotaOrderByWithAggregationInput>
    by: AIQuotaScalarFieldEnum[]
    having?: AIQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIQuotaCountAggregateInputType | true
    _avg?: AIQuotaAvgAggregateInputType
    _sum?: AIQuotaSumAggregateInputType
    _min?: AIQuotaMinAggregateInputType
    _max?: AIQuotaMaxAggregateInputType
  }


  export type AIQuotaGroupByOutputType = {
    id: string
    userId: string
    invoicesProcessed: number
    rejectedCount: number
    periodStart: Date
    periodEnd: Date
    _count: AIQuotaCountAggregateOutputType | null
    _avg: AIQuotaAvgAggregateOutputType | null
    _sum: AIQuotaSumAggregateOutputType | null
    _min: AIQuotaMinAggregateOutputType | null
    _max: AIQuotaMaxAggregateOutputType | null
  }

  type GetAIQuotaGroupByPayload<T extends AIQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AIQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], AIQuotaGroupByOutputType[P]>
        }
      >
    >


  export type AIQuotaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    invoicesProcessed?: boolean
    rejectedCount?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["aIQuota"]>

  export type AIQuotaSelectScalar = {
    id?: boolean
    userId?: boolean
    invoicesProcessed?: boolean
    rejectedCount?: boolean
    periodStart?: boolean
    periodEnd?: boolean
  }

  export type AIQuotaInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type AIQuotaGetPayload<S extends boolean | null | undefined | AIQuotaArgs> = $Types.GetResult<AIQuotaPayload, S>

  type AIQuotaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AIQuotaFindManyArgs, 'select' | 'include'> & {
      select?: AIQuotaCountAggregateInputType | true
    }

  export interface AIQuotaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIQuota'], meta: { name: 'AIQuota' } }
    /**
     * Find zero or one AIQuota that matches the filter.
     * @param {AIQuotaFindUniqueArgs} args - Arguments to find a AIQuota
     * @example
     * // Get one AIQuota
     * const aIQuota = await prisma.aIQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AIQuotaFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AIQuotaFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AIQuota'> extends True ? Prisma__AIQuotaClient<$Types.GetResult<AIQuotaPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AIQuotaClient<$Types.GetResult<AIQuotaPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one AIQuota that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AIQuotaFindUniqueOrThrowArgs} args - Arguments to find a AIQuota
     * @example
     * // Get one AIQuota
     * const aIQuota = await prisma.aIQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AIQuotaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AIQuotaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AIQuotaClient<$Types.GetResult<AIQuotaPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first AIQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIQuotaFindFirstArgs} args - Arguments to find a AIQuota
     * @example
     * // Get one AIQuota
     * const aIQuota = await prisma.aIQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AIQuotaFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AIQuotaFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AIQuota'> extends True ? Prisma__AIQuotaClient<$Types.GetResult<AIQuotaPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AIQuotaClient<$Types.GetResult<AIQuotaPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first AIQuota that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIQuotaFindFirstOrThrowArgs} args - Arguments to find a AIQuota
     * @example
     * // Get one AIQuota
     * const aIQuota = await prisma.aIQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AIQuotaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AIQuotaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AIQuotaClient<$Types.GetResult<AIQuotaPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more AIQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIQuotaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIQuotas
     * const aIQuotas = await prisma.aIQuota.findMany()
     * 
     * // Get first 10 AIQuotas
     * const aIQuotas = await prisma.aIQuota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIQuotaWithIdOnly = await prisma.aIQuota.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AIQuotaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AIQuotaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AIQuotaPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a AIQuota.
     * @param {AIQuotaCreateArgs} args - Arguments to create a AIQuota.
     * @example
     * // Create one AIQuota
     * const AIQuota = await prisma.aIQuota.create({
     *   data: {
     *     // ... data to create a AIQuota
     *   }
     * })
     * 
    **/
    create<T extends AIQuotaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AIQuotaCreateArgs<ExtArgs>>
    ): Prisma__AIQuotaClient<$Types.GetResult<AIQuotaPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many AIQuotas.
     *     @param {AIQuotaCreateManyArgs} args - Arguments to create many AIQuotas.
     *     @example
     *     // Create many AIQuotas
     *     const aIQuota = await prisma.aIQuota.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AIQuotaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AIQuotaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AIQuota.
     * @param {AIQuotaDeleteArgs} args - Arguments to delete one AIQuota.
     * @example
     * // Delete one AIQuota
     * const AIQuota = await prisma.aIQuota.delete({
     *   where: {
     *     // ... filter to delete one AIQuota
     *   }
     * })
     * 
    **/
    delete<T extends AIQuotaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AIQuotaDeleteArgs<ExtArgs>>
    ): Prisma__AIQuotaClient<$Types.GetResult<AIQuotaPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one AIQuota.
     * @param {AIQuotaUpdateArgs} args - Arguments to update one AIQuota.
     * @example
     * // Update one AIQuota
     * const aIQuota = await prisma.aIQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AIQuotaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AIQuotaUpdateArgs<ExtArgs>>
    ): Prisma__AIQuotaClient<$Types.GetResult<AIQuotaPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more AIQuotas.
     * @param {AIQuotaDeleteManyArgs} args - Arguments to filter AIQuotas to delete.
     * @example
     * // Delete a few AIQuotas
     * const { count } = await prisma.aIQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AIQuotaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AIQuotaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIQuotas
     * const aIQuota = await prisma.aIQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AIQuotaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AIQuotaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIQuota.
     * @param {AIQuotaUpsertArgs} args - Arguments to update or create a AIQuota.
     * @example
     * // Update or create a AIQuota
     * const aIQuota = await prisma.aIQuota.upsert({
     *   create: {
     *     // ... data to create a AIQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIQuota we want to update
     *   }
     * })
    **/
    upsert<T extends AIQuotaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AIQuotaUpsertArgs<ExtArgs>>
    ): Prisma__AIQuotaClient<$Types.GetResult<AIQuotaPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of AIQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIQuotaCountArgs} args - Arguments to filter AIQuotas to count.
     * @example
     * // Count the number of AIQuotas
     * const count = await prisma.aIQuota.count({
     *   where: {
     *     // ... the filter for the AIQuotas we want to count
     *   }
     * })
    **/
    count<T extends AIQuotaCountArgs>(
      args?: Subset<T, AIQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIQuotaAggregateArgs>(args: Subset<T, AIQuotaAggregateArgs>): Prisma.PrismaPromise<GetAIQuotaAggregateType<T>>

    /**
     * Group by AIQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIQuotaGroupByArgs['orderBy'] }
        : { orderBy?: AIQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AIQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AIQuotaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AIQuota base type for findUnique actions
   */
  export type AIQuotaFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQuota
     */
    select?: AIQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIQuotaInclude<ExtArgs> | null
    /**
     * Filter, which AIQuota to fetch.
     */
    where: AIQuotaWhereUniqueInput
  }

  /**
   * AIQuota findUnique
   */
  export interface AIQuotaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AIQuotaFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AIQuota findUniqueOrThrow
   */
  export type AIQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQuota
     */
    select?: AIQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIQuotaInclude<ExtArgs> | null
    /**
     * Filter, which AIQuota to fetch.
     */
    where: AIQuotaWhereUniqueInput
  }


  /**
   * AIQuota base type for findFirst actions
   */
  export type AIQuotaFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQuota
     */
    select?: AIQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIQuotaInclude<ExtArgs> | null
    /**
     * Filter, which AIQuota to fetch.
     */
    where?: AIQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIQuotas to fetch.
     */
    orderBy?: Enumerable<AIQuotaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIQuotas.
     */
    cursor?: AIQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIQuotas.
     */
    distinct?: Enumerable<AIQuotaScalarFieldEnum>
  }

  /**
   * AIQuota findFirst
   */
  export interface AIQuotaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AIQuotaFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AIQuota findFirstOrThrow
   */
  export type AIQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQuota
     */
    select?: AIQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIQuotaInclude<ExtArgs> | null
    /**
     * Filter, which AIQuota to fetch.
     */
    where?: AIQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIQuotas to fetch.
     */
    orderBy?: Enumerable<AIQuotaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIQuotas.
     */
    cursor?: AIQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIQuotas.
     */
    distinct?: Enumerable<AIQuotaScalarFieldEnum>
  }


  /**
   * AIQuota findMany
   */
  export type AIQuotaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQuota
     */
    select?: AIQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIQuotaInclude<ExtArgs> | null
    /**
     * Filter, which AIQuotas to fetch.
     */
    where?: AIQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIQuotas to fetch.
     */
    orderBy?: Enumerable<AIQuotaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIQuotas.
     */
    cursor?: AIQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIQuotas.
     */
    skip?: number
    distinct?: Enumerable<AIQuotaScalarFieldEnum>
  }


  /**
   * AIQuota create
   */
  export type AIQuotaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQuota
     */
    select?: AIQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIQuotaInclude<ExtArgs> | null
    /**
     * The data needed to create a AIQuota.
     */
    data: XOR<AIQuotaCreateInput, AIQuotaUncheckedCreateInput>
  }


  /**
   * AIQuota createMany
   */
  export type AIQuotaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIQuotas.
     */
    data: Enumerable<AIQuotaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AIQuota update
   */
  export type AIQuotaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQuota
     */
    select?: AIQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIQuotaInclude<ExtArgs> | null
    /**
     * The data needed to update a AIQuota.
     */
    data: XOR<AIQuotaUpdateInput, AIQuotaUncheckedUpdateInput>
    /**
     * Choose, which AIQuota to update.
     */
    where: AIQuotaWhereUniqueInput
  }


  /**
   * AIQuota updateMany
   */
  export type AIQuotaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIQuotas.
     */
    data: XOR<AIQuotaUpdateManyMutationInput, AIQuotaUncheckedUpdateManyInput>
    /**
     * Filter which AIQuotas to update
     */
    where?: AIQuotaWhereInput
  }


  /**
   * AIQuota upsert
   */
  export type AIQuotaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQuota
     */
    select?: AIQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIQuotaInclude<ExtArgs> | null
    /**
     * The filter to search for the AIQuota to update in case it exists.
     */
    where: AIQuotaWhereUniqueInput
    /**
     * In case the AIQuota found by the `where` argument doesn't exist, create a new AIQuota with this data.
     */
    create: XOR<AIQuotaCreateInput, AIQuotaUncheckedCreateInput>
    /**
     * In case the AIQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIQuotaUpdateInput, AIQuotaUncheckedUpdateInput>
  }


  /**
   * AIQuota delete
   */
  export type AIQuotaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQuota
     */
    select?: AIQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIQuotaInclude<ExtArgs> | null
    /**
     * Filter which AIQuota to delete.
     */
    where: AIQuotaWhereUniqueInput
  }


  /**
   * AIQuota deleteMany
   */
  export type AIQuotaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIQuotas to delete
     */
    where?: AIQuotaWhereInput
  }


  /**
   * AIQuota without action
   */
  export type AIQuotaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQuota
     */
    select?: AIQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIQuotaInclude<ExtArgs> | null
  }



  /**
   * Model ConditionMatrix
   */


  export type AggregateConditionMatrix = {
    _count: ConditionMatrixCountAggregateOutputType | null
    _min: ConditionMatrixMinAggregateOutputType | null
    _max: ConditionMatrixMaxAggregateOutputType | null
  }

  export type ConditionMatrixMinAggregateOutputType = {
    id: string | null
    vinPassportId: string | null
    version: string | null
    rulesHash: string | null
    effectiveFrom: Date | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ConditionMatrixMaxAggregateOutputType = {
    id: string | null
    vinPassportId: string | null
    version: string | null
    rulesHash: string | null
    effectiveFrom: Date | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ConditionMatrixCountAggregateOutputType = {
    id: number
    vinPassportId: number
    version: number
    rulesHash: number
    effectiveFrom: number
    isActive: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ConditionMatrixMinAggregateInputType = {
    id?: true
    vinPassportId?: true
    version?: true
    rulesHash?: true
    effectiveFrom?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ConditionMatrixMaxAggregateInputType = {
    id?: true
    vinPassportId?: true
    version?: true
    rulesHash?: true
    effectiveFrom?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ConditionMatrixCountAggregateInputType = {
    id?: true
    vinPassportId?: true
    version?: true
    rulesHash?: true
    effectiveFrom?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ConditionMatrixAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConditionMatrix to aggregate.
     */
    where?: ConditionMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConditionMatrices to fetch.
     */
    orderBy?: Enumerable<ConditionMatrixOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConditionMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConditionMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConditionMatrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConditionMatrices
    **/
    _count?: true | ConditionMatrixCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConditionMatrixMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConditionMatrixMaxAggregateInputType
  }

  export type GetConditionMatrixAggregateType<T extends ConditionMatrixAggregateArgs> = {
        [P in keyof T & keyof AggregateConditionMatrix]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConditionMatrix[P]>
      : GetScalarType<T[P], AggregateConditionMatrix[P]>
  }




  export type ConditionMatrixGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConditionMatrixWhereInput
    orderBy?: Enumerable<ConditionMatrixOrderByWithAggregationInput>
    by: ConditionMatrixScalarFieldEnum[]
    having?: ConditionMatrixScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConditionMatrixCountAggregateInputType | true
    _min?: ConditionMatrixMinAggregateInputType
    _max?: ConditionMatrixMaxAggregateInputType
  }


  export type ConditionMatrixGroupByOutputType = {
    id: string
    vinPassportId: string | null
    version: string
    rulesHash: string
    effectiveFrom: Date
    isActive: boolean
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    _count: ConditionMatrixCountAggregateOutputType | null
    _min: ConditionMatrixMinAggregateOutputType | null
    _max: ConditionMatrixMaxAggregateOutputType | null
  }

  type GetConditionMatrixGroupByPayload<T extends ConditionMatrixGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ConditionMatrixGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConditionMatrixGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConditionMatrixGroupByOutputType[P]>
            : GetScalarType<T[P], ConditionMatrixGroupByOutputType[P]>
        }
      >
    >


  export type ConditionMatrixSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vinPassportId?: boolean
    version?: boolean
    rulesHash?: boolean
    effectiveFrom?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    vinPassport?: boolean | VinPassportArgs<ExtArgs>
    auditLogs?: boolean | ConditionMatrix$auditLogsArgs<ExtArgs>
    _count?: boolean | ConditionMatrixCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["conditionMatrix"]>

  export type ConditionMatrixSelectScalar = {
    id?: boolean
    vinPassportId?: boolean
    version?: boolean
    rulesHash?: boolean
    effectiveFrom?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ConditionMatrixInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    vinPassport?: boolean | VinPassportArgs<ExtArgs>
    auditLogs?: boolean | ConditionMatrix$auditLogsArgs<ExtArgs>
    _count?: boolean | ConditionMatrixCountOutputTypeArgs<ExtArgs>
  }


  type ConditionMatrixGetPayload<S extends boolean | null | undefined | ConditionMatrixArgs> = $Types.GetResult<ConditionMatrixPayload, S>

  type ConditionMatrixCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ConditionMatrixFindManyArgs, 'select' | 'include'> & {
      select?: ConditionMatrixCountAggregateInputType | true
    }

  export interface ConditionMatrixDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConditionMatrix'], meta: { name: 'ConditionMatrix' } }
    /**
     * Find zero or one ConditionMatrix that matches the filter.
     * @param {ConditionMatrixFindUniqueArgs} args - Arguments to find a ConditionMatrix
     * @example
     * // Get one ConditionMatrix
     * const conditionMatrix = await prisma.conditionMatrix.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConditionMatrixFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ConditionMatrixFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ConditionMatrix'> extends True ? Prisma__ConditionMatrixClient<$Types.GetResult<ConditionMatrixPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ConditionMatrixClient<$Types.GetResult<ConditionMatrixPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ConditionMatrix that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConditionMatrixFindUniqueOrThrowArgs} args - Arguments to find a ConditionMatrix
     * @example
     * // Get one ConditionMatrix
     * const conditionMatrix = await prisma.conditionMatrix.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConditionMatrixFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConditionMatrixFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConditionMatrixClient<$Types.GetResult<ConditionMatrixPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ConditionMatrix that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionMatrixFindFirstArgs} args - Arguments to find a ConditionMatrix
     * @example
     * // Get one ConditionMatrix
     * const conditionMatrix = await prisma.conditionMatrix.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConditionMatrixFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ConditionMatrixFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ConditionMatrix'> extends True ? Prisma__ConditionMatrixClient<$Types.GetResult<ConditionMatrixPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ConditionMatrixClient<$Types.GetResult<ConditionMatrixPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ConditionMatrix that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionMatrixFindFirstOrThrowArgs} args - Arguments to find a ConditionMatrix
     * @example
     * // Get one ConditionMatrix
     * const conditionMatrix = await prisma.conditionMatrix.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConditionMatrixFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConditionMatrixFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConditionMatrixClient<$Types.GetResult<ConditionMatrixPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ConditionMatrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionMatrixFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConditionMatrices
     * const conditionMatrices = await prisma.conditionMatrix.findMany()
     * 
     * // Get first 10 ConditionMatrices
     * const conditionMatrices = await prisma.conditionMatrix.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conditionMatrixWithIdOnly = await prisma.conditionMatrix.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConditionMatrixFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConditionMatrixFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ConditionMatrixPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ConditionMatrix.
     * @param {ConditionMatrixCreateArgs} args - Arguments to create a ConditionMatrix.
     * @example
     * // Create one ConditionMatrix
     * const ConditionMatrix = await prisma.conditionMatrix.create({
     *   data: {
     *     // ... data to create a ConditionMatrix
     *   }
     * })
     * 
    **/
    create<T extends ConditionMatrixCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConditionMatrixCreateArgs<ExtArgs>>
    ): Prisma__ConditionMatrixClient<$Types.GetResult<ConditionMatrixPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ConditionMatrices.
     *     @param {ConditionMatrixCreateManyArgs} args - Arguments to create many ConditionMatrices.
     *     @example
     *     // Create many ConditionMatrices
     *     const conditionMatrix = await prisma.conditionMatrix.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConditionMatrixCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConditionMatrixCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConditionMatrix.
     * @param {ConditionMatrixDeleteArgs} args - Arguments to delete one ConditionMatrix.
     * @example
     * // Delete one ConditionMatrix
     * const ConditionMatrix = await prisma.conditionMatrix.delete({
     *   where: {
     *     // ... filter to delete one ConditionMatrix
     *   }
     * })
     * 
    **/
    delete<T extends ConditionMatrixDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConditionMatrixDeleteArgs<ExtArgs>>
    ): Prisma__ConditionMatrixClient<$Types.GetResult<ConditionMatrixPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ConditionMatrix.
     * @param {ConditionMatrixUpdateArgs} args - Arguments to update one ConditionMatrix.
     * @example
     * // Update one ConditionMatrix
     * const conditionMatrix = await prisma.conditionMatrix.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConditionMatrixUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConditionMatrixUpdateArgs<ExtArgs>>
    ): Prisma__ConditionMatrixClient<$Types.GetResult<ConditionMatrixPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ConditionMatrices.
     * @param {ConditionMatrixDeleteManyArgs} args - Arguments to filter ConditionMatrices to delete.
     * @example
     * // Delete a few ConditionMatrices
     * const { count } = await prisma.conditionMatrix.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConditionMatrixDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConditionMatrixDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConditionMatrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionMatrixUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConditionMatrices
     * const conditionMatrix = await prisma.conditionMatrix.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConditionMatrixUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConditionMatrixUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConditionMatrix.
     * @param {ConditionMatrixUpsertArgs} args - Arguments to update or create a ConditionMatrix.
     * @example
     * // Update or create a ConditionMatrix
     * const conditionMatrix = await prisma.conditionMatrix.upsert({
     *   create: {
     *     // ... data to create a ConditionMatrix
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConditionMatrix we want to update
     *   }
     * })
    **/
    upsert<T extends ConditionMatrixUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConditionMatrixUpsertArgs<ExtArgs>>
    ): Prisma__ConditionMatrixClient<$Types.GetResult<ConditionMatrixPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ConditionMatrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionMatrixCountArgs} args - Arguments to filter ConditionMatrices to count.
     * @example
     * // Count the number of ConditionMatrices
     * const count = await prisma.conditionMatrix.count({
     *   where: {
     *     // ... the filter for the ConditionMatrices we want to count
     *   }
     * })
    **/
    count<T extends ConditionMatrixCountArgs>(
      args?: Subset<T, ConditionMatrixCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConditionMatrixCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConditionMatrix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionMatrixAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConditionMatrixAggregateArgs>(args: Subset<T, ConditionMatrixAggregateArgs>): Prisma.PrismaPromise<GetConditionMatrixAggregateType<T>>

    /**
     * Group by ConditionMatrix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionMatrixGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConditionMatrixGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConditionMatrixGroupByArgs['orderBy'] }
        : { orderBy?: ConditionMatrixGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConditionMatrixGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConditionMatrixGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ConditionMatrix.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConditionMatrixClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    vinPassport<T extends VinPassportArgs<ExtArgs> = {}>(args?: Subset<T, VinPassportArgs<ExtArgs>>): Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    auditLogs<T extends ConditionMatrix$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, ConditionMatrix$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ConditionMatrix base type for findUnique actions
   */
  export type ConditionMatrixFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionMatrix
     */
    select?: ConditionMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionMatrixInclude<ExtArgs> | null
    /**
     * Filter, which ConditionMatrix to fetch.
     */
    where: ConditionMatrixWhereUniqueInput
  }

  /**
   * ConditionMatrix findUnique
   */
  export interface ConditionMatrixFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ConditionMatrixFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ConditionMatrix findUniqueOrThrow
   */
  export type ConditionMatrixFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionMatrix
     */
    select?: ConditionMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionMatrixInclude<ExtArgs> | null
    /**
     * Filter, which ConditionMatrix to fetch.
     */
    where: ConditionMatrixWhereUniqueInput
  }


  /**
   * ConditionMatrix base type for findFirst actions
   */
  export type ConditionMatrixFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionMatrix
     */
    select?: ConditionMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionMatrixInclude<ExtArgs> | null
    /**
     * Filter, which ConditionMatrix to fetch.
     */
    where?: ConditionMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConditionMatrices to fetch.
     */
    orderBy?: Enumerable<ConditionMatrixOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConditionMatrices.
     */
    cursor?: ConditionMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConditionMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConditionMatrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConditionMatrices.
     */
    distinct?: Enumerable<ConditionMatrixScalarFieldEnum>
  }

  /**
   * ConditionMatrix findFirst
   */
  export interface ConditionMatrixFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ConditionMatrixFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ConditionMatrix findFirstOrThrow
   */
  export type ConditionMatrixFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionMatrix
     */
    select?: ConditionMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionMatrixInclude<ExtArgs> | null
    /**
     * Filter, which ConditionMatrix to fetch.
     */
    where?: ConditionMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConditionMatrices to fetch.
     */
    orderBy?: Enumerable<ConditionMatrixOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConditionMatrices.
     */
    cursor?: ConditionMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConditionMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConditionMatrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConditionMatrices.
     */
    distinct?: Enumerable<ConditionMatrixScalarFieldEnum>
  }


  /**
   * ConditionMatrix findMany
   */
  export type ConditionMatrixFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionMatrix
     */
    select?: ConditionMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionMatrixInclude<ExtArgs> | null
    /**
     * Filter, which ConditionMatrices to fetch.
     */
    where?: ConditionMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConditionMatrices to fetch.
     */
    orderBy?: Enumerable<ConditionMatrixOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConditionMatrices.
     */
    cursor?: ConditionMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConditionMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConditionMatrices.
     */
    skip?: number
    distinct?: Enumerable<ConditionMatrixScalarFieldEnum>
  }


  /**
   * ConditionMatrix create
   */
  export type ConditionMatrixCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionMatrix
     */
    select?: ConditionMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionMatrixInclude<ExtArgs> | null
    /**
     * The data needed to create a ConditionMatrix.
     */
    data: XOR<ConditionMatrixCreateInput, ConditionMatrixUncheckedCreateInput>
  }


  /**
   * ConditionMatrix createMany
   */
  export type ConditionMatrixCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConditionMatrices.
     */
    data: Enumerable<ConditionMatrixCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ConditionMatrix update
   */
  export type ConditionMatrixUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionMatrix
     */
    select?: ConditionMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionMatrixInclude<ExtArgs> | null
    /**
     * The data needed to update a ConditionMatrix.
     */
    data: XOR<ConditionMatrixUpdateInput, ConditionMatrixUncheckedUpdateInput>
    /**
     * Choose, which ConditionMatrix to update.
     */
    where: ConditionMatrixWhereUniqueInput
  }


  /**
   * ConditionMatrix updateMany
   */
  export type ConditionMatrixUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConditionMatrices.
     */
    data: XOR<ConditionMatrixUpdateManyMutationInput, ConditionMatrixUncheckedUpdateManyInput>
    /**
     * Filter which ConditionMatrices to update
     */
    where?: ConditionMatrixWhereInput
  }


  /**
   * ConditionMatrix upsert
   */
  export type ConditionMatrixUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionMatrix
     */
    select?: ConditionMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionMatrixInclude<ExtArgs> | null
    /**
     * The filter to search for the ConditionMatrix to update in case it exists.
     */
    where: ConditionMatrixWhereUniqueInput
    /**
     * In case the ConditionMatrix found by the `where` argument doesn't exist, create a new ConditionMatrix with this data.
     */
    create: XOR<ConditionMatrixCreateInput, ConditionMatrixUncheckedCreateInput>
    /**
     * In case the ConditionMatrix was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConditionMatrixUpdateInput, ConditionMatrixUncheckedUpdateInput>
  }


  /**
   * ConditionMatrix delete
   */
  export type ConditionMatrixDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionMatrix
     */
    select?: ConditionMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionMatrixInclude<ExtArgs> | null
    /**
     * Filter which ConditionMatrix to delete.
     */
    where: ConditionMatrixWhereUniqueInput
  }


  /**
   * ConditionMatrix deleteMany
   */
  export type ConditionMatrixDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConditionMatrices to delete
     */
    where?: ConditionMatrixWhereInput
  }


  /**
   * ConditionMatrix.auditLogs
   */
  export type ConditionMatrix$auditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuditLogScalarFieldEnum>
  }


  /**
   * ConditionMatrix without action
   */
  export type ConditionMatrixArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionMatrix
     */
    select?: ConditionMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionMatrixInclude<ExtArgs> | null
  }



  /**
   * Model SystemState
   */


  export type AggregateSystemState = {
    _count: SystemStateCountAggregateOutputType | null
    _min: SystemStateMinAggregateOutputType | null
    _max: SystemStateMaxAggregateOutputType | null
  }

  export type SystemStateMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SystemStateMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SystemStateCountAggregateOutputType = {
    id: number
    key: number
    value: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type SystemStateMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SystemStateMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SystemStateCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type SystemStateAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemState to aggregate.
     */
    where?: SystemStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStates to fetch.
     */
    orderBy?: Enumerable<SystemStateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemStates
    **/
    _count?: true | SystemStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemStateMaxAggregateInputType
  }

  export type GetSystemStateAggregateType<T extends SystemStateAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemState[P]>
      : GetScalarType<T[P], AggregateSystemState[P]>
  }




  export type SystemStateGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SystemStateWhereInput
    orderBy?: Enumerable<SystemStateOrderByWithAggregationInput>
    by: SystemStateScalarFieldEnum[]
    having?: SystemStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemStateCountAggregateInputType | true
    _min?: SystemStateMinAggregateInputType
    _max?: SystemStateMaxAggregateInputType
  }


  export type SystemStateGroupByOutputType = {
    id: string
    key: string
    value: string
    updatedAt: Date
    updatedBy: string | null
    _count: SystemStateCountAggregateOutputType | null
    _min: SystemStateMinAggregateOutputType | null
    _max: SystemStateMaxAggregateOutputType | null
  }

  type GetSystemStateGroupByPayload<T extends SystemStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SystemStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemStateGroupByOutputType[P]>
            : GetScalarType<T[P], SystemStateGroupByOutputType[P]>
        }
      >
    >


  export type SystemStateSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["systemState"]>

  export type SystemStateSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  type SystemStateGetPayload<S extends boolean | null | undefined | SystemStateArgs> = $Types.GetResult<SystemStatePayload, S>

  type SystemStateCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SystemStateFindManyArgs, 'select' | 'include'> & {
      select?: SystemStateCountAggregateInputType | true
    }

  export interface SystemStateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemState'], meta: { name: 'SystemState' } }
    /**
     * Find zero or one SystemState that matches the filter.
     * @param {SystemStateFindUniqueArgs} args - Arguments to find a SystemState
     * @example
     * // Get one SystemState
     * const systemState = await prisma.systemState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SystemStateFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SystemStateFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SystemState'> extends True ? Prisma__SystemStateClient<$Types.GetResult<SystemStatePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SystemStateClient<$Types.GetResult<SystemStatePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one SystemState that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SystemStateFindUniqueOrThrowArgs} args - Arguments to find a SystemState
     * @example
     * // Get one SystemState
     * const systemState = await prisma.systemState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SystemStateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemStateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SystemStateClient<$Types.GetResult<SystemStatePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first SystemState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStateFindFirstArgs} args - Arguments to find a SystemState
     * @example
     * // Get one SystemState
     * const systemState = await prisma.systemState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SystemStateFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SystemStateFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SystemState'> extends True ? Prisma__SystemStateClient<$Types.GetResult<SystemStatePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SystemStateClient<$Types.GetResult<SystemStatePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first SystemState that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStateFindFirstOrThrowArgs} args - Arguments to find a SystemState
     * @example
     * // Get one SystemState
     * const systemState = await prisma.systemState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SystemStateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemStateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SystemStateClient<$Types.GetResult<SystemStatePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more SystemStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemStates
     * const systemStates = await prisma.systemState.findMany()
     * 
     * // Get first 10 SystemStates
     * const systemStates = await prisma.systemState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemStateWithIdOnly = await prisma.systemState.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SystemStateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemStateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SystemStatePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a SystemState.
     * @param {SystemStateCreateArgs} args - Arguments to create a SystemState.
     * @example
     * // Create one SystemState
     * const SystemState = await prisma.systemState.create({
     *   data: {
     *     // ... data to create a SystemState
     *   }
     * })
     * 
    **/
    create<T extends SystemStateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SystemStateCreateArgs<ExtArgs>>
    ): Prisma__SystemStateClient<$Types.GetResult<SystemStatePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many SystemStates.
     *     @param {SystemStateCreateManyArgs} args - Arguments to create many SystemStates.
     *     @example
     *     // Create many SystemStates
     *     const systemState = await prisma.systemState.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SystemStateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemStateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemState.
     * @param {SystemStateDeleteArgs} args - Arguments to delete one SystemState.
     * @example
     * // Delete one SystemState
     * const SystemState = await prisma.systemState.delete({
     *   where: {
     *     // ... filter to delete one SystemState
     *   }
     * })
     * 
    **/
    delete<T extends SystemStateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SystemStateDeleteArgs<ExtArgs>>
    ): Prisma__SystemStateClient<$Types.GetResult<SystemStatePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one SystemState.
     * @param {SystemStateUpdateArgs} args - Arguments to update one SystemState.
     * @example
     * // Update one SystemState
     * const systemState = await prisma.systemState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SystemStateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SystemStateUpdateArgs<ExtArgs>>
    ): Prisma__SystemStateClient<$Types.GetResult<SystemStatePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more SystemStates.
     * @param {SystemStateDeleteManyArgs} args - Arguments to filter SystemStates to delete.
     * @example
     * // Delete a few SystemStates
     * const { count } = await prisma.systemState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SystemStateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemStateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemStates
     * const systemState = await prisma.systemState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SystemStateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SystemStateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemState.
     * @param {SystemStateUpsertArgs} args - Arguments to update or create a SystemState.
     * @example
     * // Update or create a SystemState
     * const systemState = await prisma.systemState.upsert({
     *   create: {
     *     // ... data to create a SystemState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemState we want to update
     *   }
     * })
    **/
    upsert<T extends SystemStateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SystemStateUpsertArgs<ExtArgs>>
    ): Prisma__SystemStateClient<$Types.GetResult<SystemStatePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of SystemStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStateCountArgs} args - Arguments to filter SystemStates to count.
     * @example
     * // Count the number of SystemStates
     * const count = await prisma.systemState.count({
     *   where: {
     *     // ... the filter for the SystemStates we want to count
     *   }
     * })
    **/
    count<T extends SystemStateCountArgs>(
      args?: Subset<T, SystemStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemStateAggregateArgs>(args: Subset<T, SystemStateAggregateArgs>): Prisma.PrismaPromise<GetSystemStateAggregateType<T>>

    /**
     * Group by SystemState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemStateGroupByArgs['orderBy'] }
        : { orderBy?: SystemStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SystemStateClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SystemState base type for findUnique actions
   */
  export type SystemStateFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemState
     */
    select?: SystemStateSelect<ExtArgs> | null
    /**
     * Filter, which SystemState to fetch.
     */
    where: SystemStateWhereUniqueInput
  }

  /**
   * SystemState findUnique
   */
  export interface SystemStateFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SystemStateFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SystemState findUniqueOrThrow
   */
  export type SystemStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemState
     */
    select?: SystemStateSelect<ExtArgs> | null
    /**
     * Filter, which SystemState to fetch.
     */
    where: SystemStateWhereUniqueInput
  }


  /**
   * SystemState base type for findFirst actions
   */
  export type SystemStateFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemState
     */
    select?: SystemStateSelect<ExtArgs> | null
    /**
     * Filter, which SystemState to fetch.
     */
    where?: SystemStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStates to fetch.
     */
    orderBy?: Enumerable<SystemStateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemStates.
     */
    cursor?: SystemStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemStates.
     */
    distinct?: Enumerable<SystemStateScalarFieldEnum>
  }

  /**
   * SystemState findFirst
   */
  export interface SystemStateFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SystemStateFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SystemState findFirstOrThrow
   */
  export type SystemStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemState
     */
    select?: SystemStateSelect<ExtArgs> | null
    /**
     * Filter, which SystemState to fetch.
     */
    where?: SystemStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStates to fetch.
     */
    orderBy?: Enumerable<SystemStateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemStates.
     */
    cursor?: SystemStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemStates.
     */
    distinct?: Enumerable<SystemStateScalarFieldEnum>
  }


  /**
   * SystemState findMany
   */
  export type SystemStateFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemState
     */
    select?: SystemStateSelect<ExtArgs> | null
    /**
     * Filter, which SystemStates to fetch.
     */
    where?: SystemStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStates to fetch.
     */
    orderBy?: Enumerable<SystemStateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemStates.
     */
    cursor?: SystemStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStates.
     */
    skip?: number
    distinct?: Enumerable<SystemStateScalarFieldEnum>
  }


  /**
   * SystemState create
   */
  export type SystemStateCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemState
     */
    select?: SystemStateSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemState.
     */
    data: XOR<SystemStateCreateInput, SystemStateUncheckedCreateInput>
  }


  /**
   * SystemState createMany
   */
  export type SystemStateCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemStates.
     */
    data: Enumerable<SystemStateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SystemState update
   */
  export type SystemStateUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemState
     */
    select?: SystemStateSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemState.
     */
    data: XOR<SystemStateUpdateInput, SystemStateUncheckedUpdateInput>
    /**
     * Choose, which SystemState to update.
     */
    where: SystemStateWhereUniqueInput
  }


  /**
   * SystemState updateMany
   */
  export type SystemStateUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemStates.
     */
    data: XOR<SystemStateUpdateManyMutationInput, SystemStateUncheckedUpdateManyInput>
    /**
     * Filter which SystemStates to update
     */
    where?: SystemStateWhereInput
  }


  /**
   * SystemState upsert
   */
  export type SystemStateUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemState
     */
    select?: SystemStateSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemState to update in case it exists.
     */
    where: SystemStateWhereUniqueInput
    /**
     * In case the SystemState found by the `where` argument doesn't exist, create a new SystemState with this data.
     */
    create: XOR<SystemStateCreateInput, SystemStateUncheckedCreateInput>
    /**
     * In case the SystemState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemStateUpdateInput, SystemStateUncheckedUpdateInput>
  }


  /**
   * SystemState delete
   */
  export type SystemStateDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemState
     */
    select?: SystemStateSelect<ExtArgs> | null
    /**
     * Filter which SystemState to delete.
     */
    where: SystemStateWhereUniqueInput
  }


  /**
   * SystemState deleteMany
   */
  export type SystemStateDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemStates to delete
     */
    where?: SystemStateWhereInput
  }


  /**
   * SystemState without action
   */
  export type SystemStateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemState
     */
    select?: SystemStateSelect<ExtArgs> | null
  }



  /**
   * Model BlockchainTransaction
   */


  export type AggregateBlockchainTransaction = {
    _count: BlockchainTransactionCountAggregateOutputType | null
    _avg: BlockchainTransactionAvgAggregateOutputType | null
    _sum: BlockchainTransactionSumAggregateOutputType | null
    _min: BlockchainTransactionMinAggregateOutputType | null
    _max: BlockchainTransactionMaxAggregateOutputType | null
  }

  export type BlockchainTransactionAvgAggregateOutputType = {
    blockNumber: number | null
    confirmations: number | null
  }

  export type BlockchainTransactionSumAggregateOutputType = {
    blockNumber: bigint | null
    confirmations: number | null
  }

  export type BlockchainTransactionMinAggregateOutputType = {
    id: string | null
    chain: string | null
    contract: string | null
    txHash: string | null
    blockNumber: bigint | null
    eventName: string | null
    status: TxStatus | null
    entityType: EntityType | null
    entityId: string | null
    confirmations: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockchainTransactionMaxAggregateOutputType = {
    id: string | null
    chain: string | null
    contract: string | null
    txHash: string | null
    blockNumber: bigint | null
    eventName: string | null
    status: TxStatus | null
    entityType: EntityType | null
    entityId: string | null
    confirmations: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockchainTransactionCountAggregateOutputType = {
    id: number
    chain: number
    contract: number
    txHash: number
    blockNumber: number
    eventName: number
    status: number
    entityType: number
    entityId: number
    payload: number
    confirmations: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlockchainTransactionAvgAggregateInputType = {
    blockNumber?: true
    confirmations?: true
  }

  export type BlockchainTransactionSumAggregateInputType = {
    blockNumber?: true
    confirmations?: true
  }

  export type BlockchainTransactionMinAggregateInputType = {
    id?: true
    chain?: true
    contract?: true
    txHash?: true
    blockNumber?: true
    eventName?: true
    status?: true
    entityType?: true
    entityId?: true
    confirmations?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockchainTransactionMaxAggregateInputType = {
    id?: true
    chain?: true
    contract?: true
    txHash?: true
    blockNumber?: true
    eventName?: true
    status?: true
    entityType?: true
    entityId?: true
    confirmations?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockchainTransactionCountAggregateInputType = {
    id?: true
    chain?: true
    contract?: true
    txHash?: true
    blockNumber?: true
    eventName?: true
    status?: true
    entityType?: true
    entityId?: true
    payload?: true
    confirmations?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlockchainTransactionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockchainTransaction to aggregate.
     */
    where?: BlockchainTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainTransactions to fetch.
     */
    orderBy?: Enumerable<BlockchainTransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockchainTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockchainTransactions
    **/
    _count?: true | BlockchainTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockchainTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockchainTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockchainTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockchainTransactionMaxAggregateInputType
  }

  export type GetBlockchainTransactionAggregateType<T extends BlockchainTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockchainTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockchainTransaction[P]>
      : GetScalarType<T[P], AggregateBlockchainTransaction[P]>
  }




  export type BlockchainTransactionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BlockchainTransactionWhereInput
    orderBy?: Enumerable<BlockchainTransactionOrderByWithAggregationInput>
    by: BlockchainTransactionScalarFieldEnum[]
    having?: BlockchainTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockchainTransactionCountAggregateInputType | true
    _avg?: BlockchainTransactionAvgAggregateInputType
    _sum?: BlockchainTransactionSumAggregateInputType
    _min?: BlockchainTransactionMinAggregateInputType
    _max?: BlockchainTransactionMaxAggregateInputType
  }


  export type BlockchainTransactionGroupByOutputType = {
    id: string
    chain: string
    contract: string
    txHash: string
    blockNumber: bigint | null
    eventName: string | null
    status: TxStatus
    entityType: EntityType
    entityId: string
    payload: JsonValue
    confirmations: number
    userId: string | null
    createdAt: Date
    updatedAt: Date
    _count: BlockchainTransactionCountAggregateOutputType | null
    _avg: BlockchainTransactionAvgAggregateOutputType | null
    _sum: BlockchainTransactionSumAggregateOutputType | null
    _min: BlockchainTransactionMinAggregateOutputType | null
    _max: BlockchainTransactionMaxAggregateOutputType | null
  }

  type GetBlockchainTransactionGroupByPayload<T extends BlockchainTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BlockchainTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockchainTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockchainTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], BlockchainTransactionGroupByOutputType[P]>
        }
      >
    >


  export type BlockchainTransactionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chain?: boolean
    contract?: boolean
    txHash?: boolean
    blockNumber?: boolean
    eventName?: boolean
    status?: boolean
    entityType?: boolean
    entityId?: boolean
    payload?: boolean
    confirmations?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    auditLogs?: boolean | BlockchainTransaction$auditLogsArgs<ExtArgs>
    _count?: boolean | BlockchainTransactionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["blockchainTransaction"]>

  export type BlockchainTransactionSelectScalar = {
    id?: boolean
    chain?: boolean
    contract?: boolean
    txHash?: boolean
    blockNumber?: boolean
    eventName?: boolean
    status?: boolean
    entityType?: boolean
    entityId?: boolean
    payload?: boolean
    confirmations?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlockchainTransactionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    auditLogs?: boolean | BlockchainTransaction$auditLogsArgs<ExtArgs>
    _count?: boolean | BlockchainTransactionCountOutputTypeArgs<ExtArgs>
  }


  type BlockchainTransactionGetPayload<S extends boolean | null | undefined | BlockchainTransactionArgs> = $Types.GetResult<BlockchainTransactionPayload, S>

  type BlockchainTransactionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BlockchainTransactionFindManyArgs, 'select' | 'include'> & {
      select?: BlockchainTransactionCountAggregateInputType | true
    }

  export interface BlockchainTransactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockchainTransaction'], meta: { name: 'BlockchainTransaction' } }
    /**
     * Find zero or one BlockchainTransaction that matches the filter.
     * @param {BlockchainTransactionFindUniqueArgs} args - Arguments to find a BlockchainTransaction
     * @example
     * // Get one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlockchainTransactionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BlockchainTransactionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BlockchainTransaction'> extends True ? Prisma__BlockchainTransactionClient<$Types.GetResult<BlockchainTransactionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BlockchainTransactionClient<$Types.GetResult<BlockchainTransactionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one BlockchainTransaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BlockchainTransactionFindUniqueOrThrowArgs} args - Arguments to find a BlockchainTransaction
     * @example
     * // Get one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BlockchainTransactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockchainTransactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BlockchainTransactionClient<$Types.GetResult<BlockchainTransactionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first BlockchainTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionFindFirstArgs} args - Arguments to find a BlockchainTransaction
     * @example
     * // Get one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlockchainTransactionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BlockchainTransactionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BlockchainTransaction'> extends True ? Prisma__BlockchainTransactionClient<$Types.GetResult<BlockchainTransactionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BlockchainTransactionClient<$Types.GetResult<BlockchainTransactionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first BlockchainTransaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionFindFirstOrThrowArgs} args - Arguments to find a BlockchainTransaction
     * @example
     * // Get one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BlockchainTransactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockchainTransactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BlockchainTransactionClient<$Types.GetResult<BlockchainTransactionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more BlockchainTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockchainTransactions
     * const blockchainTransactions = await prisma.blockchainTransaction.findMany()
     * 
     * // Get first 10 BlockchainTransactions
     * const blockchainTransactions = await prisma.blockchainTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockchainTransactionWithIdOnly = await prisma.blockchainTransaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BlockchainTransactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockchainTransactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BlockchainTransactionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a BlockchainTransaction.
     * @param {BlockchainTransactionCreateArgs} args - Arguments to create a BlockchainTransaction.
     * @example
     * // Create one BlockchainTransaction
     * const BlockchainTransaction = await prisma.blockchainTransaction.create({
     *   data: {
     *     // ... data to create a BlockchainTransaction
     *   }
     * })
     * 
    **/
    create<T extends BlockchainTransactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BlockchainTransactionCreateArgs<ExtArgs>>
    ): Prisma__BlockchainTransactionClient<$Types.GetResult<BlockchainTransactionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many BlockchainTransactions.
     *     @param {BlockchainTransactionCreateManyArgs} args - Arguments to create many BlockchainTransactions.
     *     @example
     *     // Create many BlockchainTransactions
     *     const blockchainTransaction = await prisma.blockchainTransaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlockchainTransactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockchainTransactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BlockchainTransaction.
     * @param {BlockchainTransactionDeleteArgs} args - Arguments to delete one BlockchainTransaction.
     * @example
     * // Delete one BlockchainTransaction
     * const BlockchainTransaction = await prisma.blockchainTransaction.delete({
     *   where: {
     *     // ... filter to delete one BlockchainTransaction
     *   }
     * })
     * 
    **/
    delete<T extends BlockchainTransactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BlockchainTransactionDeleteArgs<ExtArgs>>
    ): Prisma__BlockchainTransactionClient<$Types.GetResult<BlockchainTransactionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one BlockchainTransaction.
     * @param {BlockchainTransactionUpdateArgs} args - Arguments to update one BlockchainTransaction.
     * @example
     * // Update one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlockchainTransactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BlockchainTransactionUpdateArgs<ExtArgs>>
    ): Prisma__BlockchainTransactionClient<$Types.GetResult<BlockchainTransactionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more BlockchainTransactions.
     * @param {BlockchainTransactionDeleteManyArgs} args - Arguments to filter BlockchainTransactions to delete.
     * @example
     * // Delete a few BlockchainTransactions
     * const { count } = await prisma.blockchainTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlockchainTransactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockchainTransactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockchainTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockchainTransactions
     * const blockchainTransaction = await prisma.blockchainTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlockchainTransactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BlockchainTransactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockchainTransaction.
     * @param {BlockchainTransactionUpsertArgs} args - Arguments to update or create a BlockchainTransaction.
     * @example
     * // Update or create a BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.upsert({
     *   create: {
     *     // ... data to create a BlockchainTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockchainTransaction we want to update
     *   }
     * })
    **/
    upsert<T extends BlockchainTransactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BlockchainTransactionUpsertArgs<ExtArgs>>
    ): Prisma__BlockchainTransactionClient<$Types.GetResult<BlockchainTransactionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of BlockchainTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionCountArgs} args - Arguments to filter BlockchainTransactions to count.
     * @example
     * // Count the number of BlockchainTransactions
     * const count = await prisma.blockchainTransaction.count({
     *   where: {
     *     // ... the filter for the BlockchainTransactions we want to count
     *   }
     * })
    **/
    count<T extends BlockchainTransactionCountArgs>(
      args?: Subset<T, BlockchainTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockchainTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockchainTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockchainTransactionAggregateArgs>(args: Subset<T, BlockchainTransactionAggregateArgs>): Prisma.PrismaPromise<GetBlockchainTransactionAggregateType<T>>

    /**
     * Group by BlockchainTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockchainTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockchainTransactionGroupByArgs['orderBy'] }
        : { orderBy?: BlockchainTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockchainTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockchainTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockchainTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BlockchainTransactionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    auditLogs<T extends BlockchainTransaction$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, BlockchainTransaction$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BlockchainTransaction base type for findUnique actions
   */
  export type BlockchainTransactionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransaction to fetch.
     */
    where: BlockchainTransactionWhereUniqueInput
  }

  /**
   * BlockchainTransaction findUnique
   */
  export interface BlockchainTransactionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BlockchainTransactionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BlockchainTransaction findUniqueOrThrow
   */
  export type BlockchainTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransaction to fetch.
     */
    where: BlockchainTransactionWhereUniqueInput
  }


  /**
   * BlockchainTransaction base type for findFirst actions
   */
  export type BlockchainTransactionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransaction to fetch.
     */
    where?: BlockchainTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainTransactions to fetch.
     */
    orderBy?: Enumerable<BlockchainTransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockchainTransactions.
     */
    cursor?: BlockchainTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockchainTransactions.
     */
    distinct?: Enumerable<BlockchainTransactionScalarFieldEnum>
  }

  /**
   * BlockchainTransaction findFirst
   */
  export interface BlockchainTransactionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BlockchainTransactionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BlockchainTransaction findFirstOrThrow
   */
  export type BlockchainTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransaction to fetch.
     */
    where?: BlockchainTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainTransactions to fetch.
     */
    orderBy?: Enumerable<BlockchainTransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockchainTransactions.
     */
    cursor?: BlockchainTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockchainTransactions.
     */
    distinct?: Enumerable<BlockchainTransactionScalarFieldEnum>
  }


  /**
   * BlockchainTransaction findMany
   */
  export type BlockchainTransactionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransactions to fetch.
     */
    where?: BlockchainTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainTransactions to fetch.
     */
    orderBy?: Enumerable<BlockchainTransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockchainTransactions.
     */
    cursor?: BlockchainTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainTransactions.
     */
    skip?: number
    distinct?: Enumerable<BlockchainTransactionScalarFieldEnum>
  }


  /**
   * BlockchainTransaction create
   */
  export type BlockchainTransactionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockchainTransaction.
     */
    data: XOR<BlockchainTransactionCreateInput, BlockchainTransactionUncheckedCreateInput>
  }


  /**
   * BlockchainTransaction createMany
   */
  export type BlockchainTransactionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockchainTransactions.
     */
    data: Enumerable<BlockchainTransactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BlockchainTransaction update
   */
  export type BlockchainTransactionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockchainTransaction.
     */
    data: XOR<BlockchainTransactionUpdateInput, BlockchainTransactionUncheckedUpdateInput>
    /**
     * Choose, which BlockchainTransaction to update.
     */
    where: BlockchainTransactionWhereUniqueInput
  }


  /**
   * BlockchainTransaction updateMany
   */
  export type BlockchainTransactionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockchainTransactions.
     */
    data: XOR<BlockchainTransactionUpdateManyMutationInput, BlockchainTransactionUncheckedUpdateManyInput>
    /**
     * Filter which BlockchainTransactions to update
     */
    where?: BlockchainTransactionWhereInput
  }


  /**
   * BlockchainTransaction upsert
   */
  export type BlockchainTransactionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockchainTransaction to update in case it exists.
     */
    where: BlockchainTransactionWhereUniqueInput
    /**
     * In case the BlockchainTransaction found by the `where` argument doesn't exist, create a new BlockchainTransaction with this data.
     */
    create: XOR<BlockchainTransactionCreateInput, BlockchainTransactionUncheckedCreateInput>
    /**
     * In case the BlockchainTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockchainTransactionUpdateInput, BlockchainTransactionUncheckedUpdateInput>
  }


  /**
   * BlockchainTransaction delete
   */
  export type BlockchainTransactionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter which BlockchainTransaction to delete.
     */
    where: BlockchainTransactionWhereUniqueInput
  }


  /**
   * BlockchainTransaction deleteMany
   */
  export type BlockchainTransactionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockchainTransactions to delete
     */
    where?: BlockchainTransactionWhereInput
  }


  /**
   * BlockchainTransaction.auditLogs
   */
  export type BlockchainTransaction$auditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuditLogScalarFieldEnum>
  }


  /**
   * BlockchainTransaction without action
   */
  export type BlockchainTransactionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
  }



  /**
   * Model OnChainProof
   */


  export type AggregateOnChainProof = {
    _count: OnChainProofCountAggregateOutputType | null
    _min: OnChainProofMinAggregateOutputType | null
    _max: OnChainProofMaxAggregateOutputType | null
  }

  export type OnChainProofMinAggregateOutputType = {
    id: string | null
    entityType: EntityType | null
    entityId: string | null
    hash: string | null
    algorithm: string | null
    chain: string | null
    contract: string | null
    txHash: string | null
    invoiceId: string | null
    vinPassportId: string | null
    createdAt: Date | null
  }

  export type OnChainProofMaxAggregateOutputType = {
    id: string | null
    entityType: EntityType | null
    entityId: string | null
    hash: string | null
    algorithm: string | null
    chain: string | null
    contract: string | null
    txHash: string | null
    invoiceId: string | null
    vinPassportId: string | null
    createdAt: Date | null
  }

  export type OnChainProofCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    hash: number
    algorithm: number
    chain: number
    contract: number
    txHash: number
    invoiceId: number
    vinPassportId: number
    createdAt: number
    _all: number
  }


  export type OnChainProofMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    hash?: true
    algorithm?: true
    chain?: true
    contract?: true
    txHash?: true
    invoiceId?: true
    vinPassportId?: true
    createdAt?: true
  }

  export type OnChainProofMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    hash?: true
    algorithm?: true
    chain?: true
    contract?: true
    txHash?: true
    invoiceId?: true
    vinPassportId?: true
    createdAt?: true
  }

  export type OnChainProofCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    hash?: true
    algorithm?: true
    chain?: true
    contract?: true
    txHash?: true
    invoiceId?: true
    vinPassportId?: true
    createdAt?: true
    _all?: true
  }

  export type OnChainProofAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnChainProof to aggregate.
     */
    where?: OnChainProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnChainProofs to fetch.
     */
    orderBy?: Enumerable<OnChainProofOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OnChainProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnChainProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnChainProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OnChainProofs
    **/
    _count?: true | OnChainProofCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OnChainProofMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OnChainProofMaxAggregateInputType
  }

  export type GetOnChainProofAggregateType<T extends OnChainProofAggregateArgs> = {
        [P in keyof T & keyof AggregateOnChainProof]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOnChainProof[P]>
      : GetScalarType<T[P], AggregateOnChainProof[P]>
  }




  export type OnChainProofGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OnChainProofWhereInput
    orderBy?: Enumerable<OnChainProofOrderByWithAggregationInput>
    by: OnChainProofScalarFieldEnum[]
    having?: OnChainProofScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OnChainProofCountAggregateInputType | true
    _min?: OnChainProofMinAggregateInputType
    _max?: OnChainProofMaxAggregateInputType
  }


  export type OnChainProofGroupByOutputType = {
    id: string
    entityType: EntityType
    entityId: string
    hash: string
    algorithm: string
    chain: string
    contract: string
    txHash: string
    invoiceId: string | null
    vinPassportId: string | null
    createdAt: Date
    _count: OnChainProofCountAggregateOutputType | null
    _min: OnChainProofMinAggregateOutputType | null
    _max: OnChainProofMaxAggregateOutputType | null
  }

  type GetOnChainProofGroupByPayload<T extends OnChainProofGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OnChainProofGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OnChainProofGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OnChainProofGroupByOutputType[P]>
            : GetScalarType<T[P], OnChainProofGroupByOutputType[P]>
        }
      >
    >


  export type OnChainProofSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    hash?: boolean
    algorithm?: boolean
    chain?: boolean
    contract?: boolean
    txHash?: boolean
    invoiceId?: boolean
    vinPassportId?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceArgs<ExtArgs>
    vinPassport?: boolean | VinPassportArgs<ExtArgs>
  }, ExtArgs["result"]["onChainProof"]>

  export type OnChainProofSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    hash?: boolean
    algorithm?: boolean
    chain?: boolean
    contract?: boolean
    txHash?: boolean
    invoiceId?: boolean
    vinPassportId?: boolean
    createdAt?: boolean
  }

  export type OnChainProofInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceArgs<ExtArgs>
    vinPassport?: boolean | VinPassportArgs<ExtArgs>
  }


  type OnChainProofGetPayload<S extends boolean | null | undefined | OnChainProofArgs> = $Types.GetResult<OnChainProofPayload, S>

  type OnChainProofCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OnChainProofFindManyArgs, 'select' | 'include'> & {
      select?: OnChainProofCountAggregateInputType | true
    }

  export interface OnChainProofDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OnChainProof'], meta: { name: 'OnChainProof' } }
    /**
     * Find zero or one OnChainProof that matches the filter.
     * @param {OnChainProofFindUniqueArgs} args - Arguments to find a OnChainProof
     * @example
     * // Get one OnChainProof
     * const onChainProof = await prisma.onChainProof.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OnChainProofFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OnChainProofFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OnChainProof'> extends True ? Prisma__OnChainProofClient<$Types.GetResult<OnChainProofPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__OnChainProofClient<$Types.GetResult<OnChainProofPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one OnChainProof that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OnChainProofFindUniqueOrThrowArgs} args - Arguments to find a OnChainProof
     * @example
     * // Get one OnChainProof
     * const onChainProof = await prisma.onChainProof.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OnChainProofFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OnChainProofFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OnChainProofClient<$Types.GetResult<OnChainProofPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first OnChainProof that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnChainProofFindFirstArgs} args - Arguments to find a OnChainProof
     * @example
     * // Get one OnChainProof
     * const onChainProof = await prisma.onChainProof.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OnChainProofFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OnChainProofFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OnChainProof'> extends True ? Prisma__OnChainProofClient<$Types.GetResult<OnChainProofPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__OnChainProofClient<$Types.GetResult<OnChainProofPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first OnChainProof that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnChainProofFindFirstOrThrowArgs} args - Arguments to find a OnChainProof
     * @example
     * // Get one OnChainProof
     * const onChainProof = await prisma.onChainProof.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OnChainProofFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OnChainProofFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OnChainProofClient<$Types.GetResult<OnChainProofPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more OnChainProofs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnChainProofFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OnChainProofs
     * const onChainProofs = await prisma.onChainProof.findMany()
     * 
     * // Get first 10 OnChainProofs
     * const onChainProofs = await prisma.onChainProof.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const onChainProofWithIdOnly = await prisma.onChainProof.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OnChainProofFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OnChainProofFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OnChainProofPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a OnChainProof.
     * @param {OnChainProofCreateArgs} args - Arguments to create a OnChainProof.
     * @example
     * // Create one OnChainProof
     * const OnChainProof = await prisma.onChainProof.create({
     *   data: {
     *     // ... data to create a OnChainProof
     *   }
     * })
     * 
    **/
    create<T extends OnChainProofCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OnChainProofCreateArgs<ExtArgs>>
    ): Prisma__OnChainProofClient<$Types.GetResult<OnChainProofPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many OnChainProofs.
     *     @param {OnChainProofCreateManyArgs} args - Arguments to create many OnChainProofs.
     *     @example
     *     // Create many OnChainProofs
     *     const onChainProof = await prisma.onChainProof.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OnChainProofCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OnChainProofCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OnChainProof.
     * @param {OnChainProofDeleteArgs} args - Arguments to delete one OnChainProof.
     * @example
     * // Delete one OnChainProof
     * const OnChainProof = await prisma.onChainProof.delete({
     *   where: {
     *     // ... filter to delete one OnChainProof
     *   }
     * })
     * 
    **/
    delete<T extends OnChainProofDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OnChainProofDeleteArgs<ExtArgs>>
    ): Prisma__OnChainProofClient<$Types.GetResult<OnChainProofPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one OnChainProof.
     * @param {OnChainProofUpdateArgs} args - Arguments to update one OnChainProof.
     * @example
     * // Update one OnChainProof
     * const onChainProof = await prisma.onChainProof.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OnChainProofUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OnChainProofUpdateArgs<ExtArgs>>
    ): Prisma__OnChainProofClient<$Types.GetResult<OnChainProofPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more OnChainProofs.
     * @param {OnChainProofDeleteManyArgs} args - Arguments to filter OnChainProofs to delete.
     * @example
     * // Delete a few OnChainProofs
     * const { count } = await prisma.onChainProof.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OnChainProofDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OnChainProofDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnChainProofs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnChainProofUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OnChainProofs
     * const onChainProof = await prisma.onChainProof.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OnChainProofUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OnChainProofUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OnChainProof.
     * @param {OnChainProofUpsertArgs} args - Arguments to update or create a OnChainProof.
     * @example
     * // Update or create a OnChainProof
     * const onChainProof = await prisma.onChainProof.upsert({
     *   create: {
     *     // ... data to create a OnChainProof
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OnChainProof we want to update
     *   }
     * })
    **/
    upsert<T extends OnChainProofUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OnChainProofUpsertArgs<ExtArgs>>
    ): Prisma__OnChainProofClient<$Types.GetResult<OnChainProofPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of OnChainProofs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnChainProofCountArgs} args - Arguments to filter OnChainProofs to count.
     * @example
     * // Count the number of OnChainProofs
     * const count = await prisma.onChainProof.count({
     *   where: {
     *     // ... the filter for the OnChainProofs we want to count
     *   }
     * })
    **/
    count<T extends OnChainProofCountArgs>(
      args?: Subset<T, OnChainProofCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OnChainProofCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OnChainProof.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnChainProofAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OnChainProofAggregateArgs>(args: Subset<T, OnChainProofAggregateArgs>): Prisma.PrismaPromise<GetOnChainProofAggregateType<T>>

    /**
     * Group by OnChainProof.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnChainProofGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OnChainProofGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OnChainProofGroupByArgs['orderBy'] }
        : { orderBy?: OnChainProofGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OnChainProofGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOnChainProofGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OnChainProof.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OnChainProofClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    invoice<T extends InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    vinPassport<T extends VinPassportArgs<ExtArgs> = {}>(args?: Subset<T, VinPassportArgs<ExtArgs>>): Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OnChainProof base type for findUnique actions
   */
  export type OnChainProofFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnChainProof
     */
    select?: OnChainProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OnChainProofInclude<ExtArgs> | null
    /**
     * Filter, which OnChainProof to fetch.
     */
    where: OnChainProofWhereUniqueInput
  }

  /**
   * OnChainProof findUnique
   */
  export interface OnChainProofFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OnChainProofFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OnChainProof findUniqueOrThrow
   */
  export type OnChainProofFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnChainProof
     */
    select?: OnChainProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OnChainProofInclude<ExtArgs> | null
    /**
     * Filter, which OnChainProof to fetch.
     */
    where: OnChainProofWhereUniqueInput
  }


  /**
   * OnChainProof base type for findFirst actions
   */
  export type OnChainProofFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnChainProof
     */
    select?: OnChainProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OnChainProofInclude<ExtArgs> | null
    /**
     * Filter, which OnChainProof to fetch.
     */
    where?: OnChainProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnChainProofs to fetch.
     */
    orderBy?: Enumerable<OnChainProofOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnChainProofs.
     */
    cursor?: OnChainProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnChainProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnChainProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnChainProofs.
     */
    distinct?: Enumerable<OnChainProofScalarFieldEnum>
  }

  /**
   * OnChainProof findFirst
   */
  export interface OnChainProofFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OnChainProofFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OnChainProof findFirstOrThrow
   */
  export type OnChainProofFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnChainProof
     */
    select?: OnChainProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OnChainProofInclude<ExtArgs> | null
    /**
     * Filter, which OnChainProof to fetch.
     */
    where?: OnChainProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnChainProofs to fetch.
     */
    orderBy?: Enumerable<OnChainProofOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnChainProofs.
     */
    cursor?: OnChainProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnChainProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnChainProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnChainProofs.
     */
    distinct?: Enumerable<OnChainProofScalarFieldEnum>
  }


  /**
   * OnChainProof findMany
   */
  export type OnChainProofFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnChainProof
     */
    select?: OnChainProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OnChainProofInclude<ExtArgs> | null
    /**
     * Filter, which OnChainProofs to fetch.
     */
    where?: OnChainProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnChainProofs to fetch.
     */
    orderBy?: Enumerable<OnChainProofOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OnChainProofs.
     */
    cursor?: OnChainProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnChainProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnChainProofs.
     */
    skip?: number
    distinct?: Enumerable<OnChainProofScalarFieldEnum>
  }


  /**
   * OnChainProof create
   */
  export type OnChainProofCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnChainProof
     */
    select?: OnChainProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OnChainProofInclude<ExtArgs> | null
    /**
     * The data needed to create a OnChainProof.
     */
    data: XOR<OnChainProofCreateInput, OnChainProofUncheckedCreateInput>
  }


  /**
   * OnChainProof createMany
   */
  export type OnChainProofCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OnChainProofs.
     */
    data: Enumerable<OnChainProofCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OnChainProof update
   */
  export type OnChainProofUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnChainProof
     */
    select?: OnChainProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OnChainProofInclude<ExtArgs> | null
    /**
     * The data needed to update a OnChainProof.
     */
    data: XOR<OnChainProofUpdateInput, OnChainProofUncheckedUpdateInput>
    /**
     * Choose, which OnChainProof to update.
     */
    where: OnChainProofWhereUniqueInput
  }


  /**
   * OnChainProof updateMany
   */
  export type OnChainProofUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OnChainProofs.
     */
    data: XOR<OnChainProofUpdateManyMutationInput, OnChainProofUncheckedUpdateManyInput>
    /**
     * Filter which OnChainProofs to update
     */
    where?: OnChainProofWhereInput
  }


  /**
   * OnChainProof upsert
   */
  export type OnChainProofUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnChainProof
     */
    select?: OnChainProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OnChainProofInclude<ExtArgs> | null
    /**
     * The filter to search for the OnChainProof to update in case it exists.
     */
    where: OnChainProofWhereUniqueInput
    /**
     * In case the OnChainProof found by the `where` argument doesn't exist, create a new OnChainProof with this data.
     */
    create: XOR<OnChainProofCreateInput, OnChainProofUncheckedCreateInput>
    /**
     * In case the OnChainProof was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OnChainProofUpdateInput, OnChainProofUncheckedUpdateInput>
  }


  /**
   * OnChainProof delete
   */
  export type OnChainProofDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnChainProof
     */
    select?: OnChainProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OnChainProofInclude<ExtArgs> | null
    /**
     * Filter which OnChainProof to delete.
     */
    where: OnChainProofWhereUniqueInput
  }


  /**
   * OnChainProof deleteMany
   */
  export type OnChainProofDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnChainProofs to delete
     */
    where?: OnChainProofWhereInput
  }


  /**
   * OnChainProof without action
   */
  export type OnChainProofArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnChainProof
     */
    select?: OnChainProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OnChainProofInclude<ExtArgs> | null
  }



  /**
   * Model ChainCursor
   */


  export type AggregateChainCursor = {
    _count: ChainCursorCountAggregateOutputType | null
    _avg: ChainCursorAvgAggregateOutputType | null
    _sum: ChainCursorSumAggregateOutputType | null
    _min: ChainCursorMinAggregateOutputType | null
    _max: ChainCursorMaxAggregateOutputType | null
  }

  export type ChainCursorAvgAggregateOutputType = {
    lastBlock: number | null
  }

  export type ChainCursorSumAggregateOutputType = {
    lastBlock: bigint | null
  }

  export type ChainCursorMinAggregateOutputType = {
    id: string | null
    chain: string | null
    contract: string | null
    lastBlock: bigint | null
    updatedAt: Date | null
  }

  export type ChainCursorMaxAggregateOutputType = {
    id: string | null
    chain: string | null
    contract: string | null
    lastBlock: bigint | null
    updatedAt: Date | null
  }

  export type ChainCursorCountAggregateOutputType = {
    id: number
    chain: number
    contract: number
    lastBlock: number
    updatedAt: number
    _all: number
  }


  export type ChainCursorAvgAggregateInputType = {
    lastBlock?: true
  }

  export type ChainCursorSumAggregateInputType = {
    lastBlock?: true
  }

  export type ChainCursorMinAggregateInputType = {
    id?: true
    chain?: true
    contract?: true
    lastBlock?: true
    updatedAt?: true
  }

  export type ChainCursorMaxAggregateInputType = {
    id?: true
    chain?: true
    contract?: true
    lastBlock?: true
    updatedAt?: true
  }

  export type ChainCursorCountAggregateInputType = {
    id?: true
    chain?: true
    contract?: true
    lastBlock?: true
    updatedAt?: true
    _all?: true
  }

  export type ChainCursorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChainCursor to aggregate.
     */
    where?: ChainCursorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChainCursors to fetch.
     */
    orderBy?: Enumerable<ChainCursorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChainCursorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChainCursors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChainCursors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChainCursors
    **/
    _count?: true | ChainCursorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChainCursorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChainCursorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChainCursorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChainCursorMaxAggregateInputType
  }

  export type GetChainCursorAggregateType<T extends ChainCursorAggregateArgs> = {
        [P in keyof T & keyof AggregateChainCursor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChainCursor[P]>
      : GetScalarType<T[P], AggregateChainCursor[P]>
  }




  export type ChainCursorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ChainCursorWhereInput
    orderBy?: Enumerable<ChainCursorOrderByWithAggregationInput>
    by: ChainCursorScalarFieldEnum[]
    having?: ChainCursorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChainCursorCountAggregateInputType | true
    _avg?: ChainCursorAvgAggregateInputType
    _sum?: ChainCursorSumAggregateInputType
    _min?: ChainCursorMinAggregateInputType
    _max?: ChainCursorMaxAggregateInputType
  }


  export type ChainCursorGroupByOutputType = {
    id: string
    chain: string
    contract: string
    lastBlock: bigint
    updatedAt: Date
    _count: ChainCursorCountAggregateOutputType | null
    _avg: ChainCursorAvgAggregateOutputType | null
    _sum: ChainCursorSumAggregateOutputType | null
    _min: ChainCursorMinAggregateOutputType | null
    _max: ChainCursorMaxAggregateOutputType | null
  }

  type GetChainCursorGroupByPayload<T extends ChainCursorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChainCursorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChainCursorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChainCursorGroupByOutputType[P]>
            : GetScalarType<T[P], ChainCursorGroupByOutputType[P]>
        }
      >
    >


  export type ChainCursorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chain?: boolean
    contract?: boolean
    lastBlock?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["chainCursor"]>

  export type ChainCursorSelectScalar = {
    id?: boolean
    chain?: boolean
    contract?: boolean
    lastBlock?: boolean
    updatedAt?: boolean
  }


  type ChainCursorGetPayload<S extends boolean | null | undefined | ChainCursorArgs> = $Types.GetResult<ChainCursorPayload, S>

  type ChainCursorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ChainCursorFindManyArgs, 'select' | 'include'> & {
      select?: ChainCursorCountAggregateInputType | true
    }

  export interface ChainCursorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChainCursor'], meta: { name: 'ChainCursor' } }
    /**
     * Find zero or one ChainCursor that matches the filter.
     * @param {ChainCursorFindUniqueArgs} args - Arguments to find a ChainCursor
     * @example
     * // Get one ChainCursor
     * const chainCursor = await prisma.chainCursor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChainCursorFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChainCursorFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChainCursor'> extends True ? Prisma__ChainCursorClient<$Types.GetResult<ChainCursorPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ChainCursorClient<$Types.GetResult<ChainCursorPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ChainCursor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChainCursorFindUniqueOrThrowArgs} args - Arguments to find a ChainCursor
     * @example
     * // Get one ChainCursor
     * const chainCursor = await prisma.chainCursor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChainCursorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChainCursorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ChainCursorClient<$Types.GetResult<ChainCursorPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ChainCursor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainCursorFindFirstArgs} args - Arguments to find a ChainCursor
     * @example
     * // Get one ChainCursor
     * const chainCursor = await prisma.chainCursor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChainCursorFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChainCursorFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChainCursor'> extends True ? Prisma__ChainCursorClient<$Types.GetResult<ChainCursorPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ChainCursorClient<$Types.GetResult<ChainCursorPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ChainCursor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainCursorFindFirstOrThrowArgs} args - Arguments to find a ChainCursor
     * @example
     * // Get one ChainCursor
     * const chainCursor = await prisma.chainCursor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChainCursorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChainCursorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ChainCursorClient<$Types.GetResult<ChainCursorPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ChainCursors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainCursorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChainCursors
     * const chainCursors = await prisma.chainCursor.findMany()
     * 
     * // Get first 10 ChainCursors
     * const chainCursors = await prisma.chainCursor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chainCursorWithIdOnly = await prisma.chainCursor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChainCursorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChainCursorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ChainCursorPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ChainCursor.
     * @param {ChainCursorCreateArgs} args - Arguments to create a ChainCursor.
     * @example
     * // Create one ChainCursor
     * const ChainCursor = await prisma.chainCursor.create({
     *   data: {
     *     // ... data to create a ChainCursor
     *   }
     * })
     * 
    **/
    create<T extends ChainCursorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ChainCursorCreateArgs<ExtArgs>>
    ): Prisma__ChainCursorClient<$Types.GetResult<ChainCursorPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ChainCursors.
     *     @param {ChainCursorCreateManyArgs} args - Arguments to create many ChainCursors.
     *     @example
     *     // Create many ChainCursors
     *     const chainCursor = await prisma.chainCursor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChainCursorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChainCursorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChainCursor.
     * @param {ChainCursorDeleteArgs} args - Arguments to delete one ChainCursor.
     * @example
     * // Delete one ChainCursor
     * const ChainCursor = await prisma.chainCursor.delete({
     *   where: {
     *     // ... filter to delete one ChainCursor
     *   }
     * })
     * 
    **/
    delete<T extends ChainCursorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ChainCursorDeleteArgs<ExtArgs>>
    ): Prisma__ChainCursorClient<$Types.GetResult<ChainCursorPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ChainCursor.
     * @param {ChainCursorUpdateArgs} args - Arguments to update one ChainCursor.
     * @example
     * // Update one ChainCursor
     * const chainCursor = await prisma.chainCursor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChainCursorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ChainCursorUpdateArgs<ExtArgs>>
    ): Prisma__ChainCursorClient<$Types.GetResult<ChainCursorPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ChainCursors.
     * @param {ChainCursorDeleteManyArgs} args - Arguments to filter ChainCursors to delete.
     * @example
     * // Delete a few ChainCursors
     * const { count } = await prisma.chainCursor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChainCursorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChainCursorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChainCursors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainCursorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChainCursors
     * const chainCursor = await prisma.chainCursor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChainCursorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ChainCursorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChainCursor.
     * @param {ChainCursorUpsertArgs} args - Arguments to update or create a ChainCursor.
     * @example
     * // Update or create a ChainCursor
     * const chainCursor = await prisma.chainCursor.upsert({
     *   create: {
     *     // ... data to create a ChainCursor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChainCursor we want to update
     *   }
     * })
    **/
    upsert<T extends ChainCursorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ChainCursorUpsertArgs<ExtArgs>>
    ): Prisma__ChainCursorClient<$Types.GetResult<ChainCursorPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ChainCursors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainCursorCountArgs} args - Arguments to filter ChainCursors to count.
     * @example
     * // Count the number of ChainCursors
     * const count = await prisma.chainCursor.count({
     *   where: {
     *     // ... the filter for the ChainCursors we want to count
     *   }
     * })
    **/
    count<T extends ChainCursorCountArgs>(
      args?: Subset<T, ChainCursorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChainCursorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChainCursor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainCursorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChainCursorAggregateArgs>(args: Subset<T, ChainCursorAggregateArgs>): Prisma.PrismaPromise<GetChainCursorAggregateType<T>>

    /**
     * Group by ChainCursor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainCursorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChainCursorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChainCursorGroupByArgs['orderBy'] }
        : { orderBy?: ChainCursorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChainCursorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChainCursorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ChainCursor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChainCursorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ChainCursor base type for findUnique actions
   */
  export type ChainCursorFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainCursor
     */
    select?: ChainCursorSelect<ExtArgs> | null
    /**
     * Filter, which ChainCursor to fetch.
     */
    where: ChainCursorWhereUniqueInput
  }

  /**
   * ChainCursor findUnique
   */
  export interface ChainCursorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ChainCursorFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChainCursor findUniqueOrThrow
   */
  export type ChainCursorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainCursor
     */
    select?: ChainCursorSelect<ExtArgs> | null
    /**
     * Filter, which ChainCursor to fetch.
     */
    where: ChainCursorWhereUniqueInput
  }


  /**
   * ChainCursor base type for findFirst actions
   */
  export type ChainCursorFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainCursor
     */
    select?: ChainCursorSelect<ExtArgs> | null
    /**
     * Filter, which ChainCursor to fetch.
     */
    where?: ChainCursorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChainCursors to fetch.
     */
    orderBy?: Enumerable<ChainCursorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChainCursors.
     */
    cursor?: ChainCursorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChainCursors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChainCursors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChainCursors.
     */
    distinct?: Enumerable<ChainCursorScalarFieldEnum>
  }

  /**
   * ChainCursor findFirst
   */
  export interface ChainCursorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ChainCursorFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChainCursor findFirstOrThrow
   */
  export type ChainCursorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainCursor
     */
    select?: ChainCursorSelect<ExtArgs> | null
    /**
     * Filter, which ChainCursor to fetch.
     */
    where?: ChainCursorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChainCursors to fetch.
     */
    orderBy?: Enumerable<ChainCursorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChainCursors.
     */
    cursor?: ChainCursorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChainCursors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChainCursors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChainCursors.
     */
    distinct?: Enumerable<ChainCursorScalarFieldEnum>
  }


  /**
   * ChainCursor findMany
   */
  export type ChainCursorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainCursor
     */
    select?: ChainCursorSelect<ExtArgs> | null
    /**
     * Filter, which ChainCursors to fetch.
     */
    where?: ChainCursorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChainCursors to fetch.
     */
    orderBy?: Enumerable<ChainCursorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChainCursors.
     */
    cursor?: ChainCursorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChainCursors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChainCursors.
     */
    skip?: number
    distinct?: Enumerable<ChainCursorScalarFieldEnum>
  }


  /**
   * ChainCursor create
   */
  export type ChainCursorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainCursor
     */
    select?: ChainCursorSelect<ExtArgs> | null
    /**
     * The data needed to create a ChainCursor.
     */
    data: XOR<ChainCursorCreateInput, ChainCursorUncheckedCreateInput>
  }


  /**
   * ChainCursor createMany
   */
  export type ChainCursorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChainCursors.
     */
    data: Enumerable<ChainCursorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChainCursor update
   */
  export type ChainCursorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainCursor
     */
    select?: ChainCursorSelect<ExtArgs> | null
    /**
     * The data needed to update a ChainCursor.
     */
    data: XOR<ChainCursorUpdateInput, ChainCursorUncheckedUpdateInput>
    /**
     * Choose, which ChainCursor to update.
     */
    where: ChainCursorWhereUniqueInput
  }


  /**
   * ChainCursor updateMany
   */
  export type ChainCursorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChainCursors.
     */
    data: XOR<ChainCursorUpdateManyMutationInput, ChainCursorUncheckedUpdateManyInput>
    /**
     * Filter which ChainCursors to update
     */
    where?: ChainCursorWhereInput
  }


  /**
   * ChainCursor upsert
   */
  export type ChainCursorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainCursor
     */
    select?: ChainCursorSelect<ExtArgs> | null
    /**
     * The filter to search for the ChainCursor to update in case it exists.
     */
    where: ChainCursorWhereUniqueInput
    /**
     * In case the ChainCursor found by the `where` argument doesn't exist, create a new ChainCursor with this data.
     */
    create: XOR<ChainCursorCreateInput, ChainCursorUncheckedCreateInput>
    /**
     * In case the ChainCursor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChainCursorUpdateInput, ChainCursorUncheckedUpdateInput>
  }


  /**
   * ChainCursor delete
   */
  export type ChainCursorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainCursor
     */
    select?: ChainCursorSelect<ExtArgs> | null
    /**
     * Filter which ChainCursor to delete.
     */
    where: ChainCursorWhereUniqueInput
  }


  /**
   * ChainCursor deleteMany
   */
  export type ChainCursorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChainCursors to delete
     */
    where?: ChainCursorWhereInput
  }


  /**
   * ChainCursor without action
   */
  export type ChainCursorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainCursor
     */
    select?: ChainCursorSelect<ExtArgs> | null
  }



  /**
   * Model Document
   */


  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    fileName: string | null
    fileUrl: string | null
    fileType: FileType | null
    state: FileState | null
    checksum: string | null
    vinPassportId: string | null
    invoiceId: string | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    isDeleted: boolean | null
    deletedBy: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    fileName: string | null
    fileUrl: string | null
    fileType: FileType | null
    state: FileState | null
    checksum: string | null
    vinPassportId: string | null
    invoiceId: string | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    isDeleted: boolean | null
    deletedBy: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    fileName: number
    fileUrl: number
    fileType: number
    state: number
    checksum: number
    vinPassportId: number
    invoiceId: number
    uploadedById: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    isDeleted: number
    deletedBy: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    state?: true
    checksum?: true
    vinPassportId?: true
    invoiceId?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    isDeleted?: true
    deletedBy?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    state?: true
    checksum?: true
    vinPassportId?: true
    invoiceId?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    isDeleted?: true
    deletedBy?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    state?: true
    checksum?: true
    vinPassportId?: true
    invoiceId?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    isDeleted?: true
    deletedBy?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithAggregationInput>
    by: DocumentScalarFieldEnum[]
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }


  export type DocumentGroupByOutputType = {
    id: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state: FileState
    checksum: string
    vinPassportId: string | null
    invoiceId: string | null
    uploadedById: string | null
    createdAt: Date
    updatedAt: Date | null
    deletedAt: Date | null
    isDeleted: boolean
    deletedBy: string | null
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileType?: boolean
    state?: boolean
    checksum?: boolean
    vinPassportId?: boolean
    invoiceId?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
    deletedBy?: boolean
    vinPassport?: boolean | VinPassportArgs<ExtArgs>
    invoice?: boolean | InvoiceArgs<ExtArgs>
    uploadedBy?: boolean | UserArgs<ExtArgs>
    auditLogs?: boolean | Document$auditLogsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileType?: boolean
    state?: boolean
    checksum?: boolean
    vinPassportId?: boolean
    invoiceId?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
    deletedBy?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    vinPassport?: boolean | VinPassportArgs<ExtArgs>
    invoice?: boolean | InvoiceArgs<ExtArgs>
    uploadedBy?: boolean | UserArgs<ExtArgs>
    auditLogs?: boolean | Document$auditLogsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeArgs<ExtArgs>
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentArgs> = $Types.GetResult<DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    vinPassport<T extends VinPassportArgs<ExtArgs> = {}>(args?: Subset<T, VinPassportArgs<ExtArgs>>): Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    invoice<T extends InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    uploadedBy<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    auditLogs<T extends Document$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Document$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Document base type for findUnique actions
   */
  export type DocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUnique
   */
  export interface DocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document base type for findFirst actions
   */
  export type DocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }

  /**
   * Document findFirst
   */
  export interface DocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: Enumerable<DocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document.auditLogs
   */
  export type Document$auditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuditLogScalarFieldEnum>
  }


  /**
   * Document without action
   */
  export type DocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model MechanicalHealth
   */


  export type AggregateMechanicalHealth = {
    _count: MechanicalHealthCountAggregateOutputType | null
    _min: MechanicalHealthMinAggregateOutputType | null
    _max: MechanicalHealthMaxAggregateOutputType | null
  }

  export type MechanicalHealthMinAggregateOutputType = {
    id: string | null
    vinPassportId: string | null
    lastUpdate: Date | null
    greenLight: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    isDeleted: boolean | null
  }

  export type MechanicalHealthMaxAggregateOutputType = {
    id: string | null
    vinPassportId: string | null
    lastUpdate: Date | null
    greenLight: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    isDeleted: boolean | null
  }

  export type MechanicalHealthCountAggregateOutputType = {
    id: number
    vinPassportId: number
    partsMaintained: number
    lastUpdate: number
    greenLight: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    isDeleted: number
    _all: number
  }


  export type MechanicalHealthMinAggregateInputType = {
    id?: true
    vinPassportId?: true
    lastUpdate?: true
    greenLight?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    isDeleted?: true
  }

  export type MechanicalHealthMaxAggregateInputType = {
    id?: true
    vinPassportId?: true
    lastUpdate?: true
    greenLight?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    isDeleted?: true
  }

  export type MechanicalHealthCountAggregateInputType = {
    id?: true
    vinPassportId?: true
    partsMaintained?: true
    lastUpdate?: true
    greenLight?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type MechanicalHealthAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MechanicalHealth to aggregate.
     */
    where?: MechanicalHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MechanicalHealths to fetch.
     */
    orderBy?: Enumerable<MechanicalHealthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MechanicalHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MechanicalHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MechanicalHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MechanicalHealths
    **/
    _count?: true | MechanicalHealthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MechanicalHealthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MechanicalHealthMaxAggregateInputType
  }

  export type GetMechanicalHealthAggregateType<T extends MechanicalHealthAggregateArgs> = {
        [P in keyof T & keyof AggregateMechanicalHealth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMechanicalHealth[P]>
      : GetScalarType<T[P], AggregateMechanicalHealth[P]>
  }




  export type MechanicalHealthGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MechanicalHealthWhereInput
    orderBy?: Enumerable<MechanicalHealthOrderByWithAggregationInput>
    by: MechanicalHealthScalarFieldEnum[]
    having?: MechanicalHealthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MechanicalHealthCountAggregateInputType | true
    _min?: MechanicalHealthMinAggregateInputType
    _max?: MechanicalHealthMaxAggregateInputType
  }


  export type MechanicalHealthGroupByOutputType = {
    id: string
    vinPassportId: string
    partsMaintained: JsonValue | null
    lastUpdate: Date | null
    greenLight: boolean
    createdAt: Date
    updatedAt: Date | null
    deletedAt: Date | null
    isDeleted: boolean
    _count: MechanicalHealthCountAggregateOutputType | null
    _min: MechanicalHealthMinAggregateOutputType | null
    _max: MechanicalHealthMaxAggregateOutputType | null
  }

  type GetMechanicalHealthGroupByPayload<T extends MechanicalHealthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MechanicalHealthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MechanicalHealthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MechanicalHealthGroupByOutputType[P]>
            : GetScalarType<T[P], MechanicalHealthGroupByOutputType[P]>
        }
      >
    >


  export type MechanicalHealthSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vinPassportId?: boolean
    partsMaintained?: boolean
    lastUpdate?: boolean
    greenLight?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
    vinPassport?: boolean | VinPassportArgs<ExtArgs>
    auditLogs?: boolean | MechanicalHealth$auditLogsArgs<ExtArgs>
    _count?: boolean | MechanicalHealthCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["mechanicalHealth"]>

  export type MechanicalHealthSelectScalar = {
    id?: boolean
    vinPassportId?: boolean
    partsMaintained?: boolean
    lastUpdate?: boolean
    greenLight?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
  }

  export type MechanicalHealthInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    vinPassport?: boolean | VinPassportArgs<ExtArgs>
    auditLogs?: boolean | MechanicalHealth$auditLogsArgs<ExtArgs>
    _count?: boolean | MechanicalHealthCountOutputTypeArgs<ExtArgs>
  }


  type MechanicalHealthGetPayload<S extends boolean | null | undefined | MechanicalHealthArgs> = $Types.GetResult<MechanicalHealthPayload, S>

  type MechanicalHealthCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MechanicalHealthFindManyArgs, 'select' | 'include'> & {
      select?: MechanicalHealthCountAggregateInputType | true
    }

  export interface MechanicalHealthDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MechanicalHealth'], meta: { name: 'MechanicalHealth' } }
    /**
     * Find zero or one MechanicalHealth that matches the filter.
     * @param {MechanicalHealthFindUniqueArgs} args - Arguments to find a MechanicalHealth
     * @example
     * // Get one MechanicalHealth
     * const mechanicalHealth = await prisma.mechanicalHealth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MechanicalHealthFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MechanicalHealthFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MechanicalHealth'> extends True ? Prisma__MechanicalHealthClient<$Types.GetResult<MechanicalHealthPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__MechanicalHealthClient<$Types.GetResult<MechanicalHealthPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one MechanicalHealth that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MechanicalHealthFindUniqueOrThrowArgs} args - Arguments to find a MechanicalHealth
     * @example
     * // Get one MechanicalHealth
     * const mechanicalHealth = await prisma.mechanicalHealth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MechanicalHealthFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MechanicalHealthFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MechanicalHealthClient<$Types.GetResult<MechanicalHealthPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first MechanicalHealth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicalHealthFindFirstArgs} args - Arguments to find a MechanicalHealth
     * @example
     * // Get one MechanicalHealth
     * const mechanicalHealth = await prisma.mechanicalHealth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MechanicalHealthFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MechanicalHealthFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MechanicalHealth'> extends True ? Prisma__MechanicalHealthClient<$Types.GetResult<MechanicalHealthPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__MechanicalHealthClient<$Types.GetResult<MechanicalHealthPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first MechanicalHealth that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicalHealthFindFirstOrThrowArgs} args - Arguments to find a MechanicalHealth
     * @example
     * // Get one MechanicalHealth
     * const mechanicalHealth = await prisma.mechanicalHealth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MechanicalHealthFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MechanicalHealthFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MechanicalHealthClient<$Types.GetResult<MechanicalHealthPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more MechanicalHealths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicalHealthFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MechanicalHealths
     * const mechanicalHealths = await prisma.mechanicalHealth.findMany()
     * 
     * // Get first 10 MechanicalHealths
     * const mechanicalHealths = await prisma.mechanicalHealth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mechanicalHealthWithIdOnly = await prisma.mechanicalHealth.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MechanicalHealthFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MechanicalHealthFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<MechanicalHealthPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a MechanicalHealth.
     * @param {MechanicalHealthCreateArgs} args - Arguments to create a MechanicalHealth.
     * @example
     * // Create one MechanicalHealth
     * const MechanicalHealth = await prisma.mechanicalHealth.create({
     *   data: {
     *     // ... data to create a MechanicalHealth
     *   }
     * })
     * 
    **/
    create<T extends MechanicalHealthCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MechanicalHealthCreateArgs<ExtArgs>>
    ): Prisma__MechanicalHealthClient<$Types.GetResult<MechanicalHealthPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many MechanicalHealths.
     *     @param {MechanicalHealthCreateManyArgs} args - Arguments to create many MechanicalHealths.
     *     @example
     *     // Create many MechanicalHealths
     *     const mechanicalHealth = await prisma.mechanicalHealth.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MechanicalHealthCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MechanicalHealthCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MechanicalHealth.
     * @param {MechanicalHealthDeleteArgs} args - Arguments to delete one MechanicalHealth.
     * @example
     * // Delete one MechanicalHealth
     * const MechanicalHealth = await prisma.mechanicalHealth.delete({
     *   where: {
     *     // ... filter to delete one MechanicalHealth
     *   }
     * })
     * 
    **/
    delete<T extends MechanicalHealthDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MechanicalHealthDeleteArgs<ExtArgs>>
    ): Prisma__MechanicalHealthClient<$Types.GetResult<MechanicalHealthPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one MechanicalHealth.
     * @param {MechanicalHealthUpdateArgs} args - Arguments to update one MechanicalHealth.
     * @example
     * // Update one MechanicalHealth
     * const mechanicalHealth = await prisma.mechanicalHealth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MechanicalHealthUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MechanicalHealthUpdateArgs<ExtArgs>>
    ): Prisma__MechanicalHealthClient<$Types.GetResult<MechanicalHealthPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more MechanicalHealths.
     * @param {MechanicalHealthDeleteManyArgs} args - Arguments to filter MechanicalHealths to delete.
     * @example
     * // Delete a few MechanicalHealths
     * const { count } = await prisma.mechanicalHealth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MechanicalHealthDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MechanicalHealthDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MechanicalHealths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicalHealthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MechanicalHealths
     * const mechanicalHealth = await prisma.mechanicalHealth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MechanicalHealthUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MechanicalHealthUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MechanicalHealth.
     * @param {MechanicalHealthUpsertArgs} args - Arguments to update or create a MechanicalHealth.
     * @example
     * // Update or create a MechanicalHealth
     * const mechanicalHealth = await prisma.mechanicalHealth.upsert({
     *   create: {
     *     // ... data to create a MechanicalHealth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MechanicalHealth we want to update
     *   }
     * })
    **/
    upsert<T extends MechanicalHealthUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MechanicalHealthUpsertArgs<ExtArgs>>
    ): Prisma__MechanicalHealthClient<$Types.GetResult<MechanicalHealthPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of MechanicalHealths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicalHealthCountArgs} args - Arguments to filter MechanicalHealths to count.
     * @example
     * // Count the number of MechanicalHealths
     * const count = await prisma.mechanicalHealth.count({
     *   where: {
     *     // ... the filter for the MechanicalHealths we want to count
     *   }
     * })
    **/
    count<T extends MechanicalHealthCountArgs>(
      args?: Subset<T, MechanicalHealthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MechanicalHealthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MechanicalHealth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicalHealthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MechanicalHealthAggregateArgs>(args: Subset<T, MechanicalHealthAggregateArgs>): Prisma.PrismaPromise<GetMechanicalHealthAggregateType<T>>

    /**
     * Group by MechanicalHealth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicalHealthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MechanicalHealthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MechanicalHealthGroupByArgs['orderBy'] }
        : { orderBy?: MechanicalHealthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MechanicalHealthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMechanicalHealthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MechanicalHealth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MechanicalHealthClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    vinPassport<T extends VinPassportArgs<ExtArgs> = {}>(args?: Subset<T, VinPassportArgs<ExtArgs>>): Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    auditLogs<T extends MechanicalHealth$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, MechanicalHealth$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MechanicalHealth base type for findUnique actions
   */
  export type MechanicalHealthFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicalHealth
     */
    select?: MechanicalHealthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MechanicalHealthInclude<ExtArgs> | null
    /**
     * Filter, which MechanicalHealth to fetch.
     */
    where: MechanicalHealthWhereUniqueInput
  }

  /**
   * MechanicalHealth findUnique
   */
  export interface MechanicalHealthFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MechanicalHealthFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MechanicalHealth findUniqueOrThrow
   */
  export type MechanicalHealthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicalHealth
     */
    select?: MechanicalHealthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MechanicalHealthInclude<ExtArgs> | null
    /**
     * Filter, which MechanicalHealth to fetch.
     */
    where: MechanicalHealthWhereUniqueInput
  }


  /**
   * MechanicalHealth base type for findFirst actions
   */
  export type MechanicalHealthFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicalHealth
     */
    select?: MechanicalHealthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MechanicalHealthInclude<ExtArgs> | null
    /**
     * Filter, which MechanicalHealth to fetch.
     */
    where?: MechanicalHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MechanicalHealths to fetch.
     */
    orderBy?: Enumerable<MechanicalHealthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MechanicalHealths.
     */
    cursor?: MechanicalHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MechanicalHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MechanicalHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MechanicalHealths.
     */
    distinct?: Enumerable<MechanicalHealthScalarFieldEnum>
  }

  /**
   * MechanicalHealth findFirst
   */
  export interface MechanicalHealthFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MechanicalHealthFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MechanicalHealth findFirstOrThrow
   */
  export type MechanicalHealthFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicalHealth
     */
    select?: MechanicalHealthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MechanicalHealthInclude<ExtArgs> | null
    /**
     * Filter, which MechanicalHealth to fetch.
     */
    where?: MechanicalHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MechanicalHealths to fetch.
     */
    orderBy?: Enumerable<MechanicalHealthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MechanicalHealths.
     */
    cursor?: MechanicalHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MechanicalHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MechanicalHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MechanicalHealths.
     */
    distinct?: Enumerable<MechanicalHealthScalarFieldEnum>
  }


  /**
   * MechanicalHealth findMany
   */
  export type MechanicalHealthFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicalHealth
     */
    select?: MechanicalHealthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MechanicalHealthInclude<ExtArgs> | null
    /**
     * Filter, which MechanicalHealths to fetch.
     */
    where?: MechanicalHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MechanicalHealths to fetch.
     */
    orderBy?: Enumerable<MechanicalHealthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MechanicalHealths.
     */
    cursor?: MechanicalHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MechanicalHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MechanicalHealths.
     */
    skip?: number
    distinct?: Enumerable<MechanicalHealthScalarFieldEnum>
  }


  /**
   * MechanicalHealth create
   */
  export type MechanicalHealthCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicalHealth
     */
    select?: MechanicalHealthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MechanicalHealthInclude<ExtArgs> | null
    /**
     * The data needed to create a MechanicalHealth.
     */
    data: XOR<MechanicalHealthCreateInput, MechanicalHealthUncheckedCreateInput>
  }


  /**
   * MechanicalHealth createMany
   */
  export type MechanicalHealthCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MechanicalHealths.
     */
    data: Enumerable<MechanicalHealthCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MechanicalHealth update
   */
  export type MechanicalHealthUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicalHealth
     */
    select?: MechanicalHealthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MechanicalHealthInclude<ExtArgs> | null
    /**
     * The data needed to update a MechanicalHealth.
     */
    data: XOR<MechanicalHealthUpdateInput, MechanicalHealthUncheckedUpdateInput>
    /**
     * Choose, which MechanicalHealth to update.
     */
    where: MechanicalHealthWhereUniqueInput
  }


  /**
   * MechanicalHealth updateMany
   */
  export type MechanicalHealthUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MechanicalHealths.
     */
    data: XOR<MechanicalHealthUpdateManyMutationInput, MechanicalHealthUncheckedUpdateManyInput>
    /**
     * Filter which MechanicalHealths to update
     */
    where?: MechanicalHealthWhereInput
  }


  /**
   * MechanicalHealth upsert
   */
  export type MechanicalHealthUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicalHealth
     */
    select?: MechanicalHealthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MechanicalHealthInclude<ExtArgs> | null
    /**
     * The filter to search for the MechanicalHealth to update in case it exists.
     */
    where: MechanicalHealthWhereUniqueInput
    /**
     * In case the MechanicalHealth found by the `where` argument doesn't exist, create a new MechanicalHealth with this data.
     */
    create: XOR<MechanicalHealthCreateInput, MechanicalHealthUncheckedCreateInput>
    /**
     * In case the MechanicalHealth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MechanicalHealthUpdateInput, MechanicalHealthUncheckedUpdateInput>
  }


  /**
   * MechanicalHealth delete
   */
  export type MechanicalHealthDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicalHealth
     */
    select?: MechanicalHealthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MechanicalHealthInclude<ExtArgs> | null
    /**
     * Filter which MechanicalHealth to delete.
     */
    where: MechanicalHealthWhereUniqueInput
  }


  /**
   * MechanicalHealth deleteMany
   */
  export type MechanicalHealthDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MechanicalHealths to delete
     */
    where?: MechanicalHealthWhereInput
  }


  /**
   * MechanicalHealth.auditLogs
   */
  export type MechanicalHealth$auditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuditLogScalarFieldEnum>
  }


  /**
   * MechanicalHealth without action
   */
  export type MechanicalHealthArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MechanicalHealth
     */
    select?: MechanicalHealthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MechanicalHealthInclude<ExtArgs> | null
  }



  /**
   * Model AuditLog
   */


  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: AuditAction | null
    entityType: EntityType | null
    entityId: string | null
    userId: string | null
    invoiceId: string | null
    vinPassportId: string | null
    chainTxId: string | null
    documentId: string | null
    conditionMatrixId: string | null
    mechanicalHealthId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: AuditAction | null
    entityType: EntityType | null
    entityId: string | null
    userId: string | null
    invoiceId: string | null
    vinPassportId: string | null
    chainTxId: string | null
    documentId: string | null
    conditionMatrixId: string | null
    mechanicalHealthId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    entityType: number
    entityId: number
    oldValue: number
    newValue: number
    userId: number
    invoiceId: number
    vinPassportId: number
    chainTxId: number
    documentId: number
    conditionMatrixId: number
    mechanicalHealthId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    isDeleted: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    userId?: true
    invoiceId?: true
    vinPassportId?: true
    chainTxId?: true
    documentId?: true
    conditionMatrixId?: true
    mechanicalHealthId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    userId?: true
    invoiceId?: true
    vinPassportId?: true
    chainTxId?: true
    documentId?: true
    conditionMatrixId?: true
    mechanicalHealthId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    userId?: true
    invoiceId?: true
    vinPassportId?: true
    chainTxId?: true
    documentId?: true
    conditionMatrixId?: true
    mechanicalHealthId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: Enumerable<AuditLogOrderByWithAggregationInput>
    by: AuditLogScalarFieldEnum[]
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }


  export type AuditLogGroupByOutputType = {
    id: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue: JsonValue | null
    newValue: JsonValue | null
    userId: string | null
    invoiceId: string | null
    vinPassportId: string | null
    chainTxId: string | null
    documentId: string | null
    conditionMatrixId: string | null
    mechanicalHealthId: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    userId?: boolean
    invoiceId?: boolean
    vinPassportId?: boolean
    chainTxId?: boolean
    documentId?: boolean
    conditionMatrixId?: boolean
    mechanicalHealthId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
    user?: boolean | UserArgs<ExtArgs>
    invoice?: boolean | InvoiceArgs<ExtArgs>
    vinPassport?: boolean | VinPassportArgs<ExtArgs>
    chainTx?: boolean | BlockchainTransactionArgs<ExtArgs>
    document?: boolean | DocumentArgs<ExtArgs>
    conditionMatrix?: boolean | ConditionMatrixArgs<ExtArgs>
    mechanicalHealth?: boolean | MechanicalHealthArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    userId?: boolean
    invoiceId?: boolean
    vinPassportId?: boolean
    chainTxId?: boolean
    documentId?: boolean
    conditionMatrixId?: boolean
    mechanicalHealthId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    invoice?: boolean | InvoiceArgs<ExtArgs>
    vinPassport?: boolean | VinPassportArgs<ExtArgs>
    chainTx?: boolean | BlockchainTransactionArgs<ExtArgs>
    document?: boolean | DocumentArgs<ExtArgs>
    conditionMatrix?: boolean | ConditionMatrixArgs<ExtArgs>
    mechanicalHealth?: boolean | MechanicalHealthArgs<ExtArgs>
  }


  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogArgs> = $Types.GetResult<AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuditLogFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AuditLog'> extends True ? Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuditLogFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AuditLog'> extends True ? Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AuditLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
    **/
    create<T extends AuditLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many AuditLogs.
     *     @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     *     @example
     *     // Create many AuditLogs
     *     const auditLog = await prisma.auditLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AuditLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
    **/
    delete<T extends AuditLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuditLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuditLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuditLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
    **/
    upsert<T extends AuditLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    invoice<T extends InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    vinPassport<T extends VinPassportArgs<ExtArgs> = {}>(args?: Subset<T, VinPassportArgs<ExtArgs>>): Prisma__VinPassportClient<$Types.GetResult<VinPassportPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    chainTx<T extends BlockchainTransactionArgs<ExtArgs> = {}>(args?: Subset<T, BlockchainTransactionArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Types.GetResult<BlockchainTransactionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    document<T extends DocumentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentArgs<ExtArgs>>): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    conditionMatrix<T extends ConditionMatrixArgs<ExtArgs> = {}>(args?: Subset<T, ConditionMatrixArgs<ExtArgs>>): Prisma__ConditionMatrixClient<$Types.GetResult<ConditionMatrixPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    mechanicalHealth<T extends MechanicalHealthArgs<ExtArgs> = {}>(args?: Subset<T, MechanicalHealthArgs<ExtArgs>>): Prisma__MechanicalHealthClient<$Types.GetResult<MechanicalHealthPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AuditLog base type for findUnique actions
   */
  export type AuditLogFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUnique
   */
  export interface AuditLogFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AuditLogFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }


  /**
   * AuditLog base type for findFirst actions
   */
  export type AuditLogFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: Enumerable<AuditLogScalarFieldEnum>
  }

  /**
   * AuditLog findFirst
   */
  export interface AuditLogFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AuditLogFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: Enumerable<AuditLogScalarFieldEnum>
  }


  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: Enumerable<AuditLogScalarFieldEnum>
  }


  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }


  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: Enumerable<AuditLogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }


  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }


  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }


  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }


  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }


  /**
   * AuditLog without action
   */
  export type AuditLogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
  }



  /**
   * Model Alert
   */


  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    userName: string | null
    userRole: UserRole | null
    action: AlertAction | null
    activity: string | null
    businessId: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
    userId: string | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    userName: string | null
    userRole: UserRole | null
    action: AlertAction | null
    activity: string | null
    businessId: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean | null
    userId: string | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    userName: number
    userRole: number
    action: number
    activity: number
    businessId: number
    isRead: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    deletedBy: number
    isDeleted: number
    userId: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    userName?: true
    userRole?: true
    action?: true
    activity?: true
    businessId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
    userId?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    userName?: true
    userRole?: true
    action?: true
    activity?: true
    businessId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
    userId?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    userName?: true
    userRole?: true
    action?: true
    activity?: true
    businessId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    deletedBy?: true
    isDeleted?: true
    userId?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: Enumerable<AlertOrderByWithAggregationInput>
    by: AlertScalarFieldEnum[]
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }


  export type AlertGroupByOutputType = {
    id: string
    userName: string
    userRole: UserRole
    action: AlertAction
    activity: string
    businessId: string | null
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    deletedBy: string | null
    isDeleted: boolean
    userId: string | null
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    userRole?: boolean
    action?: boolean
    activity?: boolean
    businessId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
    userId?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    userName?: boolean
    userRole?: boolean
    action?: boolean
    activity?: boolean
    businessId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
    userId?: boolean
  }

  export type AlertInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type AlertGetPayload<S extends boolean | null | undefined | AlertArgs> = $Types.GetResult<AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AlertFindManyArgs, 'select' | 'include'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AlertFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Alert'> extends True ? Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Alert that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AlertFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Alert'> extends True ? Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Alert that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AlertFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
    **/
    create<T extends AlertCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AlertCreateArgs<ExtArgs>>
    ): Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Alerts.
     *     @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     *     @example
     *     // Create many Alerts
     *     const alert = await prisma.alert.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AlertCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
    **/
    delete<T extends AlertDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>
    ): Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AlertUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>
    ): Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AlertDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AlertUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
    **/
    upsert<T extends AlertUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>
    ): Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Alert base type for findUnique actions
   */
  export type AlertFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUnique
   */
  export interface AlertFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AlertFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }


  /**
   * Alert base type for findFirst actions
   */
  export type AlertFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: Enumerable<AlertScalarFieldEnum>
  }

  /**
   * Alert findFirst
   */
  export interface AlertFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AlertFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: Enumerable<AlertScalarFieldEnum>
  }


  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: Enumerable<AlertScalarFieldEnum>
  }


  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }


  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: Enumerable<AlertCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }


  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
  }


  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }


  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }


  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
  }


  /**
   * Alert without action
   */
  export type AlertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    walletAddress: 'walletAddress',
    signature: 'signature',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    isDeleted: 'isDeleted'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AztoWalletScalarFieldEnum: {
    id: 'id',
    balance: 'balance',
    userId: 'userId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    isDeleted: 'isDeleted'
  };

  export type AztoWalletScalarFieldEnum = (typeof AztoWalletScalarFieldEnum)[keyof typeof AztoWalletScalarFieldEnum]


  export const VinPassportScalarFieldEnum: {
    id: 'id',
    vin: 'vin',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    isDeleted: 'isDeleted'
  };

  export type VinPassportScalarFieldEnum = (typeof VinPassportScalarFieldEnum)[keyof typeof VinPassportScalarFieldEnum]


  export const GasSettlementScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    vinPassportId: 'vinPassportId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    isDeleted: 'isDeleted'
  };

  export type GasSettlementScalarFieldEnum = (typeof GasSettlementScalarFieldEnum)[keyof typeof GasSettlementScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    number: 'number',
    status: 'status',
    vinPassportId: 'vinPassportId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    isDeleted: 'isDeleted'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const NormalizedPartScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    invoiceId: 'invoiceId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    isDeleted: 'isDeleted'
  };

  export type NormalizedPartScalarFieldEnum = (typeof NormalizedPartScalarFieldEnum)[keyof typeof NormalizedPartScalarFieldEnum]


  export const AIDecisionScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    model: 'model',
    promptHash: 'promptHash',
    responseHash: 'responseHash',
    decision: 'decision',
    confidence: 'confidence',
    metadata: 'metadata',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type AIDecisionScalarFieldEnum = (typeof AIDecisionScalarFieldEnum)[keyof typeof AIDecisionScalarFieldEnum]


  export const AIQuotaScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    invoicesProcessed: 'invoicesProcessed',
    rejectedCount: 'rejectedCount',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd'
  };

  export type AIQuotaScalarFieldEnum = (typeof AIQuotaScalarFieldEnum)[keyof typeof AIQuotaScalarFieldEnum]


  export const ConditionMatrixScalarFieldEnum: {
    id: 'id',
    vinPassportId: 'vinPassportId',
    version: 'version',
    rulesHash: 'rulesHash',
    effectiveFrom: 'effectiveFrom',
    isActive: 'isActive',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ConditionMatrixScalarFieldEnum = (typeof ConditionMatrixScalarFieldEnum)[keyof typeof ConditionMatrixScalarFieldEnum]


  export const SystemStateScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type SystemStateScalarFieldEnum = (typeof SystemStateScalarFieldEnum)[keyof typeof SystemStateScalarFieldEnum]


  export const BlockchainTransactionScalarFieldEnum: {
    id: 'id',
    chain: 'chain',
    contract: 'contract',
    txHash: 'txHash',
    blockNumber: 'blockNumber',
    eventName: 'eventName',
    status: 'status',
    entityType: 'entityType',
    entityId: 'entityId',
    payload: 'payload',
    confirmations: 'confirmations',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlockchainTransactionScalarFieldEnum = (typeof BlockchainTransactionScalarFieldEnum)[keyof typeof BlockchainTransactionScalarFieldEnum]


  export const OnChainProofScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    hash: 'hash',
    algorithm: 'algorithm',
    chain: 'chain',
    contract: 'contract',
    txHash: 'txHash',
    invoiceId: 'invoiceId',
    vinPassportId: 'vinPassportId',
    createdAt: 'createdAt'
  };

  export type OnChainProofScalarFieldEnum = (typeof OnChainProofScalarFieldEnum)[keyof typeof OnChainProofScalarFieldEnum]


  export const ChainCursorScalarFieldEnum: {
    id: 'id',
    chain: 'chain',
    contract: 'contract',
    lastBlock: 'lastBlock',
    updatedAt: 'updatedAt'
  };

  export type ChainCursorScalarFieldEnum = (typeof ChainCursorScalarFieldEnum)[keyof typeof ChainCursorScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    fileUrl: 'fileUrl',
    fileType: 'fileType',
    state: 'state',
    checksum: 'checksum',
    vinPassportId: 'vinPassportId',
    invoiceId: 'invoiceId',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    isDeleted: 'isDeleted',
    deletedBy: 'deletedBy'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const MechanicalHealthScalarFieldEnum: {
    id: 'id',
    vinPassportId: 'vinPassportId',
    partsMaintained: 'partsMaintained',
    lastUpdate: 'lastUpdate',
    greenLight: 'greenLight',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    isDeleted: 'isDeleted'
  };

  export type MechanicalHealthScalarFieldEnum = (typeof MechanicalHealthScalarFieldEnum)[keyof typeof MechanicalHealthScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    oldValue: 'oldValue',
    newValue: 'newValue',
    userId: 'userId',
    invoiceId: 'invoiceId',
    vinPassportId: 'vinPassportId',
    chainTxId: 'chainTxId',
    documentId: 'documentId',
    conditionMatrixId: 'conditionMatrixId',
    mechanicalHealthId: 'mechanicalHealthId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    isDeleted: 'isDeleted'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    userName: 'userName',
    userRole: 'userRole',
    action: 'action',
    activity: 'activity',
    businessId: 'businessId',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    isDeleted: 'isDeleted',
    userId: 'userId'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    role?: EnumUserRoleFilter | UserRole
    walletAddress?: StringNullableFilter | string | null
    signature?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringNullableFilter | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    updatedBy?: StringNullableFilter | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    wallet?: XOR<AztoWalletRelationFilter, AztoWalletWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    aiQuotas?: AIQuotaListRelationFilter
    aiDecisions?: AIDecisionListRelationFilter
    chainTxs?: BlockchainTransactionListRelationFilter
    alerts?: AlertListRelationFilter
    documents?: DocumentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    walletAddress?: SortOrderInput | SortOrder
    signature?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    wallet?: AztoWalletOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    aiQuotas?: AIQuotaOrderByRelationAggregateInput
    aiDecisions?: AIDecisionOrderByRelationAggregateInput
    chainTxs?: BlockchainTransactionOrderByRelationAggregateInput
    alerts?: AlertOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
    walletAddress?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    walletAddress?: SortOrderInput | SortOrder
    signature?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
    role?: EnumUserRoleWithAggregatesFilter | UserRole
    walletAddress?: StringNullableWithAggregatesFilter | string | null
    signature?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    createdBy?: StringNullableWithAggregatesFilter | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type AztoWalletWhereInput = {
    AND?: Enumerable<AztoWalletWhereInput>
    OR?: Enumerable<AztoWalletWhereInput>
    NOT?: Enumerable<AztoWalletWhereInput>
    id?: StringFilter | string
    balance?: DecimalFilter | Decimal | DecimalJsLike | number | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringNullableFilter | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    updatedBy?: StringNullableFilter | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AztoWalletOrderByWithRelationInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AztoWalletWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type AztoWalletOrderByWithAggregationInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: AztoWalletCountOrderByAggregateInput
    _avg?: AztoWalletAvgOrderByAggregateInput
    _max?: AztoWalletMaxOrderByAggregateInput
    _min?: AztoWalletMinOrderByAggregateInput
    _sum?: AztoWalletSumOrderByAggregateInput
  }

  export type AztoWalletScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AztoWalletScalarWhereWithAggregatesInput>
    OR?: Enumerable<AztoWalletScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AztoWalletScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    balance?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    createdBy?: StringNullableWithAggregatesFilter | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type VinPassportWhereInput = {
    AND?: Enumerable<VinPassportWhereInput>
    OR?: Enumerable<VinPassportWhereInput>
    NOT?: Enumerable<VinPassportWhereInput>
    id?: StringFilter | string
    vin?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringNullableFilter | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    updatedBy?: StringNullableFilter | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    invoices?: InvoiceListRelationFilter
    gasSettlements?: GasSettlementListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    onChainProofs?: OnChainProofListRelationFilter
    documents?: DocumentListRelationFilter
    conditionMatrices?: ConditionMatrixListRelationFilter
    mechanicalHealths?: MechanicalHealthListRelationFilter
  }

  export type VinPassportOrderByWithRelationInput = {
    id?: SortOrder
    vin?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    invoices?: InvoiceOrderByRelationAggregateInput
    gasSettlements?: GasSettlementOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    onChainProofs?: OnChainProofOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    conditionMatrices?: ConditionMatrixOrderByRelationAggregateInput
    mechanicalHealths?: MechanicalHealthOrderByRelationAggregateInput
  }

  export type VinPassportWhereUniqueInput = {
    id?: string
    vin?: string
  }

  export type VinPassportOrderByWithAggregationInput = {
    id?: SortOrder
    vin?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: VinPassportCountOrderByAggregateInput
    _max?: VinPassportMaxOrderByAggregateInput
    _min?: VinPassportMinOrderByAggregateInput
  }

  export type VinPassportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VinPassportScalarWhereWithAggregatesInput>
    OR?: Enumerable<VinPassportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VinPassportScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    vin?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    createdBy?: StringNullableWithAggregatesFilter | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type GasSettlementWhereInput = {
    AND?: Enumerable<GasSettlementWhereInput>
    OR?: Enumerable<GasSettlementWhereInput>
    NOT?: Enumerable<GasSettlementWhereInput>
    id?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    vinPassportId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringNullableFilter | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    updatedBy?: StringNullableFilter | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    vinPassport?: XOR<VinPassportRelationFilter, VinPassportWhereInput>
  }

  export type GasSettlementOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    vinPassportId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    vinPassport?: VinPassportOrderByWithRelationInput
  }

  export type GasSettlementWhereUniqueInput = {
    id?: string
  }

  export type GasSettlementOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    vinPassportId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: GasSettlementCountOrderByAggregateInput
    _avg?: GasSettlementAvgOrderByAggregateInput
    _max?: GasSettlementMaxOrderByAggregateInput
    _min?: GasSettlementMinOrderByAggregateInput
    _sum?: GasSettlementSumOrderByAggregateInput
  }

  export type GasSettlementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GasSettlementScalarWhereWithAggregatesInput>
    OR?: Enumerable<GasSettlementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GasSettlementScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    vinPassportId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    createdBy?: StringNullableWithAggregatesFilter | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type InvoiceWhereInput = {
    AND?: Enumerable<InvoiceWhereInput>
    OR?: Enumerable<InvoiceWhereInput>
    NOT?: Enumerable<InvoiceWhereInput>
    id?: StringFilter | string
    number?: StringFilter | string
    status?: EnumTxStatusFilter | TxStatus
    vinPassportId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringNullableFilter | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    updatedBy?: StringNullableFilter | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    vinPassport?: XOR<VinPassportRelationFilter, VinPassportWhereInput> | null
    documents?: DocumentListRelationFilter
    parts?: NormalizedPartListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    onChainProofs?: OnChainProofListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    status?: SortOrder
    vinPassportId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    vinPassport?: VinPassportOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    parts?: NormalizedPartOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    onChainProofs?: OnChainProofOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = {
    id?: string
    number?: string
  }

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    status?: SortOrder
    vinPassportId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    number?: StringWithAggregatesFilter | string
    status?: EnumTxStatusWithAggregatesFilter | TxStatus
    vinPassportId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    createdBy?: StringNullableWithAggregatesFilter | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type NormalizedPartWhereInput = {
    AND?: Enumerable<NormalizedPartWhereInput>
    OR?: Enumerable<NormalizedPartWhereInput>
    NOT?: Enumerable<NormalizedPartWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    invoiceId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringNullableFilter | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    updatedBy?: StringNullableFilter | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type NormalizedPartOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    invoiceId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type NormalizedPartWhereUniqueInput = {
    id?: string
  }

  export type NormalizedPartOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    invoiceId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: NormalizedPartCountOrderByAggregateInput
    _avg?: NormalizedPartAvgOrderByAggregateInput
    _max?: NormalizedPartMaxOrderByAggregateInput
    _min?: NormalizedPartMinOrderByAggregateInput
    _sum?: NormalizedPartSumOrderByAggregateInput
  }

  export type NormalizedPartScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NormalizedPartScalarWhereWithAggregatesInput>
    OR?: Enumerable<NormalizedPartScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NormalizedPartScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    price?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    invoiceId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    createdBy?: StringNullableWithAggregatesFilter | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type AIDecisionWhereInput = {
    AND?: Enumerable<AIDecisionWhereInput>
    OR?: Enumerable<AIDecisionWhereInput>
    NOT?: Enumerable<AIDecisionWhereInput>
    id?: StringFilter | string
    entityType?: EnumEntityTypeFilter | EntityType
    entityId?: StringFilter | string
    model?: StringFilter | string
    promptHash?: StringFilter | string
    responseHash?: StringFilter | string
    decision?: StringFilter | string
    confidence?: FloatNullableFilter | number | null
    metadata?: JsonNullableFilter
    userId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type AIDecisionOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    model?: SortOrder
    promptHash?: SortOrder
    responseHash?: SortOrder
    decision?: SortOrder
    confidence?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AIDecisionWhereUniqueInput = {
    id?: string
  }

  export type AIDecisionOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    model?: SortOrder
    promptHash?: SortOrder
    responseHash?: SortOrder
    decision?: SortOrder
    confidence?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIDecisionCountOrderByAggregateInput
    _avg?: AIDecisionAvgOrderByAggregateInput
    _max?: AIDecisionMaxOrderByAggregateInput
    _min?: AIDecisionMinOrderByAggregateInput
    _sum?: AIDecisionSumOrderByAggregateInput
  }

  export type AIDecisionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AIDecisionScalarWhereWithAggregatesInput>
    OR?: Enumerable<AIDecisionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AIDecisionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    entityType?: EnumEntityTypeWithAggregatesFilter | EntityType
    entityId?: StringWithAggregatesFilter | string
    model?: StringWithAggregatesFilter | string
    promptHash?: StringWithAggregatesFilter | string
    responseHash?: StringWithAggregatesFilter | string
    decision?: StringWithAggregatesFilter | string
    confidence?: FloatNullableWithAggregatesFilter | number | null
    metadata?: JsonNullableWithAggregatesFilter
    userId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AIQuotaWhereInput = {
    AND?: Enumerable<AIQuotaWhereInput>
    OR?: Enumerable<AIQuotaWhereInput>
    NOT?: Enumerable<AIQuotaWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    invoicesProcessed?: IntFilter | number
    rejectedCount?: IntFilter | number
    periodStart?: DateTimeFilter | Date | string
    periodEnd?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AIQuotaOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    invoicesProcessed?: SortOrder
    rejectedCount?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AIQuotaWhereUniqueInput = {
    id?: string
  }

  export type AIQuotaOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    invoicesProcessed?: SortOrder
    rejectedCount?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    _count?: AIQuotaCountOrderByAggregateInput
    _avg?: AIQuotaAvgOrderByAggregateInput
    _max?: AIQuotaMaxOrderByAggregateInput
    _min?: AIQuotaMinOrderByAggregateInput
    _sum?: AIQuotaSumOrderByAggregateInput
  }

  export type AIQuotaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AIQuotaScalarWhereWithAggregatesInput>
    OR?: Enumerable<AIQuotaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AIQuotaScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    invoicesProcessed?: IntWithAggregatesFilter | number
    rejectedCount?: IntWithAggregatesFilter | number
    periodStart?: DateTimeWithAggregatesFilter | Date | string
    periodEnd?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ConditionMatrixWhereInput = {
    AND?: Enumerable<ConditionMatrixWhereInput>
    OR?: Enumerable<ConditionMatrixWhereInput>
    NOT?: Enumerable<ConditionMatrixWhereInput>
    id?: StringFilter | string
    vinPassportId?: StringNullableFilter | string | null
    version?: StringFilter | string
    rulesHash?: StringFilter | string
    effectiveFrom?: DateTimeFilter | Date | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringNullableFilter | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    updatedBy?: StringNullableFilter | string | null
    vinPassport?: XOR<VinPassportRelationFilter, VinPassportWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
  }

  export type ConditionMatrixOrderByWithRelationInput = {
    id?: SortOrder
    vinPassportId?: SortOrderInput | SortOrder
    version?: SortOrder
    rulesHash?: SortOrder
    effectiveFrom?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    vinPassport?: VinPassportOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type ConditionMatrixWhereUniqueInput = {
    id?: string
  }

  export type ConditionMatrixOrderByWithAggregationInput = {
    id?: SortOrder
    vinPassportId?: SortOrderInput | SortOrder
    version?: SortOrder
    rulesHash?: SortOrder
    effectiveFrom?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ConditionMatrixCountOrderByAggregateInput
    _max?: ConditionMatrixMaxOrderByAggregateInput
    _min?: ConditionMatrixMinOrderByAggregateInput
  }

  export type ConditionMatrixScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ConditionMatrixScalarWhereWithAggregatesInput>
    OR?: Enumerable<ConditionMatrixScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ConditionMatrixScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    vinPassportId?: StringNullableWithAggregatesFilter | string | null
    version?: StringWithAggregatesFilter | string
    rulesHash?: StringWithAggregatesFilter | string
    effectiveFrom?: DateTimeWithAggregatesFilter | Date | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    createdBy?: StringNullableWithAggregatesFilter | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter | string | null
  }

  export type SystemStateWhereInput = {
    AND?: Enumerable<SystemStateWhereInput>
    OR?: Enumerable<SystemStateWhereInput>
    NOT?: Enumerable<SystemStateWhereInput>
    id?: StringFilter | string
    key?: StringFilter | string
    value?: StringFilter | string
    updatedAt?: DateTimeFilter | Date | string
    updatedBy?: StringNullableFilter | string | null
  }

  export type SystemStateOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
  }

  export type SystemStateWhereUniqueInput = {
    id?: string
    key?: string
  }

  export type SystemStateOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SystemStateCountOrderByAggregateInput
    _max?: SystemStateMaxOrderByAggregateInput
    _min?: SystemStateMinOrderByAggregateInput
  }

  export type SystemStateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SystemStateScalarWhereWithAggregatesInput>
    OR?: Enumerable<SystemStateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SystemStateScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    key?: StringWithAggregatesFilter | string
    value?: StringWithAggregatesFilter | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    updatedBy?: StringNullableWithAggregatesFilter | string | null
  }

  export type BlockchainTransactionWhereInput = {
    AND?: Enumerable<BlockchainTransactionWhereInput>
    OR?: Enumerable<BlockchainTransactionWhereInput>
    NOT?: Enumerable<BlockchainTransactionWhereInput>
    id?: StringFilter | string
    chain?: StringFilter | string
    contract?: StringFilter | string
    txHash?: StringFilter | string
    blockNumber?: BigIntNullableFilter | bigint | number | null
    eventName?: StringNullableFilter | string | null
    status?: EnumTxStatusFilter | TxStatus
    entityType?: EnumEntityTypeFilter | EntityType
    entityId?: StringFilter | string
    payload?: JsonFilter
    confirmations?: IntFilter | number
    userId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
  }

  export type BlockchainTransactionOrderByWithRelationInput = {
    id?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrderInput | SortOrder
    eventName?: SortOrderInput | SortOrder
    status?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    payload?: SortOrder
    confirmations?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type BlockchainTransactionWhereUniqueInput = {
    id?: string
    txHash?: string
  }

  export type BlockchainTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrderInput | SortOrder
    eventName?: SortOrderInput | SortOrder
    status?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    payload?: SortOrder
    confirmations?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlockchainTransactionCountOrderByAggregateInput
    _avg?: BlockchainTransactionAvgOrderByAggregateInput
    _max?: BlockchainTransactionMaxOrderByAggregateInput
    _min?: BlockchainTransactionMinOrderByAggregateInput
    _sum?: BlockchainTransactionSumOrderByAggregateInput
  }

  export type BlockchainTransactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BlockchainTransactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<BlockchainTransactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BlockchainTransactionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    chain?: StringWithAggregatesFilter | string
    contract?: StringWithAggregatesFilter | string
    txHash?: StringWithAggregatesFilter | string
    blockNumber?: BigIntNullableWithAggregatesFilter | bigint | number | null
    eventName?: StringNullableWithAggregatesFilter | string | null
    status?: EnumTxStatusWithAggregatesFilter | TxStatus
    entityType?: EnumEntityTypeWithAggregatesFilter | EntityType
    entityId?: StringWithAggregatesFilter | string
    payload?: JsonWithAggregatesFilter
    confirmations?: IntWithAggregatesFilter | number
    userId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OnChainProofWhereInput = {
    AND?: Enumerable<OnChainProofWhereInput>
    OR?: Enumerable<OnChainProofWhereInput>
    NOT?: Enumerable<OnChainProofWhereInput>
    id?: StringFilter | string
    entityType?: EnumEntityTypeFilter | EntityType
    entityId?: StringFilter | string
    hash?: StringFilter | string
    algorithm?: StringFilter | string
    chain?: StringFilter | string
    contract?: StringFilter | string
    txHash?: StringFilter | string
    invoiceId?: StringNullableFilter | string | null
    vinPassportId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput> | null
    vinPassport?: XOR<VinPassportRelationFilter, VinPassportWhereInput> | null
  }

  export type OnChainProofOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    hash?: SortOrder
    algorithm?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    txHash?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    vinPassportId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    vinPassport?: VinPassportOrderByWithRelationInput
  }

  export type OnChainProofWhereUniqueInput = {
    id?: string
  }

  export type OnChainProofOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    hash?: SortOrder
    algorithm?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    txHash?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    vinPassportId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OnChainProofCountOrderByAggregateInput
    _max?: OnChainProofMaxOrderByAggregateInput
    _min?: OnChainProofMinOrderByAggregateInput
  }

  export type OnChainProofScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OnChainProofScalarWhereWithAggregatesInput>
    OR?: Enumerable<OnChainProofScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OnChainProofScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    entityType?: EnumEntityTypeWithAggregatesFilter | EntityType
    entityId?: StringWithAggregatesFilter | string
    hash?: StringWithAggregatesFilter | string
    algorithm?: StringWithAggregatesFilter | string
    chain?: StringWithAggregatesFilter | string
    contract?: StringWithAggregatesFilter | string
    txHash?: StringWithAggregatesFilter | string
    invoiceId?: StringNullableWithAggregatesFilter | string | null
    vinPassportId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ChainCursorWhereInput = {
    AND?: Enumerable<ChainCursorWhereInput>
    OR?: Enumerable<ChainCursorWhereInput>
    NOT?: Enumerable<ChainCursorWhereInput>
    id?: StringFilter | string
    chain?: StringFilter | string
    contract?: StringFilter | string
    lastBlock?: BigIntFilter | bigint | number
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ChainCursorOrderByWithRelationInput = {
    id?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    lastBlock?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChainCursorWhereUniqueInput = {
    id?: string
  }

  export type ChainCursorOrderByWithAggregationInput = {
    id?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    lastBlock?: SortOrder
    updatedAt?: SortOrder
    _count?: ChainCursorCountOrderByAggregateInput
    _avg?: ChainCursorAvgOrderByAggregateInput
    _max?: ChainCursorMaxOrderByAggregateInput
    _min?: ChainCursorMinOrderByAggregateInput
    _sum?: ChainCursorSumOrderByAggregateInput
  }

  export type ChainCursorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChainCursorScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChainCursorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChainCursorScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    chain?: StringWithAggregatesFilter | string
    contract?: StringWithAggregatesFilter | string
    lastBlock?: BigIntWithAggregatesFilter | bigint | number
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DocumentWhereInput = {
    AND?: Enumerable<DocumentWhereInput>
    OR?: Enumerable<DocumentWhereInput>
    NOT?: Enumerable<DocumentWhereInput>
    id?: StringFilter | string
    fileName?: StringFilter | string
    fileUrl?: StringFilter | string
    fileType?: EnumFileTypeFilter | FileType
    state?: EnumFileStateFilter | FileState
    checksum?: StringFilter | string
    vinPassportId?: StringNullableFilter | string | null
    invoiceId?: StringNullableFilter | string | null
    uploadedById?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    isDeleted?: BoolFilter | boolean
    deletedBy?: StringNullableFilter | string | null
    vinPassport?: XOR<VinPassportRelationFilter, VinPassportWhereInput> | null
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput> | null
    uploadedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    state?: SortOrder
    checksum?: SortOrder
    vinPassportId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    uploadedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedBy?: SortOrderInput | SortOrder
    vinPassport?: VinPassportOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = {
    id?: string
  }

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    state?: SortOrder
    checksum?: SortOrder
    vinPassportId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    uploadedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    fileName?: StringWithAggregatesFilter | string
    fileUrl?: StringWithAggregatesFilter | string
    fileType?: EnumFileTypeWithAggregatesFilter | FileType
    state?: EnumFileStateWithAggregatesFilter | FileState
    checksum?: StringWithAggregatesFilter | string
    vinPassportId?: StringNullableWithAggregatesFilter | string | null
    invoiceId?: StringNullableWithAggregatesFilter | string | null
    uploadedById?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
    deletedBy?: StringNullableWithAggregatesFilter | string | null
  }

  export type MechanicalHealthWhereInput = {
    AND?: Enumerable<MechanicalHealthWhereInput>
    OR?: Enumerable<MechanicalHealthWhereInput>
    NOT?: Enumerable<MechanicalHealthWhereInput>
    id?: StringFilter | string
    vinPassportId?: StringFilter | string
    partsMaintained?: JsonNullableFilter
    lastUpdate?: DateTimeNullableFilter | Date | string | null
    greenLight?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    isDeleted?: BoolFilter | boolean
    vinPassport?: XOR<VinPassportRelationFilter, VinPassportWhereInput>
    auditLogs?: AuditLogListRelationFilter
  }

  export type MechanicalHealthOrderByWithRelationInput = {
    id?: SortOrder
    vinPassportId?: SortOrder
    partsMaintained?: SortOrderInput | SortOrder
    lastUpdate?: SortOrderInput | SortOrder
    greenLight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    vinPassport?: VinPassportOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type MechanicalHealthWhereUniqueInput = {
    id?: string
    vinPassportId?: string
  }

  export type MechanicalHealthOrderByWithAggregationInput = {
    id?: SortOrder
    vinPassportId?: SortOrder
    partsMaintained?: SortOrderInput | SortOrder
    lastUpdate?: SortOrderInput | SortOrder
    greenLight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: MechanicalHealthCountOrderByAggregateInput
    _max?: MechanicalHealthMaxOrderByAggregateInput
    _min?: MechanicalHealthMinOrderByAggregateInput
  }

  export type MechanicalHealthScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MechanicalHealthScalarWhereWithAggregatesInput>
    OR?: Enumerable<MechanicalHealthScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MechanicalHealthScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    vinPassportId?: StringWithAggregatesFilter | string
    partsMaintained?: JsonNullableWithAggregatesFilter
    lastUpdate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    greenLight?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type AuditLogWhereInput = {
    AND?: Enumerable<AuditLogWhereInput>
    OR?: Enumerable<AuditLogWhereInput>
    NOT?: Enumerable<AuditLogWhereInput>
    id?: StringFilter | string
    action?: EnumAuditActionFilter | AuditAction
    entityType?: EnumEntityTypeFilter | EntityType
    entityId?: StringFilter | string
    oldValue?: JsonNullableFilter
    newValue?: JsonNullableFilter
    userId?: StringNullableFilter | string | null
    invoiceId?: StringNullableFilter | string | null
    vinPassportId?: StringNullableFilter | string | null
    chainTxId?: StringNullableFilter | string | null
    documentId?: StringNullableFilter | string | null
    conditionMatrixId?: StringNullableFilter | string | null
    mechanicalHealthId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringNullableFilter | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    updatedBy?: StringNullableFilter | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput> | null
    vinPassport?: XOR<VinPassportRelationFilter, VinPassportWhereInput> | null
    chainTx?: XOR<BlockchainTransactionRelationFilter, BlockchainTransactionWhereInput> | null
    document?: XOR<DocumentRelationFilter, DocumentWhereInput> | null
    conditionMatrix?: XOR<ConditionMatrixRelationFilter, ConditionMatrixWhereInput> | null
    mechanicalHealth?: XOR<MechanicalHealthRelationFilter, MechanicalHealthWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    vinPassportId?: SortOrderInput | SortOrder
    chainTxId?: SortOrderInput | SortOrder
    documentId?: SortOrderInput | SortOrder
    conditionMatrixId?: SortOrderInput | SortOrder
    mechanicalHealthId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    user?: UserOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    vinPassport?: VinPassportOrderByWithRelationInput
    chainTx?: BlockchainTransactionOrderByWithRelationInput
    document?: DocumentOrderByWithRelationInput
    conditionMatrix?: ConditionMatrixOrderByWithRelationInput
    mechanicalHealth?: MechanicalHealthOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = {
    id?: string
  }

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    vinPassportId?: SortOrderInput | SortOrder
    chainTxId?: SortOrderInput | SortOrder
    documentId?: SortOrderInput | SortOrder
    conditionMatrixId?: SortOrderInput | SortOrder
    mechanicalHealthId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AuditLogScalarWhereWithAggregatesInput>
    OR?: Enumerable<AuditLogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AuditLogScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    action?: EnumAuditActionWithAggregatesFilter | AuditAction
    entityType?: EnumEntityTypeWithAggregatesFilter | EntityType
    entityId?: StringWithAggregatesFilter | string
    oldValue?: JsonNullableWithAggregatesFilter
    newValue?: JsonNullableWithAggregatesFilter
    userId?: StringNullableWithAggregatesFilter | string | null
    invoiceId?: StringNullableWithAggregatesFilter | string | null
    vinPassportId?: StringNullableWithAggregatesFilter | string | null
    chainTxId?: StringNullableWithAggregatesFilter | string | null
    documentId?: StringNullableWithAggregatesFilter | string | null
    conditionMatrixId?: StringNullableWithAggregatesFilter | string | null
    mechanicalHealthId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    createdBy?: StringNullableWithAggregatesFilter | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type AlertWhereInput = {
    AND?: Enumerable<AlertWhereInput>
    OR?: Enumerable<AlertWhereInput>
    NOT?: Enumerable<AlertWhereInput>
    id?: StringFilter | string
    userName?: StringFilter | string
    userRole?: EnumUserRoleFilter | UserRole
    action?: EnumAlertActionFilter | AlertAction
    activity?: StringFilter | string
    businessId?: StringNullableFilter | string | null
    isRead?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    userId?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    activity?: SortOrder
    businessId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AlertWhereUniqueInput = {
    id?: string
  }

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    activity?: SortOrder
    businessId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: AlertCountOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AlertScalarWhereWithAggregatesInput>
    OR?: Enumerable<AlertScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AlertScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userName?: StringWithAggregatesFilter | string
    userRole?: EnumUserRoleWithAggregatesFilter | UserRole
    action?: EnumAlertActionWithAggregatesFilter | AlertAction
    activity?: StringWithAggregatesFilter | string
    businessId?: StringNullableWithAggregatesFilter | string | null
    isRead?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
    userId?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    wallet?: AztoWalletCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    aiQuotas?: AIQuotaCreateNestedManyWithoutUserInput
    aiDecisions?: AIDecisionCreateNestedManyWithoutUserInput
    chainTxs?: BlockchainTransactionCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    wallet?: AztoWalletUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    aiQuotas?: AIQuotaUncheckedCreateNestedManyWithoutUserInput
    aiDecisions?: AIDecisionUncheckedCreateNestedManyWithoutUserInput
    chainTxs?: BlockchainTransactionUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    wallet?: AztoWalletUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    aiQuotas?: AIQuotaUpdateManyWithoutUserNestedInput
    aiDecisions?: AIDecisionUpdateManyWithoutUserNestedInput
    chainTxs?: BlockchainTransactionUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    wallet?: AztoWalletUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    aiQuotas?: AIQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiDecisions?: AIDecisionUncheckedUpdateManyWithoutUserNestedInput
    chainTxs?: BlockchainTransactionUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AztoWalletCreateInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    user: UserCreateNestedOneWithoutWalletInput
  }

  export type AztoWalletUncheckedCreateInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    userId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AztoWalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
  }

  export type AztoWalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AztoWalletCreateManyInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    userId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AztoWalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AztoWalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VinPassportCreateInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoices?: InvoiceCreateNestedManyWithoutVinPassportInput
    gasSettlements?: GasSettlementCreateNestedManyWithoutVinPassportInput
    auditLogs?: AuditLogCreateNestedManyWithoutVinPassportInput
    onChainProofs?: OnChainProofCreateNestedManyWithoutVinPassportInput
    documents?: DocumentCreateNestedManyWithoutVinPassportInput
    conditionMatrices?: ConditionMatrixCreateNestedManyWithoutVinPassportInput
    mechanicalHealths?: MechanicalHealthCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportUncheckedCreateInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVinPassportInput
    gasSettlements?: GasSettlementUncheckedCreateNestedManyWithoutVinPassportInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVinPassportInput
    onChainProofs?: OnChainProofUncheckedCreateNestedManyWithoutVinPassportInput
    documents?: DocumentUncheckedCreateNestedManyWithoutVinPassportInput
    conditionMatrices?: ConditionMatrixUncheckedCreateNestedManyWithoutVinPassportInput
    mechanicalHealths?: MechanicalHealthUncheckedCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUpdateManyWithoutVinPassportNestedInput
    gasSettlements?: GasSettlementUpdateManyWithoutVinPassportNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVinPassportNestedInput
    onChainProofs?: OnChainProofUpdateManyWithoutVinPassportNestedInput
    documents?: DocumentUpdateManyWithoutVinPassportNestedInput
    conditionMatrices?: ConditionMatrixUpdateManyWithoutVinPassportNestedInput
    mechanicalHealths?: MechanicalHealthUpdateManyWithoutVinPassportNestedInput
  }

  export type VinPassportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUncheckedUpdateManyWithoutVinPassportNestedInput
    gasSettlements?: GasSettlementUncheckedUpdateManyWithoutVinPassportNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVinPassportNestedInput
    onChainProofs?: OnChainProofUncheckedUpdateManyWithoutVinPassportNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutVinPassportNestedInput
    conditionMatrices?: ConditionMatrixUncheckedUpdateManyWithoutVinPassportNestedInput
    mechanicalHealths?: MechanicalHealthUncheckedUpdateManyWithoutVinPassportNestedInput
  }

  export type VinPassportCreateManyInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type VinPassportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VinPassportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GasSettlementCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    vinPassport: VinPassportCreateNestedOneWithoutGasSettlementsInput
  }

  export type GasSettlementUncheckedCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    vinPassportId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type GasSettlementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    vinPassport?: VinPassportUpdateOneRequiredWithoutGasSettlementsNestedInput
  }

  export type GasSettlementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vinPassportId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GasSettlementCreateManyInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    vinPassportId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type GasSettlementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GasSettlementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vinPassportId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceCreateInput = {
    id?: string
    number: string
    status: TxStatus
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    vinPassport?: VinPassportCreateNestedOneWithoutInvoicesInput
    documents?: DocumentCreateNestedManyWithoutInvoiceInput
    parts?: NormalizedPartCreateNestedManyWithoutInvoiceInput
    auditLogs?: AuditLogCreateNestedManyWithoutInvoiceInput
    onChainProofs?: OnChainProofCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    number: string
    status: TxStatus
    vinPassportId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    documents?: DocumentUncheckedCreateNestedManyWithoutInvoiceInput
    parts?: NormalizedPartUncheckedCreateNestedManyWithoutInvoiceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutInvoiceInput
    onChainProofs?: OnChainProofUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    vinPassport?: VinPassportUpdateOneWithoutInvoicesNestedInput
    documents?: DocumentUpdateManyWithoutInvoiceNestedInput
    parts?: NormalizedPartUpdateManyWithoutInvoiceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutInvoiceNestedInput
    onChainProofs?: OnChainProofUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    documents?: DocumentUncheckedUpdateManyWithoutInvoiceNestedInput
    parts?: NormalizedPartUncheckedUpdateManyWithoutInvoiceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutInvoiceNestedInput
    onChainProofs?: OnChainProofUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    number: string
    status: TxStatus
    vinPassportId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NormalizedPartCreateInput = {
    id?: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoice: InvoiceCreateNestedOneWithoutPartsInput
  }

  export type NormalizedPartUncheckedCreateInput = {
    id?: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    invoiceId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type NormalizedPartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoice?: InvoiceUpdateOneRequiredWithoutPartsNestedInput
  }

  export type NormalizedPartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NormalizedPartCreateManyInput = {
    id?: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    invoiceId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type NormalizedPartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NormalizedPartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AIDecisionCreateInput = {
    id?: string
    entityType: EntityType
    entityId: string
    model: string
    promptHash: string
    responseHash: string
    decision: string
    confidence?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAiDecisionsInput
  }

  export type AIDecisionUncheckedCreateInput = {
    id?: string
    entityType: EntityType
    entityId: string
    model: string
    promptHash: string
    responseHash: string
    decision: string
    confidence?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    createdAt?: Date | string
  }

  export type AIDecisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    promptHash?: StringFieldUpdateOperationsInput | string
    responseHash?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAiDecisionsNestedInput
  }

  export type AIDecisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    promptHash?: StringFieldUpdateOperationsInput | string
    responseHash?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIDecisionCreateManyInput = {
    id?: string
    entityType: EntityType
    entityId: string
    model: string
    promptHash: string
    responseHash: string
    decision: string
    confidence?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    createdAt?: Date | string
  }

  export type AIDecisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    promptHash?: StringFieldUpdateOperationsInput | string
    responseHash?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIDecisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    promptHash?: StringFieldUpdateOperationsInput | string
    responseHash?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIQuotaCreateInput = {
    id?: string
    invoicesProcessed?: number
    rejectedCount?: number
    periodStart: Date | string
    periodEnd: Date | string
    user: UserCreateNestedOneWithoutAiQuotasInput
  }

  export type AIQuotaUncheckedCreateInput = {
    id?: string
    userId: string
    invoicesProcessed?: number
    rejectedCount?: number
    periodStart: Date | string
    periodEnd: Date | string
  }

  export type AIQuotaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicesProcessed?: IntFieldUpdateOperationsInput | number
    rejectedCount?: IntFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiQuotasNestedInput
  }

  export type AIQuotaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invoicesProcessed?: IntFieldUpdateOperationsInput | number
    rejectedCount?: IntFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIQuotaCreateManyInput = {
    id?: string
    userId: string
    invoicesProcessed?: number
    rejectedCount?: number
    periodStart: Date | string
    periodEnd: Date | string
  }

  export type AIQuotaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicesProcessed?: IntFieldUpdateOperationsInput | number
    rejectedCount?: IntFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIQuotaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invoicesProcessed?: IntFieldUpdateOperationsInput | number
    rejectedCount?: IntFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConditionMatrixCreateInput = {
    id?: string
    version: string
    rulesHash: string
    effectiveFrom: Date | string
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    vinPassport?: VinPassportCreateNestedOneWithoutConditionMatricesInput
    auditLogs?: AuditLogCreateNestedManyWithoutConditionMatrixInput
  }

  export type ConditionMatrixUncheckedCreateInput = {
    id?: string
    vinPassportId?: string | null
    version: string
    rulesHash: string
    effectiveFrom: Date | string
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutConditionMatrixInput
  }

  export type ConditionMatrixUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    rulesHash?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassport?: VinPassportUpdateOneWithoutConditionMatricesNestedInput
    auditLogs?: AuditLogUpdateManyWithoutConditionMatrixNestedInput
  }

  export type ConditionMatrixUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    rulesHash?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutConditionMatrixNestedInput
  }

  export type ConditionMatrixCreateManyInput = {
    id?: string
    vinPassportId?: string | null
    version: string
    rulesHash: string
    effectiveFrom: Date | string
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type ConditionMatrixUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    rulesHash?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConditionMatrixUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    rulesHash?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemStateCreateInput = {
    id?: string
    key: string
    value: string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SystemStateUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SystemStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemStateCreateManyInput = {
    id?: string
    key: string
    value: string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SystemStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlockchainTransactionCreateInput = {
    id?: string
    chain: string
    contract: string
    txHash: string
    blockNumber?: bigint | number | null
    eventName?: string | null
    status: TxStatus
    entityType: EntityType
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    confirmations?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutChainTxsInput
    auditLogs?: AuditLogCreateNestedManyWithoutChainTxInput
  }

  export type BlockchainTransactionUncheckedCreateInput = {
    id?: string
    chain: string
    contract: string
    txHash: string
    blockNumber?: bigint | number | null
    eventName?: string | null
    status: TxStatus
    entityType: EntityType
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    confirmations?: number
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChainTxInput
  }

  export type BlockchainTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    confirmations?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutChainTxsNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChainTxNestedInput
  }

  export type BlockchainTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    confirmations?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChainTxNestedInput
  }

  export type BlockchainTransactionCreateManyInput = {
    id?: string
    chain: string
    contract: string
    txHash: string
    blockNumber?: bigint | number | null
    eventName?: string | null
    status: TxStatus
    entityType: EntityType
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    confirmations?: number
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockchainTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    confirmations?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockchainTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    confirmations?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnChainProofCreateInput = {
    id?: string
    entityType: EntityType
    entityId: string
    hash: string
    algorithm: string
    chain: string
    contract: string
    txHash: string
    createdAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutOnChainProofsInput
    vinPassport?: VinPassportCreateNestedOneWithoutOnChainProofsInput
  }

  export type OnChainProofUncheckedCreateInput = {
    id?: string
    entityType: EntityType
    entityId: string
    hash: string
    algorithm: string
    chain: string
    contract: string
    txHash: string
    invoiceId?: string | null
    vinPassportId?: string | null
    createdAt?: Date | string
  }

  export type OnChainProofUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    algorithm?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutOnChainProofsNestedInput
    vinPassport?: VinPassportUpdateOneWithoutOnChainProofsNestedInput
  }

  export type OnChainProofUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    algorithm?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnChainProofCreateManyInput = {
    id?: string
    entityType: EntityType
    entityId: string
    hash: string
    algorithm: string
    chain: string
    contract: string
    txHash: string
    invoiceId?: string | null
    vinPassportId?: string | null
    createdAt?: Date | string
  }

  export type OnChainProofUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    algorithm?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnChainProofUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    algorithm?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChainCursorCreateInput = {
    id?: string
    chain: string
    contract: string
    lastBlock: bigint | number
    updatedAt?: Date | string
  }

  export type ChainCursorUncheckedCreateInput = {
    id?: string
    chain: string
    contract: string
    lastBlock: bigint | number
    updatedAt?: Date | string
  }

  export type ChainCursorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    lastBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChainCursorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    lastBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChainCursorCreateManyInput = {
    id?: string
    chain: string
    contract: string
    lastBlock: bigint | number
    updatedAt?: Date | string
  }

  export type ChainCursorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    lastBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChainCursorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    lastBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state?: FileState
    checksum: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    deletedBy?: string | null
    vinPassport?: VinPassportCreateNestedOneWithoutDocumentsInput
    invoice?: InvoiceCreateNestedOneWithoutDocumentsInput
    uploadedBy?: UserCreateNestedOneWithoutDocumentsInput
    auditLogs?: AuditLogCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state?: FileState
    checksum: string
    vinPassportId?: string | null
    invoiceId?: string | null
    uploadedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    deletedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | FileType
    state?: EnumFileStateFieldUpdateOperationsInput | FileState
    checksum?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassport?: VinPassportUpdateOneWithoutDocumentsNestedInput
    invoice?: InvoiceUpdateOneWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneWithoutDocumentsNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | FileType
    state?: EnumFileStateFieldUpdateOperationsInput | FileState
    checksum?: StringFieldUpdateOperationsInput | string
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state?: FileState
    checksum: string
    vinPassportId?: string | null
    invoiceId?: string | null
    uploadedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    deletedBy?: string | null
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | FileType
    state?: EnumFileStateFieldUpdateOperationsInput | FileState
    checksum?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | FileType
    state?: EnumFileStateFieldUpdateOperationsInput | FileState
    checksum?: StringFieldUpdateOperationsInput | string
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MechanicalHealthCreateInput = {
    id?: string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: Date | string | null
    greenLight?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    vinPassport: VinPassportCreateNestedOneWithoutMechanicalHealthsInput
    auditLogs?: AuditLogCreateNestedManyWithoutMechanicalHealthInput
  }

  export type MechanicalHealthUncheckedCreateInput = {
    id?: string
    vinPassportId: string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: Date | string | null
    greenLight?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutMechanicalHealthInput
  }

  export type MechanicalHealthUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    greenLight?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    vinPassport?: VinPassportUpdateOneRequiredWithoutMechanicalHealthsNestedInput
    auditLogs?: AuditLogUpdateManyWithoutMechanicalHealthNestedInput
  }

  export type MechanicalHealthUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vinPassportId?: StringFieldUpdateOperationsInput | string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    greenLight?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    auditLogs?: AuditLogUncheckedUpdateManyWithoutMechanicalHealthNestedInput
  }

  export type MechanicalHealthCreateManyInput = {
    id?: string
    vinPassportId: string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: Date | string | null
    greenLight?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type MechanicalHealthUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    greenLight?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MechanicalHealthUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vinPassportId?: StringFieldUpdateOperationsInput | string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    greenLight?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogCreateInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    user?: UserCreateNestedOneWithoutAuditLogsInput
    invoice?: InvoiceCreateNestedOneWithoutAuditLogsInput
    vinPassport?: VinPassportCreateNestedOneWithoutAuditLogsInput
    chainTx?: BlockchainTransactionCreateNestedOneWithoutAuditLogsInput
    document?: DocumentCreateNestedOneWithoutAuditLogsInput
    conditionMatrix?: ConditionMatrixCreateNestedOneWithoutAuditLogsInput
    mechanicalHealth?: MechanicalHealthCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    invoiceId?: string | null
    vinPassportId?: string | null
    chainTxId?: string | null
    documentId?: string | null
    conditionMatrixId?: string | null
    mechanicalHealthId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAuditLogsNestedInput
    invoice?: InvoiceUpdateOneWithoutAuditLogsNestedInput
    vinPassport?: VinPassportUpdateOneWithoutAuditLogsNestedInput
    chainTx?: BlockchainTransactionUpdateOneWithoutAuditLogsNestedInput
    document?: DocumentUpdateOneWithoutAuditLogsNestedInput
    conditionMatrix?: ConditionMatrixUpdateOneWithoutAuditLogsNestedInput
    mechanicalHealth?: MechanicalHealthUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    chainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionMatrixId?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalHealthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    invoiceId?: string | null
    vinPassportId?: string | null
    chainTxId?: string | null
    documentId?: string | null
    conditionMatrixId?: string | null
    mechanicalHealthId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    chainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionMatrixId?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalHealthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlertCreateInput = {
    id?: string
    userName: string
    userRole: UserRole
    action: AlertAction
    activity: string
    businessId?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    user?: UserCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    userName: string
    userRole: UserRole
    action: AlertAction
    activity: string
    businessId?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    userId?: string | null
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userRole?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    action?: EnumAlertActionFieldUpdateOperationsInput | AlertAction
    activity?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userRole?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    action?: EnumAlertActionFieldUpdateOperationsInput | AlertAction
    activity?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertCreateManyInput = {
    id?: string
    userName: string
    userRole: UserRole
    action: AlertAction
    activity: string
    businessId?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    userId?: string | null
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userRole?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    action?: EnumAlertActionFieldUpdateOperationsInput | AlertAction
    activity?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userRole?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    action?: EnumAlertActionFieldUpdateOperationsInput | AlertAction
    activity?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type EnumUserRoleFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleFilter | UserRole
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type AztoWalletRelationFilter = {
    is?: AztoWalletWhereInput | null
    isNot?: AztoWalletWhereInput | null
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type AIQuotaListRelationFilter = {
    every?: AIQuotaWhereInput
    some?: AIQuotaWhereInput
    none?: AIQuotaWhereInput
  }

  export type AIDecisionListRelationFilter = {
    every?: AIDecisionWhereInput
    some?: AIDecisionWhereInput
    none?: AIDecisionWhereInput
  }

  export type BlockchainTransactionListRelationFilter = {
    every?: BlockchainTransactionWhereInput
    some?: BlockchainTransactionWhereInput
    none?: BlockchainTransactionWhereInput
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIQuotaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIDecisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockchainTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    walletAddress?: SortOrder
    signature?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    walletAddress?: SortOrder
    signature?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    walletAddress?: SortOrder
    signature?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumUserRoleWithAggregatesFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleWithAggregatesFilter | UserRole
    _count?: NestedIntFilter
    _min?: NestedEnumUserRoleFilter
    _max?: NestedEnumUserRoleFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AztoWalletCountOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type AztoWalletAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type AztoWalletMaxOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type AztoWalletMinOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type AztoWalletSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type GasSettlementListRelationFilter = {
    every?: GasSettlementWhereInput
    some?: GasSettlementWhereInput
    none?: GasSettlementWhereInput
  }

  export type OnChainProofListRelationFilter = {
    every?: OnChainProofWhereInput
    some?: OnChainProofWhereInput
    none?: OnChainProofWhereInput
  }

  export type ConditionMatrixListRelationFilter = {
    every?: ConditionMatrixWhereInput
    some?: ConditionMatrixWhereInput
    none?: ConditionMatrixWhereInput
  }

  export type MechanicalHealthListRelationFilter = {
    every?: MechanicalHealthWhereInput
    some?: MechanicalHealthWhereInput
    none?: MechanicalHealthWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GasSettlementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OnChainProofOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConditionMatrixOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MechanicalHealthOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VinPassportCountOrderByAggregateInput = {
    id?: SortOrder
    vin?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type VinPassportMaxOrderByAggregateInput = {
    id?: SortOrder
    vin?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type VinPassportMinOrderByAggregateInput = {
    id?: SortOrder
    vin?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type VinPassportRelationFilter = {
    is?: VinPassportWhereInput | null
    isNot?: VinPassportWhereInput | null
  }

  export type GasSettlementCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    vinPassportId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type GasSettlementAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type GasSettlementMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    vinPassportId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type GasSettlementMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    vinPassportId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type GasSettlementSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTxStatusFilter = {
    equals?: TxStatus
    in?: Enumerable<TxStatus>
    notIn?: Enumerable<TxStatus>
    not?: NestedEnumTxStatusFilter | TxStatus
  }

  export type NormalizedPartListRelationFilter = {
    every?: NormalizedPartWhereInput
    some?: NormalizedPartWhereInput
    none?: NormalizedPartWhereInput
  }

  export type NormalizedPartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    status?: SortOrder
    vinPassportId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    status?: SortOrder
    vinPassportId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    status?: SortOrder
    vinPassportId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type EnumTxStatusWithAggregatesFilter = {
    equals?: TxStatus
    in?: Enumerable<TxStatus>
    notIn?: Enumerable<TxStatus>
    not?: NestedEnumTxStatusWithAggregatesFilter | TxStatus
    _count?: NestedIntFilter
    _min?: NestedEnumTxStatusFilter
    _max?: NestedEnumTxStatusFilter
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type NormalizedPartCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    invoiceId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type NormalizedPartAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type NormalizedPartMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    invoiceId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type NormalizedPartMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    invoiceId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type NormalizedPartSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumEntityTypeFilter = {
    equals?: EntityType
    in?: Enumerable<EntityType>
    notIn?: Enumerable<EntityType>
    not?: NestedEnumEntityTypeFilter | EntityType
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type AIDecisionCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    model?: SortOrder
    promptHash?: SortOrder
    responseHash?: SortOrder
    decision?: SortOrder
    confidence?: SortOrder
    metadata?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type AIDecisionAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type AIDecisionMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    model?: SortOrder
    promptHash?: SortOrder
    responseHash?: SortOrder
    decision?: SortOrder
    confidence?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type AIDecisionMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    model?: SortOrder
    promptHash?: SortOrder
    responseHash?: SortOrder
    decision?: SortOrder
    confidence?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type AIDecisionSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type EnumEntityTypeWithAggregatesFilter = {
    equals?: EntityType
    in?: Enumerable<EntityType>
    notIn?: Enumerable<EntityType>
    not?: NestedEnumEntityTypeWithAggregatesFilter | EntityType
    _count?: NestedIntFilter
    _min?: NestedEnumEntityTypeFilter
    _max?: NestedEnumEntityTypeFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type AIQuotaCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    invoicesProcessed?: SortOrder
    rejectedCount?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
  }

  export type AIQuotaAvgOrderByAggregateInput = {
    invoicesProcessed?: SortOrder
    rejectedCount?: SortOrder
  }

  export type AIQuotaMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    invoicesProcessed?: SortOrder
    rejectedCount?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
  }

  export type AIQuotaMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    invoicesProcessed?: SortOrder
    rejectedCount?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
  }

  export type AIQuotaSumOrderByAggregateInput = {
    invoicesProcessed?: SortOrder
    rejectedCount?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type ConditionMatrixCountOrderByAggregateInput = {
    id?: SortOrder
    vinPassportId?: SortOrder
    version?: SortOrder
    rulesHash?: SortOrder
    effectiveFrom?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ConditionMatrixMaxOrderByAggregateInput = {
    id?: SortOrder
    vinPassportId?: SortOrder
    version?: SortOrder
    rulesHash?: SortOrder
    effectiveFrom?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ConditionMatrixMinOrderByAggregateInput = {
    id?: SortOrder
    vinPassportId?: SortOrder
    version?: SortOrder
    rulesHash?: SortOrder
    effectiveFrom?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemStateCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemStateMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemStateMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type BigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number | null
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type BlockchainTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    eventName?: SortOrder
    status?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    payload?: SortOrder
    confirmations?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockchainTransactionAvgOrderByAggregateInput = {
    blockNumber?: SortOrder
    confirmations?: SortOrder
  }

  export type BlockchainTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    eventName?: SortOrder
    status?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    confirmations?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockchainTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    eventName?: SortOrder
    status?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    confirmations?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockchainTransactionSumOrderByAggregateInput = {
    blockNumber?: SortOrder
    confirmations?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number | null
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type OnChainProofCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    hash?: SortOrder
    algorithm?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    txHash?: SortOrder
    invoiceId?: SortOrder
    vinPassportId?: SortOrder
    createdAt?: SortOrder
  }

  export type OnChainProofMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    hash?: SortOrder
    algorithm?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    txHash?: SortOrder
    invoiceId?: SortOrder
    vinPassportId?: SortOrder
    createdAt?: SortOrder
  }

  export type OnChainProofMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    hash?: SortOrder
    algorithm?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    txHash?: SortOrder
    invoiceId?: SortOrder
    vinPassportId?: SortOrder
    createdAt?: SortOrder
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type ChainCursorCountOrderByAggregateInput = {
    id?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    lastBlock?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChainCursorAvgOrderByAggregateInput = {
    lastBlock?: SortOrder
  }

  export type ChainCursorMaxOrderByAggregateInput = {
    id?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    lastBlock?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChainCursorMinOrderByAggregateInput = {
    id?: SortOrder
    chain?: SortOrder
    contract?: SortOrder
    lastBlock?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChainCursorSumOrderByAggregateInput = {
    lastBlock?: SortOrder
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type EnumFileTypeFilter = {
    equals?: FileType
    in?: Enumerable<FileType>
    notIn?: Enumerable<FileType>
    not?: NestedEnumFileTypeFilter | FileType
  }

  export type EnumFileStateFilter = {
    equals?: FileState
    in?: Enumerable<FileState>
    notIn?: Enumerable<FileState>
    not?: NestedEnumFileStateFilter | FileState
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    state?: SortOrder
    checksum?: SortOrder
    vinPassportId?: SortOrder
    invoiceId?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
    deletedBy?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    state?: SortOrder
    checksum?: SortOrder
    vinPassportId?: SortOrder
    invoiceId?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
    deletedBy?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    state?: SortOrder
    checksum?: SortOrder
    vinPassportId?: SortOrder
    invoiceId?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
    deletedBy?: SortOrder
  }

  export type EnumFileTypeWithAggregatesFilter = {
    equals?: FileType
    in?: Enumerable<FileType>
    notIn?: Enumerable<FileType>
    not?: NestedEnumFileTypeWithAggregatesFilter | FileType
    _count?: NestedIntFilter
    _min?: NestedEnumFileTypeFilter
    _max?: NestedEnumFileTypeFilter
  }

  export type EnumFileStateWithAggregatesFilter = {
    equals?: FileState
    in?: Enumerable<FileState>
    notIn?: Enumerable<FileState>
    not?: NestedEnumFileStateWithAggregatesFilter | FileState
    _count?: NestedIntFilter
    _min?: NestedEnumFileStateFilter
    _max?: NestedEnumFileStateFilter
  }

  export type MechanicalHealthCountOrderByAggregateInput = {
    id?: SortOrder
    vinPassportId?: SortOrder
    partsMaintained?: SortOrder
    lastUpdate?: SortOrder
    greenLight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type MechanicalHealthMaxOrderByAggregateInput = {
    id?: SortOrder
    vinPassportId?: SortOrder
    lastUpdate?: SortOrder
    greenLight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type MechanicalHealthMinOrderByAggregateInput = {
    id?: SortOrder
    vinPassportId?: SortOrder
    lastUpdate?: SortOrder
    greenLight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type EnumAuditActionFilter = {
    equals?: AuditAction
    in?: Enumerable<AuditAction>
    notIn?: Enumerable<AuditAction>
    not?: NestedEnumAuditActionFilter | AuditAction
  }

  export type BlockchainTransactionRelationFilter = {
    is?: BlockchainTransactionWhereInput | null
    isNot?: BlockchainTransactionWhereInput | null
  }

  export type DocumentRelationFilter = {
    is?: DocumentWhereInput | null
    isNot?: DocumentWhereInput | null
  }

  export type ConditionMatrixRelationFilter = {
    is?: ConditionMatrixWhereInput | null
    isNot?: ConditionMatrixWhereInput | null
  }

  export type MechanicalHealthRelationFilter = {
    is?: MechanicalHealthWhereInput | null
    isNot?: MechanicalHealthWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    userId?: SortOrder
    invoiceId?: SortOrder
    vinPassportId?: SortOrder
    chainTxId?: SortOrder
    documentId?: SortOrder
    conditionMatrixId?: SortOrder
    mechanicalHealthId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    invoiceId?: SortOrder
    vinPassportId?: SortOrder
    chainTxId?: SortOrder
    documentId?: SortOrder
    conditionMatrixId?: SortOrder
    mechanicalHealthId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    invoiceId?: SortOrder
    vinPassportId?: SortOrder
    chainTxId?: SortOrder
    documentId?: SortOrder
    conditionMatrixId?: SortOrder
    mechanicalHealthId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter = {
    equals?: AuditAction
    in?: Enumerable<AuditAction>
    notIn?: Enumerable<AuditAction>
    not?: NestedEnumAuditActionWithAggregatesFilter | AuditAction
    _count?: NestedIntFilter
    _min?: NestedEnumAuditActionFilter
    _max?: NestedEnumAuditActionFilter
  }

  export type EnumAlertActionFilter = {
    equals?: AlertAction
    in?: Enumerable<AlertAction>
    notIn?: Enumerable<AlertAction>
    not?: NestedEnumAlertActionFilter | AlertAction
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    activity?: SortOrder
    businessId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    activity?: SortOrder
    businessId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    activity?: SortOrder
    businessId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
  }

  export type EnumAlertActionWithAggregatesFilter = {
    equals?: AlertAction
    in?: Enumerable<AlertAction>
    notIn?: Enumerable<AlertAction>
    not?: NestedEnumAlertActionWithAggregatesFilter | AlertAction
    _count?: NestedIntFilter
    _min?: NestedEnumAlertActionFilter
    _max?: NestedEnumAlertActionFilter
  }

  export type AztoWalletCreateNestedOneWithoutUserInput = {
    create?: XOR<AztoWalletCreateWithoutUserInput, AztoWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: AztoWalletCreateOrConnectWithoutUserInput
    connect?: AztoWalletWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutUserInput>, Enumerable<AuditLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutUserInput>
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type AIQuotaCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AIQuotaCreateWithoutUserInput>, Enumerable<AIQuotaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AIQuotaCreateOrConnectWithoutUserInput>
    createMany?: AIQuotaCreateManyUserInputEnvelope
    connect?: Enumerable<AIQuotaWhereUniqueInput>
  }

  export type AIDecisionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AIDecisionCreateWithoutUserInput>, Enumerable<AIDecisionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AIDecisionCreateOrConnectWithoutUserInput>
    createMany?: AIDecisionCreateManyUserInputEnvelope
    connect?: Enumerable<AIDecisionWhereUniqueInput>
  }

  export type BlockchainTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BlockchainTransactionCreateWithoutUserInput>, Enumerable<BlockchainTransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BlockchainTransactionCreateOrConnectWithoutUserInput>
    createMany?: BlockchainTransactionCreateManyUserInputEnvelope
    connect?: Enumerable<BlockchainTransactionWhereUniqueInput>
  }

  export type AlertCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AlertCreateWithoutUserInput>, Enumerable<AlertUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutUserInput>
    createMany?: AlertCreateManyUserInputEnvelope
    connect?: Enumerable<AlertWhereUniqueInput>
  }

  export type DocumentCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutUploadedByInput>, Enumerable<DocumentUncheckedCreateWithoutUploadedByInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutUploadedByInput>
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type AztoWalletUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AztoWalletCreateWithoutUserInput, AztoWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: AztoWalletCreateOrConnectWithoutUserInput
    connect?: AztoWalletWhereUniqueInput
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutUserInput>, Enumerable<AuditLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutUserInput>
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type AIQuotaUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AIQuotaCreateWithoutUserInput>, Enumerable<AIQuotaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AIQuotaCreateOrConnectWithoutUserInput>
    createMany?: AIQuotaCreateManyUserInputEnvelope
    connect?: Enumerable<AIQuotaWhereUniqueInput>
  }

  export type AIDecisionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AIDecisionCreateWithoutUserInput>, Enumerable<AIDecisionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AIDecisionCreateOrConnectWithoutUserInput>
    createMany?: AIDecisionCreateManyUserInputEnvelope
    connect?: Enumerable<AIDecisionWhereUniqueInput>
  }

  export type BlockchainTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BlockchainTransactionCreateWithoutUserInput>, Enumerable<BlockchainTransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BlockchainTransactionCreateOrConnectWithoutUserInput>
    createMany?: BlockchainTransactionCreateManyUserInputEnvelope
    connect?: Enumerable<BlockchainTransactionWhereUniqueInput>
  }

  export type AlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AlertCreateWithoutUserInput>, Enumerable<AlertUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutUserInput>
    createMany?: AlertCreateManyUserInputEnvelope
    connect?: Enumerable<AlertWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutUploadedByInput>, Enumerable<DocumentUncheckedCreateWithoutUploadedByInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutUploadedByInput>
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AztoWalletUpdateOneWithoutUserNestedInput = {
    create?: XOR<AztoWalletCreateWithoutUserInput, AztoWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: AztoWalletCreateOrConnectWithoutUserInput
    upsert?: AztoWalletUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: AztoWalletWhereUniqueInput
    update?: XOR<AztoWalletUpdateWithoutUserInput, AztoWalletUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutUserInput>, Enumerable<AuditLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type AIQuotaUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AIQuotaCreateWithoutUserInput>, Enumerable<AIQuotaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AIQuotaCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AIQuotaUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AIQuotaCreateManyUserInputEnvelope
    set?: Enumerable<AIQuotaWhereUniqueInput>
    disconnect?: Enumerable<AIQuotaWhereUniqueInput>
    delete?: Enumerable<AIQuotaWhereUniqueInput>
    connect?: Enumerable<AIQuotaWhereUniqueInput>
    update?: Enumerable<AIQuotaUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AIQuotaUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AIQuotaScalarWhereInput>
  }

  export type AIDecisionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AIDecisionCreateWithoutUserInput>, Enumerable<AIDecisionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AIDecisionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AIDecisionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AIDecisionCreateManyUserInputEnvelope
    set?: Enumerable<AIDecisionWhereUniqueInput>
    disconnect?: Enumerable<AIDecisionWhereUniqueInput>
    delete?: Enumerable<AIDecisionWhereUniqueInput>
    connect?: Enumerable<AIDecisionWhereUniqueInput>
    update?: Enumerable<AIDecisionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AIDecisionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AIDecisionScalarWhereInput>
  }

  export type BlockchainTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BlockchainTransactionCreateWithoutUserInput>, Enumerable<BlockchainTransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BlockchainTransactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BlockchainTransactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BlockchainTransactionCreateManyUserInputEnvelope
    set?: Enumerable<BlockchainTransactionWhereUniqueInput>
    disconnect?: Enumerable<BlockchainTransactionWhereUniqueInput>
    delete?: Enumerable<BlockchainTransactionWhereUniqueInput>
    connect?: Enumerable<BlockchainTransactionWhereUniqueInput>
    update?: Enumerable<BlockchainTransactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BlockchainTransactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BlockchainTransactionScalarWhereInput>
  }

  export type AlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AlertCreateWithoutUserInput>, Enumerable<AlertUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AlertUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AlertCreateManyUserInputEnvelope
    set?: Enumerable<AlertWhereUniqueInput>
    disconnect?: Enumerable<AlertWhereUniqueInput>
    delete?: Enumerable<AlertWhereUniqueInput>
    connect?: Enumerable<AlertWhereUniqueInput>
    update?: Enumerable<AlertUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AlertUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AlertScalarWhereInput>
  }

  export type DocumentUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutUploadedByInput>, Enumerable<DocumentUncheckedCreateWithoutUploadedByInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutUploadedByInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutUploadedByInput>
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutUploadedByInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutUploadedByInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type AztoWalletUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AztoWalletCreateWithoutUserInput, AztoWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: AztoWalletCreateOrConnectWithoutUserInput
    upsert?: AztoWalletUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: AztoWalletWhereUniqueInput
    update?: XOR<AztoWalletUpdateWithoutUserInput, AztoWalletUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutUserInput>, Enumerable<AuditLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type AIQuotaUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AIQuotaCreateWithoutUserInput>, Enumerable<AIQuotaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AIQuotaCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AIQuotaUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AIQuotaCreateManyUserInputEnvelope
    set?: Enumerable<AIQuotaWhereUniqueInput>
    disconnect?: Enumerable<AIQuotaWhereUniqueInput>
    delete?: Enumerable<AIQuotaWhereUniqueInput>
    connect?: Enumerable<AIQuotaWhereUniqueInput>
    update?: Enumerable<AIQuotaUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AIQuotaUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AIQuotaScalarWhereInput>
  }

  export type AIDecisionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AIDecisionCreateWithoutUserInput>, Enumerable<AIDecisionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AIDecisionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AIDecisionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AIDecisionCreateManyUserInputEnvelope
    set?: Enumerable<AIDecisionWhereUniqueInput>
    disconnect?: Enumerable<AIDecisionWhereUniqueInput>
    delete?: Enumerable<AIDecisionWhereUniqueInput>
    connect?: Enumerable<AIDecisionWhereUniqueInput>
    update?: Enumerable<AIDecisionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AIDecisionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AIDecisionScalarWhereInput>
  }

  export type BlockchainTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BlockchainTransactionCreateWithoutUserInput>, Enumerable<BlockchainTransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BlockchainTransactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BlockchainTransactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BlockchainTransactionCreateManyUserInputEnvelope
    set?: Enumerable<BlockchainTransactionWhereUniqueInput>
    disconnect?: Enumerable<BlockchainTransactionWhereUniqueInput>
    delete?: Enumerable<BlockchainTransactionWhereUniqueInput>
    connect?: Enumerable<BlockchainTransactionWhereUniqueInput>
    update?: Enumerable<BlockchainTransactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BlockchainTransactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BlockchainTransactionScalarWhereInput>
  }

  export type AlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AlertCreateWithoutUserInput>, Enumerable<AlertUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AlertUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AlertCreateManyUserInputEnvelope
    set?: Enumerable<AlertWhereUniqueInput>
    disconnect?: Enumerable<AlertWhereUniqueInput>
    delete?: Enumerable<AlertWhereUniqueInput>
    connect?: Enumerable<AlertWhereUniqueInput>
    update?: Enumerable<AlertUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AlertUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AlertScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutUploadedByInput>, Enumerable<DocumentUncheckedCreateWithoutUploadedByInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutUploadedByInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutUploadedByInput>
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutUploadedByInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutUploadedByInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutWalletInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    connect?: UserWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    upsert?: UserUpsertWithoutWalletInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
  }

  export type InvoiceCreateNestedManyWithoutVinPassportInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutVinPassportInput>, Enumerable<InvoiceUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutVinPassportInput>
    createMany?: InvoiceCreateManyVinPassportInputEnvelope
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type GasSettlementCreateNestedManyWithoutVinPassportInput = {
    create?: XOR<Enumerable<GasSettlementCreateWithoutVinPassportInput>, Enumerable<GasSettlementUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<GasSettlementCreateOrConnectWithoutVinPassportInput>
    createMany?: GasSettlementCreateManyVinPassportInputEnvelope
    connect?: Enumerable<GasSettlementWhereUniqueInput>
  }

  export type AuditLogCreateNestedManyWithoutVinPassportInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutVinPassportInput>, Enumerable<AuditLogUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutVinPassportInput>
    createMany?: AuditLogCreateManyVinPassportInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type OnChainProofCreateNestedManyWithoutVinPassportInput = {
    create?: XOR<Enumerable<OnChainProofCreateWithoutVinPassportInput>, Enumerable<OnChainProofUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<OnChainProofCreateOrConnectWithoutVinPassportInput>
    createMany?: OnChainProofCreateManyVinPassportInputEnvelope
    connect?: Enumerable<OnChainProofWhereUniqueInput>
  }

  export type DocumentCreateNestedManyWithoutVinPassportInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutVinPassportInput>, Enumerable<DocumentUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutVinPassportInput>
    createMany?: DocumentCreateManyVinPassportInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type ConditionMatrixCreateNestedManyWithoutVinPassportInput = {
    create?: XOR<Enumerable<ConditionMatrixCreateWithoutVinPassportInput>, Enumerable<ConditionMatrixUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<ConditionMatrixCreateOrConnectWithoutVinPassportInput>
    createMany?: ConditionMatrixCreateManyVinPassportInputEnvelope
    connect?: Enumerable<ConditionMatrixWhereUniqueInput>
  }

  export type MechanicalHealthCreateNestedManyWithoutVinPassportInput = {
    create?: XOR<Enumerable<MechanicalHealthCreateWithoutVinPassportInput>, Enumerable<MechanicalHealthUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<MechanicalHealthCreateOrConnectWithoutVinPassportInput>
    createMany?: MechanicalHealthCreateManyVinPassportInputEnvelope
    connect?: Enumerable<MechanicalHealthWhereUniqueInput>
  }

  export type InvoiceUncheckedCreateNestedManyWithoutVinPassportInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutVinPassportInput>, Enumerable<InvoiceUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutVinPassportInput>
    createMany?: InvoiceCreateManyVinPassportInputEnvelope
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type GasSettlementUncheckedCreateNestedManyWithoutVinPassportInput = {
    create?: XOR<Enumerable<GasSettlementCreateWithoutVinPassportInput>, Enumerable<GasSettlementUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<GasSettlementCreateOrConnectWithoutVinPassportInput>
    createMany?: GasSettlementCreateManyVinPassportInputEnvelope
    connect?: Enumerable<GasSettlementWhereUniqueInput>
  }

  export type AuditLogUncheckedCreateNestedManyWithoutVinPassportInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutVinPassportInput>, Enumerable<AuditLogUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutVinPassportInput>
    createMany?: AuditLogCreateManyVinPassportInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type OnChainProofUncheckedCreateNestedManyWithoutVinPassportInput = {
    create?: XOR<Enumerable<OnChainProofCreateWithoutVinPassportInput>, Enumerable<OnChainProofUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<OnChainProofCreateOrConnectWithoutVinPassportInput>
    createMany?: OnChainProofCreateManyVinPassportInputEnvelope
    connect?: Enumerable<OnChainProofWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutVinPassportInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutVinPassportInput>, Enumerable<DocumentUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutVinPassportInput>
    createMany?: DocumentCreateManyVinPassportInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type ConditionMatrixUncheckedCreateNestedManyWithoutVinPassportInput = {
    create?: XOR<Enumerable<ConditionMatrixCreateWithoutVinPassportInput>, Enumerable<ConditionMatrixUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<ConditionMatrixCreateOrConnectWithoutVinPassportInput>
    createMany?: ConditionMatrixCreateManyVinPassportInputEnvelope
    connect?: Enumerable<ConditionMatrixWhereUniqueInput>
  }

  export type MechanicalHealthUncheckedCreateNestedManyWithoutVinPassportInput = {
    create?: XOR<Enumerable<MechanicalHealthCreateWithoutVinPassportInput>, Enumerable<MechanicalHealthUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<MechanicalHealthCreateOrConnectWithoutVinPassportInput>
    createMany?: MechanicalHealthCreateManyVinPassportInputEnvelope
    connect?: Enumerable<MechanicalHealthWhereUniqueInput>
  }

  export type InvoiceUpdateManyWithoutVinPassportNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutVinPassportInput>, Enumerable<InvoiceUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutVinPassportInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutVinPassportInput>
    createMany?: InvoiceCreateManyVinPassportInputEnvelope
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutVinPassportInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutVinPassportInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type GasSettlementUpdateManyWithoutVinPassportNestedInput = {
    create?: XOR<Enumerable<GasSettlementCreateWithoutVinPassportInput>, Enumerable<GasSettlementUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<GasSettlementCreateOrConnectWithoutVinPassportInput>
    upsert?: Enumerable<GasSettlementUpsertWithWhereUniqueWithoutVinPassportInput>
    createMany?: GasSettlementCreateManyVinPassportInputEnvelope
    set?: Enumerable<GasSettlementWhereUniqueInput>
    disconnect?: Enumerable<GasSettlementWhereUniqueInput>
    delete?: Enumerable<GasSettlementWhereUniqueInput>
    connect?: Enumerable<GasSettlementWhereUniqueInput>
    update?: Enumerable<GasSettlementUpdateWithWhereUniqueWithoutVinPassportInput>
    updateMany?: Enumerable<GasSettlementUpdateManyWithWhereWithoutVinPassportInput>
    deleteMany?: Enumerable<GasSettlementScalarWhereInput>
  }

  export type AuditLogUpdateManyWithoutVinPassportNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutVinPassportInput>, Enumerable<AuditLogUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutVinPassportInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutVinPassportInput>
    createMany?: AuditLogCreateManyVinPassportInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutVinPassportInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutVinPassportInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type OnChainProofUpdateManyWithoutVinPassportNestedInput = {
    create?: XOR<Enumerable<OnChainProofCreateWithoutVinPassportInput>, Enumerable<OnChainProofUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<OnChainProofCreateOrConnectWithoutVinPassportInput>
    upsert?: Enumerable<OnChainProofUpsertWithWhereUniqueWithoutVinPassportInput>
    createMany?: OnChainProofCreateManyVinPassportInputEnvelope
    set?: Enumerable<OnChainProofWhereUniqueInput>
    disconnect?: Enumerable<OnChainProofWhereUniqueInput>
    delete?: Enumerable<OnChainProofWhereUniqueInput>
    connect?: Enumerable<OnChainProofWhereUniqueInput>
    update?: Enumerable<OnChainProofUpdateWithWhereUniqueWithoutVinPassportInput>
    updateMany?: Enumerable<OnChainProofUpdateManyWithWhereWithoutVinPassportInput>
    deleteMany?: Enumerable<OnChainProofScalarWhereInput>
  }

  export type DocumentUpdateManyWithoutVinPassportNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutVinPassportInput>, Enumerable<DocumentUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutVinPassportInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutVinPassportInput>
    createMany?: DocumentCreateManyVinPassportInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutVinPassportInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutVinPassportInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type ConditionMatrixUpdateManyWithoutVinPassportNestedInput = {
    create?: XOR<Enumerable<ConditionMatrixCreateWithoutVinPassportInput>, Enumerable<ConditionMatrixUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<ConditionMatrixCreateOrConnectWithoutVinPassportInput>
    upsert?: Enumerable<ConditionMatrixUpsertWithWhereUniqueWithoutVinPassportInput>
    createMany?: ConditionMatrixCreateManyVinPassportInputEnvelope
    set?: Enumerable<ConditionMatrixWhereUniqueInput>
    disconnect?: Enumerable<ConditionMatrixWhereUniqueInput>
    delete?: Enumerable<ConditionMatrixWhereUniqueInput>
    connect?: Enumerable<ConditionMatrixWhereUniqueInput>
    update?: Enumerable<ConditionMatrixUpdateWithWhereUniqueWithoutVinPassportInput>
    updateMany?: Enumerable<ConditionMatrixUpdateManyWithWhereWithoutVinPassportInput>
    deleteMany?: Enumerable<ConditionMatrixScalarWhereInput>
  }

  export type MechanicalHealthUpdateManyWithoutVinPassportNestedInput = {
    create?: XOR<Enumerable<MechanicalHealthCreateWithoutVinPassportInput>, Enumerable<MechanicalHealthUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<MechanicalHealthCreateOrConnectWithoutVinPassportInput>
    upsert?: Enumerable<MechanicalHealthUpsertWithWhereUniqueWithoutVinPassportInput>
    createMany?: MechanicalHealthCreateManyVinPassportInputEnvelope
    set?: Enumerable<MechanicalHealthWhereUniqueInput>
    disconnect?: Enumerable<MechanicalHealthWhereUniqueInput>
    delete?: Enumerable<MechanicalHealthWhereUniqueInput>
    connect?: Enumerable<MechanicalHealthWhereUniqueInput>
    update?: Enumerable<MechanicalHealthUpdateWithWhereUniqueWithoutVinPassportInput>
    updateMany?: Enumerable<MechanicalHealthUpdateManyWithWhereWithoutVinPassportInput>
    deleteMany?: Enumerable<MechanicalHealthScalarWhereInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutVinPassportNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutVinPassportInput>, Enumerable<InvoiceUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutVinPassportInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutVinPassportInput>
    createMany?: InvoiceCreateManyVinPassportInputEnvelope
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutVinPassportInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutVinPassportInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type GasSettlementUncheckedUpdateManyWithoutVinPassportNestedInput = {
    create?: XOR<Enumerable<GasSettlementCreateWithoutVinPassportInput>, Enumerable<GasSettlementUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<GasSettlementCreateOrConnectWithoutVinPassportInput>
    upsert?: Enumerable<GasSettlementUpsertWithWhereUniqueWithoutVinPassportInput>
    createMany?: GasSettlementCreateManyVinPassportInputEnvelope
    set?: Enumerable<GasSettlementWhereUniqueInput>
    disconnect?: Enumerable<GasSettlementWhereUniqueInput>
    delete?: Enumerable<GasSettlementWhereUniqueInput>
    connect?: Enumerable<GasSettlementWhereUniqueInput>
    update?: Enumerable<GasSettlementUpdateWithWhereUniqueWithoutVinPassportInput>
    updateMany?: Enumerable<GasSettlementUpdateManyWithWhereWithoutVinPassportInput>
    deleteMany?: Enumerable<GasSettlementScalarWhereInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutVinPassportNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutVinPassportInput>, Enumerable<AuditLogUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutVinPassportInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutVinPassportInput>
    createMany?: AuditLogCreateManyVinPassportInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutVinPassportInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutVinPassportInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type OnChainProofUncheckedUpdateManyWithoutVinPassportNestedInput = {
    create?: XOR<Enumerable<OnChainProofCreateWithoutVinPassportInput>, Enumerable<OnChainProofUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<OnChainProofCreateOrConnectWithoutVinPassportInput>
    upsert?: Enumerable<OnChainProofUpsertWithWhereUniqueWithoutVinPassportInput>
    createMany?: OnChainProofCreateManyVinPassportInputEnvelope
    set?: Enumerable<OnChainProofWhereUniqueInput>
    disconnect?: Enumerable<OnChainProofWhereUniqueInput>
    delete?: Enumerable<OnChainProofWhereUniqueInput>
    connect?: Enumerable<OnChainProofWhereUniqueInput>
    update?: Enumerable<OnChainProofUpdateWithWhereUniqueWithoutVinPassportInput>
    updateMany?: Enumerable<OnChainProofUpdateManyWithWhereWithoutVinPassportInput>
    deleteMany?: Enumerable<OnChainProofScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutVinPassportNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutVinPassportInput>, Enumerable<DocumentUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutVinPassportInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutVinPassportInput>
    createMany?: DocumentCreateManyVinPassportInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutVinPassportInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutVinPassportInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type ConditionMatrixUncheckedUpdateManyWithoutVinPassportNestedInput = {
    create?: XOR<Enumerable<ConditionMatrixCreateWithoutVinPassportInput>, Enumerable<ConditionMatrixUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<ConditionMatrixCreateOrConnectWithoutVinPassportInput>
    upsert?: Enumerable<ConditionMatrixUpsertWithWhereUniqueWithoutVinPassportInput>
    createMany?: ConditionMatrixCreateManyVinPassportInputEnvelope
    set?: Enumerable<ConditionMatrixWhereUniqueInput>
    disconnect?: Enumerable<ConditionMatrixWhereUniqueInput>
    delete?: Enumerable<ConditionMatrixWhereUniqueInput>
    connect?: Enumerable<ConditionMatrixWhereUniqueInput>
    update?: Enumerable<ConditionMatrixUpdateWithWhereUniqueWithoutVinPassportInput>
    updateMany?: Enumerable<ConditionMatrixUpdateManyWithWhereWithoutVinPassportInput>
    deleteMany?: Enumerable<ConditionMatrixScalarWhereInput>
  }

  export type MechanicalHealthUncheckedUpdateManyWithoutVinPassportNestedInput = {
    create?: XOR<Enumerable<MechanicalHealthCreateWithoutVinPassportInput>, Enumerable<MechanicalHealthUncheckedCreateWithoutVinPassportInput>>
    connectOrCreate?: Enumerable<MechanicalHealthCreateOrConnectWithoutVinPassportInput>
    upsert?: Enumerable<MechanicalHealthUpsertWithWhereUniqueWithoutVinPassportInput>
    createMany?: MechanicalHealthCreateManyVinPassportInputEnvelope
    set?: Enumerable<MechanicalHealthWhereUniqueInput>
    disconnect?: Enumerable<MechanicalHealthWhereUniqueInput>
    delete?: Enumerable<MechanicalHealthWhereUniqueInput>
    connect?: Enumerable<MechanicalHealthWhereUniqueInput>
    update?: Enumerable<MechanicalHealthUpdateWithWhereUniqueWithoutVinPassportInput>
    updateMany?: Enumerable<MechanicalHealthUpdateManyWithWhereWithoutVinPassportInput>
    deleteMany?: Enumerable<MechanicalHealthScalarWhereInput>
  }

  export type VinPassportCreateNestedOneWithoutGasSettlementsInput = {
    create?: XOR<VinPassportCreateWithoutGasSettlementsInput, VinPassportUncheckedCreateWithoutGasSettlementsInput>
    connectOrCreate?: VinPassportCreateOrConnectWithoutGasSettlementsInput
    connect?: VinPassportWhereUniqueInput
  }

  export type VinPassportUpdateOneRequiredWithoutGasSettlementsNestedInput = {
    create?: XOR<VinPassportCreateWithoutGasSettlementsInput, VinPassportUncheckedCreateWithoutGasSettlementsInput>
    connectOrCreate?: VinPassportCreateOrConnectWithoutGasSettlementsInput
    upsert?: VinPassportUpsertWithoutGasSettlementsInput
    connect?: VinPassportWhereUniqueInput
    update?: XOR<VinPassportUpdateWithoutGasSettlementsInput, VinPassportUncheckedUpdateWithoutGasSettlementsInput>
  }

  export type VinPassportCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<VinPassportCreateWithoutInvoicesInput, VinPassportUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: VinPassportCreateOrConnectWithoutInvoicesInput
    connect?: VinPassportWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutInvoiceInput>, Enumerable<DocumentUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutInvoiceInput>
    createMany?: DocumentCreateManyInvoiceInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type NormalizedPartCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<NormalizedPartCreateWithoutInvoiceInput>, Enumerable<NormalizedPartUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<NormalizedPartCreateOrConnectWithoutInvoiceInput>
    createMany?: NormalizedPartCreateManyInvoiceInputEnvelope
    connect?: Enumerable<NormalizedPartWhereUniqueInput>
  }

  export type AuditLogCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutInvoiceInput>, Enumerable<AuditLogUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutInvoiceInput>
    createMany?: AuditLogCreateManyInvoiceInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type OnChainProofCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<OnChainProofCreateWithoutInvoiceInput>, Enumerable<OnChainProofUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<OnChainProofCreateOrConnectWithoutInvoiceInput>
    createMany?: OnChainProofCreateManyInvoiceInputEnvelope
    connect?: Enumerable<OnChainProofWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutInvoiceInput>, Enumerable<DocumentUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutInvoiceInput>
    createMany?: DocumentCreateManyInvoiceInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type NormalizedPartUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<NormalizedPartCreateWithoutInvoiceInput>, Enumerable<NormalizedPartUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<NormalizedPartCreateOrConnectWithoutInvoiceInput>
    createMany?: NormalizedPartCreateManyInvoiceInputEnvelope
    connect?: Enumerable<NormalizedPartWhereUniqueInput>
  }

  export type AuditLogUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutInvoiceInput>, Enumerable<AuditLogUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutInvoiceInput>
    createMany?: AuditLogCreateManyInvoiceInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type OnChainProofUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<OnChainProofCreateWithoutInvoiceInput>, Enumerable<OnChainProofUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<OnChainProofCreateOrConnectWithoutInvoiceInput>
    createMany?: OnChainProofCreateManyInvoiceInputEnvelope
    connect?: Enumerable<OnChainProofWhereUniqueInput>
  }

  export type EnumTxStatusFieldUpdateOperationsInput = {
    set?: TxStatus
  }

  export type VinPassportUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<VinPassportCreateWithoutInvoicesInput, VinPassportUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: VinPassportCreateOrConnectWithoutInvoicesInput
    upsert?: VinPassportUpsertWithoutInvoicesInput
    disconnect?: boolean
    delete?: boolean
    connect?: VinPassportWhereUniqueInput
    update?: XOR<VinPassportUpdateWithoutInvoicesInput, VinPassportUncheckedUpdateWithoutInvoicesInput>
  }

  export type DocumentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutInvoiceInput>, Enumerable<DocumentUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: DocumentCreateManyInvoiceInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type NormalizedPartUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<NormalizedPartCreateWithoutInvoiceInput>, Enumerable<NormalizedPartUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<NormalizedPartCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<NormalizedPartUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: NormalizedPartCreateManyInvoiceInputEnvelope
    set?: Enumerable<NormalizedPartWhereUniqueInput>
    disconnect?: Enumerable<NormalizedPartWhereUniqueInput>
    delete?: Enumerable<NormalizedPartWhereUniqueInput>
    connect?: Enumerable<NormalizedPartWhereUniqueInput>
    update?: Enumerable<NormalizedPartUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<NormalizedPartUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<NormalizedPartScalarWhereInput>
  }

  export type AuditLogUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutInvoiceInput>, Enumerable<AuditLogUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: AuditLogCreateManyInvoiceInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type OnChainProofUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<OnChainProofCreateWithoutInvoiceInput>, Enumerable<OnChainProofUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<OnChainProofCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<OnChainProofUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: OnChainProofCreateManyInvoiceInputEnvelope
    set?: Enumerable<OnChainProofWhereUniqueInput>
    disconnect?: Enumerable<OnChainProofWhereUniqueInput>
    delete?: Enumerable<OnChainProofWhereUniqueInput>
    connect?: Enumerable<OnChainProofWhereUniqueInput>
    update?: Enumerable<OnChainProofUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<OnChainProofUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<OnChainProofScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutInvoiceInput>, Enumerable<DocumentUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: DocumentCreateManyInvoiceInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type NormalizedPartUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<NormalizedPartCreateWithoutInvoiceInput>, Enumerable<NormalizedPartUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<NormalizedPartCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<NormalizedPartUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: NormalizedPartCreateManyInvoiceInputEnvelope
    set?: Enumerable<NormalizedPartWhereUniqueInput>
    disconnect?: Enumerable<NormalizedPartWhereUniqueInput>
    delete?: Enumerable<NormalizedPartWhereUniqueInput>
    connect?: Enumerable<NormalizedPartWhereUniqueInput>
    update?: Enumerable<NormalizedPartUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<NormalizedPartUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<NormalizedPartScalarWhereInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutInvoiceInput>, Enumerable<AuditLogUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: AuditLogCreateManyInvoiceInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type OnChainProofUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<OnChainProofCreateWithoutInvoiceInput>, Enumerable<OnChainProofUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<OnChainProofCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<OnChainProofUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: OnChainProofCreateManyInvoiceInputEnvelope
    set?: Enumerable<OnChainProofWhereUniqueInput>
    disconnect?: Enumerable<OnChainProofWhereUniqueInput>
    delete?: Enumerable<OnChainProofWhereUniqueInput>
    connect?: Enumerable<OnChainProofWhereUniqueInput>
    update?: Enumerable<OnChainProofUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<OnChainProofUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<OnChainProofScalarWhereInput>
  }

  export type InvoiceCreateNestedOneWithoutPartsInput = {
    create?: XOR<InvoiceCreateWithoutPartsInput, InvoiceUncheckedCreateWithoutPartsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPartsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutPartsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPartsInput, InvoiceUncheckedCreateWithoutPartsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPartsInput
    upsert?: InvoiceUpsertWithoutPartsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<InvoiceUpdateWithoutPartsInput, InvoiceUncheckedUpdateWithoutPartsInput>
  }

  export type UserCreateNestedOneWithoutAiDecisionsInput = {
    create?: XOR<UserCreateWithoutAiDecisionsInput, UserUncheckedCreateWithoutAiDecisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiDecisionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumEntityTypeFieldUpdateOperationsInput = {
    set?: EntityType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutAiDecisionsNestedInput = {
    create?: XOR<UserCreateWithoutAiDecisionsInput, UserUncheckedCreateWithoutAiDecisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiDecisionsInput
    upsert?: UserUpsertWithoutAiDecisionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAiDecisionsInput, UserUncheckedUpdateWithoutAiDecisionsInput>
  }

  export type UserCreateNestedOneWithoutAiQuotasInput = {
    create?: XOR<UserCreateWithoutAiQuotasInput, UserUncheckedCreateWithoutAiQuotasInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiQuotasInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAiQuotasNestedInput = {
    create?: XOR<UserCreateWithoutAiQuotasInput, UserUncheckedCreateWithoutAiQuotasInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiQuotasInput
    upsert?: UserUpsertWithoutAiQuotasInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAiQuotasInput, UserUncheckedUpdateWithoutAiQuotasInput>
  }

  export type VinPassportCreateNestedOneWithoutConditionMatricesInput = {
    create?: XOR<VinPassportCreateWithoutConditionMatricesInput, VinPassportUncheckedCreateWithoutConditionMatricesInput>
    connectOrCreate?: VinPassportCreateOrConnectWithoutConditionMatricesInput
    connect?: VinPassportWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutConditionMatrixInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutConditionMatrixInput>, Enumerable<AuditLogUncheckedCreateWithoutConditionMatrixInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutConditionMatrixInput>
    createMany?: AuditLogCreateManyConditionMatrixInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type AuditLogUncheckedCreateNestedManyWithoutConditionMatrixInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutConditionMatrixInput>, Enumerable<AuditLogUncheckedCreateWithoutConditionMatrixInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutConditionMatrixInput>
    createMany?: AuditLogCreateManyConditionMatrixInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type VinPassportUpdateOneWithoutConditionMatricesNestedInput = {
    create?: XOR<VinPassportCreateWithoutConditionMatricesInput, VinPassportUncheckedCreateWithoutConditionMatricesInput>
    connectOrCreate?: VinPassportCreateOrConnectWithoutConditionMatricesInput
    upsert?: VinPassportUpsertWithoutConditionMatricesInput
    disconnect?: boolean
    delete?: boolean
    connect?: VinPassportWhereUniqueInput
    update?: XOR<VinPassportUpdateWithoutConditionMatricesInput, VinPassportUncheckedUpdateWithoutConditionMatricesInput>
  }

  export type AuditLogUpdateManyWithoutConditionMatrixNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutConditionMatrixInput>, Enumerable<AuditLogUncheckedCreateWithoutConditionMatrixInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutConditionMatrixInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutConditionMatrixInput>
    createMany?: AuditLogCreateManyConditionMatrixInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutConditionMatrixInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutConditionMatrixInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutConditionMatrixNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutConditionMatrixInput>, Enumerable<AuditLogUncheckedCreateWithoutConditionMatrixInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutConditionMatrixInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutConditionMatrixInput>
    createMany?: AuditLogCreateManyConditionMatrixInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutConditionMatrixInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutConditionMatrixInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutChainTxsInput = {
    create?: XOR<UserCreateWithoutChainTxsInput, UserUncheckedCreateWithoutChainTxsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChainTxsInput
    connect?: UserWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutChainTxInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutChainTxInput>, Enumerable<AuditLogUncheckedCreateWithoutChainTxInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutChainTxInput>
    createMany?: AuditLogCreateManyChainTxInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type AuditLogUncheckedCreateNestedManyWithoutChainTxInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutChainTxInput>, Enumerable<AuditLogUncheckedCreateWithoutChainTxInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutChainTxInput>
    createMany?: AuditLogCreateManyChainTxInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserUpdateOneWithoutChainTxsNestedInput = {
    create?: XOR<UserCreateWithoutChainTxsInput, UserUncheckedCreateWithoutChainTxsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChainTxsInput
    upsert?: UserUpsertWithoutChainTxsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutChainTxsInput, UserUncheckedUpdateWithoutChainTxsInput>
  }

  export type AuditLogUpdateManyWithoutChainTxNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutChainTxInput>, Enumerable<AuditLogUncheckedCreateWithoutChainTxInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutChainTxInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutChainTxInput>
    createMany?: AuditLogCreateManyChainTxInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutChainTxInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutChainTxInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutChainTxNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutChainTxInput>, Enumerable<AuditLogUncheckedCreateWithoutChainTxInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutChainTxInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutChainTxInput>
    createMany?: AuditLogCreateManyChainTxInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutChainTxInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutChainTxInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type InvoiceCreateNestedOneWithoutOnChainProofsInput = {
    create?: XOR<InvoiceCreateWithoutOnChainProofsInput, InvoiceUncheckedCreateWithoutOnChainProofsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOnChainProofsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type VinPassportCreateNestedOneWithoutOnChainProofsInput = {
    create?: XOR<VinPassportCreateWithoutOnChainProofsInput, VinPassportUncheckedCreateWithoutOnChainProofsInput>
    connectOrCreate?: VinPassportCreateOrConnectWithoutOnChainProofsInput
    connect?: VinPassportWhereUniqueInput
  }

  export type InvoiceUpdateOneWithoutOnChainProofsNestedInput = {
    create?: XOR<InvoiceCreateWithoutOnChainProofsInput, InvoiceUncheckedCreateWithoutOnChainProofsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOnChainProofsInput
    upsert?: InvoiceUpsertWithoutOnChainProofsInput
    disconnect?: boolean
    delete?: boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<InvoiceUpdateWithoutOnChainProofsInput, InvoiceUncheckedUpdateWithoutOnChainProofsInput>
  }

  export type VinPassportUpdateOneWithoutOnChainProofsNestedInput = {
    create?: XOR<VinPassportCreateWithoutOnChainProofsInput, VinPassportUncheckedCreateWithoutOnChainProofsInput>
    connectOrCreate?: VinPassportCreateOrConnectWithoutOnChainProofsInput
    upsert?: VinPassportUpsertWithoutOnChainProofsInput
    disconnect?: boolean
    delete?: boolean
    connect?: VinPassportWhereUniqueInput
    update?: XOR<VinPassportUpdateWithoutOnChainProofsInput, VinPassportUncheckedUpdateWithoutOnChainProofsInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type VinPassportCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<VinPassportCreateWithoutDocumentsInput, VinPassportUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: VinPassportCreateOrConnectWithoutDocumentsInput
    connect?: VinPassportWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<InvoiceCreateWithoutDocumentsInput, InvoiceUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutDocumentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutDocumentInput>, Enumerable<AuditLogUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutDocumentInput>
    createMany?: AuditLogCreateManyDocumentInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type AuditLogUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutDocumentInput>, Enumerable<AuditLogUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutDocumentInput>
    createMany?: AuditLogCreateManyDocumentInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: FileType
  }

  export type EnumFileStateFieldUpdateOperationsInput = {
    set?: FileState
  }

  export type VinPassportUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<VinPassportCreateWithoutDocumentsInput, VinPassportUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: VinPassportCreateOrConnectWithoutDocumentsInput
    upsert?: VinPassportUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: VinPassportWhereUniqueInput
    update?: XOR<VinPassportUpdateWithoutDocumentsInput, VinPassportUncheckedUpdateWithoutDocumentsInput>
  }

  export type InvoiceUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutDocumentsInput, InvoiceUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutDocumentsInput
    upsert?: InvoiceUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<InvoiceUpdateWithoutDocumentsInput, InvoiceUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type AuditLogUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutDocumentInput>, Enumerable<AuditLogUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: AuditLogCreateManyDocumentInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutDocumentInput>, Enumerable<AuditLogUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: AuditLogCreateManyDocumentInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type VinPassportCreateNestedOneWithoutMechanicalHealthsInput = {
    create?: XOR<VinPassportCreateWithoutMechanicalHealthsInput, VinPassportUncheckedCreateWithoutMechanicalHealthsInput>
    connectOrCreate?: VinPassportCreateOrConnectWithoutMechanicalHealthsInput
    connect?: VinPassportWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutMechanicalHealthInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutMechanicalHealthInput>, Enumerable<AuditLogUncheckedCreateWithoutMechanicalHealthInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutMechanicalHealthInput>
    createMany?: AuditLogCreateManyMechanicalHealthInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type AuditLogUncheckedCreateNestedManyWithoutMechanicalHealthInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutMechanicalHealthInput>, Enumerable<AuditLogUncheckedCreateWithoutMechanicalHealthInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutMechanicalHealthInput>
    createMany?: AuditLogCreateManyMechanicalHealthInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type VinPassportUpdateOneRequiredWithoutMechanicalHealthsNestedInput = {
    create?: XOR<VinPassportCreateWithoutMechanicalHealthsInput, VinPassportUncheckedCreateWithoutMechanicalHealthsInput>
    connectOrCreate?: VinPassportCreateOrConnectWithoutMechanicalHealthsInput
    upsert?: VinPassportUpsertWithoutMechanicalHealthsInput
    connect?: VinPassportWhereUniqueInput
    update?: XOR<VinPassportUpdateWithoutMechanicalHealthsInput, VinPassportUncheckedUpdateWithoutMechanicalHealthsInput>
  }

  export type AuditLogUpdateManyWithoutMechanicalHealthNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutMechanicalHealthInput>, Enumerable<AuditLogUncheckedCreateWithoutMechanicalHealthInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutMechanicalHealthInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutMechanicalHealthInput>
    createMany?: AuditLogCreateManyMechanicalHealthInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutMechanicalHealthInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutMechanicalHealthInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutMechanicalHealthNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutMechanicalHealthInput>, Enumerable<AuditLogUncheckedCreateWithoutMechanicalHealthInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutMechanicalHealthInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutMechanicalHealthInput>
    createMany?: AuditLogCreateManyMechanicalHealthInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutMechanicalHealthInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutMechanicalHealthInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<InvoiceCreateWithoutAuditLogsInput, InvoiceUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutAuditLogsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type VinPassportCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<VinPassportCreateWithoutAuditLogsInput, VinPassportUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: VinPassportCreateOrConnectWithoutAuditLogsInput
    connect?: VinPassportWhereUniqueInput
  }

  export type BlockchainTransactionCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<BlockchainTransactionCreateWithoutAuditLogsInput, BlockchainTransactionUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutAuditLogsInput
    connect?: BlockchainTransactionWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<DocumentCreateWithoutAuditLogsInput, DocumentUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutAuditLogsInput
    connect?: DocumentWhereUniqueInput
  }

  export type ConditionMatrixCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<ConditionMatrixCreateWithoutAuditLogsInput, ConditionMatrixUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ConditionMatrixCreateOrConnectWithoutAuditLogsInput
    connect?: ConditionMatrixWhereUniqueInput
  }

  export type MechanicalHealthCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<MechanicalHealthCreateWithoutAuditLogsInput, MechanicalHealthUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: MechanicalHealthCreateOrConnectWithoutAuditLogsInput
    connect?: MechanicalHealthWhereUniqueInput
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: AuditAction
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type InvoiceUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<InvoiceCreateWithoutAuditLogsInput, InvoiceUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutAuditLogsInput
    upsert?: InvoiceUpsertWithoutAuditLogsInput
    disconnect?: boolean
    delete?: boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<InvoiceUpdateWithoutAuditLogsInput, InvoiceUncheckedUpdateWithoutAuditLogsInput>
  }

  export type VinPassportUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<VinPassportCreateWithoutAuditLogsInput, VinPassportUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: VinPassportCreateOrConnectWithoutAuditLogsInput
    upsert?: VinPassportUpsertWithoutAuditLogsInput
    disconnect?: boolean
    delete?: boolean
    connect?: VinPassportWhereUniqueInput
    update?: XOR<VinPassportUpdateWithoutAuditLogsInput, VinPassportUncheckedUpdateWithoutAuditLogsInput>
  }

  export type BlockchainTransactionUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<BlockchainTransactionCreateWithoutAuditLogsInput, BlockchainTransactionUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutAuditLogsInput
    upsert?: BlockchainTransactionUpsertWithoutAuditLogsInput
    disconnect?: boolean
    delete?: boolean
    connect?: BlockchainTransactionWhereUniqueInput
    update?: XOR<BlockchainTransactionUpdateWithoutAuditLogsInput, BlockchainTransactionUncheckedUpdateWithoutAuditLogsInput>
  }

  export type DocumentUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<DocumentCreateWithoutAuditLogsInput, DocumentUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutAuditLogsInput
    upsert?: DocumentUpsertWithoutAuditLogsInput
    disconnect?: boolean
    delete?: boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutAuditLogsInput, DocumentUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ConditionMatrixUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<ConditionMatrixCreateWithoutAuditLogsInput, ConditionMatrixUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ConditionMatrixCreateOrConnectWithoutAuditLogsInput
    upsert?: ConditionMatrixUpsertWithoutAuditLogsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ConditionMatrixWhereUniqueInput
    update?: XOR<ConditionMatrixUpdateWithoutAuditLogsInput, ConditionMatrixUncheckedUpdateWithoutAuditLogsInput>
  }

  export type MechanicalHealthUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<MechanicalHealthCreateWithoutAuditLogsInput, MechanicalHealthUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: MechanicalHealthCreateOrConnectWithoutAuditLogsInput
    upsert?: MechanicalHealthUpsertWithoutAuditLogsInput
    disconnect?: boolean
    delete?: boolean
    connect?: MechanicalHealthWhereUniqueInput
    update?: XOR<MechanicalHealthUpdateWithoutAuditLogsInput, MechanicalHealthUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutAlertsInput = {
    create?: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAlertActionFieldUpdateOperationsInput = {
    set?: AlertAction
  }

  export type UserUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsInput
    upsert?: UserUpsertWithoutAlertsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumUserRoleFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleFilter | UserRole
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleWithAggregatesFilter | UserRole
    _count?: NestedIntFilter
    _min?: NestedEnumUserRoleFilter
    _max?: NestedEnumUserRoleFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedEnumTxStatusFilter = {
    equals?: TxStatus
    in?: Enumerable<TxStatus>
    notIn?: Enumerable<TxStatus>
    not?: NestedEnumTxStatusFilter | TxStatus
  }

  export type NestedEnumTxStatusWithAggregatesFilter = {
    equals?: TxStatus
    in?: Enumerable<TxStatus>
    notIn?: Enumerable<TxStatus>
    not?: NestedEnumTxStatusWithAggregatesFilter | TxStatus
    _count?: NestedIntFilter
    _min?: NestedEnumTxStatusFilter
    _max?: NestedEnumTxStatusFilter
  }

  export type NestedEnumEntityTypeFilter = {
    equals?: EntityType
    in?: Enumerable<EntityType>
    notIn?: Enumerable<EntityType>
    not?: NestedEnumEntityTypeFilter | EntityType
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumEntityTypeWithAggregatesFilter = {
    equals?: EntityType
    in?: Enumerable<EntityType>
    notIn?: Enumerable<EntityType>
    not?: NestedEnumEntityTypeWithAggregatesFilter | EntityType
    _count?: NestedIntFilter
    _min?: NestedEnumEntityTypeFilter
    _max?: NestedEnumEntityTypeFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedBigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number | null
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number | null
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type NestedEnumFileTypeFilter = {
    equals?: FileType
    in?: Enumerable<FileType>
    notIn?: Enumerable<FileType>
    not?: NestedEnumFileTypeFilter | FileType
  }

  export type NestedEnumFileStateFilter = {
    equals?: FileState
    in?: Enumerable<FileState>
    notIn?: Enumerable<FileState>
    not?: NestedEnumFileStateFilter | FileState
  }

  export type NestedEnumFileTypeWithAggregatesFilter = {
    equals?: FileType
    in?: Enumerable<FileType>
    notIn?: Enumerable<FileType>
    not?: NestedEnumFileTypeWithAggregatesFilter | FileType
    _count?: NestedIntFilter
    _min?: NestedEnumFileTypeFilter
    _max?: NestedEnumFileTypeFilter
  }

  export type NestedEnumFileStateWithAggregatesFilter = {
    equals?: FileState
    in?: Enumerable<FileState>
    notIn?: Enumerable<FileState>
    not?: NestedEnumFileStateWithAggregatesFilter | FileState
    _count?: NestedIntFilter
    _min?: NestedEnumFileStateFilter
    _max?: NestedEnumFileStateFilter
  }

  export type NestedEnumAuditActionFilter = {
    equals?: AuditAction
    in?: Enumerable<AuditAction>
    notIn?: Enumerable<AuditAction>
    not?: NestedEnumAuditActionFilter | AuditAction
  }

  export type NestedEnumAuditActionWithAggregatesFilter = {
    equals?: AuditAction
    in?: Enumerable<AuditAction>
    notIn?: Enumerable<AuditAction>
    not?: NestedEnumAuditActionWithAggregatesFilter | AuditAction
    _count?: NestedIntFilter
    _min?: NestedEnumAuditActionFilter
    _max?: NestedEnumAuditActionFilter
  }

  export type NestedEnumAlertActionFilter = {
    equals?: AlertAction
    in?: Enumerable<AlertAction>
    notIn?: Enumerable<AlertAction>
    not?: NestedEnumAlertActionFilter | AlertAction
  }

  export type NestedEnumAlertActionWithAggregatesFilter = {
    equals?: AlertAction
    in?: Enumerable<AlertAction>
    notIn?: Enumerable<AlertAction>
    not?: NestedEnumAlertActionWithAggregatesFilter | AlertAction
    _count?: NestedIntFilter
    _min?: NestedEnumAlertActionFilter
    _max?: NestedEnumAlertActionFilter
  }

  export type AztoWalletCreateWithoutUserInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AztoWalletUncheckedCreateWithoutUserInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AztoWalletCreateOrConnectWithoutUserInput = {
    where: AztoWalletWhereUniqueInput
    create: XOR<AztoWalletCreateWithoutUserInput, AztoWalletUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoice?: InvoiceCreateNestedOneWithoutAuditLogsInput
    vinPassport?: VinPassportCreateNestedOneWithoutAuditLogsInput
    chainTx?: BlockchainTransactionCreateNestedOneWithoutAuditLogsInput
    document?: DocumentCreateNestedOneWithoutAuditLogsInput
    conditionMatrix?: ConditionMatrixCreateNestedOneWithoutAuditLogsInput
    mechanicalHealth?: MechanicalHealthCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    invoiceId?: string | null
    vinPassportId?: string | null
    chainTxId?: string | null
    documentId?: string | null
    conditionMatrixId?: string | null
    mechanicalHealthId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: Enumerable<AuditLogCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AIQuotaCreateWithoutUserInput = {
    id?: string
    invoicesProcessed?: number
    rejectedCount?: number
    periodStart: Date | string
    periodEnd: Date | string
  }

  export type AIQuotaUncheckedCreateWithoutUserInput = {
    id?: string
    invoicesProcessed?: number
    rejectedCount?: number
    periodStart: Date | string
    periodEnd: Date | string
  }

  export type AIQuotaCreateOrConnectWithoutUserInput = {
    where: AIQuotaWhereUniqueInput
    create: XOR<AIQuotaCreateWithoutUserInput, AIQuotaUncheckedCreateWithoutUserInput>
  }

  export type AIQuotaCreateManyUserInputEnvelope = {
    data: Enumerable<AIQuotaCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AIDecisionCreateWithoutUserInput = {
    id?: string
    entityType: EntityType
    entityId: string
    model: string
    promptHash: string
    responseHash: string
    decision: string
    confidence?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AIDecisionUncheckedCreateWithoutUserInput = {
    id?: string
    entityType: EntityType
    entityId: string
    model: string
    promptHash: string
    responseHash: string
    decision: string
    confidence?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AIDecisionCreateOrConnectWithoutUserInput = {
    where: AIDecisionWhereUniqueInput
    create: XOR<AIDecisionCreateWithoutUserInput, AIDecisionUncheckedCreateWithoutUserInput>
  }

  export type AIDecisionCreateManyUserInputEnvelope = {
    data: Enumerable<AIDecisionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type BlockchainTransactionCreateWithoutUserInput = {
    id?: string
    chain: string
    contract: string
    txHash: string
    blockNumber?: bigint | number | null
    eventName?: string | null
    status: TxStatus
    entityType: EntityType
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    confirmations?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutChainTxInput
  }

  export type BlockchainTransactionUncheckedCreateWithoutUserInput = {
    id?: string
    chain: string
    contract: string
    txHash: string
    blockNumber?: bigint | number | null
    eventName?: string | null
    status: TxStatus
    entityType: EntityType
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    confirmations?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChainTxInput
  }

  export type BlockchainTransactionCreateOrConnectWithoutUserInput = {
    where: BlockchainTransactionWhereUniqueInput
    create: XOR<BlockchainTransactionCreateWithoutUserInput, BlockchainTransactionUncheckedCreateWithoutUserInput>
  }

  export type BlockchainTransactionCreateManyUserInputEnvelope = {
    data: Enumerable<BlockchainTransactionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutUserInput = {
    id?: string
    userName: string
    userRole: UserRole
    action: AlertAction
    activity: string
    businessId?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AlertUncheckedCreateWithoutUserInput = {
    id?: string
    userName: string
    userRole: UserRole
    action: AlertAction
    activity: string
    businessId?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AlertCreateOrConnectWithoutUserInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput>
  }

  export type AlertCreateManyUserInputEnvelope = {
    data: Enumerable<AlertCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutUploadedByInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state?: FileState
    checksum: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    deletedBy?: string | null
    vinPassport?: VinPassportCreateNestedOneWithoutDocumentsInput
    invoice?: InvoiceCreateNestedOneWithoutDocumentsInput
    auditLogs?: AuditLogCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutUploadedByInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state?: FileState
    checksum: string
    vinPassportId?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    deletedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type DocumentCreateManyUploadedByInputEnvelope = {
    data: Enumerable<DocumentCreateManyUploadedByInput>
    skipDuplicates?: boolean
  }

  export type AztoWalletUpsertWithoutUserInput = {
    update: XOR<AztoWalletUpdateWithoutUserInput, AztoWalletUncheckedUpdateWithoutUserInput>
    create: XOR<AztoWalletCreateWithoutUserInput, AztoWalletUncheckedCreateWithoutUserInput>
  }

  export type AztoWalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AztoWalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutAuditLogsInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: Enumerable<AuditLogScalarWhereInput>
    OR?: Enumerable<AuditLogScalarWhereInput>
    NOT?: Enumerable<AuditLogScalarWhereInput>
    id?: StringFilter | string
    action?: EnumAuditActionFilter | AuditAction
    entityType?: EnumEntityTypeFilter | EntityType
    entityId?: StringFilter | string
    oldValue?: JsonNullableFilter
    newValue?: JsonNullableFilter
    userId?: StringNullableFilter | string | null
    invoiceId?: StringNullableFilter | string | null
    vinPassportId?: StringNullableFilter | string | null
    chainTxId?: StringNullableFilter | string | null
    documentId?: StringNullableFilter | string | null
    conditionMatrixId?: StringNullableFilter | string | null
    mechanicalHealthId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringNullableFilter | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    updatedBy?: StringNullableFilter | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
  }

  export type AIQuotaUpsertWithWhereUniqueWithoutUserInput = {
    where: AIQuotaWhereUniqueInput
    update: XOR<AIQuotaUpdateWithoutUserInput, AIQuotaUncheckedUpdateWithoutUserInput>
    create: XOR<AIQuotaCreateWithoutUserInput, AIQuotaUncheckedCreateWithoutUserInput>
  }

  export type AIQuotaUpdateWithWhereUniqueWithoutUserInput = {
    where: AIQuotaWhereUniqueInput
    data: XOR<AIQuotaUpdateWithoutUserInput, AIQuotaUncheckedUpdateWithoutUserInput>
  }

  export type AIQuotaUpdateManyWithWhereWithoutUserInput = {
    where: AIQuotaScalarWhereInput
    data: XOR<AIQuotaUpdateManyMutationInput, AIQuotaUncheckedUpdateManyWithoutAiQuotasInput>
  }

  export type AIQuotaScalarWhereInput = {
    AND?: Enumerable<AIQuotaScalarWhereInput>
    OR?: Enumerable<AIQuotaScalarWhereInput>
    NOT?: Enumerable<AIQuotaScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    invoicesProcessed?: IntFilter | number
    rejectedCount?: IntFilter | number
    periodStart?: DateTimeFilter | Date | string
    periodEnd?: DateTimeFilter | Date | string
  }

  export type AIDecisionUpsertWithWhereUniqueWithoutUserInput = {
    where: AIDecisionWhereUniqueInput
    update: XOR<AIDecisionUpdateWithoutUserInput, AIDecisionUncheckedUpdateWithoutUserInput>
    create: XOR<AIDecisionCreateWithoutUserInput, AIDecisionUncheckedCreateWithoutUserInput>
  }

  export type AIDecisionUpdateWithWhereUniqueWithoutUserInput = {
    where: AIDecisionWhereUniqueInput
    data: XOR<AIDecisionUpdateWithoutUserInput, AIDecisionUncheckedUpdateWithoutUserInput>
  }

  export type AIDecisionUpdateManyWithWhereWithoutUserInput = {
    where: AIDecisionScalarWhereInput
    data: XOR<AIDecisionUpdateManyMutationInput, AIDecisionUncheckedUpdateManyWithoutAiDecisionsInput>
  }

  export type AIDecisionScalarWhereInput = {
    AND?: Enumerable<AIDecisionScalarWhereInput>
    OR?: Enumerable<AIDecisionScalarWhereInput>
    NOT?: Enumerable<AIDecisionScalarWhereInput>
    id?: StringFilter | string
    entityType?: EnumEntityTypeFilter | EntityType
    entityId?: StringFilter | string
    model?: StringFilter | string
    promptHash?: StringFilter | string
    responseHash?: StringFilter | string
    decision?: StringFilter | string
    confidence?: FloatNullableFilter | number | null
    metadata?: JsonNullableFilter
    userId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type BlockchainTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: BlockchainTransactionWhereUniqueInput
    update: XOR<BlockchainTransactionUpdateWithoutUserInput, BlockchainTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<BlockchainTransactionCreateWithoutUserInput, BlockchainTransactionUncheckedCreateWithoutUserInput>
  }

  export type BlockchainTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: BlockchainTransactionWhereUniqueInput
    data: XOR<BlockchainTransactionUpdateWithoutUserInput, BlockchainTransactionUncheckedUpdateWithoutUserInput>
  }

  export type BlockchainTransactionUpdateManyWithWhereWithoutUserInput = {
    where: BlockchainTransactionScalarWhereInput
    data: XOR<BlockchainTransactionUpdateManyMutationInput, BlockchainTransactionUncheckedUpdateManyWithoutChainTxsInput>
  }

  export type BlockchainTransactionScalarWhereInput = {
    AND?: Enumerable<BlockchainTransactionScalarWhereInput>
    OR?: Enumerable<BlockchainTransactionScalarWhereInput>
    NOT?: Enumerable<BlockchainTransactionScalarWhereInput>
    id?: StringFilter | string
    chain?: StringFilter | string
    contract?: StringFilter | string
    txHash?: StringFilter | string
    blockNumber?: BigIntNullableFilter | bigint | number | null
    eventName?: StringNullableFilter | string | null
    status?: EnumTxStatusFilter | TxStatus
    entityType?: EnumEntityTypeFilter | EntityType
    entityId?: StringFilter | string
    payload?: JsonFilter
    confirmations?: IntFilter | number
    userId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AlertUpsertWithWhereUniqueWithoutUserInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutUserInput, AlertUncheckedUpdateWithoutUserInput>
    create: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutUserInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutUserInput, AlertUncheckedUpdateWithoutUserInput>
  }

  export type AlertUpdateManyWithWhereWithoutUserInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutAlertsInput>
  }

  export type AlertScalarWhereInput = {
    AND?: Enumerable<AlertScalarWhereInput>
    OR?: Enumerable<AlertScalarWhereInput>
    NOT?: Enumerable<AlertScalarWhereInput>
    id?: StringFilter | string
    userName?: StringFilter | string
    userRole?: EnumUserRoleFilter | UserRole
    action?: EnumAlertActionFilter | AlertAction
    activity?: StringFilter | string
    businessId?: StringNullableFilter | string | null
    isRead?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    userId?: StringNullableFilter | string | null
  }

  export type DocumentUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUploadedByInput, DocumentUncheckedUpdateWithoutUploadedByInput>
    create: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUploadedByInput, DocumentUncheckedUpdateWithoutUploadedByInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUploadedByInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: Enumerable<DocumentScalarWhereInput>
    OR?: Enumerable<DocumentScalarWhereInput>
    NOT?: Enumerable<DocumentScalarWhereInput>
    id?: StringFilter | string
    fileName?: StringFilter | string
    fileUrl?: StringFilter | string
    fileType?: EnumFileTypeFilter | FileType
    state?: EnumFileStateFilter | FileState
    checksum?: StringFilter | string
    vinPassportId?: StringNullableFilter | string | null
    invoiceId?: StringNullableFilter | string | null
    uploadedById?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    isDeleted?: BoolFilter | boolean
    deletedBy?: StringNullableFilter | string | null
  }

  export type UserCreateWithoutWalletInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    aiQuotas?: AIQuotaCreateNestedManyWithoutUserInput
    aiDecisions?: AIDecisionCreateNestedManyWithoutUserInput
    chainTxs?: BlockchainTransactionCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutWalletInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    aiQuotas?: AIQuotaUncheckedCreateNestedManyWithoutUserInput
    aiDecisions?: AIDecisionUncheckedCreateNestedManyWithoutUserInput
    chainTxs?: BlockchainTransactionUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutWalletInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
  }

  export type UserUpsertWithoutWalletInput = {
    update: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
  }

  export type UserUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    aiQuotas?: AIQuotaUpdateManyWithoutUserNestedInput
    aiDecisions?: AIDecisionUpdateManyWithoutUserNestedInput
    chainTxs?: BlockchainTransactionUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    aiQuotas?: AIQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiDecisions?: AIDecisionUncheckedUpdateManyWithoutUserNestedInput
    chainTxs?: BlockchainTransactionUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type InvoiceCreateWithoutVinPassportInput = {
    id?: string
    number: string
    status: TxStatus
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    documents?: DocumentCreateNestedManyWithoutInvoiceInput
    parts?: NormalizedPartCreateNestedManyWithoutInvoiceInput
    auditLogs?: AuditLogCreateNestedManyWithoutInvoiceInput
    onChainProofs?: OnChainProofCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutVinPassportInput = {
    id?: string
    number: string
    status: TxStatus
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    documents?: DocumentUncheckedCreateNestedManyWithoutInvoiceInput
    parts?: NormalizedPartUncheckedCreateNestedManyWithoutInvoiceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutInvoiceInput
    onChainProofs?: OnChainProofUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutVinPassportInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutVinPassportInput, InvoiceUncheckedCreateWithoutVinPassportInput>
  }

  export type InvoiceCreateManyVinPassportInputEnvelope = {
    data: Enumerable<InvoiceCreateManyVinPassportInput>
    skipDuplicates?: boolean
  }

  export type GasSettlementCreateWithoutVinPassportInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type GasSettlementUncheckedCreateWithoutVinPassportInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type GasSettlementCreateOrConnectWithoutVinPassportInput = {
    where: GasSettlementWhereUniqueInput
    create: XOR<GasSettlementCreateWithoutVinPassportInput, GasSettlementUncheckedCreateWithoutVinPassportInput>
  }

  export type GasSettlementCreateManyVinPassportInputEnvelope = {
    data: Enumerable<GasSettlementCreateManyVinPassportInput>
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutVinPassportInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    user?: UserCreateNestedOneWithoutAuditLogsInput
    invoice?: InvoiceCreateNestedOneWithoutAuditLogsInput
    chainTx?: BlockchainTransactionCreateNestedOneWithoutAuditLogsInput
    document?: DocumentCreateNestedOneWithoutAuditLogsInput
    conditionMatrix?: ConditionMatrixCreateNestedOneWithoutAuditLogsInput
    mechanicalHealth?: MechanicalHealthCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutVinPassportInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    invoiceId?: string | null
    chainTxId?: string | null
    documentId?: string | null
    conditionMatrixId?: string | null
    mechanicalHealthId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogCreateOrConnectWithoutVinPassportInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutVinPassportInput, AuditLogUncheckedCreateWithoutVinPassportInput>
  }

  export type AuditLogCreateManyVinPassportInputEnvelope = {
    data: Enumerable<AuditLogCreateManyVinPassportInput>
    skipDuplicates?: boolean
  }

  export type OnChainProofCreateWithoutVinPassportInput = {
    id?: string
    entityType: EntityType
    entityId: string
    hash: string
    algorithm: string
    chain: string
    contract: string
    txHash: string
    createdAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutOnChainProofsInput
  }

  export type OnChainProofUncheckedCreateWithoutVinPassportInput = {
    id?: string
    entityType: EntityType
    entityId: string
    hash: string
    algorithm: string
    chain: string
    contract: string
    txHash: string
    invoiceId?: string | null
    createdAt?: Date | string
  }

  export type OnChainProofCreateOrConnectWithoutVinPassportInput = {
    where: OnChainProofWhereUniqueInput
    create: XOR<OnChainProofCreateWithoutVinPassportInput, OnChainProofUncheckedCreateWithoutVinPassportInput>
  }

  export type OnChainProofCreateManyVinPassportInputEnvelope = {
    data: Enumerable<OnChainProofCreateManyVinPassportInput>
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutVinPassportInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state?: FileState
    checksum: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    deletedBy?: string | null
    invoice?: InvoiceCreateNestedOneWithoutDocumentsInput
    uploadedBy?: UserCreateNestedOneWithoutDocumentsInput
    auditLogs?: AuditLogCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutVinPassportInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state?: FileState
    checksum: string
    invoiceId?: string | null
    uploadedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    deletedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutVinPassportInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutVinPassportInput, DocumentUncheckedCreateWithoutVinPassportInput>
  }

  export type DocumentCreateManyVinPassportInputEnvelope = {
    data: Enumerable<DocumentCreateManyVinPassportInput>
    skipDuplicates?: boolean
  }

  export type ConditionMatrixCreateWithoutVinPassportInput = {
    id?: string
    version: string
    rulesHash: string
    effectiveFrom: Date | string
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    auditLogs?: AuditLogCreateNestedManyWithoutConditionMatrixInput
  }

  export type ConditionMatrixUncheckedCreateWithoutVinPassportInput = {
    id?: string
    version: string
    rulesHash: string
    effectiveFrom: Date | string
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutConditionMatrixInput
  }

  export type ConditionMatrixCreateOrConnectWithoutVinPassportInput = {
    where: ConditionMatrixWhereUniqueInput
    create: XOR<ConditionMatrixCreateWithoutVinPassportInput, ConditionMatrixUncheckedCreateWithoutVinPassportInput>
  }

  export type ConditionMatrixCreateManyVinPassportInputEnvelope = {
    data: Enumerable<ConditionMatrixCreateManyVinPassportInput>
    skipDuplicates?: boolean
  }

  export type MechanicalHealthCreateWithoutVinPassportInput = {
    id?: string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: Date | string | null
    greenLight?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    auditLogs?: AuditLogCreateNestedManyWithoutMechanicalHealthInput
  }

  export type MechanicalHealthUncheckedCreateWithoutVinPassportInput = {
    id?: string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: Date | string | null
    greenLight?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutMechanicalHealthInput
  }

  export type MechanicalHealthCreateOrConnectWithoutVinPassportInput = {
    where: MechanicalHealthWhereUniqueInput
    create: XOR<MechanicalHealthCreateWithoutVinPassportInput, MechanicalHealthUncheckedCreateWithoutVinPassportInput>
  }

  export type MechanicalHealthCreateManyVinPassportInputEnvelope = {
    data: Enumerable<MechanicalHealthCreateManyVinPassportInput>
    skipDuplicates?: boolean
  }

  export type InvoiceUpsertWithWhereUniqueWithoutVinPassportInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutVinPassportInput, InvoiceUncheckedUpdateWithoutVinPassportInput>
    create: XOR<InvoiceCreateWithoutVinPassportInput, InvoiceUncheckedCreateWithoutVinPassportInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutVinPassportInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutVinPassportInput, InvoiceUncheckedUpdateWithoutVinPassportInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutVinPassportInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: Enumerable<InvoiceScalarWhereInput>
    OR?: Enumerable<InvoiceScalarWhereInput>
    NOT?: Enumerable<InvoiceScalarWhereInput>
    id?: StringFilter | string
    number?: StringFilter | string
    status?: EnumTxStatusFilter | TxStatus
    vinPassportId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringNullableFilter | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    updatedBy?: StringNullableFilter | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
  }

  export type GasSettlementUpsertWithWhereUniqueWithoutVinPassportInput = {
    where: GasSettlementWhereUniqueInput
    update: XOR<GasSettlementUpdateWithoutVinPassportInput, GasSettlementUncheckedUpdateWithoutVinPassportInput>
    create: XOR<GasSettlementCreateWithoutVinPassportInput, GasSettlementUncheckedCreateWithoutVinPassportInput>
  }

  export type GasSettlementUpdateWithWhereUniqueWithoutVinPassportInput = {
    where: GasSettlementWhereUniqueInput
    data: XOR<GasSettlementUpdateWithoutVinPassportInput, GasSettlementUncheckedUpdateWithoutVinPassportInput>
  }

  export type GasSettlementUpdateManyWithWhereWithoutVinPassportInput = {
    where: GasSettlementScalarWhereInput
    data: XOR<GasSettlementUpdateManyMutationInput, GasSettlementUncheckedUpdateManyWithoutGasSettlementsInput>
  }

  export type GasSettlementScalarWhereInput = {
    AND?: Enumerable<GasSettlementScalarWhereInput>
    OR?: Enumerable<GasSettlementScalarWhereInput>
    NOT?: Enumerable<GasSettlementScalarWhereInput>
    id?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    vinPassportId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringNullableFilter | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    updatedBy?: StringNullableFilter | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutVinPassportInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutVinPassportInput, AuditLogUncheckedUpdateWithoutVinPassportInput>
    create: XOR<AuditLogCreateWithoutVinPassportInput, AuditLogUncheckedCreateWithoutVinPassportInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutVinPassportInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutVinPassportInput, AuditLogUncheckedUpdateWithoutVinPassportInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutVinPassportInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutAuditLogsInput>
  }

  export type OnChainProofUpsertWithWhereUniqueWithoutVinPassportInput = {
    where: OnChainProofWhereUniqueInput
    update: XOR<OnChainProofUpdateWithoutVinPassportInput, OnChainProofUncheckedUpdateWithoutVinPassportInput>
    create: XOR<OnChainProofCreateWithoutVinPassportInput, OnChainProofUncheckedCreateWithoutVinPassportInput>
  }

  export type OnChainProofUpdateWithWhereUniqueWithoutVinPassportInput = {
    where: OnChainProofWhereUniqueInput
    data: XOR<OnChainProofUpdateWithoutVinPassportInput, OnChainProofUncheckedUpdateWithoutVinPassportInput>
  }

  export type OnChainProofUpdateManyWithWhereWithoutVinPassportInput = {
    where: OnChainProofScalarWhereInput
    data: XOR<OnChainProofUpdateManyMutationInput, OnChainProofUncheckedUpdateManyWithoutOnChainProofsInput>
  }

  export type OnChainProofScalarWhereInput = {
    AND?: Enumerable<OnChainProofScalarWhereInput>
    OR?: Enumerable<OnChainProofScalarWhereInput>
    NOT?: Enumerable<OnChainProofScalarWhereInput>
    id?: StringFilter | string
    entityType?: EnumEntityTypeFilter | EntityType
    entityId?: StringFilter | string
    hash?: StringFilter | string
    algorithm?: StringFilter | string
    chain?: StringFilter | string
    contract?: StringFilter | string
    txHash?: StringFilter | string
    invoiceId?: StringNullableFilter | string | null
    vinPassportId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutVinPassportInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutVinPassportInput, DocumentUncheckedUpdateWithoutVinPassportInput>
    create: XOR<DocumentCreateWithoutVinPassportInput, DocumentUncheckedCreateWithoutVinPassportInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutVinPassportInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutVinPassportInput, DocumentUncheckedUpdateWithoutVinPassportInput>
  }

  export type DocumentUpdateManyWithWhereWithoutVinPassportInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type ConditionMatrixUpsertWithWhereUniqueWithoutVinPassportInput = {
    where: ConditionMatrixWhereUniqueInput
    update: XOR<ConditionMatrixUpdateWithoutVinPassportInput, ConditionMatrixUncheckedUpdateWithoutVinPassportInput>
    create: XOR<ConditionMatrixCreateWithoutVinPassportInput, ConditionMatrixUncheckedCreateWithoutVinPassportInput>
  }

  export type ConditionMatrixUpdateWithWhereUniqueWithoutVinPassportInput = {
    where: ConditionMatrixWhereUniqueInput
    data: XOR<ConditionMatrixUpdateWithoutVinPassportInput, ConditionMatrixUncheckedUpdateWithoutVinPassportInput>
  }

  export type ConditionMatrixUpdateManyWithWhereWithoutVinPassportInput = {
    where: ConditionMatrixScalarWhereInput
    data: XOR<ConditionMatrixUpdateManyMutationInput, ConditionMatrixUncheckedUpdateManyWithoutConditionMatricesInput>
  }

  export type ConditionMatrixScalarWhereInput = {
    AND?: Enumerable<ConditionMatrixScalarWhereInput>
    OR?: Enumerable<ConditionMatrixScalarWhereInput>
    NOT?: Enumerable<ConditionMatrixScalarWhereInput>
    id?: StringFilter | string
    vinPassportId?: StringNullableFilter | string | null
    version?: StringFilter | string
    rulesHash?: StringFilter | string
    effectiveFrom?: DateTimeFilter | Date | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringNullableFilter | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    updatedBy?: StringNullableFilter | string | null
  }

  export type MechanicalHealthUpsertWithWhereUniqueWithoutVinPassportInput = {
    where: MechanicalHealthWhereUniqueInput
    update: XOR<MechanicalHealthUpdateWithoutVinPassportInput, MechanicalHealthUncheckedUpdateWithoutVinPassportInput>
    create: XOR<MechanicalHealthCreateWithoutVinPassportInput, MechanicalHealthUncheckedCreateWithoutVinPassportInput>
  }

  export type MechanicalHealthUpdateWithWhereUniqueWithoutVinPassportInput = {
    where: MechanicalHealthWhereUniqueInput
    data: XOR<MechanicalHealthUpdateWithoutVinPassportInput, MechanicalHealthUncheckedUpdateWithoutVinPassportInput>
  }

  export type MechanicalHealthUpdateManyWithWhereWithoutVinPassportInput = {
    where: MechanicalHealthScalarWhereInput
    data: XOR<MechanicalHealthUpdateManyMutationInput, MechanicalHealthUncheckedUpdateManyWithoutMechanicalHealthsInput>
  }

  export type MechanicalHealthScalarWhereInput = {
    AND?: Enumerable<MechanicalHealthScalarWhereInput>
    OR?: Enumerable<MechanicalHealthScalarWhereInput>
    NOT?: Enumerable<MechanicalHealthScalarWhereInput>
    id?: StringFilter | string
    vinPassportId?: StringFilter | string
    partsMaintained?: JsonNullableFilter
    lastUpdate?: DateTimeNullableFilter | Date | string | null
    greenLight?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    isDeleted?: BoolFilter | boolean
  }

  export type VinPassportCreateWithoutGasSettlementsInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoices?: InvoiceCreateNestedManyWithoutVinPassportInput
    auditLogs?: AuditLogCreateNestedManyWithoutVinPassportInput
    onChainProofs?: OnChainProofCreateNestedManyWithoutVinPassportInput
    documents?: DocumentCreateNestedManyWithoutVinPassportInput
    conditionMatrices?: ConditionMatrixCreateNestedManyWithoutVinPassportInput
    mechanicalHealths?: MechanicalHealthCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportUncheckedCreateWithoutGasSettlementsInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVinPassportInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVinPassportInput
    onChainProofs?: OnChainProofUncheckedCreateNestedManyWithoutVinPassportInput
    documents?: DocumentUncheckedCreateNestedManyWithoutVinPassportInput
    conditionMatrices?: ConditionMatrixUncheckedCreateNestedManyWithoutVinPassportInput
    mechanicalHealths?: MechanicalHealthUncheckedCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportCreateOrConnectWithoutGasSettlementsInput = {
    where: VinPassportWhereUniqueInput
    create: XOR<VinPassportCreateWithoutGasSettlementsInput, VinPassportUncheckedCreateWithoutGasSettlementsInput>
  }

  export type VinPassportUpsertWithoutGasSettlementsInput = {
    update: XOR<VinPassportUpdateWithoutGasSettlementsInput, VinPassportUncheckedUpdateWithoutGasSettlementsInput>
    create: XOR<VinPassportCreateWithoutGasSettlementsInput, VinPassportUncheckedCreateWithoutGasSettlementsInput>
  }

  export type VinPassportUpdateWithoutGasSettlementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUpdateManyWithoutVinPassportNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVinPassportNestedInput
    onChainProofs?: OnChainProofUpdateManyWithoutVinPassportNestedInput
    documents?: DocumentUpdateManyWithoutVinPassportNestedInput
    conditionMatrices?: ConditionMatrixUpdateManyWithoutVinPassportNestedInput
    mechanicalHealths?: MechanicalHealthUpdateManyWithoutVinPassportNestedInput
  }

  export type VinPassportUncheckedUpdateWithoutGasSettlementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUncheckedUpdateManyWithoutVinPassportNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVinPassportNestedInput
    onChainProofs?: OnChainProofUncheckedUpdateManyWithoutVinPassportNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutVinPassportNestedInput
    conditionMatrices?: ConditionMatrixUncheckedUpdateManyWithoutVinPassportNestedInput
    mechanicalHealths?: MechanicalHealthUncheckedUpdateManyWithoutVinPassportNestedInput
  }

  export type VinPassportCreateWithoutInvoicesInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    gasSettlements?: GasSettlementCreateNestedManyWithoutVinPassportInput
    auditLogs?: AuditLogCreateNestedManyWithoutVinPassportInput
    onChainProofs?: OnChainProofCreateNestedManyWithoutVinPassportInput
    documents?: DocumentCreateNestedManyWithoutVinPassportInput
    conditionMatrices?: ConditionMatrixCreateNestedManyWithoutVinPassportInput
    mechanicalHealths?: MechanicalHealthCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportUncheckedCreateWithoutInvoicesInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    gasSettlements?: GasSettlementUncheckedCreateNestedManyWithoutVinPassportInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVinPassportInput
    onChainProofs?: OnChainProofUncheckedCreateNestedManyWithoutVinPassportInput
    documents?: DocumentUncheckedCreateNestedManyWithoutVinPassportInput
    conditionMatrices?: ConditionMatrixUncheckedCreateNestedManyWithoutVinPassportInput
    mechanicalHealths?: MechanicalHealthUncheckedCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportCreateOrConnectWithoutInvoicesInput = {
    where: VinPassportWhereUniqueInput
    create: XOR<VinPassportCreateWithoutInvoicesInput, VinPassportUncheckedCreateWithoutInvoicesInput>
  }

  export type DocumentCreateWithoutInvoiceInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state?: FileState
    checksum: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    deletedBy?: string | null
    vinPassport?: VinPassportCreateNestedOneWithoutDocumentsInput
    uploadedBy?: UserCreateNestedOneWithoutDocumentsInput
    auditLogs?: AuditLogCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state?: FileState
    checksum: string
    vinPassportId?: string | null
    uploadedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    deletedBy?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutInvoiceInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutInvoiceInput, DocumentUncheckedCreateWithoutInvoiceInput>
  }

  export type DocumentCreateManyInvoiceInputEnvelope = {
    data: Enumerable<DocumentCreateManyInvoiceInput>
    skipDuplicates?: boolean
  }

  export type NormalizedPartCreateWithoutInvoiceInput = {
    id?: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type NormalizedPartUncheckedCreateWithoutInvoiceInput = {
    id?: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type NormalizedPartCreateOrConnectWithoutInvoiceInput = {
    where: NormalizedPartWhereUniqueInput
    create: XOR<NormalizedPartCreateWithoutInvoiceInput, NormalizedPartUncheckedCreateWithoutInvoiceInput>
  }

  export type NormalizedPartCreateManyInvoiceInputEnvelope = {
    data: Enumerable<NormalizedPartCreateManyInvoiceInput>
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutInvoiceInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    user?: UserCreateNestedOneWithoutAuditLogsInput
    vinPassport?: VinPassportCreateNestedOneWithoutAuditLogsInput
    chainTx?: BlockchainTransactionCreateNestedOneWithoutAuditLogsInput
    document?: DocumentCreateNestedOneWithoutAuditLogsInput
    conditionMatrix?: ConditionMatrixCreateNestedOneWithoutAuditLogsInput
    mechanicalHealth?: MechanicalHealthCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutInvoiceInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    vinPassportId?: string | null
    chainTxId?: string | null
    documentId?: string | null
    conditionMatrixId?: string | null
    mechanicalHealthId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogCreateOrConnectWithoutInvoiceInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutInvoiceInput, AuditLogUncheckedCreateWithoutInvoiceInput>
  }

  export type AuditLogCreateManyInvoiceInputEnvelope = {
    data: Enumerable<AuditLogCreateManyInvoiceInput>
    skipDuplicates?: boolean
  }

  export type OnChainProofCreateWithoutInvoiceInput = {
    id?: string
    entityType: EntityType
    entityId: string
    hash: string
    algorithm: string
    chain: string
    contract: string
    txHash: string
    createdAt?: Date | string
    vinPassport?: VinPassportCreateNestedOneWithoutOnChainProofsInput
  }

  export type OnChainProofUncheckedCreateWithoutInvoiceInput = {
    id?: string
    entityType: EntityType
    entityId: string
    hash: string
    algorithm: string
    chain: string
    contract: string
    txHash: string
    vinPassportId?: string | null
    createdAt?: Date | string
  }

  export type OnChainProofCreateOrConnectWithoutInvoiceInput = {
    where: OnChainProofWhereUniqueInput
    create: XOR<OnChainProofCreateWithoutInvoiceInput, OnChainProofUncheckedCreateWithoutInvoiceInput>
  }

  export type OnChainProofCreateManyInvoiceInputEnvelope = {
    data: Enumerable<OnChainProofCreateManyInvoiceInput>
    skipDuplicates?: boolean
  }

  export type VinPassportUpsertWithoutInvoicesInput = {
    update: XOR<VinPassportUpdateWithoutInvoicesInput, VinPassportUncheckedUpdateWithoutInvoicesInput>
    create: XOR<VinPassportCreateWithoutInvoicesInput, VinPassportUncheckedCreateWithoutInvoicesInput>
  }

  export type VinPassportUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    gasSettlements?: GasSettlementUpdateManyWithoutVinPassportNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVinPassportNestedInput
    onChainProofs?: OnChainProofUpdateManyWithoutVinPassportNestedInput
    documents?: DocumentUpdateManyWithoutVinPassportNestedInput
    conditionMatrices?: ConditionMatrixUpdateManyWithoutVinPassportNestedInput
    mechanicalHealths?: MechanicalHealthUpdateManyWithoutVinPassportNestedInput
  }

  export type VinPassportUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    gasSettlements?: GasSettlementUncheckedUpdateManyWithoutVinPassportNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVinPassportNestedInput
    onChainProofs?: OnChainProofUncheckedUpdateManyWithoutVinPassportNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutVinPassportNestedInput
    conditionMatrices?: ConditionMatrixUncheckedUpdateManyWithoutVinPassportNestedInput
    mechanicalHealths?: MechanicalHealthUncheckedUpdateManyWithoutVinPassportNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutInvoiceInput, DocumentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<DocumentCreateWithoutInvoiceInput, DocumentUncheckedCreateWithoutInvoiceInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutInvoiceInput, DocumentUncheckedUpdateWithoutInvoiceInput>
  }

  export type DocumentUpdateManyWithWhereWithoutInvoiceInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type NormalizedPartUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: NormalizedPartWhereUniqueInput
    update: XOR<NormalizedPartUpdateWithoutInvoiceInput, NormalizedPartUncheckedUpdateWithoutInvoiceInput>
    create: XOR<NormalizedPartCreateWithoutInvoiceInput, NormalizedPartUncheckedCreateWithoutInvoiceInput>
  }

  export type NormalizedPartUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: NormalizedPartWhereUniqueInput
    data: XOR<NormalizedPartUpdateWithoutInvoiceInput, NormalizedPartUncheckedUpdateWithoutInvoiceInput>
  }

  export type NormalizedPartUpdateManyWithWhereWithoutInvoiceInput = {
    where: NormalizedPartScalarWhereInput
    data: XOR<NormalizedPartUpdateManyMutationInput, NormalizedPartUncheckedUpdateManyWithoutPartsInput>
  }

  export type NormalizedPartScalarWhereInput = {
    AND?: Enumerable<NormalizedPartScalarWhereInput>
    OR?: Enumerable<NormalizedPartScalarWhereInput>
    NOT?: Enumerable<NormalizedPartScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    invoiceId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringNullableFilter | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    updatedBy?: StringNullableFilter | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutInvoiceInput, AuditLogUncheckedUpdateWithoutInvoiceInput>
    create: XOR<AuditLogCreateWithoutInvoiceInput, AuditLogUncheckedCreateWithoutInvoiceInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutInvoiceInput, AuditLogUncheckedUpdateWithoutInvoiceInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutInvoiceInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutAuditLogsInput>
  }

  export type OnChainProofUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: OnChainProofWhereUniqueInput
    update: XOR<OnChainProofUpdateWithoutInvoiceInput, OnChainProofUncheckedUpdateWithoutInvoiceInput>
    create: XOR<OnChainProofCreateWithoutInvoiceInput, OnChainProofUncheckedCreateWithoutInvoiceInput>
  }

  export type OnChainProofUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: OnChainProofWhereUniqueInput
    data: XOR<OnChainProofUpdateWithoutInvoiceInput, OnChainProofUncheckedUpdateWithoutInvoiceInput>
  }

  export type OnChainProofUpdateManyWithWhereWithoutInvoiceInput = {
    where: OnChainProofScalarWhereInput
    data: XOR<OnChainProofUpdateManyMutationInput, OnChainProofUncheckedUpdateManyWithoutOnChainProofsInput>
  }

  export type InvoiceCreateWithoutPartsInput = {
    id?: string
    number: string
    status: TxStatus
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    vinPassport?: VinPassportCreateNestedOneWithoutInvoicesInput
    documents?: DocumentCreateNestedManyWithoutInvoiceInput
    auditLogs?: AuditLogCreateNestedManyWithoutInvoiceInput
    onChainProofs?: OnChainProofCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPartsInput = {
    id?: string
    number: string
    status: TxStatus
    vinPassportId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    documents?: DocumentUncheckedCreateNestedManyWithoutInvoiceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutInvoiceInput
    onChainProofs?: OnChainProofUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPartsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPartsInput, InvoiceUncheckedCreateWithoutPartsInput>
  }

  export type InvoiceUpsertWithoutPartsInput = {
    update: XOR<InvoiceUpdateWithoutPartsInput, InvoiceUncheckedUpdateWithoutPartsInput>
    create: XOR<InvoiceCreateWithoutPartsInput, InvoiceUncheckedCreateWithoutPartsInput>
  }

  export type InvoiceUpdateWithoutPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    vinPassport?: VinPassportUpdateOneWithoutInvoicesNestedInput
    documents?: DocumentUpdateManyWithoutInvoiceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutInvoiceNestedInput
    onChainProofs?: OnChainProofUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    documents?: DocumentUncheckedUpdateManyWithoutInvoiceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutInvoiceNestedInput
    onChainProofs?: OnChainProofUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type UserCreateWithoutAiDecisionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    wallet?: AztoWalletCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    aiQuotas?: AIQuotaCreateNestedManyWithoutUserInput
    chainTxs?: BlockchainTransactionCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAiDecisionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    wallet?: AztoWalletUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    aiQuotas?: AIQuotaUncheckedCreateNestedManyWithoutUserInput
    chainTxs?: BlockchainTransactionUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAiDecisionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiDecisionsInput, UserUncheckedCreateWithoutAiDecisionsInput>
  }

  export type UserUpsertWithoutAiDecisionsInput = {
    update: XOR<UserUpdateWithoutAiDecisionsInput, UserUncheckedUpdateWithoutAiDecisionsInput>
    create: XOR<UserCreateWithoutAiDecisionsInput, UserUncheckedCreateWithoutAiDecisionsInput>
  }

  export type UserUpdateWithoutAiDecisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    wallet?: AztoWalletUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    aiQuotas?: AIQuotaUpdateManyWithoutUserNestedInput
    chainTxs?: BlockchainTransactionUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAiDecisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    wallet?: AztoWalletUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    aiQuotas?: AIQuotaUncheckedUpdateManyWithoutUserNestedInput
    chainTxs?: BlockchainTransactionUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutAiQuotasInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    wallet?: AztoWalletCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    aiDecisions?: AIDecisionCreateNestedManyWithoutUserInput
    chainTxs?: BlockchainTransactionCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAiQuotasInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    wallet?: AztoWalletUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    aiDecisions?: AIDecisionUncheckedCreateNestedManyWithoutUserInput
    chainTxs?: BlockchainTransactionUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAiQuotasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiQuotasInput, UserUncheckedCreateWithoutAiQuotasInput>
  }

  export type UserUpsertWithoutAiQuotasInput = {
    update: XOR<UserUpdateWithoutAiQuotasInput, UserUncheckedUpdateWithoutAiQuotasInput>
    create: XOR<UserCreateWithoutAiQuotasInput, UserUncheckedCreateWithoutAiQuotasInput>
  }

  export type UserUpdateWithoutAiQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    wallet?: AztoWalletUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    aiDecisions?: AIDecisionUpdateManyWithoutUserNestedInput
    chainTxs?: BlockchainTransactionUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAiQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    wallet?: AztoWalletUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    aiDecisions?: AIDecisionUncheckedUpdateManyWithoutUserNestedInput
    chainTxs?: BlockchainTransactionUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type VinPassportCreateWithoutConditionMatricesInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoices?: InvoiceCreateNestedManyWithoutVinPassportInput
    gasSettlements?: GasSettlementCreateNestedManyWithoutVinPassportInput
    auditLogs?: AuditLogCreateNestedManyWithoutVinPassportInput
    onChainProofs?: OnChainProofCreateNestedManyWithoutVinPassportInput
    documents?: DocumentCreateNestedManyWithoutVinPassportInput
    mechanicalHealths?: MechanicalHealthCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportUncheckedCreateWithoutConditionMatricesInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVinPassportInput
    gasSettlements?: GasSettlementUncheckedCreateNestedManyWithoutVinPassportInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVinPassportInput
    onChainProofs?: OnChainProofUncheckedCreateNestedManyWithoutVinPassportInput
    documents?: DocumentUncheckedCreateNestedManyWithoutVinPassportInput
    mechanicalHealths?: MechanicalHealthUncheckedCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportCreateOrConnectWithoutConditionMatricesInput = {
    where: VinPassportWhereUniqueInput
    create: XOR<VinPassportCreateWithoutConditionMatricesInput, VinPassportUncheckedCreateWithoutConditionMatricesInput>
  }

  export type AuditLogCreateWithoutConditionMatrixInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    user?: UserCreateNestedOneWithoutAuditLogsInput
    invoice?: InvoiceCreateNestedOneWithoutAuditLogsInput
    vinPassport?: VinPassportCreateNestedOneWithoutAuditLogsInput
    chainTx?: BlockchainTransactionCreateNestedOneWithoutAuditLogsInput
    document?: DocumentCreateNestedOneWithoutAuditLogsInput
    mechanicalHealth?: MechanicalHealthCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutConditionMatrixInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    invoiceId?: string | null
    vinPassportId?: string | null
    chainTxId?: string | null
    documentId?: string | null
    mechanicalHealthId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogCreateOrConnectWithoutConditionMatrixInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutConditionMatrixInput, AuditLogUncheckedCreateWithoutConditionMatrixInput>
  }

  export type AuditLogCreateManyConditionMatrixInputEnvelope = {
    data: Enumerable<AuditLogCreateManyConditionMatrixInput>
    skipDuplicates?: boolean
  }

  export type VinPassportUpsertWithoutConditionMatricesInput = {
    update: XOR<VinPassportUpdateWithoutConditionMatricesInput, VinPassportUncheckedUpdateWithoutConditionMatricesInput>
    create: XOR<VinPassportCreateWithoutConditionMatricesInput, VinPassportUncheckedCreateWithoutConditionMatricesInput>
  }

  export type VinPassportUpdateWithoutConditionMatricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUpdateManyWithoutVinPassportNestedInput
    gasSettlements?: GasSettlementUpdateManyWithoutVinPassportNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVinPassportNestedInput
    onChainProofs?: OnChainProofUpdateManyWithoutVinPassportNestedInput
    documents?: DocumentUpdateManyWithoutVinPassportNestedInput
    mechanicalHealths?: MechanicalHealthUpdateManyWithoutVinPassportNestedInput
  }

  export type VinPassportUncheckedUpdateWithoutConditionMatricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUncheckedUpdateManyWithoutVinPassportNestedInput
    gasSettlements?: GasSettlementUncheckedUpdateManyWithoutVinPassportNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVinPassportNestedInput
    onChainProofs?: OnChainProofUncheckedUpdateManyWithoutVinPassportNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutVinPassportNestedInput
    mechanicalHealths?: MechanicalHealthUncheckedUpdateManyWithoutVinPassportNestedInput
  }

  export type AuditLogUpsertWithWhereUniqueWithoutConditionMatrixInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutConditionMatrixInput, AuditLogUncheckedUpdateWithoutConditionMatrixInput>
    create: XOR<AuditLogCreateWithoutConditionMatrixInput, AuditLogUncheckedCreateWithoutConditionMatrixInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutConditionMatrixInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutConditionMatrixInput, AuditLogUncheckedUpdateWithoutConditionMatrixInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutConditionMatrixInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutAuditLogsInput>
  }

  export type UserCreateWithoutChainTxsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    wallet?: AztoWalletCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    aiQuotas?: AIQuotaCreateNestedManyWithoutUserInput
    aiDecisions?: AIDecisionCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutChainTxsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    wallet?: AztoWalletUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    aiQuotas?: AIQuotaUncheckedCreateNestedManyWithoutUserInput
    aiDecisions?: AIDecisionUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutChainTxsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChainTxsInput, UserUncheckedCreateWithoutChainTxsInput>
  }

  export type AuditLogCreateWithoutChainTxInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    user?: UserCreateNestedOneWithoutAuditLogsInput
    invoice?: InvoiceCreateNestedOneWithoutAuditLogsInput
    vinPassport?: VinPassportCreateNestedOneWithoutAuditLogsInput
    document?: DocumentCreateNestedOneWithoutAuditLogsInput
    conditionMatrix?: ConditionMatrixCreateNestedOneWithoutAuditLogsInput
    mechanicalHealth?: MechanicalHealthCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutChainTxInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    invoiceId?: string | null
    vinPassportId?: string | null
    documentId?: string | null
    conditionMatrixId?: string | null
    mechanicalHealthId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogCreateOrConnectWithoutChainTxInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutChainTxInput, AuditLogUncheckedCreateWithoutChainTxInput>
  }

  export type AuditLogCreateManyChainTxInputEnvelope = {
    data: Enumerable<AuditLogCreateManyChainTxInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutChainTxsInput = {
    update: XOR<UserUpdateWithoutChainTxsInput, UserUncheckedUpdateWithoutChainTxsInput>
    create: XOR<UserCreateWithoutChainTxsInput, UserUncheckedCreateWithoutChainTxsInput>
  }

  export type UserUpdateWithoutChainTxsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    wallet?: AztoWalletUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    aiQuotas?: AIQuotaUpdateManyWithoutUserNestedInput
    aiDecisions?: AIDecisionUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutChainTxsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    wallet?: AztoWalletUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    aiQuotas?: AIQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiDecisions?: AIDecisionUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type AuditLogUpsertWithWhereUniqueWithoutChainTxInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutChainTxInput, AuditLogUncheckedUpdateWithoutChainTxInput>
    create: XOR<AuditLogCreateWithoutChainTxInput, AuditLogUncheckedCreateWithoutChainTxInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutChainTxInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutChainTxInput, AuditLogUncheckedUpdateWithoutChainTxInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutChainTxInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutAuditLogsInput>
  }

  export type InvoiceCreateWithoutOnChainProofsInput = {
    id?: string
    number: string
    status: TxStatus
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    vinPassport?: VinPassportCreateNestedOneWithoutInvoicesInput
    documents?: DocumentCreateNestedManyWithoutInvoiceInput
    parts?: NormalizedPartCreateNestedManyWithoutInvoiceInput
    auditLogs?: AuditLogCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutOnChainProofsInput = {
    id?: string
    number: string
    status: TxStatus
    vinPassportId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    documents?: DocumentUncheckedCreateNestedManyWithoutInvoiceInput
    parts?: NormalizedPartUncheckedCreateNestedManyWithoutInvoiceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutOnChainProofsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOnChainProofsInput, InvoiceUncheckedCreateWithoutOnChainProofsInput>
  }

  export type VinPassportCreateWithoutOnChainProofsInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoices?: InvoiceCreateNestedManyWithoutVinPassportInput
    gasSettlements?: GasSettlementCreateNestedManyWithoutVinPassportInput
    auditLogs?: AuditLogCreateNestedManyWithoutVinPassportInput
    documents?: DocumentCreateNestedManyWithoutVinPassportInput
    conditionMatrices?: ConditionMatrixCreateNestedManyWithoutVinPassportInput
    mechanicalHealths?: MechanicalHealthCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportUncheckedCreateWithoutOnChainProofsInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVinPassportInput
    gasSettlements?: GasSettlementUncheckedCreateNestedManyWithoutVinPassportInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVinPassportInput
    documents?: DocumentUncheckedCreateNestedManyWithoutVinPassportInput
    conditionMatrices?: ConditionMatrixUncheckedCreateNestedManyWithoutVinPassportInput
    mechanicalHealths?: MechanicalHealthUncheckedCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportCreateOrConnectWithoutOnChainProofsInput = {
    where: VinPassportWhereUniqueInput
    create: XOR<VinPassportCreateWithoutOnChainProofsInput, VinPassportUncheckedCreateWithoutOnChainProofsInput>
  }

  export type InvoiceUpsertWithoutOnChainProofsInput = {
    update: XOR<InvoiceUpdateWithoutOnChainProofsInput, InvoiceUncheckedUpdateWithoutOnChainProofsInput>
    create: XOR<InvoiceCreateWithoutOnChainProofsInput, InvoiceUncheckedCreateWithoutOnChainProofsInput>
  }

  export type InvoiceUpdateWithoutOnChainProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    vinPassport?: VinPassportUpdateOneWithoutInvoicesNestedInput
    documents?: DocumentUpdateManyWithoutInvoiceNestedInput
    parts?: NormalizedPartUpdateManyWithoutInvoiceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutOnChainProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    documents?: DocumentUncheckedUpdateManyWithoutInvoiceNestedInput
    parts?: NormalizedPartUncheckedUpdateManyWithoutInvoiceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type VinPassportUpsertWithoutOnChainProofsInput = {
    update: XOR<VinPassportUpdateWithoutOnChainProofsInput, VinPassportUncheckedUpdateWithoutOnChainProofsInput>
    create: XOR<VinPassportCreateWithoutOnChainProofsInput, VinPassportUncheckedCreateWithoutOnChainProofsInput>
  }

  export type VinPassportUpdateWithoutOnChainProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUpdateManyWithoutVinPassportNestedInput
    gasSettlements?: GasSettlementUpdateManyWithoutVinPassportNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVinPassportNestedInput
    documents?: DocumentUpdateManyWithoutVinPassportNestedInput
    conditionMatrices?: ConditionMatrixUpdateManyWithoutVinPassportNestedInput
    mechanicalHealths?: MechanicalHealthUpdateManyWithoutVinPassportNestedInput
  }

  export type VinPassportUncheckedUpdateWithoutOnChainProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUncheckedUpdateManyWithoutVinPassportNestedInput
    gasSettlements?: GasSettlementUncheckedUpdateManyWithoutVinPassportNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVinPassportNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutVinPassportNestedInput
    conditionMatrices?: ConditionMatrixUncheckedUpdateManyWithoutVinPassportNestedInput
    mechanicalHealths?: MechanicalHealthUncheckedUpdateManyWithoutVinPassportNestedInput
  }

  export type VinPassportCreateWithoutDocumentsInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoices?: InvoiceCreateNestedManyWithoutVinPassportInput
    gasSettlements?: GasSettlementCreateNestedManyWithoutVinPassportInput
    auditLogs?: AuditLogCreateNestedManyWithoutVinPassportInput
    onChainProofs?: OnChainProofCreateNestedManyWithoutVinPassportInput
    conditionMatrices?: ConditionMatrixCreateNestedManyWithoutVinPassportInput
    mechanicalHealths?: MechanicalHealthCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportUncheckedCreateWithoutDocumentsInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVinPassportInput
    gasSettlements?: GasSettlementUncheckedCreateNestedManyWithoutVinPassportInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVinPassportInput
    onChainProofs?: OnChainProofUncheckedCreateNestedManyWithoutVinPassportInput
    conditionMatrices?: ConditionMatrixUncheckedCreateNestedManyWithoutVinPassportInput
    mechanicalHealths?: MechanicalHealthUncheckedCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportCreateOrConnectWithoutDocumentsInput = {
    where: VinPassportWhereUniqueInput
    create: XOR<VinPassportCreateWithoutDocumentsInput, VinPassportUncheckedCreateWithoutDocumentsInput>
  }

  export type InvoiceCreateWithoutDocumentsInput = {
    id?: string
    number: string
    status: TxStatus
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    vinPassport?: VinPassportCreateNestedOneWithoutInvoicesInput
    parts?: NormalizedPartCreateNestedManyWithoutInvoiceInput
    auditLogs?: AuditLogCreateNestedManyWithoutInvoiceInput
    onChainProofs?: OnChainProofCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutDocumentsInput = {
    id?: string
    number: string
    status: TxStatus
    vinPassportId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    parts?: NormalizedPartUncheckedCreateNestedManyWithoutInvoiceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutInvoiceInput
    onChainProofs?: OnChainProofUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutDocumentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutDocumentsInput, InvoiceUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutDocumentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    wallet?: AztoWalletCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    aiQuotas?: AIQuotaCreateNestedManyWithoutUserInput
    aiDecisions?: AIDecisionCreateNestedManyWithoutUserInput
    chainTxs?: BlockchainTransactionCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    wallet?: AztoWalletUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    aiQuotas?: AIQuotaUncheckedCreateNestedManyWithoutUserInput
    aiDecisions?: AIDecisionUncheckedCreateNestedManyWithoutUserInput
    chainTxs?: BlockchainTransactionUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type AuditLogCreateWithoutDocumentInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    user?: UserCreateNestedOneWithoutAuditLogsInput
    invoice?: InvoiceCreateNestedOneWithoutAuditLogsInput
    vinPassport?: VinPassportCreateNestedOneWithoutAuditLogsInput
    chainTx?: BlockchainTransactionCreateNestedOneWithoutAuditLogsInput
    conditionMatrix?: ConditionMatrixCreateNestedOneWithoutAuditLogsInput
    mechanicalHealth?: MechanicalHealthCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutDocumentInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    invoiceId?: string | null
    vinPassportId?: string | null
    chainTxId?: string | null
    conditionMatrixId?: string | null
    mechanicalHealthId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogCreateOrConnectWithoutDocumentInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutDocumentInput, AuditLogUncheckedCreateWithoutDocumentInput>
  }

  export type AuditLogCreateManyDocumentInputEnvelope = {
    data: Enumerable<AuditLogCreateManyDocumentInput>
    skipDuplicates?: boolean
  }

  export type VinPassportUpsertWithoutDocumentsInput = {
    update: XOR<VinPassportUpdateWithoutDocumentsInput, VinPassportUncheckedUpdateWithoutDocumentsInput>
    create: XOR<VinPassportCreateWithoutDocumentsInput, VinPassportUncheckedCreateWithoutDocumentsInput>
  }

  export type VinPassportUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUpdateManyWithoutVinPassportNestedInput
    gasSettlements?: GasSettlementUpdateManyWithoutVinPassportNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVinPassportNestedInput
    onChainProofs?: OnChainProofUpdateManyWithoutVinPassportNestedInput
    conditionMatrices?: ConditionMatrixUpdateManyWithoutVinPassportNestedInput
    mechanicalHealths?: MechanicalHealthUpdateManyWithoutVinPassportNestedInput
  }

  export type VinPassportUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUncheckedUpdateManyWithoutVinPassportNestedInput
    gasSettlements?: GasSettlementUncheckedUpdateManyWithoutVinPassportNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVinPassportNestedInput
    onChainProofs?: OnChainProofUncheckedUpdateManyWithoutVinPassportNestedInput
    conditionMatrices?: ConditionMatrixUncheckedUpdateManyWithoutVinPassportNestedInput
    mechanicalHealths?: MechanicalHealthUncheckedUpdateManyWithoutVinPassportNestedInput
  }

  export type InvoiceUpsertWithoutDocumentsInput = {
    update: XOR<InvoiceUpdateWithoutDocumentsInput, InvoiceUncheckedUpdateWithoutDocumentsInput>
    create: XOR<InvoiceCreateWithoutDocumentsInput, InvoiceUncheckedCreateWithoutDocumentsInput>
  }

  export type InvoiceUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    vinPassport?: VinPassportUpdateOneWithoutInvoicesNestedInput
    parts?: NormalizedPartUpdateManyWithoutInvoiceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutInvoiceNestedInput
    onChainProofs?: OnChainProofUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    parts?: NormalizedPartUncheckedUpdateManyWithoutInvoiceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutInvoiceNestedInput
    onChainProofs?: OnChainProofUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    wallet?: AztoWalletUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    aiQuotas?: AIQuotaUpdateManyWithoutUserNestedInput
    aiDecisions?: AIDecisionUpdateManyWithoutUserNestedInput
    chainTxs?: BlockchainTransactionUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    wallet?: AztoWalletUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    aiQuotas?: AIQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiDecisions?: AIDecisionUncheckedUpdateManyWithoutUserNestedInput
    chainTxs?: BlockchainTransactionUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AuditLogUpsertWithWhereUniqueWithoutDocumentInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutDocumentInput, AuditLogUncheckedUpdateWithoutDocumentInput>
    create: XOR<AuditLogCreateWithoutDocumentInput, AuditLogUncheckedCreateWithoutDocumentInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutDocumentInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutDocumentInput, AuditLogUncheckedUpdateWithoutDocumentInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutDocumentInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutAuditLogsInput>
  }

  export type VinPassportCreateWithoutMechanicalHealthsInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoices?: InvoiceCreateNestedManyWithoutVinPassportInput
    gasSettlements?: GasSettlementCreateNestedManyWithoutVinPassportInput
    auditLogs?: AuditLogCreateNestedManyWithoutVinPassportInput
    onChainProofs?: OnChainProofCreateNestedManyWithoutVinPassportInput
    documents?: DocumentCreateNestedManyWithoutVinPassportInput
    conditionMatrices?: ConditionMatrixCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportUncheckedCreateWithoutMechanicalHealthsInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVinPassportInput
    gasSettlements?: GasSettlementUncheckedCreateNestedManyWithoutVinPassportInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutVinPassportInput
    onChainProofs?: OnChainProofUncheckedCreateNestedManyWithoutVinPassportInput
    documents?: DocumentUncheckedCreateNestedManyWithoutVinPassportInput
    conditionMatrices?: ConditionMatrixUncheckedCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportCreateOrConnectWithoutMechanicalHealthsInput = {
    where: VinPassportWhereUniqueInput
    create: XOR<VinPassportCreateWithoutMechanicalHealthsInput, VinPassportUncheckedCreateWithoutMechanicalHealthsInput>
  }

  export type AuditLogCreateWithoutMechanicalHealthInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    user?: UserCreateNestedOneWithoutAuditLogsInput
    invoice?: InvoiceCreateNestedOneWithoutAuditLogsInput
    vinPassport?: VinPassportCreateNestedOneWithoutAuditLogsInput
    chainTx?: BlockchainTransactionCreateNestedOneWithoutAuditLogsInput
    document?: DocumentCreateNestedOneWithoutAuditLogsInput
    conditionMatrix?: ConditionMatrixCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutMechanicalHealthInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    invoiceId?: string | null
    vinPassportId?: string | null
    chainTxId?: string | null
    documentId?: string | null
    conditionMatrixId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogCreateOrConnectWithoutMechanicalHealthInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutMechanicalHealthInput, AuditLogUncheckedCreateWithoutMechanicalHealthInput>
  }

  export type AuditLogCreateManyMechanicalHealthInputEnvelope = {
    data: Enumerable<AuditLogCreateManyMechanicalHealthInput>
    skipDuplicates?: boolean
  }

  export type VinPassportUpsertWithoutMechanicalHealthsInput = {
    update: XOR<VinPassportUpdateWithoutMechanicalHealthsInput, VinPassportUncheckedUpdateWithoutMechanicalHealthsInput>
    create: XOR<VinPassportCreateWithoutMechanicalHealthsInput, VinPassportUncheckedCreateWithoutMechanicalHealthsInput>
  }

  export type VinPassportUpdateWithoutMechanicalHealthsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUpdateManyWithoutVinPassportNestedInput
    gasSettlements?: GasSettlementUpdateManyWithoutVinPassportNestedInput
    auditLogs?: AuditLogUpdateManyWithoutVinPassportNestedInput
    onChainProofs?: OnChainProofUpdateManyWithoutVinPassportNestedInput
    documents?: DocumentUpdateManyWithoutVinPassportNestedInput
    conditionMatrices?: ConditionMatrixUpdateManyWithoutVinPassportNestedInput
  }

  export type VinPassportUncheckedUpdateWithoutMechanicalHealthsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUncheckedUpdateManyWithoutVinPassportNestedInput
    gasSettlements?: GasSettlementUncheckedUpdateManyWithoutVinPassportNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutVinPassportNestedInput
    onChainProofs?: OnChainProofUncheckedUpdateManyWithoutVinPassportNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutVinPassportNestedInput
    conditionMatrices?: ConditionMatrixUncheckedUpdateManyWithoutVinPassportNestedInput
  }

  export type AuditLogUpsertWithWhereUniqueWithoutMechanicalHealthInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutMechanicalHealthInput, AuditLogUncheckedUpdateWithoutMechanicalHealthInput>
    create: XOR<AuditLogCreateWithoutMechanicalHealthInput, AuditLogUncheckedCreateWithoutMechanicalHealthInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutMechanicalHealthInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutMechanicalHealthInput, AuditLogUncheckedUpdateWithoutMechanicalHealthInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutMechanicalHealthInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    wallet?: AztoWalletCreateNestedOneWithoutUserInput
    aiQuotas?: AIQuotaCreateNestedManyWithoutUserInput
    aiDecisions?: AIDecisionCreateNestedManyWithoutUserInput
    chainTxs?: BlockchainTransactionCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    wallet?: AztoWalletUncheckedCreateNestedOneWithoutUserInput
    aiQuotas?: AIQuotaUncheckedCreateNestedManyWithoutUserInput
    aiDecisions?: AIDecisionUncheckedCreateNestedManyWithoutUserInput
    chainTxs?: BlockchainTransactionUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type InvoiceCreateWithoutAuditLogsInput = {
    id?: string
    number: string
    status: TxStatus
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    vinPassport?: VinPassportCreateNestedOneWithoutInvoicesInput
    documents?: DocumentCreateNestedManyWithoutInvoiceInput
    parts?: NormalizedPartCreateNestedManyWithoutInvoiceInput
    onChainProofs?: OnChainProofCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    number: string
    status: TxStatus
    vinPassportId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    documents?: DocumentUncheckedCreateNestedManyWithoutInvoiceInput
    parts?: NormalizedPartUncheckedCreateNestedManyWithoutInvoiceInput
    onChainProofs?: OnChainProofUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutAuditLogsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutAuditLogsInput, InvoiceUncheckedCreateWithoutAuditLogsInput>
  }

  export type VinPassportCreateWithoutAuditLogsInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoices?: InvoiceCreateNestedManyWithoutVinPassportInput
    gasSettlements?: GasSettlementCreateNestedManyWithoutVinPassportInput
    onChainProofs?: OnChainProofCreateNestedManyWithoutVinPassportInput
    documents?: DocumentCreateNestedManyWithoutVinPassportInput
    conditionMatrices?: ConditionMatrixCreateNestedManyWithoutVinPassportInput
    mechanicalHealths?: MechanicalHealthCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVinPassportInput
    gasSettlements?: GasSettlementUncheckedCreateNestedManyWithoutVinPassportInput
    onChainProofs?: OnChainProofUncheckedCreateNestedManyWithoutVinPassportInput
    documents?: DocumentUncheckedCreateNestedManyWithoutVinPassportInput
    conditionMatrices?: ConditionMatrixUncheckedCreateNestedManyWithoutVinPassportInput
    mechanicalHealths?: MechanicalHealthUncheckedCreateNestedManyWithoutVinPassportInput
  }

  export type VinPassportCreateOrConnectWithoutAuditLogsInput = {
    where: VinPassportWhereUniqueInput
    create: XOR<VinPassportCreateWithoutAuditLogsInput, VinPassportUncheckedCreateWithoutAuditLogsInput>
  }

  export type BlockchainTransactionCreateWithoutAuditLogsInput = {
    id?: string
    chain: string
    contract: string
    txHash: string
    blockNumber?: bigint | number | null
    eventName?: string | null
    status: TxStatus
    entityType: EntityType
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    confirmations?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutChainTxsInput
  }

  export type BlockchainTransactionUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    chain: string
    contract: string
    txHash: string
    blockNumber?: bigint | number | null
    eventName?: string | null
    status: TxStatus
    entityType: EntityType
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    confirmations?: number
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockchainTransactionCreateOrConnectWithoutAuditLogsInput = {
    where: BlockchainTransactionWhereUniqueInput
    create: XOR<BlockchainTransactionCreateWithoutAuditLogsInput, BlockchainTransactionUncheckedCreateWithoutAuditLogsInput>
  }

  export type DocumentCreateWithoutAuditLogsInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state?: FileState
    checksum: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    deletedBy?: string | null
    vinPassport?: VinPassportCreateNestedOneWithoutDocumentsInput
    invoice?: InvoiceCreateNestedOneWithoutDocumentsInput
    uploadedBy?: UserCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state?: FileState
    checksum: string
    vinPassportId?: string | null
    invoiceId?: string | null
    uploadedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    deletedBy?: string | null
  }

  export type DocumentCreateOrConnectWithoutAuditLogsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutAuditLogsInput, DocumentUncheckedCreateWithoutAuditLogsInput>
  }

  export type ConditionMatrixCreateWithoutAuditLogsInput = {
    id?: string
    version: string
    rulesHash: string
    effectiveFrom: Date | string
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    vinPassport?: VinPassportCreateNestedOneWithoutConditionMatricesInput
  }

  export type ConditionMatrixUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    vinPassportId?: string | null
    version: string
    rulesHash: string
    effectiveFrom: Date | string
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type ConditionMatrixCreateOrConnectWithoutAuditLogsInput = {
    where: ConditionMatrixWhereUniqueInput
    create: XOR<ConditionMatrixCreateWithoutAuditLogsInput, ConditionMatrixUncheckedCreateWithoutAuditLogsInput>
  }

  export type MechanicalHealthCreateWithoutAuditLogsInput = {
    id?: string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: Date | string | null
    greenLight?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    vinPassport: VinPassportCreateNestedOneWithoutMechanicalHealthsInput
  }

  export type MechanicalHealthUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    vinPassportId: string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: Date | string | null
    greenLight?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type MechanicalHealthCreateOrConnectWithoutAuditLogsInput = {
    where: MechanicalHealthWhereUniqueInput
    create: XOR<MechanicalHealthCreateWithoutAuditLogsInput, MechanicalHealthUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    wallet?: AztoWalletUpdateOneWithoutUserNestedInput
    aiQuotas?: AIQuotaUpdateManyWithoutUserNestedInput
    aiDecisions?: AIDecisionUpdateManyWithoutUserNestedInput
    chainTxs?: BlockchainTransactionUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    wallet?: AztoWalletUncheckedUpdateOneWithoutUserNestedInput
    aiQuotas?: AIQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiDecisions?: AIDecisionUncheckedUpdateManyWithoutUserNestedInput
    chainTxs?: BlockchainTransactionUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type InvoiceUpsertWithoutAuditLogsInput = {
    update: XOR<InvoiceUpdateWithoutAuditLogsInput, InvoiceUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<InvoiceCreateWithoutAuditLogsInput, InvoiceUncheckedCreateWithoutAuditLogsInput>
  }

  export type InvoiceUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    vinPassport?: VinPassportUpdateOneWithoutInvoicesNestedInput
    documents?: DocumentUpdateManyWithoutInvoiceNestedInput
    parts?: NormalizedPartUpdateManyWithoutInvoiceNestedInput
    onChainProofs?: OnChainProofUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    documents?: DocumentUncheckedUpdateManyWithoutInvoiceNestedInput
    parts?: NormalizedPartUncheckedUpdateManyWithoutInvoiceNestedInput
    onChainProofs?: OnChainProofUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type VinPassportUpsertWithoutAuditLogsInput = {
    update: XOR<VinPassportUpdateWithoutAuditLogsInput, VinPassportUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<VinPassportCreateWithoutAuditLogsInput, VinPassportUncheckedCreateWithoutAuditLogsInput>
  }

  export type VinPassportUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUpdateManyWithoutVinPassportNestedInput
    gasSettlements?: GasSettlementUpdateManyWithoutVinPassportNestedInput
    onChainProofs?: OnChainProofUpdateManyWithoutVinPassportNestedInput
    documents?: DocumentUpdateManyWithoutVinPassportNestedInput
    conditionMatrices?: ConditionMatrixUpdateManyWithoutVinPassportNestedInput
    mechanicalHealths?: MechanicalHealthUpdateManyWithoutVinPassportNestedInput
  }

  export type VinPassportUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUncheckedUpdateManyWithoutVinPassportNestedInput
    gasSettlements?: GasSettlementUncheckedUpdateManyWithoutVinPassportNestedInput
    onChainProofs?: OnChainProofUncheckedUpdateManyWithoutVinPassportNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutVinPassportNestedInput
    conditionMatrices?: ConditionMatrixUncheckedUpdateManyWithoutVinPassportNestedInput
    mechanicalHealths?: MechanicalHealthUncheckedUpdateManyWithoutVinPassportNestedInput
  }

  export type BlockchainTransactionUpsertWithoutAuditLogsInput = {
    update: XOR<BlockchainTransactionUpdateWithoutAuditLogsInput, BlockchainTransactionUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<BlockchainTransactionCreateWithoutAuditLogsInput, BlockchainTransactionUncheckedCreateWithoutAuditLogsInput>
  }

  export type BlockchainTransactionUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    confirmations?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutChainTxsNestedInput
  }

  export type BlockchainTransactionUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    confirmations?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpsertWithoutAuditLogsInput = {
    update: XOR<DocumentUpdateWithoutAuditLogsInput, DocumentUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<DocumentCreateWithoutAuditLogsInput, DocumentUncheckedCreateWithoutAuditLogsInput>
  }

  export type DocumentUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | FileType
    state?: EnumFileStateFieldUpdateOperationsInput | FileState
    checksum?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassport?: VinPassportUpdateOneWithoutDocumentsNestedInput
    invoice?: InvoiceUpdateOneWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | FileType
    state?: EnumFileStateFieldUpdateOperationsInput | FileState
    checksum?: StringFieldUpdateOperationsInput | string
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConditionMatrixUpsertWithoutAuditLogsInput = {
    update: XOR<ConditionMatrixUpdateWithoutAuditLogsInput, ConditionMatrixUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<ConditionMatrixCreateWithoutAuditLogsInput, ConditionMatrixUncheckedCreateWithoutAuditLogsInput>
  }

  export type ConditionMatrixUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    rulesHash?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassport?: VinPassportUpdateOneWithoutConditionMatricesNestedInput
  }

  export type ConditionMatrixUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    rulesHash?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MechanicalHealthUpsertWithoutAuditLogsInput = {
    update: XOR<MechanicalHealthUpdateWithoutAuditLogsInput, MechanicalHealthUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<MechanicalHealthCreateWithoutAuditLogsInput, MechanicalHealthUncheckedCreateWithoutAuditLogsInput>
  }

  export type MechanicalHealthUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    greenLight?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    vinPassport?: VinPassportUpdateOneRequiredWithoutMechanicalHealthsNestedInput
  }

  export type MechanicalHealthUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vinPassportId?: StringFieldUpdateOperationsInput | string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    greenLight?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateWithoutAlertsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    wallet?: AztoWalletCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    aiQuotas?: AIQuotaCreateNestedManyWithoutUserInput
    aiDecisions?: AIDecisionCreateNestedManyWithoutUserInput
    chainTxs?: BlockchainTransactionCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAlertsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    role: UserRole
    walletAddress?: string | null
    signature?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
    wallet?: AztoWalletUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    aiQuotas?: AIQuotaUncheckedCreateNestedManyWithoutUserInput
    aiDecisions?: AIDecisionUncheckedCreateNestedManyWithoutUserInput
    chainTxs?: BlockchainTransactionUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
  }

  export type UserUpsertWithoutAlertsInput = {
    update: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
  }

  export type UserUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    wallet?: AztoWalletUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    aiQuotas?: AIQuotaUpdateManyWithoutUserNestedInput
    aiDecisions?: AIDecisionUpdateManyWithoutUserNestedInput
    chainTxs?: BlockchainTransactionUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    wallet?: AztoWalletUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    aiQuotas?: AIQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiDecisions?: AIDecisionUncheckedUpdateManyWithoutUserNestedInput
    chainTxs?: BlockchainTransactionUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    invoiceId?: string | null
    vinPassportId?: string | null
    chainTxId?: string | null
    documentId?: string | null
    conditionMatrixId?: string | null
    mechanicalHealthId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AIQuotaCreateManyUserInput = {
    id?: string
    invoicesProcessed?: number
    rejectedCount?: number
    periodStart: Date | string
    periodEnd: Date | string
  }

  export type AIDecisionCreateManyUserInput = {
    id?: string
    entityType: EntityType
    entityId: string
    model: string
    promptHash: string
    responseHash: string
    decision: string
    confidence?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BlockchainTransactionCreateManyUserInput = {
    id?: string
    chain: string
    contract: string
    txHash: string
    blockNumber?: bigint | number | null
    eventName?: string | null
    status: TxStatus
    entityType: EntityType
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    confirmations?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertCreateManyUserInput = {
    id?: string
    userName: string
    userRole: UserRole
    action: AlertAction
    activity: string
    businessId?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type DocumentCreateManyUploadedByInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state?: FileState
    checksum: string
    vinPassportId?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    deletedBy?: string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invoice?: InvoiceUpdateOneWithoutAuditLogsNestedInput
    vinPassport?: VinPassportUpdateOneWithoutAuditLogsNestedInput
    chainTx?: BlockchainTransactionUpdateOneWithoutAuditLogsNestedInput
    document?: DocumentUpdateOneWithoutAuditLogsNestedInput
    conditionMatrix?: ConditionMatrixUpdateOneWithoutAuditLogsNestedInput
    mechanicalHealth?: MechanicalHealthUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    chainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionMatrixId?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalHealthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogUncheckedUpdateManyWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    chainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionMatrixId?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalHealthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AIQuotaUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicesProcessed?: IntFieldUpdateOperationsInput | number
    rejectedCount?: IntFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIQuotaUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicesProcessed?: IntFieldUpdateOperationsInput | number
    rejectedCount?: IntFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIQuotaUncheckedUpdateManyWithoutAiQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicesProcessed?: IntFieldUpdateOperationsInput | number
    rejectedCount?: IntFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIDecisionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    promptHash?: StringFieldUpdateOperationsInput | string
    responseHash?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIDecisionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    promptHash?: StringFieldUpdateOperationsInput | string
    responseHash?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIDecisionUncheckedUpdateManyWithoutAiDecisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    promptHash?: StringFieldUpdateOperationsInput | string
    responseHash?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockchainTransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    confirmations?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutChainTxNestedInput
  }

  export type BlockchainTransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    confirmations?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChainTxNestedInput
  }

  export type BlockchainTransactionUncheckedUpdateManyWithoutChainTxsInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    confirmations?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userRole?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    action?: EnumAlertActionFieldUpdateOperationsInput | AlertAction
    activity?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlertUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userRole?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    action?: EnumAlertActionFieldUpdateOperationsInput | AlertAction
    activity?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlertUncheckedUpdateManyWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userRole?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    action?: EnumAlertActionFieldUpdateOperationsInput | AlertAction
    activity?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DocumentUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | FileType
    state?: EnumFileStateFieldUpdateOperationsInput | FileState
    checksum?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassport?: VinPassportUpdateOneWithoutDocumentsNestedInput
    invoice?: InvoiceUpdateOneWithoutDocumentsNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | FileType
    state?: EnumFileStateFieldUpdateOperationsInput | FileState
    checksum?: StringFieldUpdateOperationsInput | string
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | FileType
    state?: EnumFileStateFieldUpdateOperationsInput | FileState
    checksum?: StringFieldUpdateOperationsInput | string
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateManyVinPassportInput = {
    id?: string
    number: string
    status: TxStatus
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type GasSettlementCreateManyVinPassportInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogCreateManyVinPassportInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    invoiceId?: string | null
    chainTxId?: string | null
    documentId?: string | null
    conditionMatrixId?: string | null
    mechanicalHealthId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type OnChainProofCreateManyVinPassportInput = {
    id?: string
    entityType: EntityType
    entityId: string
    hash: string
    algorithm: string
    chain: string
    contract: string
    txHash: string
    invoiceId?: string | null
    createdAt?: Date | string
  }

  export type DocumentCreateManyVinPassportInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state?: FileState
    checksum: string
    invoiceId?: string | null
    uploadedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    deletedBy?: string | null
  }

  export type ConditionMatrixCreateManyVinPassportInput = {
    id?: string
    version: string
    rulesHash: string
    effectiveFrom: Date | string
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type MechanicalHealthCreateManyVinPassportInput = {
    id?: string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: Date | string | null
    greenLight?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type InvoiceUpdateWithoutVinPassportInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    documents?: DocumentUpdateManyWithoutInvoiceNestedInput
    parts?: NormalizedPartUpdateManyWithoutInvoiceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutInvoiceNestedInput
    onChainProofs?: OnChainProofUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutVinPassportInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    documents?: DocumentUncheckedUpdateManyWithoutInvoiceNestedInput
    parts?: NormalizedPartUncheckedUpdateManyWithoutInvoiceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutInvoiceNestedInput
    onChainProofs?: OnChainProofUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | TxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GasSettlementUpdateWithoutVinPassportInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GasSettlementUncheckedUpdateWithoutVinPassportInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GasSettlementUncheckedUpdateManyWithoutGasSettlementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogUpdateWithoutVinPassportInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAuditLogsNestedInput
    invoice?: InvoiceUpdateOneWithoutAuditLogsNestedInput
    chainTx?: BlockchainTransactionUpdateOneWithoutAuditLogsNestedInput
    document?: DocumentUpdateOneWithoutAuditLogsNestedInput
    conditionMatrix?: ConditionMatrixUpdateOneWithoutAuditLogsNestedInput
    mechanicalHealth?: MechanicalHealthUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutVinPassportInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    chainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionMatrixId?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalHealthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OnChainProofUpdateWithoutVinPassportInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    algorithm?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutOnChainProofsNestedInput
  }

  export type OnChainProofUncheckedUpdateWithoutVinPassportInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    algorithm?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnChainProofUncheckedUpdateManyWithoutOnChainProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    algorithm?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutVinPassportInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | FileType
    state?: EnumFileStateFieldUpdateOperationsInput | FileState
    checksum?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUpdateOneWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneWithoutDocumentsNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutVinPassportInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | FileType
    state?: EnumFileStateFieldUpdateOperationsInput | FileState
    checksum?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type ConditionMatrixUpdateWithoutVinPassportInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    rulesHash?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUpdateManyWithoutConditionMatrixNestedInput
  }

  export type ConditionMatrixUncheckedUpdateWithoutVinPassportInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    rulesHash?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutConditionMatrixNestedInput
  }

  export type ConditionMatrixUncheckedUpdateManyWithoutConditionMatricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    rulesHash?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MechanicalHealthUpdateWithoutVinPassportInput = {
    id?: StringFieldUpdateOperationsInput | string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    greenLight?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    auditLogs?: AuditLogUpdateManyWithoutMechanicalHealthNestedInput
  }

  export type MechanicalHealthUncheckedUpdateWithoutVinPassportInput = {
    id?: StringFieldUpdateOperationsInput | string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    greenLight?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    auditLogs?: AuditLogUncheckedUpdateManyWithoutMechanicalHealthNestedInput
  }

  export type MechanicalHealthUncheckedUpdateManyWithoutMechanicalHealthsInput = {
    id?: StringFieldUpdateOperationsInput | string
    partsMaintained?: NullableJsonNullValueInput | InputJsonValue
    lastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    greenLight?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DocumentCreateManyInvoiceInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileType: FileType
    state?: FileState
    checksum: string
    vinPassportId?: string | null
    uploadedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    deletedBy?: string | null
  }

  export type NormalizedPartCreateManyInvoiceInput = {
    id?: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogCreateManyInvoiceInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    vinPassportId?: string | null
    chainTxId?: string | null
    documentId?: string | null
    conditionMatrixId?: string | null
    mechanicalHealthId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type OnChainProofCreateManyInvoiceInput = {
    id?: string
    entityType: EntityType
    entityId: string
    hash: string
    algorithm: string
    chain: string
    contract: string
    txHash: string
    vinPassportId?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | FileType
    state?: EnumFileStateFieldUpdateOperationsInput | FileState
    checksum?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassport?: VinPassportUpdateOneWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneWithoutDocumentsNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | FileType
    state?: EnumFileStateFieldUpdateOperationsInput | FileState
    checksum?: StringFieldUpdateOperationsInput | string
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type NormalizedPartUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NormalizedPartUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NormalizedPartUncheckedUpdateManyWithoutPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAuditLogsNestedInput
    vinPassport?: VinPassportUpdateOneWithoutAuditLogsNestedInput
    chainTx?: BlockchainTransactionUpdateOneWithoutAuditLogsNestedInput
    document?: DocumentUpdateOneWithoutAuditLogsNestedInput
    conditionMatrix?: ConditionMatrixUpdateOneWithoutAuditLogsNestedInput
    mechanicalHealth?: MechanicalHealthUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    chainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionMatrixId?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalHealthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OnChainProofUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    algorithm?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vinPassport?: VinPassportUpdateOneWithoutOnChainProofsNestedInput
  }

  export type OnChainProofUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    algorithm?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyConditionMatrixInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    invoiceId?: string | null
    vinPassportId?: string | null
    chainTxId?: string | null
    documentId?: string | null
    mechanicalHealthId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogUpdateWithoutConditionMatrixInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAuditLogsNestedInput
    invoice?: InvoiceUpdateOneWithoutAuditLogsNestedInput
    vinPassport?: VinPassportUpdateOneWithoutAuditLogsNestedInput
    chainTx?: BlockchainTransactionUpdateOneWithoutAuditLogsNestedInput
    document?: DocumentUpdateOneWithoutAuditLogsNestedInput
    mechanicalHealth?: MechanicalHealthUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutConditionMatrixInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    chainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalHealthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogCreateManyChainTxInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    invoiceId?: string | null
    vinPassportId?: string | null
    documentId?: string | null
    conditionMatrixId?: string | null
    mechanicalHealthId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogUpdateWithoutChainTxInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAuditLogsNestedInput
    invoice?: InvoiceUpdateOneWithoutAuditLogsNestedInput
    vinPassport?: VinPassportUpdateOneWithoutAuditLogsNestedInput
    document?: DocumentUpdateOneWithoutAuditLogsNestedInput
    conditionMatrix?: ConditionMatrixUpdateOneWithoutAuditLogsNestedInput
    mechanicalHealth?: MechanicalHealthUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutChainTxInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionMatrixId?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalHealthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogCreateManyDocumentInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    invoiceId?: string | null
    vinPassportId?: string | null
    chainTxId?: string | null
    conditionMatrixId?: string | null
    mechanicalHealthId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAuditLogsNestedInput
    invoice?: InvoiceUpdateOneWithoutAuditLogsNestedInput
    vinPassport?: VinPassportUpdateOneWithoutAuditLogsNestedInput
    chainTx?: BlockchainTransactionUpdateOneWithoutAuditLogsNestedInput
    conditionMatrix?: ConditionMatrixUpdateOneWithoutAuditLogsNestedInput
    mechanicalHealth?: MechanicalHealthUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    chainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionMatrixId?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalHealthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogCreateManyMechanicalHealthInput = {
    id?: string
    action: AuditAction
    entityType: EntityType
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    invoiceId?: string | null
    vinPassportId?: string | null
    chainTxId?: string | null
    documentId?: string | null
    conditionMatrixId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isDeleted?: boolean
  }

  export type AuditLogUpdateWithoutMechanicalHealthInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAuditLogsNestedInput
    invoice?: InvoiceUpdateOneWithoutAuditLogsNestedInput
    vinPassport?: VinPassportUpdateOneWithoutAuditLogsNestedInput
    chainTx?: BlockchainTransactionUpdateOneWithoutAuditLogsNestedInput
    document?: DocumentUpdateOneWithoutAuditLogsNestedInput
    conditionMatrix?: ConditionMatrixUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutMechanicalHealthInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    vinPassportId?: NullableStringFieldUpdateOperationsInput | string | null
    chainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionMatrixId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}